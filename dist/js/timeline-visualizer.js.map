{"version":3,"sources":["node_modules/browser-pack/_prelude.js","dist/index.js","dist/lib/timelineVisualizer.js","node_modules/events/events.js","node_modules/lodash.isequal/index.js","node_modules/superfly-timeline/dist/api/api.js","node_modules/superfly-timeline/dist/api/enums.js","node_modules/superfly-timeline/dist/index.js","node_modules/superfly-timeline/dist/lib.js","node_modules/superfly-timeline/dist/resolver/cache.js","node_modules/superfly-timeline/dist/resolver/common.js","node_modules/superfly-timeline/dist/resolver/expression.js","node_modules/superfly-timeline/dist/resolver/resolver.js","node_modules/superfly-timeline/dist/resolver/state.js","node_modules/superfly-timeline/dist/resolver/validate.js","node_modules/superfly-timeline/node_modules/tslib/tslib.js","node_modules/tslib/tslib.js","node_modules/underscore/underscore-umd.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACniCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxzDA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3jBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACp4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC7TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC5RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"timeline-visualizer.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst tslib_1 = require(\"tslib\");\r\ntslib_1.__exportStar(require(\"./lib/timelineVisualizer\"), exports);\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TimelineVisualizer = void 0;\r\nconst isEqual = require(\"lodash.isequal\");\r\nconst superfly_timeline_1 = require(\"superfly-timeline\");\r\nconst events_1 = require(\"events\");\r\n/** Step size/ time step. */\r\nconst DEFAULT_STEP_SIZE = 1;\r\n/** Width of label column. */\r\nconst LABEL_WIDTH_OF_TIMELINE = 0.25;\r\n/** Default zoom */\r\nconst DEFAULT_ZOOM_VALUE = 100;\r\n/** Factor to zoom by */\r\nconst ZOOM_FACTOR = 1.001;\r\n/** Factor to pan by (pan = PAN_FACTOR * STEP_SIZE) */\r\nconst PAN_FACTOR = 10;\r\n/** Maximum layer height */\r\nconst MAX_LAYER_HEIGHT = 60;\r\n/** Amount to move playhead per second. */\r\nconst DEFAULT_PLAYHEAD_SPEED = 1;\r\n/** BEGIN STYLING VALUES */\r\n/** Timeline background color. */\r\nconst COLOR_BACKGROUND = '#333333';\r\n/** Layer label background color. */\r\nconst COLOR_LABEL_BACKGROUND = '#666666';\r\n/** Color of the ruler lines */\r\nconst RULER_LINE_COLOR = '#999999';\r\n/** Width of the ruler lines */\r\nconst RULER_LINE_WIDTH = 1;\r\n/** Playhead color. */\r\nconst COLOR_PLAYHEAD = 'rgba(255, 0, 0, 0.5)';\r\n/** Playhead thickness. */\r\nconst THICKNESS_PLAYHEAD = 5;\r\n/** Color of line separating timeline rows. */\r\nconst COLOR_LINE = 'black';\r\n/** Height of line separating rows. */\r\nconst THICKNESS_LINE = 1;\r\n/** Text properties. */\r\nconst TEXT_FONT_FAMILY = 'Calibri';\r\nconst TEXT_FONT_SIZE = 16;\r\nconst TEXT_COLOR = 'white';\r\n/** Timeline object properties. */\r\nconst COLOR_TIMELINE_OBJECT_FILL = 'rgb(22, 102, 247, 0.75)';\r\nconst COLOR_TIMELINE_OBJECT_BORDER = 'rgba(232, 240, 255, 0.85)';\r\nconst THICKNESS_TIMELINE_OBJECT_BORDER = 1;\r\n/** Timeline object height as a proportion of the row height. */\r\nconst TIMELINE_OBJECT_HEIGHT = 1;\r\n/** END STYLING VALUES */\r\n/** BEGIN CONSTANTS FOR STATE MANAGEMENT */\r\nconst MOUSEIN = 0;\r\nconst MOUSEOUT = 1;\r\nclass TimelineVisualizer extends events_1.EventEmitter {\r\n    /**\r\n     * @param {string} canvasId The ID of the canvas object to draw within.\r\n     */\r\n    constructor(canvasId, options = {}) {\r\n        super();\r\n        // Step size.\r\n        this.stepSize = DEFAULT_STEP_SIZE;\r\n        /** @private @readonly Proportion of the canvas to be used for the layer labels column. */\r\n        this._layerLabelWidthProportionOfCanvas = LABEL_WIDTH_OF_TIMELINE;\r\n        /** Layers on timeline. */\r\n        this._layerLabels = {};\r\n        /** State of the timeline. */\r\n        this._timelineState = {};\r\n        /** Map of objects for determining hovered object */\r\n        this._hoveredObjectMap = {};\r\n        /** Start time of the current view. Defines the objects within view on the timeline [time] */\r\n        this._viewStartTime = 0;\r\n        /** Range of the current view [time] */\r\n        // private _viewTimeRange: number = 1\r\n        // private _drawTimeEnd: number\r\n        /** Store whether the mouse is held down, for scrolling. */\r\n        this._mouseDown = false;\r\n        /** Current zoom amount. */\r\n        this._timelineZoom = DEFAULT_ZOOM_VALUE;\r\n        /** Whether or not the playhead should move. */\r\n        this._playHeadPlaying = false;\r\n        /** Speed of the playhead [units / second] */\r\n        this._playSpeed = DEFAULT_PLAYHEAD_SPEED;\r\n        /** The current time position of the playhead. */\r\n        this._playHeadTime = 0;\r\n        /** The last time updateDraw() did a draw. */\r\n        this._updateDrawLastTime = 0;\r\n        /** Whether the mouse last moved over an object or out. */\r\n        this._lastHoverAction = MOUSEOUT;\r\n        /** Name of object that was last hovered over. */\r\n        this._lastHoveredHash = '';\r\n        /** If the visualizer automatically should re-resolve the timeline when navigating the viewport */\r\n        this._timelineResolveAuto = false;\r\n        /** At what time the timeline was resolved [time] */\r\n        this._timelineResolveStart = 0;\r\n        this._timelineResolveEnd = 0;\r\n        this._timelineResolveZoom = 1;\r\n        this._timelineResolveCount = 100;\r\n        this._timelineResolveCountAdjust = 1;\r\n        /** How much extra (outside the current viewport) the timeline should be resolved to [ratio] */\r\n        this._timelineResolveExpand = 3;\r\n        this.latestUpdateTime = 0;\r\n        this.reresolveTimeout = null;\r\n        this._mergeIterator = 0;\r\n        // Initialise other values.\r\n        this._canvasId = canvasId;\r\n        this.initCanvas();\r\n        this._drawPlayhead = !!options.drawPlayhead;\r\n        // Calculate width of label column.\r\n        this._layerLabelWidth = this._canvasWidth * this._layerLabelWidthProportionOfCanvas;\r\n        // Calculate timeline width and start point.\r\n        this._viewDrawX = this._layerLabelWidth;\r\n        this._viewDrawWidth = this._canvasWidth - this._layerLabelWidth;\r\n        // Draw background.\r\n        this.drawBackground();\r\n        // Draw playhead.\r\n        this.drawPlayhead();\r\n        this.updateDraw();\r\n    }\r\n    /**\r\n     * Initialises the canvas and registers canvas events.\r\n     */\r\n    initCanvas() {\r\n        // Create new canvas object.\r\n        this._canvasContainer = document.getElementById(this._canvasId);\r\n        if (!this._canvasContainer)\r\n            throw new Error(`Canvas \"${this._canvasId}\" not found`);\r\n        // Get rendering context.\r\n        this._canvas = this._canvasContainer.getContext('2d');\r\n        // Register canvas interaction event handlers.\r\n        this._canvasContainer.addEventListener('mousedown', (event) => this.canvasMouseDown(event));\r\n        this._canvasContainer.addEventListener('mouseup', (event) => this.canvasMouseUp(event));\r\n        this._canvasContainer.addEventListener('mousemove', (event) => this.canvasMouseMove(event));\r\n        this._canvasContainer.addEventListener('wheel', (event) => this.canvasScrollWheel(event));\r\n        // Get width and height of canvas.\r\n        this._canvasWidth = this._canvasContainer.width;\r\n        this._canvasHeight = this._canvasContainer.height;\r\n    }\r\n    /**\r\n     * Updates the timeline, should be called when actions are added/removed from a timeline\r\n     * but the same timeline is being drawn.\r\n     * @param {TimelineObject[]} timeline Timeline to draw.\r\n     * @param {ResolveOptions} options Resolve options.\r\n     */\r\n    updateTimeline(timeline, options) {\r\n        // If options have not been specified set time to 0.\r\n        if (options === undefined) {\r\n            options = {\r\n                time: 0,\r\n                limitCount: 10\r\n            };\r\n        }\r\n        this.latestTimeline = timeline;\r\n        this.latestOptions = options;\r\n        if (!options.limitTime) {\r\n            this._timelineResolveAuto = true;\r\n        }\r\n        else {\r\n            this._timelineResolveAuto = false;\r\n        }\r\n        const options2 = Object.assign({}, options);\r\n        if (this._timelineResolveAuto) {\r\n            this.updateTimelineResolveWindow();\r\n        }\r\n        if (this._resolvedStates === undefined) { // If first time this runs\r\n            // Set timeline start and end times.\r\n            if (options2.time !== undefined) {\r\n                this._viewStartTime = options2.time;\r\n            }\r\n            // Move playhead to start time.\r\n            this._playHeadTime = this._viewStartTime;\r\n        }\r\n        this._updateTimeline(true);\r\n    }\r\n    _updateTimeline(fromNewTimeline = false) {\r\n        const options2 = Object.assign({}, this.latestOptions);\r\n        if (this._timelineResolveAuto) {\r\n            options2.time = this._timelineResolveStart;\r\n            options2.limitTime = this._timelineResolveEnd;\r\n            options2.limitCount = Math.ceil(this._timelineResolveCount * this._timelineResolveCountAdjust);\r\n        }\r\n        // If the playhead is being drawn, the resolve time should be at the playhead time.\r\n        if (this._drawPlayhead && this._playHeadTime > options2.time) {\r\n            options2.time = this._playHeadTime;\r\n        }\r\n        // Resolve the timeline.\r\n        const startResolve = Date.now();\r\n        const resolvedTimeline = superfly_timeline_1.Resolver.resolveTimeline(this.latestTimeline, options2);\r\n        let newResolvedStates = superfly_timeline_1.Resolver.resolveAllStates(resolvedTimeline);\r\n        if (this._resolvedStates === undefined) { // If first time this runs\r\n            this._resolvedStates = newResolvedStates;\r\n        }\r\n        else {\r\n            if (this._drawPlayhead) {\r\n                // Trim the current timeline:\r\n                if (newResolvedStates) {\r\n                    // Merge the timelines.\r\n                    this._resolvedStates = this.mergeTimelineObjects(this._resolvedStates, newResolvedStates, fromNewTimeline);\r\n                }\r\n            }\r\n            else {\r\n                // Otherwise we only see one timeline at a time.\r\n                // Overwrite the previous timeline:\r\n                this._resolvedStates = newResolvedStates;\r\n            }\r\n        }\r\n        // Update layers.\r\n        this.updateLayerLabels();\r\n        this.latestUpdateTime = Date.now() - startResolve;\r\n        // Redraw the timeline.\r\n        this.redrawTimeline();\r\n        this.latestUpdateTime = Date.now() - startResolve;\r\n    }\r\n    /**\r\n     * Sets the viewport to a position, zoom, and playback speed.\r\n     * Playback speed currently not implemented.\r\n     * @param viewPort Object to update viewport with.\r\n     */\r\n    setViewPort(viewPort) {\r\n        // Whether the viewport has changed.\r\n        let changed = false;\r\n        // If zoom has been specified.\r\n        if (viewPort.zoom !== undefined) {\r\n            // Zoom to specified zoom.\r\n            this._timelineZoom = viewPort.zoom;\r\n            changed = true;\r\n        }\r\n        // If timestamp has been specified.\r\n        if (viewPort.timestamp !== undefined) {\r\n            // Set start time to specified time.\r\n            if (viewPort.timestamp > 0) {\r\n                this._viewStartTime = viewPort.timestamp;\r\n                changed = true;\r\n            }\r\n        }\r\n        if (viewPort.playViewPort !== undefined) {\r\n            this._playViewPort = viewPort.playViewPort;\r\n        }\r\n        // If the playback speed has been set, set the new playback speed.\r\n        if (viewPort.playSpeed !== undefined) {\r\n            if (!this._drawPlayhead)\r\n                throw new Error('setViewPort: viewPort.playSpeed was set, but drawPlayhead was not set in constructor');\r\n            this._playSpeed = viewPort.playSpeed;\r\n        }\r\n        // Set playhead playing/ not playing.\r\n        if (viewPort.playPlayhead !== undefined) {\r\n            if (!this._drawPlayhead)\r\n                throw new Error('setViewPort: viewPort.playPlayhead was set, but drawPlayhead was not set in constructor');\r\n            this._playHeadPlaying = viewPort.playPlayhead;\r\n        }\r\n        if (viewPort.playheadTime !== undefined) {\r\n            if (!this._drawPlayhead)\r\n                throw new Error('setViewPort: viewPort.playheadTime was set, but drawPlayhead was not set in constructor');\r\n            this._playHeadTime = Math.max(0, viewPort.playheadTime);\r\n            if (this._playHeadTime > 0)\r\n                this._updateDrawLastTime = this._playHeadTime;\r\n            changed = true;\r\n        }\r\n        // Redraw timeline if anything has changed.\r\n        if (changed === true) {\r\n            this.redrawTimeline();\r\n        }\r\n    }\r\n    /**\r\n     * Accessor for polling the currently hovered over object.\r\n     */\r\n    getHoveredObject() {\r\n        return this._hoveredOver;\r\n    }\r\n    /**\r\n     * Calculates the height to give to each row to fit all layers on screen.\r\n     * @param {String[]} layers Map of layers to use.\r\n     * @returns Height of rows.\r\n     */\r\n    calculateRowHeight(layers) {\r\n        return Math.min(MAX_LAYER_HEIGHT, this._canvasHeight / Object.keys(layers).length);\r\n    }\r\n    updateLayerLabels() {\r\n        // Store layers to draw.\r\n        const o = this.getLayersToDraw();\r\n        if (!isEqual(this._layerLabels, o.layers)) {\r\n            this._layerLabels = o.layers;\r\n            // Calculate row height.\r\n            this._rowHeight = this.calculateRowHeight(this._layerLabels);\r\n            // Set timeline object height.\r\n            this._timelineObjectHeight = this._rowHeight * TIMELINE_OBJECT_HEIGHT;\r\n            this._numberOfLayers = Object.keys(this._layerLabels).length;\r\n            this._rowsTotalHeight = this._rowHeight * this._numberOfLayers;\r\n        }\r\n    }\r\n    getLayers() {\r\n        const layers = Object.entries(this._layerLabels);\r\n        layers.sort((a, b) => a[1] - b[1]);\r\n        return layers.map(l => l[0]);\r\n    }\r\n    /**\r\n     * Draws the layer labels to the canvas.\r\n     */\r\n    drawLayerLabels() {\r\n        let row = 0;\r\n        // Iterate through layers.\r\n        for (let layerName of this.getLayers()) {\r\n            this._canvas.fillStyle = COLOR_LABEL_BACKGROUND;\r\n            this._canvas.fillRect(0, row * this._rowHeight, this._layerLabelWidth, this._rowHeight);\r\n            this._canvas.fillStyle = TEXT_COLOR;\r\n            this._canvas.font = TEXT_FONT_SIZE.toString() + 'px ' + TEXT_FONT_FAMILY;\r\n            this._canvas.textBaseline = 'middle';\r\n            this._canvas.fillText(layerName, 0, (row * this._rowHeight) + (this._rowHeight / 2), this._layerLabelWidth);\r\n            if (this._layerLabels[layerName] !== 0) {\r\n                this._canvas.fillStyle = COLOR_LINE;\r\n                this._canvas.fillRect(this._layerLabelWidth, row * this._rowHeight, this._viewDrawWidth, THICKNESS_LINE);\r\n            }\r\n            row++;\r\n        }\r\n    }\r\n    /**\r\n     * Draws the timeline background.\r\n     */\r\n    drawBackground() {\r\n        this._canvas.fillStyle = COLOR_BACKGROUND;\r\n        this._canvas.fillRect(0, 0, this._canvasWidth, this._canvasHeight);\r\n        this.drawBackgroundRuler();\r\n    }\r\n    /**\r\n     * Draw a ruler on top of background\r\n     */\r\n    drawBackgroundRuler() {\r\n        const range = this.viewRange;\r\n        const endTime = this.viewEndTime;\r\n        const circaNumberOfLines = 5;\r\n        const rounder = Math.pow(10, Math.floor(Math.log10(range / circaNumberOfLines))); // What to round the ruler to\r\n        const rounderNext = rounder * 10;\r\n        const numberOfLines = Math.floor(range / rounder);\r\n        const rulerDiff = rounder;\r\n        const startTime = Math.floor(this._viewStartTime / rounder) * rounder;\r\n        const opacity = (Math.min(1, circaNumberOfLines / numberOfLines));\r\n        if (rulerDiff) {\r\n            this._canvas.strokeStyle = RULER_LINE_COLOR;\r\n            this._canvas.lineWidth = RULER_LINE_WIDTH;\r\n            for (let rulerTime = startTime; rulerTime < endTime; rulerTime += rulerDiff) {\r\n                this._canvas.beginPath();\r\n                let x = this.timeToXCoord(rulerTime);\r\n                let distanceToNext = (rulerTime / rounderNext) % 1;\r\n                if (distanceToNext > 0.5)\r\n                    distanceToNext -= 1;\r\n                distanceToNext = Math.abs(distanceToNext);\r\n                if (distanceToNext < 0.01) {\r\n                    // Is a significant line\r\n                    this._canvas.globalAlpha = 1;\r\n                }\r\n                else {\r\n                    this._canvas.globalAlpha = opacity;\r\n                }\r\n                if (x >= this._viewDrawX) {\r\n                    this._canvas.moveTo(x, 0);\r\n                    this._canvas.lineTo(x, this._canvasHeight);\r\n                }\r\n                this._canvas.stroke();\r\n            }\r\n            this._canvas.globalAlpha = 1;\r\n        }\r\n    }\r\n    /**\r\n     * Draws the playhead initially.\r\n     */\r\n    drawPlayhead() {\r\n        // If the playhead should be draw.\r\n        if (this._drawPlayhead) {\r\n            if (this.istimeInView(this._playHeadTime)) {\r\n                this._canvas.fillStyle = COLOR_PLAYHEAD;\r\n                this._canvas.fillRect(this.timeToXCoord(this._playHeadTime), 0, THICKNESS_PLAYHEAD, this._canvasHeight);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Gets the layers to draw from the timeline.\r\n     */\r\n    getLayersToDraw() {\r\n        this._hoveredObjectMap = {};\r\n        const layersArray = this._resolvedStates ? Object.keys(this._resolvedStates.layers) : [];\r\n        layersArray.sort((a, b) => {\r\n            if (a > b)\r\n                return 1;\r\n            if (a < b)\r\n                return 1;\r\n            return 0;\r\n        });\r\n        const layers = {};\r\n        layersArray.forEach((layerName, index) => {\r\n            layers[layerName] = index;\r\n            this._hoveredObjectMap[layerName] = [];\r\n        });\r\n        return {\r\n            layers: layers,\r\n            layersArray: layersArray\r\n        };\r\n    }\r\n    /**\r\n     * Redraws the timeline to the canvas.\r\n     */\r\n    redrawTimeline() {\r\n        this._canvas.clearRect(0, 0, this._canvasWidth, this._canvasHeight);\r\n        this.drawBackground();\r\n        this.drawLayerLabels();\r\n        // Recompute objects positions\r\n        this._timelineState = this.getTimelineDrawState(this._resolvedStates);\r\n        // Draw the current state.\r\n        this.drawTimelineState(this._timelineState);\r\n        this.drawPlayhead();\r\n        this.checkAutomaticReresolve();\r\n    }\r\n    /**\r\n     * Draws a timeline state to the canvas.\r\n     * @param {TimelineDrawState} currentDrawState State to draw.\r\n     */\r\n    drawTimelineState(currentDrawState) {\r\n        for (let element in currentDrawState) {\r\n            const drawState = currentDrawState[element];\r\n            if (drawState.visible) {\r\n                this._canvas.fillStyle = COLOR_TIMELINE_OBJECT_FILL;\r\n                this._canvas.fillRect(drawState.left, drawState.top, drawState.width, drawState.height);\r\n                this._canvas.strokeStyle = COLOR_TIMELINE_OBJECT_BORDER;\r\n                this._canvas.lineWidth = THICKNESS_TIMELINE_OBJECT_BORDER;\r\n                this._canvas.strokeRect(drawState.left, drawState.top, drawState.width, drawState.height);\r\n                this._canvas.fillStyle = TEXT_COLOR;\r\n                this._canvas.font = TEXT_FONT_SIZE.toString() + 'px ' + TEXT_FONT_FAMILY;\r\n                this._canvas.textBaseline = 'top';\r\n                this._canvas.fillText(drawState.title, drawState.left, drawState.top);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns the draw states for all timeline objects.\r\n     * @param {ResolvedStates} timeline Timeline to draw.\r\n     * @returns {TimelineDrawState} State of time-based objects.\r\n     */\r\n    getTimelineDrawState(timeline) {\r\n        let currentDrawState = {};\r\n        if (timeline) {\r\n            for (let objId in timeline.objects) {\r\n                let timelineObj = timeline.objects[objId];\r\n                for (let _i = 0; _i < timelineObj.resolved.instances.length; _i++) {\r\n                    let instanceObj = timelineObj.resolved.instances[_i];\r\n                    let name = 'timelineObject:' + objId + ':' + instanceObj.id;\r\n                    currentDrawState[name] = this.createStateForObject(timelineObj, instanceObj.start, instanceObj.end);\r\n                    if (currentDrawState[name].visible === true) {\r\n                        if (!this._hoveredObjectMap[timelineObj.layer + ''])\r\n                            this._hoveredObjectMap[timelineObj.layer + ''] = [];\r\n                        this._hoveredObjectMap[timelineObj.layer + ''].push({\r\n                            startX: currentDrawState[name].left,\r\n                            endX: currentDrawState[name].left + currentDrawState[name].width,\r\n                            objectRefId: objId,\r\n                            instanceId: instanceObj.id,\r\n                            type: 'timelineObject',\r\n                            name: name\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return currentDrawState;\r\n    }\r\n    /**\r\n     * Creates a draw state for a timeline object.\r\n     * @param {string} layer Object's layer.\r\n     * @param {number} start Start time.\r\n     * @param {number} end End time.\r\n     * @returns {DrawState} State of the object to draw.\r\n     */\r\n    createStateForObject(obj, start, end) {\r\n        // Default state (hidden).\r\n        let state = {\r\n            height: 0,\r\n            left: 0,\r\n            top: 0,\r\n            width: 0,\r\n            visible: false,\r\n            title: 'N/A'\r\n        };\r\n        // State should be default if the object is not being shown.\r\n        if (this.showOnTimeline(start, end)) {\r\n            // Get object dimensions and position.\r\n            let objectWidth = this.getObjectWidth(start, end);\r\n            let xCoord = this.capXcoordToView(this.timeToXCoord(start));\r\n            let objectTop = this.getObjectOffsetFromTop(obj.layer + '');\r\n            // Set state properties.\r\n            state.height = this._timelineObjectHeight;\r\n            state.left = xCoord;\r\n            state.top = objectTop;\r\n            state.width = objectWidth;\r\n            state.visible = true;\r\n            state.title = obj.id;\r\n        }\r\n        return state;\r\n    }\r\n    /**\r\n     * Calculates the offset, in pixels from the start of the timeline for an object.\r\n     * @param {number} start start time of the object.\r\n     * @returns {number} Offset in pixels.\r\n     */\r\n    // private getObjectOffsetFromTimelineStart (start: number): number {\r\n    // \t// Calculate offset.\r\n    // \tlet offset = (start - this._viewStartTime) * this.pixelsWidthPerUnitTime\r\n    // \t// Offset cannot be to the left of the timeline start position.\r\n    // \tif (offset < 0) {\r\n    // \t\toffset = 0\r\n    // \t}\r\n    // \treturn offset\r\n    // }\r\n    /**\r\n     * Calculates the width, in pixels, of an object based on its duration.\r\n     * @param {number} start Start time of the object.\r\n     * @param {number} end End time of the object.\r\n     * @returns {number} Width in pixels.\r\n     */\r\n    getObjectWidth(startTime, endTime) {\r\n        if (!endTime)\r\n            return this._canvasWidth;\r\n        // If the start time is less than the timeline start, set to timeline start.\r\n        if (startTime < this._viewStartTime) {\r\n            startTime = this._viewStartTime;\r\n        }\r\n        // Calculate duration of the object remaining on the timeline.\r\n        let duration = endTime - startTime;\r\n        // Return end point position in pixels.\r\n        return duration * this.pixelsWidthPerUnitTime;\r\n    }\r\n    /**\r\n     * Determines whether to show an object on the timeline.\r\n     * @param {number} start Object start time.\r\n     * @param {number} end Object end time.\r\n     * @returns {true} if object should be shown on the timeline.\r\n     */\r\n    showOnTimeline(start, end) {\r\n        let isAfter = start >= this.viewEndTime;\r\n        let isBefore = (end || Infinity) <= this._viewStartTime;\r\n        return !isAfter && !isBefore;\r\n    }\r\n    /**\r\n     * Calculate position of object instance from top of timeline according to its layer.\r\n     * @param {string} layer Object's layer.\r\n     * @returns Position relative to top of canvas in pixels.\r\n     */\r\n    getObjectOffsetFromTop(layerName) {\r\n        let top = this._layerLabels[layerName];\r\n        return top * this._rowHeight;\r\n    }\r\n    /**\r\n     * Moves the playhead. Called periodically.\r\n     */\r\n    updateDraw() {\r\n        const now = Date.now();\r\n        // How long time since last update:\r\n        const dt = (this._updateDrawLastTime > 0 ?\r\n            now - this._updateDrawLastTime :\r\n            1) / 1000;\r\n        this._updateDrawLastTime = now;\r\n        const deltaTime = this._playSpeed * dt;\r\n        // Check playhead should be drawn.\r\n        let needRedraw = false;\r\n        if (this._playHeadPlaying && this._drawPlayhead) {\r\n            if (this._playViewPort &&\r\n                this.istimeInView(this._playHeadTime) // Only play if playhead is in view\r\n            ) {\r\n                this._viewStartTime += deltaTime;\r\n            }\r\n            // Move playhead forward\r\n            this._playHeadTime += deltaTime;\r\n            needRedraw = true;\r\n        }\r\n        if (needRedraw) {\r\n            this.redrawTimeline();\r\n        }\r\n        // call this function on next frame\r\n        window.requestAnimationFrame(() => this.updateDraw());\r\n    }\r\n    /**\r\n     * Handles mouse down event.\r\n     * @param event Mouse event.\r\n     */\r\n    canvasMouseDown(event) {\r\n        // Store mouse is down.\r\n        this._mouseDown = true;\r\n        // Store X position of mouse on click.\r\n        this._mouseLastX = event.clientX;\r\n        // Prevent event.\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n    }\r\n    /**\r\n     * Handles mouse up event.\r\n     * @param event Mouse event.\r\n     */\r\n    canvasMouseUp(event) {\r\n        // Mouse no longer down.\r\n        this._mouseDown = false;\r\n        // Reset scroll direction.\r\n        this._lastScrollDirection = 0;\r\n        // Prevent event.\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n    }\r\n    /**\r\n     * Handles mouse movement on canvas.\r\n     * @param event Mouse event.\r\n     */\r\n    canvasMouseMove(event) {\r\n        // If mouse is down.\r\n        if (this._mouseDown) {\r\n            // If we are beginning scrolling, we can move freely.\r\n            if (this._lastScrollDirection === undefined || this._lastScrollDirection === 0) {\r\n                // Store current mouse X.\r\n                this._mouseLastX = event.clientX;\r\n                // Calculate change in X.\r\n                let deltaX = event.clientX - this._mouseLastX;\r\n                // Store scrolling direction.\r\n                if (deltaX < 0) {\r\n                    this._lastScrollDirection = -1;\r\n                }\r\n                else {\r\n                    this._lastScrollDirection = 1;\r\n                }\r\n                // Scroll to new X position.\r\n                this.canvasScrollByDeltaX(-deltaX);\r\n            }\r\n            else {\r\n                // Calculate scroll direction.\r\n                let direction = this._mouseLastX - event.clientX;\r\n                // If changing direction, store new direction but don't scroll.\r\n                if (direction < 0 && this._lastScrollDirection === 1) {\r\n                    this._mouseLastX = event.clientX;\r\n                    this._lastScrollDirection = -1;\r\n                }\r\n                else if (direction > 0 && this._lastScrollDirection === -1) {\r\n                    this._mouseLastX = event.clientX;\r\n                    this._lastScrollDirection = 1;\r\n                }\r\n                else {\r\n                    // Calculate change in X.\r\n                    let deltaX = event.clientX - this._mouseLastX;\r\n                    // Store last X position.\r\n                    this._mouseLastX = event.clientX;\r\n                    // Move by change in X.\r\n                    this.canvasScrollByDeltaX(-deltaX);\r\n                }\r\n            }\r\n            // Redraw timeline.\r\n            this.redrawTimeline();\r\n        }\r\n        else {\r\n            // Whether an object is under the cursor.\r\n            let found = false;\r\n            // Find the object that is currently hovered over.\r\n            let mousePos = this.getMousePos(this._canvasContainer, event);\r\n            if (mousePos.x > this._viewDrawX) {\r\n                if (mousePos.y < this._rowsTotalHeight) {\r\n                    let selectedRow = Math.floor((mousePos.y / this._rowsTotalHeight) * this._numberOfLayers);\r\n                    let layer;\r\n                    Object.keys(this._layerLabels).forEach(layerName => {\r\n                        if (this._layerLabels[layerName] === selectedRow)\r\n                            layer = layerName;\r\n                    });\r\n                    let hoverMapData = (layer ? this._hoveredObjectMap[layer] : []) || [];\r\n                    hoverMapData.forEach(object => {\r\n                        if (object.startX <= mousePos.x && object.endX >= mousePos.x) {\r\n                            found = true;\r\n                            const hoverHash = object.type + object.objectRefId + object.instanceId; // hash-ish\r\n                            if (this._lastHoveredHash !== hoverHash) {\r\n                                // Get object metadata from the object name of the hovered object.\r\n                                // If we are hovering over a timeline object.\r\n                                if (object.type === 'timelineObject') {\r\n                                    // Get the timeline object and the instance being hovered over.\r\n                                    if (this._resolvedStates) {\r\n                                        let timelineObject = this._resolvedStates.objects[object.objectRefId];\r\n                                        let instance = timelineObject.resolved.instances.find(instance => instance.id === object.instanceId);\r\n                                        if (instance) {\r\n                                            // Construct hover info.\r\n                                            let hoverInfo = {\r\n                                                object: timelineObject,\r\n                                                instance: instance,\r\n                                                pointer: { xPostion: mousePos.x, yPosition: mousePos.y }\r\n                                            };\r\n                                            // Set currently hovered object.\r\n                                            this._hoveredOver = hoverInfo;\r\n                                            // Emit event.\r\n                                            this.emit('timeline:hover', { detail: this._hoveredOver });\r\n                                        }\r\n                                        // Store last items.\r\n                                        this._lastHoverAction = MOUSEIN;\r\n                                        this._lastHoveredHash = hoverHash;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            // Emit undefined when mouse out.\r\n            if (!found && this._lastHoverAction === MOUSEIN) {\r\n                this.emit('timeline:hover', { detail: undefined });\r\n                this._lastHoverAction = MOUSEOUT;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Handles scroll wheel events on the canvas.\r\n     * @param event Scroll event.\r\n     */\r\n    canvasScrollWheel(event) {\r\n        // Get mouse pointer coordinates on canvas.\r\n        let canvasCoord = this.getMousePos(this._canvasContainer, event);\r\n        // Don't scroll if mouse is not over timeline.\r\n        if (canvasCoord.x <= this._viewDrawX) {\r\n            return;\r\n        }\r\n        let changed = false;\r\n        // CTRL + scroll to zoom.\r\n        if (event.ctrlKey === true) {\r\n            if (event.deltaY) {\r\n                changed = true;\r\n                const zoomFactor = Math.pow(ZOOM_FACTOR, -event.deltaY);\r\n                this.zoomUnderCursor(canvasCoord.x, zoomFactor);\r\n            }\r\n        }\r\n        else if (event.deltaX !== 0) { // Scroll on x-axis\r\n            changed = true;\r\n            // Pan.\r\n            this.canvasScrollByDeltaX((event.deltaX * (PAN_FACTOR * this.stepSize)));\r\n        }\r\n        else if (event.deltaY !== 0 && event.altKey === true) { // Also scroll on alt-key + scroll y-axis\r\n            changed = true;\r\n            // Pan.\r\n            this.canvasScrollByDeltaX((event.deltaY * (PAN_FACTOR * this.stepSize)));\r\n        }\r\n        // Prevent event.\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        if (changed) {\r\n            // Redraw timeline.\r\n            this.redrawTimeline();\r\n        }\r\n    }\r\n    /**\r\n     * Scroll across the canvas by a specified X value.\r\n     * @param {number} deltaX Value to move by.\r\n     */\r\n    canvasScrollByDeltaX(deltaX) {\r\n        // Calculate new starting time.\r\n        let targetStart = this._viewStartTime + (deltaX / this.pixelsWidthPerUnitTime);\r\n        // Starting time cannot be < 0.\r\n        if (targetStart < 0) {\r\n            targetStart = 0;\r\n        }\r\n        // Optimisation, don't redraw if nothing has changed.\r\n        if (targetStart === this._viewStartTime) {\r\n            return;\r\n        }\r\n        this._viewStartTime = targetStart;\r\n    }\r\n    /**\r\n     * Zooms into/out of timeline, keeping the time under the cursor in the same position.\r\n     * @param cursorX Position of mouse cursor.\r\n     */\r\n    zoomUnderCursor(cursorX, zoomFactor) {\r\n        // Point in time of the cursor\r\n        let cursorTime = this.xCoordToTime(cursorX);\r\n        // Ratio (in view range) of the cursor\r\n        let cursorRatio = this.timeToRatio(cursorTime);\r\n        // Change zoom:\r\n        this._timelineZoom = this._timelineZoom * zoomFactor;\r\n        // Limit within current view\r\n        cursorRatio = Math.max(0, Math.min(1, cursorRatio));\r\n        // Calculate start\r\n        let targetStart = cursorTime - (cursorRatio * this.viewRange);\r\n        // Start cannot be less than 0\r\n        if (targetStart < 0) {\r\n            targetStart = 0;\r\n        }\r\n        // Set draw time\r\n        this._viewStartTime = targetStart;\r\n    }\r\n    /**\r\n     * Gets the mouse position relative to the top-left of the canvas [pixels]\r\n     * @param canvas\r\n     * @param evt\r\n     * @returns {x: number, y: number} Position.\r\n     */\r\n    getMousePos(canvas, evt) {\r\n        const rect = canvas.getBoundingClientRect();\r\n        return {\r\n            x: evt.clientX - rect.left,\r\n            y: evt.clientY - rect.top\r\n        };\r\n    }\r\n    /**\r\n     * Trims a timeline so that objects only exist within a specified time period.\r\n     * @param timeline Timeline to trim.\r\n     * @param trim Times to trim between.\r\n     */\r\n    trimTimeline(timeline, trim) {\r\n        // The new resolved objects.\r\n        let newObjects = {};\r\n        // Iterate through resolved objects.\r\n        Object.keys(timeline.objects).forEach((objId) => {\r\n            const obj = timeline.objects[objId];\r\n            const resultingInstances = [];\r\n            obj.resolved.instances.forEach(instance => {\r\n                // Whether to insert this object into the new timeline.\r\n                let useInstance = false;\r\n                let newInstance = Object.assign({}, instance); // clone\r\n                // If trimming the start time.\r\n                if (trim.start) {\r\n                    // If the object ends after the trim start time.\r\n                    if ((instance.end || Infinity) > trim.start) {\r\n                        useInstance = true;\r\n                        if (newInstance.start < trim.start) {\r\n                            newInstance.start = trim.start;\r\n                        }\r\n                    }\r\n                }\r\n                // If trimming the end time.\r\n                if (trim.end) {\r\n                    // If the object starts before the trim end time.\r\n                    if (instance.start < trim.end) {\r\n                        useInstance = true;\r\n                        if ((newInstance.end || Infinity) > trim.end) {\r\n                            newInstance.end = trim.end;\r\n                        }\r\n                    }\r\n                }\r\n                if (!trim.start && !trim.end) {\r\n                    useInstance = true;\r\n                }\r\n                if (useInstance &&\r\n                    newInstance.start < (newInstance.end || Infinity)) {\r\n                    resultingInstances.push(newInstance);\r\n                }\r\n            });\r\n            // If there isn't a resolved object for the new instance, create it.\r\n            if (!newObjects[objId]) {\r\n                let newObject = {\r\n                    content: obj.content,\r\n                    enable: obj.enable,\r\n                    id: obj.id,\r\n                    layer: obj.layer,\r\n                    resolved: {\r\n                        instances: [],\r\n                        levelDeep: obj.resolved.levelDeep,\r\n                        resolved: obj.resolved.resolved,\r\n                        resolving: obj.resolved.resolving,\r\n                        directReferences: obj.resolved.directReferences,\r\n                    }\r\n                };\r\n                newObjects[objId] = newObject;\r\n            }\r\n            newObjects[objId].resolved.instances = resultingInstances;\r\n        });\r\n        return {\r\n            classes: timeline.classes,\r\n            layers: timeline.layers,\r\n            objects: newObjects,\r\n            options: timeline.options,\r\n            statistics: timeline.statistics,\r\n            state: timeline.state,\r\n            nextEvents: timeline.nextEvents\r\n        };\r\n    }\r\n    /**\r\n     * Merges two timelines by merging instances of objects that intersect each other.\r\n     * @param past Older timeline.\r\n     * @param present Newer timeline.\r\n     * @returns {ResolvedTimeline} containing merged timelines.\r\n     */\r\n    mergeTimelineObjects(past, present, fromNewTimeline) {\r\n        const resultingObjects = {};\r\n        if (fromNewTimeline) {\r\n            past = this.trimTimeline(past, { end: this._playHeadTime });\r\n            present = this.trimTimeline(present, { start: this._playHeadTime });\r\n            // Because we want to keep old objects, this iterator is used to create unique old ids for them\r\n            this._mergeIterator++;\r\n            Object.keys(past.objects).forEach((objId) => {\r\n                const pastObj = past.objects[objId];\r\n                // @ts-ignore: hack to mark it as a \"past object\"\r\n                if (pastObj.__pastObj) {\r\n                    // Copy over it right away, it's old. Don't do anything else\r\n                    resultingObjects[objId] = pastObj;\r\n                    return;\r\n                }\r\n                // If an object exists in both timelines\r\n                const presentObj = present.objects[objId];\r\n                if (presentObj) {\r\n                    if (\r\n                    // Compare the objects, only look into merging them if they look identical\r\n                    isEqual(Object.assign({}, pastObj, { resolved: null }), Object.assign({}, presentObj, { resolved: null }))) {\r\n                        // This assumes that all past instances stop at a certain time at the very latest,\r\n                        // and that all new instances start at that time at the very earliest.\r\n                        // Iterate over all instances of those objects.\r\n                        const allInstances = {};\r\n                        pastObj.resolved.instances.forEach(pastInstance => {\r\n                            allInstances[pastInstance.end + ''] = pastInstance;\r\n                        });\r\n                        presentObj.resolved.instances.forEach(presentInstance => {\r\n                            if (allInstances[presentInstance.start + '']) {\r\n                                // The instances are next to each other, merge them into one:\r\n                                allInstances[presentInstance.start + ''].end = presentInstance.end;\r\n                            }\r\n                            else {\r\n                                allInstances[presentInstance.start + ''] = presentInstance;\r\n                            }\r\n                        });\r\n                        presentObj.resolved.instances = [];\r\n                        Object.keys(allInstances).forEach(key => {\r\n                            const instance = allInstances[key];\r\n                            presentObj.resolved.instances.push(instance);\r\n                        });\r\n                        // Copy over the new object\r\n                        resultingObjects[objId] = presentObj;\r\n                        return; // don't copy over old object\r\n                    }\r\n                    else {\r\n                        // The objects doesn't look identical\r\n                        // Copy over the new object\r\n                        resultingObjects[objId] = presentObj;\r\n                    }\r\n                }\r\n                else {\r\n                    // The old object doesn't exist in the new timeline\r\n                }\r\n                // @ts-ignore: hack to mark it as a \"past object\"\r\n                pastObj.__pastObj = true;\r\n                // Copy over the old object\r\n                resultingObjects[this._mergeIterator + '__' + objId] = pastObj;\r\n            });\r\n            // Iterate over the next objects\r\n            Object.keys(present.objects).forEach((objId) => {\r\n                const presentObj = present.objects[objId];\r\n                if (!past.objects[objId]) { // (if it did existed in the past, it has already been handled)\r\n                    // Just copy over the new object\r\n                    resultingObjects[objId] = presentObj;\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            // No new timeline, objects and instances are only added\r\n            Object.keys(past.objects).forEach((objId) => {\r\n                const pastObj = past.objects[objId];\r\n                resultingObjects[objId] = pastObj;\r\n            });\r\n            Object.keys(present.objects).forEach((objId) => {\r\n                const presentObj = present.objects[objId];\r\n                const existingObj = resultingObjects[objId];\r\n                if (existingObj) {\r\n                    // merge with old instances\r\n                    const existingInstances = {};\r\n                    existingObj.resolved.instances.forEach(instance => {\r\n                        existingInstances[instance.start + '_' + instance.end] = true;\r\n                    });\r\n                    presentObj.resolved.instances.forEach(instance => {\r\n                        // Only push instances that aren't already present:\r\n                        if (!existingInstances[instance.start + '_' + instance.end]) {\r\n                            existingObj.resolved.instances.push(instance);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    resultingObjects[objId] = presentObj;\r\n                }\r\n            });\r\n        }\r\n        const resultingLayers = {};\r\n        Object.keys(resultingObjects).forEach(key => {\r\n            const obj = resultingObjects[key];\r\n            const layer = obj.layer + '';\r\n            if (!resultingLayers[layer])\r\n                resultingLayers[layer] = [];\r\n            resultingLayers[layer].push(key);\r\n        });\r\n        return Object.assign(Object.assign({}, present), { objects: resultingObjects, layers: resultingLayers });\r\n    }\r\n    updateTimelineResolveWindow() {\r\n        const { start, end } = this.getExpandedStartEndTime(1);\r\n        this._timelineResolveStart = start;\r\n        this._timelineResolveEnd = end;\r\n        this._timelineResolveZoom = this._timelineZoom;\r\n        if (this.latestUpdateTime) {\r\n            // Calculate an optimal number of objects to create, so that the drawing still runs smoothly.\r\n            const targetResolveTime = 50; // ms\r\n            let ratio = targetResolveTime / this.latestUpdateTime;\r\n            this._timelineResolveCountAdjust = Math.max(0.1, Math.min(10, (1 + (this._timelineResolveCountAdjust * ratio)) / 2));\r\n        }\r\n    }\r\n    getExpandedStartEndTime(multiplier = 1) {\r\n        let start = this._viewStartTime;\r\n        let end = this.viewEndTime;\r\n        let duration = end - start;\r\n        let expand = duration * (this._timelineResolveExpand - 1) * multiplier;\r\n        start -= expand * 0.33;\r\n        end += expand * 0.66; // expand more into the future\r\n        start = Math.max(0, start);\r\n        end = Math.max(0, end);\r\n        const zoomDiff = Math.max(this._timelineResolveZoom, this._timelineZoom) /\r\n            Math.min(this._timelineResolveZoom, this._timelineZoom);\r\n        return { start, end, zoomDiff };\r\n    }\r\n    checkAutomaticReresolve() {\r\n        const { start, end, zoomDiff } = this.getExpandedStartEndTime(0.2);\r\n        if (this._timelineResolveAuto && (start < this._timelineResolveStart ||\r\n            end > this._timelineResolveEnd ||\r\n            zoomDiff > 3)) {\r\n            if (!this.reresolveTimeout) {\r\n                this.reresolveTimeout = setTimeout(() => {\r\n                    this.reresolveTimeout = null;\r\n                    this.updateTimelineResolveWindow();\r\n                    this._updateTimeline();\r\n                }, Math.max(100, this.latestUpdateTime * 5));\r\n            }\r\n        }\r\n    }\r\n    // --------------------- Conversions between position & time -------------\r\n    /**\r\n     * Calculate the X coordinate of a time value.\r\n     * @param {number} time The time to convert.\r\n     * @returns {number} The X coordinate of the time.\r\n     */\r\n    timeToXCoord(time) {\r\n        return this._viewDrawX + ((time - this._viewStartTime) * this.pixelsWidthPerUnitTime);\r\n    }\r\n    /**\r\n     * Calculate the time of a X coordinate.\r\n     * @param {number} time The X coordinate to convert.\r\n     * @returns {number} The time of the X coordinate.\r\n     */\r\n    xCoordToTime(position) {\r\n        return this._viewStartTime + ((position - this._viewDrawX) / this.pixelsWidthPerUnitTime);\r\n    }\r\n    /** Calculate the ratio of the time in current view (0 i beginning, 1 is end)  */\r\n    timeToRatio(time) {\r\n        return (time - this._viewStartTime) / this.viewRange;\r\n    }\r\n    /** Returns true if the position is within the current view  */\r\n    istimeInView(time) {\r\n        const ratio = this.timeToRatio(time);\r\n        return ratio >= 0 && ratio < 1;\r\n    }\r\n    capXcoordToView(position) {\r\n        return Math.max(this._viewDrawX, Math.min(this._viewDrawX + this._viewDrawWidth, position));\r\n    }\r\n    // -------------- Getters / Convenience functions ---------------------\r\n    /** Zoom factor [pixels / time] */\r\n    get pixelsWidthPerUnitTime() {\r\n        return (this._timelineZoom / 100);\r\n    }\r\n    /** The range of the view [time] */\r\n    get viewRange() {\r\n        return this._viewDrawWidth / this.pixelsWidthPerUnitTime;\r\n    }\r\n    /** The end time of the view [time] */\r\n    get viewEndTime() {\r\n        return this._viewStartTime + this.viewRange;\r\n    }\r\n}\r\nexports.TimelineVisualizer = TimelineVisualizer;\r\n//# sourceMappingURL=timelineVisualizer.js.map","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar objectCreate = Object.create || objectCreatePolyfill\nvar objectKeys = Object.keys || objectKeysPolyfill\nvar bind = Function.prototype.bind || functionBindPolyfill\n\nfunction EventEmitter() {\n  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {\n    this._events = objectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nvar hasDefineProperty;\ntry {\n  var o = {};\n  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });\n  hasDefineProperty = o.x === 0;\n} catch (err) { hasDefineProperty = false }\nif (hasDefineProperty) {\n  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n    enumerable: true,\n    get: function() {\n      return defaultMaxListeners;\n    },\n    set: function(arg) {\n      // check whether the input is a positive number (whose value is zero or\n      // greater and not a NaN).\n      if (typeof arg !== 'number' || arg < 0 || arg !== arg)\n        throw new TypeError('\"defaultMaxListeners\" must be a positive number');\n      defaultMaxListeners = arg;\n    }\n  });\n} else {\n  EventEmitter.defaultMaxListeners = defaultMaxListeners;\n}\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    if (arguments.length > 1)\n      er = arguments[1];\n    if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Unhandled \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n      // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n      // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = objectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n          listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n          prepend ? [listener, existing] : [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n            existing.length + ' \"' + String(type) + '\" listeners ' +\n            'added. Use emitter.setMaxListeners() to ' +\n            'increase limit.');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        if (typeof console === 'object' && console.warn) {\n          console.warn('%s: %s', w.name, w.message);\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    switch (arguments.length) {\n      case 0:\n        return this.listener.call(this.target);\n      case 1:\n        return this.listener.call(this.target, arguments[0]);\n      case 2:\n        return this.listener.call(this.target, arguments[0], arguments[1]);\n      case 3:\n        return this.listener.call(this.target, arguments[0], arguments[1],\n            arguments[2]);\n      default:\n        var args = new Array(arguments.length);\n        for (var i = 0; i < args.length; ++i)\n          args[i] = arguments[i];\n        this.listener.apply(this.target, args);\n    }\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = bind.call(onceWrapper, state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = objectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else\n          spliceOne(list, position);\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = objectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = objectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = objectKeys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = objectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (!events)\n    return [];\n\n  var evlistener = events[type];\n  if (!evlistener)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction objectCreatePolyfill(proto) {\n  var F = function() {};\n  F.prototype = proto;\n  return new F;\n}\nfunction objectKeysPolyfill(obj) {\n  var keys = [];\n  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {\n    keys.push(k);\n  }\n  return k;\n}\nfunction functionBindPolyfill(context) {\n  var fn = this;\n  return function () {\n    return fn.apply(context, arguments);\n  };\n}\n","/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = isEqual;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=api.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EventType = void 0;\nvar EventType;\n(function (EventType) {\n    EventType[EventType[\"START\"] = 0] = \"START\";\n    EventType[EventType[\"END\"] = 1] = \"END\";\n    EventType[EventType[\"KEYFRAME\"] = 2] = \"KEYFRAME\";\n})(EventType = exports.EventType || (exports.EventType = {}));\n//# sourceMappingURL=enums.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateKeyframe = exports.validateObject = exports.validateTimeline = exports.Resolver = void 0;\nconst tslib_1 = require(\"tslib\");\n(0, tslib_1.__exportStar)(require(\"./api/enums\"), exports);\n(0, tslib_1.__exportStar)(require(\"./api/api\"), exports);\nvar resolver_1 = require(\"./resolver/resolver\");\nObject.defineProperty(exports, \"Resolver\", { enumerable: true, get: function () { return resolver_1.Resolver; } });\nvar validate_1 = require(\"./resolver/validate\");\nObject.defineProperty(exports, \"validateTimeline\", { enumerable: true, get: function () { return validate_1.validateTimeline; } });\nObject.defineProperty(exports, \"validateObject\", { enumerable: true, get: function () { return validate_1.validateObject; } });\nObject.defineProperty(exports, \"validateKeyframe\", { enumerable: true, get: function () { return validate_1.validateKeyframe; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cleanCacheResult = exports.cacheResult = exports.applyParentInstances = exports.setInstanceStartTime = exports.setInstanceEndTime = exports.resetId = exports.getId = exports.joinCaps = exports.addCapsToResuming = exports.joinReferences = exports.isReference = exports.capInstances = exports.applyRepeatingInstances = exports.operateOnArrays = exports.invertInstances = exports.convertEventsToInstances = exports.cleanInstances = exports.sortEvents = exports.isNumeric = exports.isConstant = exports.extendMandadory = void 0;\nconst _ = require(\"underscore\");\n/**\n * Somewhat like _.extend, but with strong types & mandated additional properties\n * @param original Object to be extended\n * @param extendObj properties to add\n */\nfunction extendMandadory(original, extendObj) {\n    return _.extend(original, extendObj);\n}\nexports.extendMandadory = extendMandadory;\nfunction isConstant(str) {\n    return !!(isNumeric(str) || (_.isString(str) && (str.match(/^true$/) || str.match(/^false$/))));\n}\nexports.isConstant = isConstant;\nfunction isNumeric(str) {\n    if (str === null)\n        return false;\n    if (_.isNumber(str))\n        return true;\n    if (_.isString(str))\n        return !!(str.match(/^[-+]?[0-9.]+$/) && !_.isNaN(parseFloat(str)));\n    return false;\n}\nexports.isNumeric = isNumeric;\nfunction sortEvents(events) {\n    return events.sort((a, b) => {\n        if (a.time > b.time)\n            return 1;\n        if (a.time < b.time)\n            return -1;\n        const aId = a.data && (a.data.id || (a.data.instance && a.data.instance.id));\n        const bId = b.data && (b.data.id || (b.data.instance && b.data.instance.id));\n        if (aId && bId && aId === bId) {\n            // If the event refer to the same ID, let the ending event be first:\n            if (a.value && !b.value)\n                return -1;\n            if (!a.value && b.value)\n                return 1;\n        }\n        if (a.value && !b.value)\n            return 1;\n        if (!a.value && b.value)\n            return -1;\n        return 0;\n    });\n}\nexports.sortEvents = sortEvents;\n/**\n * Clean up instances, join overlapping etc..\n * @param instances\n */\nfunction cleanInstances(instances, allowMerge, allowZeroGaps = false) {\n    // First, optimize for certain common situations:\n    if (instances.length === 0)\n        return [];\n    if (instances.length === 1)\n        return instances;\n    const events = [];\n    for (let i = 0; i < instances.length; i++) {\n        const instance = instances[i];\n        events.push({\n            time: instance.start,\n            value: true,\n            data: { instance: instance },\n            references: instance.references,\n        });\n        if (instance.end !== null) {\n            events.push({\n                time: instance.end,\n                value: false,\n                data: { instance: instance },\n                references: instance.references,\n            });\n        }\n    }\n    return convertEventsToInstances(events, allowMerge, allowZeroGaps);\n}\nexports.cleanInstances = cleanInstances;\nfunction convertEventsToInstances(events, allowMerge, allowZeroGaps = false) {\n    sortEvents(events);\n    const activeInstances = {};\n    let activeInstanceId = null;\n    let previousActive = false;\n    const negativeInstances = {};\n    let previousNegative = false;\n    let negativeInstanceId = null;\n    const returnInstances = [];\n    for (let i = 0; i < events.length; i++) {\n        const event = events[i];\n        const eventId = event.data.id || event.data.instance.id;\n        const lastInstance = returnInstances[returnInstances.length - 1];\n        if (event.value) {\n            activeInstances[eventId] = event;\n            delete negativeInstances[eventId];\n        }\n        else {\n            delete activeInstances[eventId];\n            negativeInstances[eventId] = event;\n        }\n        if (Object.keys(activeInstances).length) {\n            // There is an active instance\n            if (!allowMerge && !allowZeroGaps && lastInstance && previousNegative) {\n                // There is previously an inActive (negative) instance\n                lastInstance.start = event.time;\n            }\n            else {\n                const o = handleActiveInstances(event, lastInstance, activeInstanceId, eventId, activeInstances, allowMerge, allowZeroGaps);\n                activeInstanceId = o.activeInstanceId;\n                if (o.returnInstance) {\n                    returnInstances.push(o.returnInstance);\n                }\n            }\n            previousActive = true;\n            previousNegative = false;\n        }\n        else {\n            // No instances are active\n            if (lastInstance && previousActive) {\n                lastInstance.end = event.time;\n            }\n            else {\n                if (Object.keys(negativeInstances).length) {\n                    // There is a negative instance running\n                    const o = handleActiveInstances(event, lastInstance, negativeInstanceId, eventId, negativeInstances, allowMerge, allowZeroGaps);\n                    negativeInstanceId = o.activeInstanceId;\n                    if (o.returnInstance) {\n                        returnInstances.push({\n                            ...o.returnInstance,\n                            start: o.returnInstance.end || 0,\n                            end: o.returnInstance.start,\n                        });\n                    }\n                    previousNegative = true;\n                }\n            }\n            previousActive = false;\n        }\n    }\n    return returnInstances;\n}\nexports.convertEventsToInstances = convertEventsToInstances;\nfunction handleActiveInstances(event, lastInstance, activeInstanceId, eventId, activeInstances, allowMerge, allowZeroGaps = false) {\n    let returnInstance = null;\n    if (!allowMerge &&\n        event.value &&\n        lastInstance &&\n        lastInstance.end === null &&\n        activeInstanceId !== null &&\n        activeInstanceId !== eventId) {\n        // Start a new instance:\n        lastInstance.end = event.time;\n        returnInstance = {\n            id: getId(),\n            start: event.time,\n            end: null,\n            references: event.references,\n            originalEnd: event.data.instance.originalEnd,\n            originalStart: event.data.instance.originalStart,\n        };\n        activeInstanceId = eventId;\n    }\n    else if (!allowMerge && !event.value && lastInstance && activeInstanceId === eventId) {\n        // The active instance stopped playing, but another is still playing\n        const latestInstance = _.reduce(activeInstances, (memo, instanceEvent, id) => {\n            if (memo === null || memo.event.time < instanceEvent.time) {\n                return {\n                    event: instanceEvent,\n                    id: id,\n                };\n            }\n            return memo;\n        }, null);\n        if (latestInstance) {\n            // Restart that instance now:\n            lastInstance.end = event.time;\n            returnInstance = {\n                id: eventId + '_' + getId(),\n                start: event.time,\n                end: null,\n                references: latestInstance.event.references,\n                originalEnd: event.data.instance.originalEnd,\n                originalStart: event.data.instance.originalStart,\n            };\n            activeInstanceId = latestInstance.id;\n        }\n    }\n    else if (allowMerge && !allowZeroGaps && lastInstance && lastInstance.end === event.time) {\n        // The previously running ended just now\n        // resume previous instance:\n        lastInstance.end = null;\n        lastInstance.references = joinReferences(lastInstance.references, event.references);\n        addCapsToResuming(lastInstance, event.data.instance.caps);\n    }\n    else if (!lastInstance || lastInstance.end !== null) {\n        // There is no previously running instance\n        // Start a new instance:\n        returnInstance = {\n            id: eventId,\n            start: event.time,\n            end: null,\n            references: event.references,\n            caps: event.data.instance.caps,\n            originalEnd: event.data.instance.originalEnd,\n            originalStart: event.data.instance.originalStart,\n        };\n        activeInstanceId = eventId;\n    }\n    else {\n        // There is already a running instance\n        lastInstance.references = joinReferences(lastInstance.references, event.references);\n        addCapsToResuming(lastInstance, event.data.instance.caps);\n    }\n    if (lastInstance && lastInstance.caps && !lastInstance.caps.length)\n        delete lastInstance.caps;\n    if (returnInstance &&\n        lastInstance &&\n        lastInstance.start === lastInstance.end &&\n        lastInstance.end === returnInstance.start) {\n        // replace the previous zero-length with this one instead\n        lastInstance.id = returnInstance.id;\n        lastInstance.start = returnInstance.start;\n        lastInstance.end = returnInstance.end;\n        lastInstance.references = returnInstance.references;\n        lastInstance.caps = returnInstance.caps;\n        lastInstance.originalStart = returnInstance.originalStart;\n        lastInstance.originalEnd = returnInstance.originalEnd;\n        returnInstance = null;\n    }\n    return {\n        activeInstanceId,\n        returnInstance,\n    };\n}\nfunction invertInstances(instances) {\n    if (instances.length) {\n        instances = cleanInstances(instances, true, true);\n        const invertedInstances = [];\n        if (instances[0].start !== 0) {\n            invertedInstances.push({\n                id: getId(),\n                isFirst: true,\n                start: 0,\n                end: null,\n                references: joinReferences(instances[0].references, instances[0].id),\n            });\n        }\n        for (let i = 0; i < instances.length; i++) {\n            const instance = instances[i];\n            const last = _.last(invertedInstances);\n            if (last) {\n                last.end = instance.start;\n            }\n            if (instance.end !== null) {\n                invertedInstances.push({\n                    id: getId(),\n                    start: instance.end,\n                    end: null,\n                    references: joinReferences(instance.references, instance.id),\n                    caps: instance.caps,\n                });\n            }\n        }\n        return invertedInstances;\n    }\n    else {\n        return [\n            {\n                id: getId(),\n                isFirst: true,\n                start: 0,\n                end: null,\n                references: [],\n            },\n        ];\n    }\n}\nexports.invertInstances = invertInstances;\n/**\n * Perform an action on 2 arrays. Behaves somewhat like the \".*\"-operator in Matlab\n * @param array0\n * @param array1\n * @param operate\n */\nfunction operateOnArrays(array0, array1, operate) {\n    if (array0 === null || array1 === null)\n        return null;\n    if (isReference(array0) && isReference(array1)) {\n        return operate(array0, array1);\n    }\n    const result = [];\n    const minLength = Math.min(_.isArray(array0) ? array0.length : Infinity, _.isArray(array1) ? array1.length : Infinity);\n    for (let i = 0; i < minLength; i++) {\n        const a = _.isArray(array0)\n            ? array0[i]\n            : { id: '', start: array0.value, end: array0.value, references: array0.references };\n        const b = _.isArray(array1)\n            ? array1[i]\n            : { id: '', start: array1.value, end: array1.value, references: array1.references };\n        const start = a.isFirst\n            ? { value: a.start, references: a.references }\n            : b.isFirst\n                ? { value: b.start, references: b.references }\n                : operate({ value: a.start, references: joinReferences(a.id, a.references) }, { value: b.start, references: joinReferences(b.id, b.references) });\n        const end = a.isFirst\n            ? a.end !== null\n                ? { value: a.end, references: a.references }\n                : null\n            : b.isFirst\n                ? b.end !== null\n                    ? { value: b.end, references: b.references }\n                    : null\n                : operate(a.end !== null ? { value: a.end, references: joinReferences(a.id, a.references) } : null, b.end !== null ? { value: b.end, references: joinReferences(b.id, b.references) } : null);\n        if (start !== null) {\n            result.push({\n                id: getId(),\n                start: start.value,\n                end: end === null ? null : end.value,\n                references: joinReferences(start.references, end !== null ? end.references : []),\n                caps: joinCaps(a.caps, b.caps),\n            });\n        }\n    }\n    return cleanInstances(result, false);\n}\nexports.operateOnArrays = operateOnArrays;\nfunction applyRepeatingInstances(instances, repeatTime0, options) {\n    if (repeatTime0 === null || !repeatTime0.value)\n        return instances;\n    const repeatTime = repeatTime0.value;\n    if (isReference(instances)) {\n        instances = [\n            {\n                id: '',\n                start: instances.value,\n                end: null,\n                references: instances.references,\n            },\n        ];\n    }\n    const repeatedInstances = [];\n    for (let i = 0; i < instances.length; i++) {\n        const instance = instances[i];\n        let startTime = Math.max(options.time - ((options.time - instance.start) % repeatTime), instance.start);\n        let endTime = instance.end === null ? null : instance.end + (startTime - instance.start);\n        const cap = (instance.caps ? _.find(instance.caps, (cap) => instance.references.indexOf(cap.id) !== -1) : null) || null;\n        const limit = options.limitCount || 2;\n        for (let i = 0; i < limit; i++) {\n            if (options.limitTime && startTime >= options.limitTime)\n                break;\n            const cappedStartTime = cap ? Math.max(cap.start, startTime) : startTime;\n            const cappedEndTime = cap && cap.end !== null && endTime !== null ? Math.min(cap.end, endTime) : endTime;\n            if ((cappedEndTime !== null && cappedEndTime !== void 0 ? cappedEndTime : Infinity) > cappedStartTime) {\n                repeatedInstances.push({\n                    id: getId(),\n                    start: cappedStartTime,\n                    end: cappedEndTime,\n                    references: joinReferences(instance.id, instance.references, repeatTime0.references),\n                });\n            }\n            startTime += repeatTime;\n            if (endTime !== null)\n                endTime += repeatTime;\n        }\n    }\n    return cleanInstances(repeatedInstances, false);\n}\nexports.applyRepeatingInstances = applyRepeatingInstances;\n/**\n * Cap instances so that they are within their parentInstances\n * @param instances\n * @param parentInstances\n */\nfunction capInstances(instances, parentInstances) {\n    var _a, _b, _c, _d, _e, _f;\n    if (isReference(parentInstances) || parentInstances === null)\n        return instances;\n    let returnInstances = [];\n    for (let i = 0; i < instances.length; i++) {\n        const instanceOrg = instances[i];\n        const addedInstanceTimes = new Set();\n        for (let j = 0; j < parentInstances.length; j++) {\n            const parent = parentInstances[j];\n            // First, check if the instance crosses the parent at all:\n            if (instanceOrg.start <= ((_a = parent.end) !== null && _a !== void 0 ? _a : Infinity) && ((_b = instanceOrg.end) !== null && _b !== void 0 ? _b : Infinity) >= parent.start) {\n                const instance = _.clone(instanceOrg);\n                // Cap start\n                if (instance.start < parent.start) {\n                    setInstanceStartTime(instance, parent.start);\n                }\n                // Cap end\n                if (((_c = instance.end) !== null && _c !== void 0 ? _c : Infinity) > ((_d = parent.end) !== null && _d !== void 0 ? _d : Infinity)) {\n                    setInstanceEndTime(instance, parent.end);\n                }\n                if (instance.start >= parent.start && ((_e = instance.end) !== null && _e !== void 0 ? _e : Infinity) <= ((_f = parent.end) !== null && _f !== void 0 ? _f : Infinity)) {\n                    // The instance is within the parent\n                    if (instance.start === instance.end && addedInstanceTimes.has(instance.start)) {\n                        // Don't add zero-length instances if there are already is instances covering that time\n                    }\n                    else {\n                        instance.references = joinReferences(instance.references, parent.references);\n                        returnInstances.push(instance);\n                        addedInstanceTimes.add(instance.start);\n                        if (instance.end)\n                            addedInstanceTimes.add(instance.end);\n                    }\n                }\n            }\n        }\n    }\n    returnInstances.sort((a, b) => a.start - b.start);\n    // Ensure unique ids:\n    const ids = {};\n    for (let i = 0; i < returnInstances.length; i++) {\n        const instance = returnInstances[i];\n        // tslint:disable-next-line\n        if (ids[instance.id] !== undefined) {\n            instance.id = instance.id + ++ids[instance.id];\n        }\n        else {\n            ids[instance.id] = 0;\n        }\n    }\n    // Clean up the instances, to remove duplicates\n    returnInstances = cleanInstances(returnInstances, true, true);\n    return returnInstances;\n}\nexports.capInstances = capInstances;\nfunction isReference(ref0) {\n    const ref = ref0;\n    return (typeof ref === 'object' &&\n        !_.isArray(ref) &&\n        ref.value !== undefined &&\n        _.isArray(ref.references) &&\n        ref !== null);\n}\nexports.isReference = isReference;\nfunction joinReferences(...references) {\n    const refMap = {};\n    const refs = [];\n    for (let i = 0; i < references.length; i++) {\n        const reference = references[i];\n        if (reference) {\n            if (typeof reference === 'string') {\n                if (!refMap[reference])\n                    refs.push(reference);\n                refMap[reference] = true;\n            }\n            else {\n                for (let j = 0; j < reference.length; j++) {\n                    const ref = reference[j];\n                    if (ref) {\n                        if (!refMap[ref])\n                            refs.push(ref);\n                        refMap[ref] = true;\n                    }\n                }\n            }\n        }\n    }\n    return refs.sort((a, b) => {\n        if (a > b)\n            return 1;\n        if (a < b)\n            return -1;\n        return 0;\n    });\n}\nexports.joinReferences = joinReferences;\nfunction addCapsToResuming(instance, ...caps) {\n    const capsToAdd = [];\n    const joinedCaps = joinCaps(...caps);\n    for (let i = 0; i < joinedCaps.length; i++) {\n        const cap = joinedCaps[i];\n        if (cap.end !== null && instance.end !== null && cap.end > instance.end) {\n            capsToAdd.push({\n                id: cap.id,\n                start: 0,\n                end: cap.end,\n            });\n        }\n    }\n    instance.caps = joinCaps(instance.caps, capsToAdd);\n}\nexports.addCapsToResuming = addCapsToResuming;\nfunction joinCaps(...caps) {\n    const capMap = {};\n    for (let i = 0; i < caps.length; i++) {\n        const caps2 = caps[i];\n        if (caps2) {\n            for (let j = 0; j < caps2.length; j++) {\n                const cap2 = caps2[j];\n                capMap[cap2.id] = cap2;\n            }\n        }\n    }\n    return Object.values(capMap);\n}\nexports.joinCaps = joinCaps;\nlet idCount = 0;\n/**\n * Returns a unique id\n */\nfunction getId() {\n    return '@' + (idCount++).toString(36);\n}\nexports.getId = getId;\nfunction resetId() {\n    idCount = 0;\n}\nexports.resetId = resetId;\nfunction setInstanceEndTime(instance, endTime) {\n    instance.originalEnd = instance.originalEnd !== undefined ? instance.originalEnd : instance.end;\n    instance.end = endTime;\n}\nexports.setInstanceEndTime = setInstanceEndTime;\nfunction setInstanceStartTime(instance, startTime) {\n    instance.originalStart = instance.originalStart !== undefined ? instance.originalStart : instance.start;\n    instance.start = startTime;\n}\nexports.setInstanceStartTime = setInstanceStartTime;\nfunction applyParentInstances(parentInstances, value) {\n    return operateOnArrays(parentInstances, value, operate);\n}\nexports.applyParentInstances = applyParentInstances;\nfunction operate(a, b) {\n    if (a === null || b === null)\n        return null;\n    return {\n        value: a.value + b.value,\n        references: joinReferences(a.references, b.references),\n    };\n}\nconst cacheResultCache = {};\nlet cleanCacheResultTimeout = null;\n/** Cache the result of function for a limited time */\nfunction cacheResult(name, fcn, limitTime = 1000) {\n    if (Math.random() < 0.01) {\n        if (cleanCacheResultTimeout)\n            clearTimeout(cleanCacheResultTimeout);\n        cleanCacheResultTimeout = setTimeout(() => {\n            cleanCacheResult();\n        }, 100);\n    }\n    const cache = cacheResultCache[name];\n    if (!cache || cache.ttl < Date.now()) {\n        const value = fcn();\n        cacheResultCache[name] = {\n            ttl: Date.now() + limitTime,\n            value: value,\n        };\n        return value;\n    }\n    else {\n        return cache.value;\n    }\n}\nexports.cacheResult = cacheResult;\nfunction cleanCacheResult() {\n    if (cleanCacheResultTimeout) {\n        clearTimeout(cleanCacheResultTimeout);\n        cleanCacheResultTimeout = null;\n    }\n    _.each(cacheResultCache, (cache, name) => {\n        if (cache.ttl < Date.now())\n            delete cacheResultCache[name];\n    });\n}\nexports.cleanCacheResult = cleanCacheResult;\n//# sourceMappingURL=lib.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getObjectReferences = exports.hashTimelineObject = exports.initializeCache = void 0;\nfunction initializeCache(cacheOrg, resolvedTimeline) {\n    const cache = cacheOrg;\n    if (!cache.objHashes)\n        cache.objHashes = {};\n    if (!cache.resolvedTimeline)\n        cache.resolvedTimeline = resolvedTimeline;\n    // Todo: make statistics work when using cache\n    return cache;\n}\nexports.initializeCache = initializeCache;\n/** Return a \"hash-string\" which changes whenever anything that affects timing of a timeline-object has changed. */\nfunction hashTimelineObject(obj) {\n    const thingsThatMatter = [\n        JSON.stringify(obj.enable),\n        obj.disabled + '',\n        obj.priority + '',\n        obj.resolved.parentId || '',\n        obj.resolved.isKeyframe + '',\n        obj.classes ? obj.classes.join('.') : '',\n        obj.layer + '',\n        obj.seamless + '',\n        /*\n        Note: The following properties are ignored, as they don't affect timing or resolving:\n         * id\n         * children\n         * keyframes\n         * isGroup\n         * content\n         */\n    ];\n    return thingsThatMatter.join(',');\n}\nexports.hashTimelineObject = hashTimelineObject;\nfunction getObjectReferences(obj) {\n    return obj.resolved.directReferences;\n}\nexports.getObjectReferences = getObjectReferences;\n//# sourceMappingURL=cache.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addObjectToResolvedTimeline = void 0;\nfunction addObjectToResolvedTimeline(resolvedTimeline, obj) {\n    resolvedTimeline.objects[obj.id] = obj;\n    if (obj.classes) {\n        for (let i = 0; i < obj.classes.length; i++) {\n            const className = obj.classes[i];\n            if (className) {\n                if (!resolvedTimeline.classes[className])\n                    resolvedTimeline.classes[className] = [];\n                resolvedTimeline.classes[className].push(obj.id);\n            }\n        }\n    }\n    if (obj.layer) {\n        if (!resolvedTimeline.layers[obj.layer])\n            resolvedTimeline.layers[obj.layer] = [];\n        resolvedTimeline.layers[obj.layer].push(obj.id);\n    }\n}\nexports.addObjectToResolvedTimeline = addObjectToResolvedTimeline;\n//# sourceMappingURL=common.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateExpression = exports.wrapInnerExpressions = exports.simplifyExpression = exports.interpretExpression = exports.OPERATORS = void 0;\nconst _ = require(\"underscore\");\nconst lib_1 = require(\"../lib\");\nexports.OPERATORS = ['&', '|', '+', '-', '*', '/', '%', '!'];\nconst REGEXP_OPERATORS = _.map(exports.OPERATORS, (o) => '\\\\' + o).join('');\nfunction interpretExpression(expression) {\n    if ((0, lib_1.isNumeric)(expression)) {\n        return parseFloat(expression);\n    }\n    else if (_.isString(expression)) {\n        const expressionString = expression;\n        return (0, lib_1.cacheResult)(expressionString, () => {\n            const expr = expressionString.replace(new RegExp('([' + REGEXP_OPERATORS + '\\\\(\\\\)])', 'g'), ' $1 '); // Make sure there's a space between every operator & operand\n            const words = _.compact(expr.split(' '));\n            if (words.length === 0)\n                return null; // empty expression\n            // Fix special case: a + - b\n            for (let i = words.length - 2; i >= 1; i--) {\n                if ((words[i] === '-' || words[i] === '+') && wordIsOperator(exports.OPERATORS, words[i - 1])) {\n                    words[i] = words[i] + words[i + 1];\n                    words.splice(i + 1, 1);\n                }\n            }\n            const innerExpression = wrapInnerExpressions(words);\n            if (innerExpression.rest.length)\n                throw new Error('interpretExpression: syntax error: parentheses don\\'t add up in \"' + expr + '\".');\n            if (innerExpression.inner.length % 2 !== 1)\n                throw new Error('interpretExpression: operands & operators don\\'t add up: \"' +\n                    innerExpression.inner.join(' ') +\n                    '\".');\n            const expression = words2Expression(exports.OPERATORS, innerExpression.inner);\n            validateExpression(exports.OPERATORS, expression);\n            return expression;\n        }, 100 * 1000);\n    }\n    else {\n        return expression;\n    }\n}\nexports.interpretExpression = interpretExpression;\n/** Try to simplify an expression, this includes:\n * * Combine constant operands, using arithmetic operators\n * ...more to come?\n */\nfunction simplifyExpression(expr0) {\n    const expr = _.isString(expr0) ? interpretExpression(expr0) : expr0;\n    if (!expr)\n        return expr;\n    if (isExpressionObject(expr)) {\n        const l = simplifyExpression(expr.l);\n        const o = expr.o;\n        const r = simplifyExpression(expr.r);\n        if ((0, lib_1.isConstant)(l) && (0, lib_1.isConstant)(r) && _.isNumber(l) && _.isNumber(r)) {\n            // The operands can be combined:\n            return o === '+'\n                ? l + r\n                : o === '-'\n                    ? l - r\n                    : o === '*'\n                        ? l * r\n                        : o === '/'\n                            ? l / r\n                            : o === '%'\n                                ? l % r\n                                : { l, o, r };\n        }\n        return { l, o, r };\n    }\n    return expr;\n}\nexports.simplifyExpression = simplifyExpression;\nfunction isExpressionObject(expr) {\n    return typeof expr === 'object' && _.has(expr, 'l') && _.has(expr, 'o') && _.has(expr, 'r');\n}\nfunction wordIsOperator(operatorList, word) {\n    if (operatorList.indexOf(word) !== -1)\n        return true;\n    return false;\n}\n// Turns ['a', '(', 'b', 'c', ')'] into ['a', ['b', 'c']]\n// or ['a', '&', '!', 'b'] into ['a', '&', ['', '!', 'b']]\nfunction wrapInnerExpressions(words) {\n    for (let i = 0; i < words.length; i++) {\n        if (words[i] === '(') {\n            const tmp = wrapInnerExpressions(words.slice(i + 1));\n            // insert inner expression and remove tha\n            words[i] = tmp.inner;\n            words.splice(i + 1, 99999, ...tmp.rest);\n        }\n        else if (words[i] === ')') {\n            return {\n                inner: words.slice(0, i),\n                rest: words.slice(i + 1),\n            };\n        }\n        else if (words[i] === '!') {\n            const tmp = wrapInnerExpressions(words.slice(i + 1));\n            // insert inner expression after the '!'\n            words[i] = ['', '!'].concat(tmp.inner);\n            words.splice(i + 1, 99999, ...tmp.rest);\n        }\n    }\n    return {\n        inner: words,\n        rest: [],\n    };\n}\nexports.wrapInnerExpressions = wrapInnerExpressions;\nfunction words2Expression(operatorList, words) {\n    if (!words || !words.length)\n        throw new Error('words2Expression: syntax error: unbalanced expression');\n    while (words.length === 1 && _.isArray(words[0]))\n        words = words[0];\n    if (words.length === 1)\n        return words[0];\n    // Find the operator with the highest priority:\n    let operatorI = -1;\n    for (let i = 0; i < operatorList.length; i++) {\n        const operator = operatorList[i];\n        if (operatorI === -1) {\n            operatorI = words.lastIndexOf(operator);\n        }\n    }\n    if (operatorI !== -1) {\n        const l = words.slice(0, operatorI);\n        const r = words.slice(operatorI + 1);\n        const expr = {\n            l: words2Expression(operatorList, l),\n            o: words[operatorI],\n            r: words2Expression(operatorList, r),\n        };\n        return expr;\n    }\n    else\n        throw new Error('words2Expression: syntax error: operator not found: \"' + words.join(' ') + '\"');\n}\n/** Validates an expression. Returns true on success, throws error if not */\nfunction validateExpression(operatorList, expr0, breadcrumbs) {\n    if (!breadcrumbs)\n        breadcrumbs = 'ROOT';\n    if (_.isObject(expr0) && !_.isArray(expr0)) {\n        const expr = expr0;\n        if (!_.has(expr, 'l'))\n            throw new Error(`validateExpression: ${breadcrumbs}.l missing in ${JSON.stringify(expr)}`);\n        if (!_.has(expr, 'o'))\n            throw new Error(`validateExpression: ${breadcrumbs}.o missing in ${JSON.stringify(expr)}`);\n        if (!_.has(expr, 'r'))\n            throw new Error(`validateExpression: ${breadcrumbs}.r missing in ${JSON.stringify(expr)}`);\n        if (!_.isString(expr.o))\n            throw new Error(`validateExpression: ${breadcrumbs}.o not a string`);\n        if (!wordIsOperator(operatorList, expr.o))\n            throw new Error(breadcrumbs + '.o not valid: \"' + expr.o + '\"');\n        return (validateExpression(operatorList, expr.l, breadcrumbs + '.l') &&\n            validateExpression(operatorList, expr.r, breadcrumbs + '.r'));\n    }\n    else if (!_.isNull(expr0) && !_.isString(expr0) && !_.isNumber(expr0)) {\n        throw new Error(`validateExpression: ${breadcrumbs} is of invalid type`);\n    }\n    return true;\n}\nexports.validateExpression = validateExpression;\n//# sourceMappingURL=expression.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lookupExpression = exports.resolveTimelineObj = exports.Resolver = void 0;\nconst _ = require(\"underscore\");\nconst lib_1 = require(\"../lib\");\nconst validate_1 = require(\"./validate\");\nconst expression_1 = require(\"./expression\");\nconst state_1 = require(\"./state\");\nconst common_1 = require(\"./common\");\nconst cache_1 = require(\"./cache\");\nclass Resolver {\n    /**\n     * Go through all objects on the timeline and calculate all the timings.\n     * Returns a ResolvedTimeline which can be piped into Resolver.getState()\n     * @param timeline Array of timeline objects\n     * @param options Resolve options\n     */\n    static resolveTimeline(timeline, options) {\n        if (!_.isArray(timeline))\n            throw new Error('resolveTimeline: parameter timeline missing');\n        if (!options)\n            throw new Error('resolveTimeline: parameter options missing');\n        (0, validate_1.validateTimeline)(timeline, false);\n        (0, lib_1.resetId)();\n        const resolvedTimeline = {\n            options: { ...options },\n            objects: {},\n            classes: {},\n            layers: {},\n            statistics: {\n                unresolvedCount: 0,\n                resolvedCount: 0,\n                resolvedInstanceCount: 0,\n                resolvedObjectCount: 0,\n                resolvedGroupCount: 0,\n                resolvedKeyframeCount: 0,\n                resolvingCount: 0,\n            },\n        };\n        // Step 1: pre-populate resolvedTimeline with objects\n        const addToResolvedTimeline = (obj, levelDeep, parentId, isKeyframe) => {\n            if (resolvedTimeline.objects[obj.id])\n                throw Error(`All timelineObjects must be unique! (duplicate: \"${obj.id}\")`);\n            const o = (0, lib_1.extendMandadory)(_.clone(obj), {\n                resolved: {\n                    resolved: false,\n                    resolving: false,\n                    instances: [],\n                    levelDeep: levelDeep,\n                    isSelfReferencing: false,\n                    directReferences: [],\n                },\n            });\n            if (parentId) {\n                o.resolved.parentId = parentId;\n                o.resolved.directReferences.push(parentId);\n            }\n            if (isKeyframe)\n                o.resolved.isKeyframe = true;\n            (0, common_1.addObjectToResolvedTimeline)(resolvedTimeline, o);\n            // Add children:\n            if (obj.isGroup && obj.children) {\n                for (let i = 0; i < obj.children.length; i++) {\n                    const child = obj.children[i];\n                    addToResolvedTimeline(child, levelDeep + 1, obj.id);\n                }\n            }\n            // Add keyframes:\n            if (obj.keyframes) {\n                for (let i = 0; i < obj.keyframes.length; i++) {\n                    const keyframe = obj.keyframes[i];\n                    const kf2 = (0, lib_1.extendMandadory)(_.clone(keyframe), {\n                        layer: '',\n                    });\n                    addToResolvedTimeline(kf2, levelDeep + 1, obj.id, true);\n                }\n            }\n        };\n        for (let i = 0; i < timeline.length; i++) {\n            const obj = timeline[i];\n            addToResolvedTimeline(obj, 0);\n        }\n        // Step 2: go though and resolve the objects\n        if (options.cache) {\n            // Figure out which objects has changed since last time\n            const cache = (0, cache_1.initializeCache)(options.cache, resolvedTimeline);\n            // Go through all new objects, and determine whether they have changed:\n            const allNewObjects = {};\n            const changedReferences = {};\n            const getAllReferencesThisObjectAffects = (newObj) => {\n                const references = ['#' + newObj.id];\n                if (newObj.classes) {\n                    for (const className of newObj.classes) {\n                        references.push('.' + className);\n                    }\n                }\n                if (newObj.layer)\n                    references.push('$' + newObj.layer);\n                return references;\n            };\n            const addChangedObject = (obj) => {\n                const references = getAllReferencesThisObjectAffects(obj);\n                for (const ref of references) {\n                    changedReferences[ref] = true;\n                }\n            };\n            for (const obj of Object.values(resolvedTimeline.objects)) {\n                const oldHash = cache.objHashes[obj.id];\n                const newHash = (0, cache_1.hashTimelineObject)(obj);\n                allNewObjects[obj.id] = true;\n                if (!oldHash || oldHash !== newHash) {\n                    cache.objHashes[obj.id] = newHash;\n                    addChangedObject(obj);\n                    const oldObj = cache.resolvedTimeline.objects[obj.id];\n                    if (oldObj)\n                        addChangedObject(oldObj);\n                }\n                else {\n                    // No timing-affecting changes detected\n                    // Even though the timeline-properties hasn't changed,\n                    // the content (and other properties) might have:\n                    const oldObj = cache.resolvedTimeline.objects[obj.id];\n                    cache.resolvedTimeline.objects[obj.id] = {\n                        ...obj,\n                        resolved: oldObj.resolved,\n                    };\n                }\n            }\n            if (cache.hasOldData) {\n                // Go through all old hashes, removing the ones that doesn't exist anymore\n                for (const objId in cache.resolvedTimeline.objects) {\n                    if (!allNewObjects[objId]) {\n                        const obj = cache.resolvedTimeline.objects[objId];\n                        delete cache.objHashes[objId];\n                        addChangedObject(obj);\n                    }\n                }\n                // Invalidate objects, by gradually removing the invalidated ones from validObjects\n                // Prepare validObjects:\n                const validObjects = {};\n                for (const obj of Object.values(resolvedTimeline.objects)) {\n                    validObjects[obj.id] = obj;\n                }\n                /** All references that depend on another reference (ie objects, classs or layers): */\n                const affectReferenceMap = {};\n                for (const obj of Object.values(resolvedTimeline.objects)) {\n                    // Add everything that this object affects:\n                    const cachedObj = cache.resolvedTimeline.objects[obj.id];\n                    let affectedReferences = getAllReferencesThisObjectAffects(obj);\n                    if (cachedObj) {\n                        affectedReferences = _.uniq(affectedReferences.concat(getAllReferencesThisObjectAffects(cachedObj)));\n                    }\n                    for (let i = 0; i < affectedReferences.length; i++) {\n                        const ref = affectedReferences[i];\n                        const objRef = '#' + obj.id;\n                        if (ref !== objRef) {\n                            if (!affectReferenceMap[objRef])\n                                affectReferenceMap[objRef] = [];\n                            affectReferenceMap[objRef].push(ref);\n                        }\n                    }\n                    // Add everything that this object is affected by:\n                    if (changedReferences['#' + obj.id]) {\n                        // The object is directly said to be invalid, no need to add it to referencingObjects,\n                        // since it'll be easily invalidated anyway later\n                    }\n                    else {\n                        // Note: we only have to check for the OLD object, since if the old and the new object differs,\n                        // that would mean it'll be directly invalidated anyway.\n                        if (cachedObj) {\n                            // Fetch all references for the object from the last time it was resolved.\n                            // Note: This can be done, since _if_ the object was changed in any way since last resolve\n                            // it'll be invalidated anyway\n                            const dependOnReferences = (0, cache_1.getObjectReferences)(cachedObj);\n                            for (let i = 0; i < dependOnReferences.length; i++) {\n                                const ref = dependOnReferences[i];\n                                if (!affectReferenceMap[ref])\n                                    affectReferenceMap[ref] = [];\n                                affectReferenceMap[ref].push('#' + obj.id);\n                            }\n                        }\n                    }\n                }\n                // Invalidate all changed objects, and recursively invalidate all objects that reference those objects:\n                const handledReferences = {};\n                for (const reference of Object.keys(changedReferences)) {\n                    invalidateObjectsWithReference(handledReferences, reference, affectReferenceMap, validObjects);\n                }\n                // The objects that are left in validObjects at this point are still valid.\n                // We can reuse the old resolving for those:\n                for (const obj of Object.values(validObjects)) {\n                    if (!cache.resolvedTimeline.objects[obj.id])\n                        throw new Error(`Something went wrong: \"${obj.id}\" does not exist in cache.resolvedTimeline.objects`);\n                    resolvedTimeline.objects[obj.id] = cache.resolvedTimeline.objects[obj.id];\n                }\n            }\n            for (const obj of Object.values(resolvedTimeline.objects)) {\n                resolveTimelineObj(resolvedTimeline, obj);\n            }\n            // Save for next time:\n            cache.resolvedTimeline = resolvedTimeline;\n            cache.hasOldData = true;\n            // Update statistics, since that's not accurate after having used the cache:\n            resolvedTimeline.statistics.unresolvedCount = 0;\n            resolvedTimeline.statistics.resolvedCount = 0;\n            resolvedTimeline.statistics.resolvedInstanceCount = 0;\n            resolvedTimeline.statistics.resolvedObjectCount = 0;\n            resolvedTimeline.statistics.resolvedGroupCount = 0;\n            resolvedTimeline.statistics.resolvedKeyframeCount = 0;\n            for (const obj of Object.values(resolvedTimeline.objects)) {\n                updateStatistics(resolvedTimeline, obj);\n            }\n            return resolvedTimeline;\n        }\n        else {\n            // If there are no cache provided, just resolve all objects:\n            for (const obj of Object.values(resolvedTimeline.objects)) {\n                resolveTimelineObj(resolvedTimeline, obj);\n            }\n            return resolvedTimeline;\n        }\n    }\n    /** Calculate the state for all points in time.  */\n    static resolveAllStates(resolvedTimeline, cache) {\n        return (0, state_1.resolveStates)(resolvedTimeline, cache);\n    }\n    /**\n     * Calculate the state at a given point in time.\n     * Using a ResolvedTimeline calculated by Resolver.resolveTimeline() or\n     * a ResolvedStates calculated by Resolver.resolveAllStates()\n     * @param resolved ResolvedTimeline calculated by Resolver.resolveTimeline.\n     * @param time The point in time where to calculate the state\n     * @param eventLimit (Optional) Limits the number of returned upcoming events.\n     */\n    static getState(resolved, time, eventLimit) {\n        return (0, state_1.getState)(resolved, time, eventLimit);\n    }\n}\nexports.Resolver = Resolver;\nfunction resolveTimelineObj(resolvedTimeline, obj) {\n    if (obj.resolved.resolved)\n        return;\n    if (obj.resolved.resolving)\n        throw new Error(`Circular dependency when trying to resolve \"${obj.id}\"`);\n    obj.resolved.resolving = true;\n    resolvedTimeline.statistics.resolvingCount++;\n    let instances = [];\n    let directReferences = [];\n    const enables = _.isArray(obj.enable) ? obj.enable : [obj.enable];\n    for (let i = 0; i < enables.length; i++) {\n        const enable = enables[i];\n        let newInstances = [];\n        const repeatingExpr = enable.repeating !== undefined ? (0, expression_1.interpretExpression)(enable.repeating) : null;\n        const lookedRepeating = lookupExpression(resolvedTimeline, obj, repeatingExpr, 'duration');\n        const lookedupRepeating = lookedRepeating.instances;\n        directReferences = directReferences.concat(lookedRepeating.allReferences);\n        if (_.isArray(lookedupRepeating)) {\n            throw new Error(`lookupExpression should never return an array for .duration lookup`); // perhaps tmp? maybe revisit this at some point\n        }\n        let start = enable.while !== undefined ? enable.while : enable.start !== undefined ? enable.start : '';\n        if (enable.while + '' === '1') {\n            start = 'true';\n        }\n        else if (enable.while + '' === '0') {\n            start = 'false';\n        }\n        const startExpr = (0, expression_1.simplifyExpression)(start);\n        let parentInstances = null;\n        let hasParent = false;\n        let startRefersToParent = false;\n        if (obj.resolved.parentId) {\n            hasParent = true;\n            const lookup = lookupExpression(resolvedTimeline, obj, (0, expression_1.interpretExpression)(`#${obj.resolved.parentId}`), 'start');\n            parentInstances = lookup.instances; // a start-reference will always return an array, or null\n            directReferences = directReferences.concat(lookup.allReferences);\n            if ((0, lib_1.isConstant)(startExpr)) {\n                // Only use parent if the expression resolves to a number (ie doesn't contain any references)\n                startRefersToParent = true;\n            }\n        }\n        const lookupStart = lookupExpression(resolvedTimeline, obj, startExpr, 'start');\n        let lookedupStarts = lookupStart.instances;\n        directReferences = directReferences.concat(lookupStart.allReferences);\n        if (startRefersToParent) {\n            lookedupStarts = (0, lib_1.applyParentInstances)(parentInstances, lookedupStarts);\n        }\n        if (enable.while) {\n            if (_.isArray(lookedupStarts)) {\n                newInstances = lookedupStarts;\n            }\n            else if (lookedupStarts !== null) {\n                newInstances = [\n                    {\n                        id: (0, lib_1.getId)(),\n                        start: lookedupStarts.value,\n                        end: null,\n                        references: lookedupStarts.references,\n                    },\n                ];\n            }\n        }\n        else {\n            const events = [];\n            let iStart = 0;\n            let iEnd = 0;\n            if (_.isArray(lookedupStarts)) {\n                for (let i = 0; i < lookedupStarts.length; i++) {\n                    const instance = lookedupStarts[i];\n                    events.push({\n                        time: instance.start,\n                        value: true,\n                        data: { instance: instance, id: obj.id + '_' + iStart++ },\n                        references: instance.references,\n                    });\n                }\n            }\n            else if (lookedupStarts !== null) {\n                events.push({\n                    time: lookedupStarts.value,\n                    value: true,\n                    data: {\n                        instance: {\n                            id: (0, lib_1.getId)(),\n                            start: lookedupStarts.value,\n                            end: null,\n                            references: lookedupStarts.references,\n                        },\n                        id: obj.id + '_' + iStart++,\n                    },\n                    references: lookedupStarts.references,\n                });\n            }\n            if (enable.end !== undefined) {\n                const endExpr = (0, expression_1.interpretExpression)(enable.end);\n                let endRefersToParent = false;\n                if (obj.resolved.parentId) {\n                    if ((0, lib_1.isConstant)(endExpr)) {\n                        // Only use parent if the expression resolves to a number (ie doesn't contain any references)\n                        endRefersToParent = true;\n                    }\n                }\n                // lookedupEnds will contain an inverted list of instances. Therefore .start means an end\n                const lookupEnd = endExpr ? lookupExpression(resolvedTimeline, obj, endExpr, 'end') : null;\n                let lookedupEnds = lookupEnd ? lookupEnd.instances : null;\n                if (lookupEnd)\n                    directReferences = directReferences.concat(lookupEnd.allReferences);\n                if (endRefersToParent) {\n                    lookedupEnds = (0, lib_1.applyParentInstances)(parentInstances, lookedupEnds);\n                }\n                if (_.isArray(lookedupEnds)) {\n                    for (let i = 0; i < lookedupEnds.length; i++) {\n                        const instance = lookedupEnds[i];\n                        events.push({\n                            time: instance.start,\n                            value: false,\n                            data: { instance: instance, id: obj.id + '_' + iEnd++ },\n                            references: instance.references,\n                        });\n                    }\n                }\n                else if (lookedupEnds !== null) {\n                    events.push({\n                        time: lookedupEnds.value,\n                        value: false,\n                        data: {\n                            instance: {\n                                id: (0, lib_1.getId)(),\n                                start: lookedupEnds.value,\n                                end: null,\n                                references: lookedupEnds.references,\n                            },\n                            id: obj.id + '_' + iEnd++,\n                        },\n                        references: lookedupEnds.references,\n                    });\n                }\n            }\n            else if (enable.duration !== undefined) {\n                const durationExpr = (0, expression_1.interpretExpression)(enable.duration);\n                const lookupDuration = lookupExpression(resolvedTimeline, obj, durationExpr, 'duration');\n                let lookedupDuration = lookupDuration.instances;\n                directReferences = directReferences.concat(lookupDuration.allReferences);\n                if (_.isArray(lookedupDuration) && lookedupDuration.length === 1) {\n                    lookedupDuration = {\n                        value: lookedupDuration[0].start,\n                        references: lookedupDuration[0].references,\n                    };\n                }\n                if (_.isArray(lookedupDuration) && !lookedupDuration.length)\n                    lookedupDuration = null;\n                if (_.isArray(lookedupDuration)) {\n                    throw new Error(`lookupExpression should never return an array for .duration lookup`); // perhaps tmp? maybe revisit this at some point\n                }\n                else if (lookedupDuration !== null) {\n                    if (lookedupRepeating !== null && lookedupDuration.value > lookedupRepeating.value)\n                        lookedupDuration.value = lookedupRepeating.value;\n                    const tmpLookedupDuration = lookedupDuration; // cast type\n                    for (let i = 0; i < events.length; i++) {\n                        const e = events[i];\n                        if (e.value) {\n                            const time = e.time + tmpLookedupDuration.value;\n                            const references = (0, lib_1.joinReferences)(e.references, tmpLookedupDuration.references);\n                            events.push({\n                                time: time,\n                                value: false,\n                                data: {\n                                    id: e.data.id,\n                                    instance: {\n                                        id: e.data.instance.id,\n                                        start: time,\n                                        end: null,\n                                        references: references,\n                                    },\n                                },\n                                references: references,\n                            });\n                        }\n                    }\n                }\n            }\n            newInstances = (0, lib_1.convertEventsToInstances)(events, false);\n        }\n        if (hasParent) {\n            // figure out what parent-instance the instances are tied to, and cap them\n            const cappedInstances = [];\n            for (let i = 0; i < newInstances.length; i++) {\n                const instance = newInstances[i];\n                if (parentInstances) {\n                    const referredParentInstance = _.find(parentInstances, (parentInstance) => {\n                        return instance.references.indexOf(parentInstance.id) !== -1;\n                    });\n                    if (referredParentInstance) {\n                        // If the child refers to its parent, there should be one specific instance to cap into\n                        const cappedInstance = (0, lib_1.capInstances)([instance], [referredParentInstance])[0];\n                        if (cappedInstance) {\n                            if (!cappedInstance.caps)\n                                cappedInstance.caps = [];\n                            cappedInstance.caps.push({\n                                id: referredParentInstance.id,\n                                start: referredParentInstance.start,\n                                end: referredParentInstance.end,\n                            });\n                            cappedInstances.push(cappedInstance);\n                        }\n                    }\n                    else {\n                        // If the child doesn't refer to its parent, it should be capped within all of its parent instances\n                        for (let i = 0; i < parentInstances.length; i++) {\n                            const parentInstance = parentInstances[i];\n                            const cappedInstance = (0, lib_1.capInstances)([instance], [parentInstance])[0];\n                            if (cappedInstance) {\n                                if (parentInstance) {\n                                    if (!cappedInstance.caps)\n                                        cappedInstance.caps = [];\n                                    cappedInstance.caps.push({\n                                        id: parentInstance.id,\n                                        start: parentInstance.start,\n                                        end: parentInstance.end,\n                                    });\n                                }\n                                cappedInstances.push(cappedInstance);\n                            }\n                        }\n                    }\n                }\n            }\n            newInstances = cappedInstances;\n        }\n        newInstances = (0, lib_1.applyRepeatingInstances)(newInstances, lookedupRepeating, resolvedTimeline.options);\n        instances = instances.concat(newInstances);\n    }\n    // Make sure the instance ids are unique:\n    const ids = {};\n    for (const instance of instances) {\n        if (ids[instance.id]) {\n            instance.id = `${instance.id}_${(0, lib_1.getId)()}`;\n        }\n        ids[instance.id] = true;\n    }\n    if (obj.seamless && instances.length > 1) {\n        instances = (0, lib_1.cleanInstances)(instances, true, false);\n    }\n    obj.resolved.resolved = true;\n    obj.resolved.resolving = false;\n    obj.resolved.instances = instances;\n    obj.resolved.directReferences = directReferences;\n    updateStatistics(resolvedTimeline, obj);\n}\nexports.resolveTimelineObj = resolveTimelineObj;\nfunction updateStatistics(resolvedTimeline, obj) {\n    if (obj.resolved.instances.length) {\n        resolvedTimeline.statistics.resolvedInstanceCount += obj.resolved.instances.length;\n        resolvedTimeline.statistics.resolvedCount += 1;\n        if (obj.isGroup) {\n            resolvedTimeline.statistics.resolvedGroupCount += 1;\n        }\n        if (obj.resolved.isKeyframe) {\n            resolvedTimeline.statistics.resolvedKeyframeCount += 1;\n        }\n        else {\n            resolvedTimeline.statistics.resolvedObjectCount += 1;\n        }\n    }\n    else {\n        resolvedTimeline.statistics.unresolvedCount += 1;\n    }\n}\n/** Invalidate all changed objects, and recursively invalidate all objects that reference those objects */\nfunction invalidateObjectsWithReference(handledReferences, reference, affectReferenceMap, validObjects) {\n    if (handledReferences[reference])\n        return; // to avoid infinite loops\n    handledReferences[reference] = true;\n    if (reference[0] === '#') {\n        // an id\n        const objId = reference.slice(1);\n        if (validObjects[objId]) {\n            delete validObjects[objId];\n        }\n    }\n    // Invalidate all objects that depend on any of the references that this reference affects:\n    const affectedReferences = affectReferenceMap[reference];\n    if (affectedReferences) {\n        for (let i = 0; i < affectedReferences.length; i++) {\n            const referencingReference = affectedReferences[i];\n            invalidateObjectsWithReference(handledReferences, referencingReference, affectReferenceMap, validObjects);\n        }\n    }\n}\n/**\n * Look up a reference on the timeline\n * Return values:\n * Array<TimelineObjectInstance>: Instances on the timeline where the reference expression is true\n * ValueWithReference: A singular value which can be combined arithmetically with Instances\n * null: Means \"something is invalid\", an null-value will always return null when combined with other values\n *\n * @param resolvedTimeline\n * @param obj\n * @param expr\n * @param context\n */\nfunction lookupExpression(resolvedTimeline, obj, expr, context) {\n    if (expr === null)\n        return { instances: null, allReferences: [] };\n    if (_.isString(expr) && (0, lib_1.isNumeric)(expr)) {\n        return {\n            instances: {\n                value: parseFloat(expr),\n                references: [],\n            },\n            allReferences: [],\n        };\n    }\n    else if (_.isNumber(expr)) {\n        return {\n            instances: {\n                value: expr,\n                references: [],\n            },\n            allReferences: [],\n        };\n    }\n    else if (_.isString(expr)) {\n        expr = expr.trim();\n        if ((0, lib_1.isConstant)(expr)) {\n            if (expr.match(/^true$/i)) {\n                return {\n                    instances: {\n                        value: 0,\n                        references: [],\n                    },\n                    allReferences: [],\n                };\n            }\n            else if (expr.match(/^false$/i)) {\n                return {\n                    instances: [],\n                    allReferences: [],\n                };\n            }\n        }\n        // Look up string\n        let invert = false;\n        let ignoreFirstIfZero = false;\n        let referencedObjs = [];\n        let ref = context;\n        let rest = '';\n        let objIdsToReference = [];\n        const allReferences = [];\n        let referenceIsOk = false;\n        // Match id, example: \"#objectId.start\"\n        const m = expr.match(/^\\W*#([^.]+)(.*)/);\n        if (m) {\n            const id = m[1];\n            rest = m[2];\n            referenceIsOk = true;\n            objIdsToReference = [id];\n            allReferences.push('#' + id);\n        }\n        else {\n            // Match class, example: \".className.start\"\n            const m = expr.match(/^\\W*\\.([^.]+)(.*)/);\n            if (m) {\n                const className = m[1];\n                rest = m[2];\n                referenceIsOk = true;\n                objIdsToReference = resolvedTimeline.classes[className] || [];\n                allReferences.push('.' + className);\n            }\n            else {\n                // Match layer, example: \"$layer\"\n                const m = expr.match(/^\\W*\\$([^.]+)(.*)/);\n                if (m) {\n                    const layer = m[1];\n                    rest = m[2];\n                    referenceIsOk = true;\n                    objIdsToReference = resolvedTimeline.layers[layer] || [];\n                    allReferences.push('$' + layer);\n                }\n            }\n        }\n        for (let i = 0; i < objIdsToReference.length; i++) {\n            const refObjId = objIdsToReference[i];\n            if (refObjId !== obj.id) {\n                const refObj = resolvedTimeline.objects[refObjId];\n                if (refObj) {\n                    referencedObjs.push(refObj);\n                }\n            }\n            else {\n                // Looks like the object is referencing itself!\n                if (obj.resolved.resolving) {\n                    obj.resolved.isSelfReferencing = true;\n                }\n            }\n        }\n        if (!referenceIsOk) {\n            return { instances: null, allReferences: [] };\n        }\n        if (obj.resolved.isSelfReferencing) {\n            // Exclude any self-referencing objects:\n            referencedObjs = _.filter(referencedObjs, (refObj) => {\n                return !refObj.resolved.isSelfReferencing;\n            });\n        }\n        if (referencedObjs.length) {\n            if (rest.match(/start/))\n                ref = 'start';\n            if (rest.match(/end/))\n                ref = 'end';\n            if (rest.match(/duration/))\n                ref = 'duration';\n            if (ref === 'duration') {\n                // Duration refers to the first object on the resolved timeline\n                const instanceDurations = [];\n                for (let i = 0; i < referencedObjs.length; i++) {\n                    const referencedObj = referencedObjs[i];\n                    resolveTimelineObj(resolvedTimeline, referencedObj);\n                    if (referencedObj.resolved.resolved) {\n                        if (obj.resolved.isSelfReferencing && referencedObj.resolved.isSelfReferencing) {\n                            // If the querying object is self-referencing, exclude any other self-referencing objects,\n                            // ignore the object\n                        }\n                        else {\n                            const firstInstance = _.first(referencedObj.resolved.instances);\n                            if (firstInstance) {\n                                const duration = firstInstance.end !== null ? firstInstance.end - firstInstance.start : null;\n                                if (duration !== null) {\n                                    instanceDurations.push({\n                                        value: duration,\n                                        references: (0, lib_1.joinReferences)(referencedObj.id, firstInstance.references),\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n                let firstDuration = null;\n                for (let i = 0; i < instanceDurations.length; i++) {\n                    const d = instanceDurations[i];\n                    if (firstDuration === null || d.value < firstDuration.value)\n                        firstDuration = d;\n                }\n                return { instances: firstDuration, allReferences: allReferences };\n            }\n            else {\n                let returnInstances = [];\n                if (ref === 'start') {\n                    // nothing\n                }\n                else if (ref === 'end') {\n                    invert = !invert;\n                    ignoreFirstIfZero = true;\n                }\n                else\n                    throw Error(`Unknown ref: \"${ref}\"`);\n                for (let i = 0; i < referencedObjs.length; i++) {\n                    const referencedObj = referencedObjs[i];\n                    resolveTimelineObj(resolvedTimeline, referencedObj);\n                    if (referencedObj.resolved.resolved) {\n                        if (obj.resolved.isSelfReferencing && referencedObj.resolved.isSelfReferencing) {\n                            // If the querying object is self-referencing, exclude any other self-referencing objects,\n                            // ignore the object\n                        }\n                        else {\n                            returnInstances = returnInstances.concat(referencedObj.resolved.instances);\n                        }\n                    }\n                }\n                if (returnInstances.length) {\n                    if (invert) {\n                        returnInstances = (0, lib_1.invertInstances)(returnInstances);\n                    }\n                    else {\n                        returnInstances = (0, lib_1.cleanInstances)(returnInstances, true, true);\n                    }\n                    if (ignoreFirstIfZero) {\n                        const first = _.first(returnInstances);\n                        if (first && first.start === 0) {\n                            returnInstances.splice(0, 1);\n                        }\n                    }\n                    return { instances: returnInstances, allReferences: allReferences };\n                }\n                else {\n                    return { instances: [], allReferences: allReferences };\n                }\n            }\n        }\n        else {\n            return { instances: [], allReferences: allReferences };\n        }\n    }\n    else {\n        if (expr) {\n            const l = lookupExpression(resolvedTimeline, obj, expr.l, context);\n            const r = lookupExpression(resolvedTimeline, obj, expr.r, context);\n            const lookupExpr = {\n                l: l.instances,\n                o: expr.o,\n                r: r.instances,\n            };\n            const allReferences = l.allReferences.concat(r.allReferences);\n            if (lookupExpr.o === '!') {\n                // Discard l, invert and return r:\n                if (lookupExpr.r && _.isArray(lookupExpr.r)) {\n                    return {\n                        instances: (0, lib_1.invertInstances)(lookupExpr.r),\n                        allReferences: allReferences,\n                    };\n                }\n                else {\n                    // We can't invert a value\n                    return {\n                        instances: lookupExpr.r,\n                        allReferences: allReferences,\n                    };\n                }\n            }\n            else {\n                if (_.isNull(lookupExpr.l) || _.isNull(lookupExpr.r)) {\n                    return { instances: null, allReferences: allReferences };\n                }\n                if (lookupExpr.o === '&' || lookupExpr.o === '|') {\n                    let events = [];\n                    const addEvents = (instances, left) => {\n                        for (let i = 0; i < instances.length; i++) {\n                            const instance = instances[i];\n                            if (instance.start !== instance.end) {\n                                // event doesn't actually exist...\n                                events.push({\n                                    left: left,\n                                    time: instance.start,\n                                    value: true,\n                                    references: [],\n                                    data: true,\n                                    instance: instance,\n                                });\n                                if (instance.end !== null) {\n                                    events.push({\n                                        left: left,\n                                        time: instance.end,\n                                        value: false,\n                                        references: [],\n                                        data: false,\n                                        instance: instance,\n                                    });\n                                }\n                            }\n                        }\n                    };\n                    if (_.isArray(lookupExpr.l))\n                        addEvents(lookupExpr.l, true);\n                    if (_.isArray(lookupExpr.r))\n                        addEvents(lookupExpr.r, false);\n                    events = (0, lib_1.sortEvents)(events);\n                    const calcResult = lookupExpr.o === '&'\n                        ? (left, right) => !!(left && right)\n                        : lookupExpr.o === '|'\n                            ? (left, right) => !!(left || right)\n                            : () => {\n                                return false;\n                            };\n                    let leftValue = (0, lib_1.isReference)(lookupExpr.l) ? !!lookupExpr.l.value : false;\n                    let rightValue = (0, lib_1.isReference)(lookupExpr.r) ? !!lookupExpr.r.value : false;\n                    let leftInstance = null;\n                    let rightInstance = null;\n                    let resultValue = calcResult(leftValue, rightValue);\n                    const instances = [];\n                    const updateInstance = (time, value, references, caps) => {\n                        if (value) {\n                            instances.push({\n                                id: (0, lib_1.getId)(),\n                                start: time,\n                                end: null,\n                                references: references,\n                                caps: caps,\n                            });\n                        }\n                        else {\n                            const last = _.last(instances);\n                            if (last) {\n                                last.end = time;\n                                // don't update reference on end\n                            }\n                        }\n                    };\n                    updateInstance(0, resultValue, (0, lib_1.joinReferences)((0, lib_1.isReference)(lookupExpr.l) ? lookupExpr.l.references : [], (0, lib_1.isReference)(lookupExpr.r) ? lookupExpr.r.references : []), []);\n                    for (let i = 0; i < events.length; i++) {\n                        const e = events[i];\n                        const next = events[i + 1];\n                        if (e.left) {\n                            leftValue = e.value;\n                            leftInstance = e.instance;\n                        }\n                        else {\n                            rightValue = e.value;\n                            rightInstance = e.instance;\n                        }\n                        if (!next || next.time !== e.time) {\n                            const newResultValue = calcResult(leftValue, rightValue);\n                            const resultCaps = (leftInstance ? leftInstance.caps || [] : []).concat(rightInstance ? rightInstance.caps || [] : []);\n                            if (newResultValue !== resultValue) {\n                                updateInstance(e.time, newResultValue, (0, lib_1.joinReferences)(leftInstance ? leftInstance.references : [], rightInstance ? rightInstance.references : []), resultCaps);\n                                resultValue = newResultValue;\n                            }\n                        }\n                    }\n                    return { instances: instances, allReferences: allReferences };\n                }\n                else {\n                    const operateInner = lookupExpr.o === '+'\n                        ? (a, b) => {\n                            return {\n                                value: a.value + b.value,\n                                references: (0, lib_1.joinReferences)(a.references, b.references),\n                            };\n                        }\n                        : lookupExpr.o === '-'\n                            ? (a, b) => {\n                                return {\n                                    value: a.value - b.value,\n                                    references: (0, lib_1.joinReferences)(a.references, b.references),\n                                };\n                            }\n                            : lookupExpr.o === '*'\n                                ? (a, b) => {\n                                    return {\n                                        value: a.value * b.value,\n                                        references: (0, lib_1.joinReferences)(a.references, b.references),\n                                    };\n                                }\n                                : lookupExpr.o === '/'\n                                    ? (a, b) => {\n                                        return {\n                                            value: a.value / b.value,\n                                            references: (0, lib_1.joinReferences)(a.references, b.references),\n                                        };\n                                    }\n                                    : lookupExpr.o === '%'\n                                        ? (a, b) => {\n                                            return {\n                                                value: a.value % b.value,\n                                                references: (0, lib_1.joinReferences)(a.references, b.references),\n                                            };\n                                        }\n                                        : () => null;\n                    const operate = (a, b) => {\n                        if (a === null || b === null)\n                            return null;\n                        return operateInner(a, b);\n                    };\n                    const result = (0, lib_1.operateOnArrays)(lookupExpr.l, lookupExpr.r, operate);\n                    return { instances: result, allReferences: allReferences };\n                }\n            }\n        }\n    }\n    return { instances: null, allReferences: [] };\n}\nexports.lookupExpression = lookupExpression;\n//# sourceMappingURL=resolver.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyKeyframeContent = exports.resolveStates = exports.getState = void 0;\nconst _ = require(\"underscore\");\nconst common_1 = require(\"./common\");\nconst enums_1 = require(\"../api/enums\");\nconst lib_1 = require(\"../lib\");\nfunction getState(resolved, time, eventLimit = 0) {\n    const resolvedStates = isResolvedStates(resolved) ? resolved : resolveStates(resolved);\n    const state = {\n        time: time,\n        layers: {},\n        nextEvents: _.filter(resolvedStates.nextEvents, (e) => e.time > time),\n    };\n    if (eventLimit)\n        state.nextEvents = state.nextEvents.slice(0, eventLimit);\n    const layerKeys = Object.keys(resolvedStates.layers);\n    for (let i = 0; i < layerKeys.length; i++) {\n        const layer = layerKeys[i];\n        const o = getStateAtTime(resolvedStates.state, layer, time);\n        if (o)\n            state.layers[layer] = o;\n    }\n    return state;\n}\nexports.getState = getState;\nfunction resolveStates(resolved, cache) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const resolvedStates = {\n        options: resolved.options,\n        statistics: resolved.statistics,\n        // These will be re-created during the state-resolving:\n        objects: {},\n        classes: {},\n        layers: {},\n        state: {},\n        nextEvents: [],\n    };\n    if (cache && resolved.statistics.resolvingCount === 0 && cache.resolvedStates) {\n        // Nothing has changed since last time, just return the states right away:\n        return cache.resolvedStates;\n    }\n    const resolvedObjects = _.values(resolved.objects);\n    // Sort to make sure parent groups are evaluated before their children:\n    resolvedObjects.sort((a, b) => {\n        if ((a.resolved.levelDeep || 0) > (b.resolved.levelDeep || 0))\n            return 1;\n        if ((a.resolved.levelDeep || 0) < (b.resolved.levelDeep || 0))\n            return -1;\n        if (a.id > b.id)\n            return 1;\n        if (a.id < b.id)\n            return -1;\n        return 0;\n    });\n    // Step 1: Collect all points-of-interest (which points in time we want to evaluate)\n    // and which instances that are interesting\n    const pointsInTime = {};\n    const addPointInTime = (time, checkId, order, obj, instance) => {\n        // Note on order: Ending events come before starting events\n        if (!pointsInTime[time + ''])\n            pointsInTime[time + ''] = [];\n        pointsInTime[time + ''].push({ obj, instance, checkId, order });\n    };\n    for (const obj of resolvedObjects) {\n        if (!obj.disabled && obj.resolved.resolved) {\n            if (!obj.resolved.isKeyframe) {\n                const parentTimes = getTimesFromParents(resolved, obj);\n                if (obj.layer) {\n                    // if layer is empty, don't put in state\n                    for (const instance of obj.resolved.instances) {\n                        const timeEvents = [];\n                        timeEvents.push({ time: instance.start, enable: true });\n                        if (instance.end)\n                            timeEvents.push({ time: instance.end, enable: false });\n                        // Also include times from parents, as they could affect the state of this instance:\n                        for (let i = 0; i < parentTimes.length; i++) {\n                            const parentTime = parentTimes[i];\n                            if (parentTime &&\n                                parentTime.time > (instance.start || 0) &&\n                                parentTime.time < ((_a = instance.end) !== null && _a !== void 0 ? _a : Infinity)) {\n                                timeEvents.push(parentTime);\n                            }\n                        }\n                        // Save a reference to this instance on all points in time that could affect it:\n                        for (let i = 0; i < timeEvents.length; i++) {\n                            const timeEvent = timeEvents[i];\n                            if (timeEvent.enable) {\n                                addPointInTime(timeEvent.time, 'start', 1, obj, instance);\n                            }\n                            else {\n                                addPointInTime(timeEvent.time, 'end', 0, obj, instance);\n                            }\n                        }\n                    }\n                }\n            }\n            else if (obj.resolved.isKeyframe && obj.resolved.parentId) {\n                const keyframe = obj;\n                // Also add keyframes to pointsInTime:\n                for (const instance of keyframe.resolved.instances) {\n                    // Keyframe start time\n                    addPointInTime(instance.start, 'start', 1, keyframe, instance);\n                    // Keyframe end time\n                    if (instance.end !== null) {\n                        addPointInTime(instance.end, 'end', 0, keyframe, instance);\n                    }\n                }\n            }\n        }\n    }\n    // Step 2: Resolve the state for the points-of-interest\n    // This is done by sweeping the points-of-interest chronologically,\n    // determining the state for every point in time by adding & removing objects from aspiringInstances\n    // Then sorting it to determine who takes precedence\n    const eventObjectTimes = {};\n    const currentState = {};\n    const activeObjIds = {};\n    const activeKeyframes = {};\n    const activeKeyframesChecked = {};\n    /** The objects in aspiringInstances  */\n    const aspiringInstances = {};\n    const keyframeEvents = [];\n    const times = Object.keys(pointsInTime)\n        .map((time) => parseFloat(time))\n        // Sort chronologically:\n        .sort((a, b) => a - b);\n    // Iterate through all points-of-interest times:\n    for (let i = 0; i < times.length; i++) {\n        const time = times[i];\n        const instancesToCheck = pointsInTime[time];\n        const checkedObjectsThisTime = {};\n        instancesToCheck.sort((a, b) => {\n            if (a.obj.resolved && b.obj.resolved) {\n                // Keyframes comes first:\n                if (a.obj.resolved.isKeyframe && !b.obj.resolved.isKeyframe)\n                    return -1;\n                if (!a.obj.resolved.isKeyframe && b.obj.resolved.isKeyframe)\n                    return 1;\n                if (a.order > b.order)\n                    return 1;\n                if (a.order < b.order)\n                    return -1;\n                // Deeper objects (children in groups) comes later, we want to check the parent groups first:\n                if ((a.obj.resolved.levelDeep || 0) > (b.obj.resolved.levelDeep || 0))\n                    return 1;\n                if ((a.obj.resolved.levelDeep || 0) < (b.obj.resolved.levelDeep || 0))\n                    return -1;\n            }\n            return 0;\n        });\n        for (let j = 0; j < instancesToCheck.length; j++) {\n            const o = instancesToCheck[j];\n            const obj = o.obj;\n            const instance = o.instance;\n            let toBeEnabled = (instance.start || 0) <= time && ((_b = instance.end) !== null && _b !== void 0 ? _b : Infinity) > time;\n            const layer = obj.layer + '';\n            const identifier = obj.id + '_' + instance.id + '_' + o.checkId;\n            if (!checkedObjectsThisTime[identifier]) {\n                // Only check each object and event-type once for every point in time\n                checkedObjectsThisTime[identifier] = true;\n                if (!obj.resolved.isKeyframe) {\n                    // If object has a parent, only set if parent is on a layer (if layer is set for parent)\n                    if (toBeEnabled && obj.resolved.parentId) {\n                        const parentObj = obj.resolved.parentId ? resolved.objects[obj.resolved.parentId] : null;\n                        toBeEnabled = !!(parentObj && (!parentObj.layer || activeObjIds[parentObj.id]));\n                    }\n                    if (!aspiringInstances[obj.layer])\n                        aspiringInstances[obj.layer] = [];\n                    if (toBeEnabled) {\n                        // The instance wants to be enabled (is starting)\n                        // Add to aspiringInstances:\n                        aspiringInstances[obj.layer].push({ obj, instance });\n                    }\n                    else {\n                        // The instance doesn't want to be enabled (is ending)\n                        // Remove from aspiringInstances:\n                        aspiringInstances[layer] = _.reject(aspiringInstances[layer] || [], (o) => o.obj.id === obj.id);\n                    }\n                    // Evaluate the layer to determine who has the throne:\n                    aspiringInstances[layer].sort((a, b) => {\n                        // Determine who takes precedence:\n                        // First, sort using priority\n                        if ((a.obj.priority || 0) < (b.obj.priority || 0))\n                            return 1;\n                        if ((a.obj.priority || 0) > (b.obj.priority || 0))\n                            return -1;\n                        // Then, sort using the start time\n                        if ((a.instance.start || 0) < (b.instance.start || 0))\n                            return 1;\n                        if ((a.instance.start || 0) > (b.instance.start || 0))\n                            return -1;\n                        // Last resort: sort using id:\n                        if (a.obj.id > b.obj.id)\n                            return 1;\n                        if (a.obj.id < b.obj.id)\n                            return -1;\n                        return 0;\n                    });\n                    // Now, the one on top has the throne\n                    // Update current state:\n                    const currentOnTopOfLayer = aspiringInstances[layer][0];\n                    const prevObj = currentState[layer];\n                    const replaceOldObj = currentOnTopOfLayer &&\n                        (!prevObj ||\n                            prevObj.id !== currentOnTopOfLayer.obj.id ||\n                            prevObj.instance.id !== currentOnTopOfLayer.instance.id);\n                    const removeOldObj = !currentOnTopOfLayer && prevObj;\n                    if (replaceOldObj || removeOldObj) {\n                        if (prevObj) {\n                            // Cap the old instance, so it'll end at this point in time:\n                            (0, lib_1.setInstanceEndTime)(prevObj.instance, time);\n                            // Update activeObjIds:\n                            delete activeObjIds[prevObj.id];\n                            // Add to nextEvents:\n                            resolvedStates.nextEvents.push({\n                                type: enums_1.EventType.END,\n                                time: time,\n                                objId: prevObj.id,\n                            });\n                            eventObjectTimes[instance.end + ''] = enums_1.EventType.END;\n                        }\n                    }\n                    let changed = false;\n                    if (replaceOldObj) {\n                        // Set the new object to State\n                        // Construct a new object clone:\n                        let newObj;\n                        if (resolvedStates.objects[currentOnTopOfLayer.obj.id]) {\n                            // Use the already existing one\n                            newObj = resolvedStates.objects[currentOnTopOfLayer.obj.id];\n                        }\n                        else {\n                            newObj = _.clone(currentOnTopOfLayer.obj);\n                            newObj.content = JSON.parse(JSON.stringify(newObj.content));\n                            newObj.resolved = {\n                                ...(newObj.resolved || {}),\n                                instances: [],\n                            };\n                            (0, common_1.addObjectToResolvedTimeline)(resolvedStates, newObj);\n                        }\n                        const newInstance = {\n                            ...currentOnTopOfLayer.instance,\n                            // We're setting new start & end times so they match up with the state:\n                            start: time,\n                            end: null,\n                            fromInstanceId: currentOnTopOfLayer.instance.id,\n                            originalEnd: currentOnTopOfLayer.instance.originalEnd !== undefined\n                                ? currentOnTopOfLayer.instance.originalEnd\n                                : currentOnTopOfLayer.instance.end,\n                            originalStart: currentOnTopOfLayer.instance.originalStart !== undefined\n                                ? currentOnTopOfLayer.instance.originalStart\n                                : currentOnTopOfLayer.instance.start,\n                        };\n                        // Make the instance id unique:\n                        for (let i = 0; i < newObj.resolved.instances.length; i++) {\n                            if (newObj.resolved.instances[i].id === newInstance.id) {\n                                newInstance.id = newInstance.id + '_$' + newObj.resolved.instances.length;\n                            }\n                        }\n                        newObj.resolved.instances.push(newInstance);\n                        const newObjInstance = {\n                            ...newObj,\n                            instance: newInstance,\n                        };\n                        // Save to current state:\n                        currentState[layer] = newObjInstance;\n                        // Update activeObjIds:\n                        activeObjIds[newObjInstance.id] = newObjInstance;\n                        // Add to nextEvents:\n                        resolvedStates.nextEvents.push({\n                            type: enums_1.EventType.START,\n                            time: newInstance.start,\n                            objId: obj.id,\n                        });\n                        eventObjectTimes[newInstance.start + ''] = enums_1.EventType.START;\n                        changed = true;\n                    }\n                    else if (removeOldObj) {\n                        // Remove from current state:\n                        delete currentState[layer];\n                        changed = true;\n                    }\n                    if (changed) {\n                        // Also make sure any children are updated:\n                        // Go through the object on hand, but also the one in the currentState\n                        const parentsToCheck = [];\n                        if (obj.isGroup)\n                            parentsToCheck.push(obj);\n                        if ((_c = currentState[layer]) === null || _c === void 0 ? void 0 : _c.isGroup)\n                            parentsToCheck.push(currentState[layer]);\n                        for (const parent of parentsToCheck) {\n                            if ((_d = parent.children) === null || _d === void 0 ? void 0 : _d.length) {\n                                for (const child0 of parent.children) {\n                                    const child = resolved.objects[child0.id];\n                                    for (const instance of child.resolved.instances) {\n                                        if (instance.start <= time && ((_e = instance.end) !== null && _e !== void 0 ? _e : Infinity) > time) {\n                                            // Add the child instance, because that might be affected:\n                                            addPointInTime(time, 'child', 99, child, instance);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                else {\n                    // Is a keyframe\n                    const keyframe = obj;\n                    // Add keyframe to resolvedStates.objects:\n                    resolvedStates.objects[keyframe.id] = keyframe;\n                    const toBeEnabled = (instance.start || 0) <= time && ((_f = instance.end) !== null && _f !== void 0 ? _f : Infinity) > time;\n                    if (toBeEnabled) {\n                        const newObjInstance = {\n                            ...keyframe,\n                            instance: instance,\n                        };\n                        activeKeyframes[keyframe.id] = newObjInstance;\n                    }\n                    else {\n                        delete activeKeyframes[keyframe.id];\n                        delete activeKeyframesChecked[keyframe.id];\n                    }\n                }\n            }\n        }\n        // Go through keyframes:\n        const activeKeyframesObjIds = Object.keys(activeKeyframes);\n        for (let i = 0; i < activeKeyframesObjIds.length; i++) {\n            const objId = activeKeyframesObjIds[i];\n            const objInstance = activeKeyframes[objId];\n            const keyframe = objInstance;\n            const instance = objInstance.instance;\n            // Check if the keyframe's parent is currently active?\n            if (keyframe.resolved.parentId) {\n                const parentObj = activeObjIds[keyframe.resolved.parentId];\n                if (parentObj && parentObj.layer) {\n                    // keyframe is on an active object\n                    const parentObjInstance = currentState[parentObj.layer];\n                    if (parentObjInstance) {\n                        if (!activeKeyframesChecked[objId]) {\n                            // hasn't started before\n                            activeKeyframesChecked[objId] = true;\n                            // Note: The keyframes are a little bit special, since their contents are applied to their parents.\n                            // That application is done in the getStateAtTime function.\n                            // Add keyframe to nextEvents:\n                            keyframeEvents.push({\n                                type: enums_1.EventType.KEYFRAME,\n                                time: instance.start,\n                                objId: keyframe.id,\n                            });\n                            // Cap end within parent\n                            let instanceEnd = Math.min((_g = instance.end) !== null && _g !== void 0 ? _g : Infinity, (_h = parentObjInstance.instance.end) !== null && _h !== void 0 ? _h : Infinity);\n                            if (instanceEnd === Infinity)\n                                instanceEnd = null;\n                            if (instanceEnd !== null) {\n                                keyframeEvents.push({\n                                    type: enums_1.EventType.KEYFRAME,\n                                    time: instanceEnd,\n                                    objId: keyframe.id,\n                                });\n                            }\n                        }\n                        continue;\n                    }\n                }\n            }\n            // else: the keyframe:s parent isn't active, remove/stop the keyframe then:\n            delete activeKeyframesChecked[objId];\n        }\n    }\n    // At this point, the instances of all objects (excluding keyframes) are properly calculated,\n    // taking into account priorities, clashes etc.\n    // Cap children inside their parents:\n    {\n        const allChildren = Object.values(resolvedStates.objects)\n            .filter((obj) => !!obj.resolved.parentId)\n            // Sort, so that the outermost are handled first:\n            .sort((a, b) => {\n            var _a, _b;\n            return ((_a = a.resolved.levelDeep) !== null && _a !== void 0 ? _a : 0) - ((_b = b.resolved.levelDeep) !== null && _b !== void 0 ? _b : 0);\n        });\n        for (const obj of allChildren) {\n            if (obj.resolved.parentId) {\n                const parent = resolvedStates.objects[obj.resolved.parentId];\n                if (parent) {\n                    obj.resolved.instances = (0, lib_1.cleanInstances)((0, lib_1.capInstances)(obj.resolved.instances, parent.resolved.instances), false, false);\n                }\n            }\n        }\n    }\n    // At this point, all instances of the objects should be properly calculated.\n    // Go through all instances of all objects to create temporary states of all layers and times:\n    {\n        const states = {};\n        for (const id of Object.keys(resolvedStates.objects)) {\n            const obj = resolvedStates.objects[id];\n            const layer = `${obj.layer}`;\n            if (!states[layer])\n                states[layer] = {};\n            const stateLayer = states[layer];\n            if (!obj.resolved.isKeyframe) {\n                for (const instance of obj.resolved.instances) {\n                    const startTime = instance.start + '';\n                    if (!stateLayer[startTime]) {\n                        stateLayer[startTime] = {\n                            startCount: 0,\n                            endCount: 0,\n                            objectInstance: null,\n                        };\n                    }\n                    const newObjInstance = {\n                        ...obj,\n                        instance: instance,\n                    };\n                    stateLayer[startTime].startCount++;\n                    stateLayer[startTime].objectInstance = newObjInstance;\n                    if (instance.end !== null) {\n                        const endTime = instance.end + '';\n                        if (!stateLayer[endTime]) {\n                            stateLayer[endTime] = {\n                                startCount: 0,\n                                endCount: 0,\n                                objectInstance: null,\n                            };\n                        }\n                        stateLayer[endTime].endCount++;\n                    }\n                }\n            }\n        }\n        // Go through the temporary states and apply the changes to the resolvedStates.state:\n        for (const layer of Object.keys(states)) {\n            let sum = 0;\n            const times = Object.keys(states[layer])\n                .map((time) => parseFloat(time))\n                // Sort chronologically:\n                .sort((a, b) => a - b);\n            for (let i = 0; i < times.length; i++) {\n                const time = times[i];\n                const s = states[layer][`${time}`];\n                sum += s.startCount;\n                sum -= s.endCount;\n                // Check for fatal bugs:\n                // If the sum is larger than one, more than one start was found at the same time, which should not be possible.\n                if (sum > 1)\n                    throw new Error(`Too many start events at ${layer} ${time}: ${sum}`);\n                // If the sum is less than zero, there have been more ends than starts, which should not be possible.\n                if (sum < 0)\n                    throw new Error(`Too many end events at ${layer} ${time}: ${sum}`);\n                // Apply the state:\n                if (!resolvedStates.state[layer])\n                    resolvedStates.state[layer] = {};\n                if (sum) {\n                    // This means that the object has started\n                    if (!s.objectInstance)\n                        throw new Error(`objectInstance not set, event though sum=${sum} at ${layer} ${time}`);\n                    resolvedStates.state[layer][time] = [s.objectInstance];\n                }\n                else {\n                    // This means that the object has ended\n                    resolvedStates.state[layer][time] = null;\n                }\n            }\n        }\n    }\n    // Cap keyframes inside their parents:\n    for (const id of Object.keys(resolvedStates.objects)) {\n        {\n            const keyframe = resolvedStates.objects[id];\n            if (keyframe.resolved.isKeyframe && keyframe.resolved.parentId) {\n                const parent = resolvedStates.objects[keyframe.resolved.parentId];\n                if (parent) {\n                    // Cap the keyframe instances within its parents instances:\n                    keyframe.resolved.instances = (0, lib_1.capInstances)(keyframe.resolved.instances, parent.resolved.instances);\n                    // Ensure sure the instances are in the state\n                    for (let i = 0; i < keyframe.resolved.instances.length; i++) {\n                        const instance = keyframe.resolved.instances[i];\n                        const keyframeInstance = {\n                            ...keyframe,\n                            instance: instance,\n                            isKeyframe: true,\n                            keyframeEndTime: instance.end,\n                        };\n                        // Add keyframe to the tracking state:\n                        addKeyframeAtTime(resolvedStates.state, parent.layer + '', instance.start, keyframeInstance);\n                    }\n                }\n            }\n        }\n        // Fix (merge) instances of seamless objects:\n        {\n            const obj = resolvedStates.objects[id];\n            if (obj.seamless && obj.resolved.instances.length > 1) {\n                obj.resolved.instances = (0, lib_1.cleanInstances)(obj.resolved.instances, true, false);\n            }\n        }\n    }\n    // At this point, ALL instances are properly calculated.\n    // Go through the keyframe events and add them to nextEvents:\n    for (let i = 0; i < keyframeEvents.length; i++) {\n        const keyframeEvent = keyframeEvents[i];\n        // tslint:disable-next-line\n        if (eventObjectTimes[keyframeEvent.time + ''] === undefined) {\n            // no need to put a keyframe event if there's already another event there\n            resolvedStates.nextEvents.push(keyframeEvent);\n            eventObjectTimes[keyframeEvent.time + ''] = enums_1.EventType.KEYFRAME;\n        }\n    }\n    resolvedStates.nextEvents.sort((a, b) => {\n        if (a.time > b.time)\n            return 1;\n        if (a.time < b.time)\n            return -1;\n        if (a.type > b.type)\n            return -1;\n        if (a.type < b.type)\n            return 1;\n        if (a.objId < b.objId)\n            return -1;\n        if (a.objId > b.objId)\n            return 1;\n        return 0;\n    });\n    if (cache) {\n        cache.resolvedStates = resolvedStates;\n    }\n    return resolvedStates;\n}\nexports.resolveStates = resolveStates;\nfunction applyKeyframeContent(parentContent, keyframeContent) {\n    for (const [attr, value] of Object.entries(keyframeContent)) {\n        if (_.isArray(value)) {\n            if (!_.isArray(parentContent[attr]))\n                parentContent[attr] = [];\n            applyKeyframeContent(parentContent[attr], value);\n            parentContent[attr].splice(value.length, 99999);\n        }\n        else if (_.isObject(value)) {\n            if (!_.isObject(parentContent[attr]) || _.isArray(parentContent[attr]))\n                parentContent[attr] = {};\n            applyKeyframeContent(parentContent[attr], value);\n        }\n        else {\n            parentContent[attr] = value;\n        }\n    }\n}\nexports.applyKeyframeContent = applyKeyframeContent;\nfunction getTimesFromParents(resolved, obj) {\n    let times = [];\n    const parentObj = obj.resolved.parentId ? resolved.objects[obj.resolved.parentId] : null;\n    if (parentObj && parentObj.resolved.resolved) {\n        for (const instance of parentObj.resolved.instances) {\n            times.push({ time: instance.start, enable: true });\n            if (instance.end)\n                times.push({ time: instance.end, enable: false });\n        }\n        times = times.concat(getTimesFromParents(resolved, parentObj));\n    }\n    return times;\n}\nfunction addKeyframeAtTime(states, layer, time, objInstanceKf) {\n    if (!states[layer])\n        states[layer] = {};\n    const inner = states[layer][time + ''];\n    if (!inner) {\n        states[layer][time + ''] = [objInstanceKf];\n    }\n    else {\n        inner.push(objInstanceKf);\n    }\n}\nfunction getStateAtTime(states, layer, requestTime) {\n    var _a;\n    const layerStates = states[layer] || {};\n    const times = Object.keys(layerStates)\n        .map((time) => parseFloat(time))\n        // Sort chronologically:\n        .sort((a, b) => {\n        return a - b;\n    });\n    let state = null;\n    let isCloned = false;\n    for (let i = 0; i < times.length; i++) {\n        const time = times[i];\n        if (time <= requestTime) {\n            const currentStateInstances = layerStates[time + ''];\n            if (currentStateInstances && currentStateInstances.length) {\n                const keyframes = [];\n                for (let i = 0; i < currentStateInstances.length; i++) {\n                    const currentState = currentStateInstances[i];\n                    if (currentState && currentState.isKeyframe) {\n                        keyframes.push(currentState);\n                    }\n                    else {\n                        state = currentState;\n                        isCloned = false;\n                    }\n                }\n                for (let i = 0; i < keyframes.length; i++) {\n                    const keyframe = keyframes[i];\n                    if (state && keyframe.resolved.parentId === state.id) {\n                        if (((_a = keyframe.keyframeEndTime) !== null && _a !== void 0 ? _a : Infinity) > requestTime) {\n                            if (!isCloned) {\n                                isCloned = true;\n                                state = {\n                                    ...state,\n                                    content: JSON.parse(JSON.stringify(state.content)),\n                                };\n                            }\n                            // Apply the keyframe on the state:\n                            applyKeyframeContent(state.content, keyframe.content);\n                        }\n                    }\n                }\n            }\n            else {\n                state = null;\n                isCloned = false;\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return state;\n}\nfunction isResolvedStates(resolved) {\n    return !!(resolved && typeof resolved === 'object' && resolved.objects && resolved.state && resolved.nextEvents);\n}\n//# sourceMappingURL=state.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateKeyframe = exports.validateObject = exports.validateTimeline = void 0;\nconst _ = require(\"underscore\");\nfunction validateObject0(obj, strict, uniqueIds) {\n    if (!uniqueIds)\n        uniqueIds = {};\n    if (!obj)\n        throw new Error(`Object is undefined`);\n    if (typeof obj !== 'object')\n        throw new Error(`Object is not an object`);\n    if (!obj.id)\n        throw new Error(`Object missing \"id\" attribute`);\n    if (typeof obj.id !== 'string')\n        throw new Error(`Object \"id\" attribute is not a string: \"${obj.id}\"`);\n    if (uniqueIds[obj.id])\n        throw new Error(`Object id \"${obj.id}\" is not unique`);\n    uniqueIds[obj.id] = true;\n    if (obj.layer === undefined)\n        throw new Error(`Object \"${obj.id}\": \"layer\" attribute is undefined`);\n    if (!obj.content)\n        throw new Error(`Object \"${obj.id}\": \"content\" attribute must be set`);\n    if (!obj.enable)\n        throw new Error(`Object \"${obj.id}\": \"enable\" attribute must be set`);\n    const enables = _.isArray(obj.enable) ? obj.enable : [obj.enable];\n    for (let i = 0; i < enables.length; i++) {\n        const enable = enables[i];\n        if (enable.start !== undefined) {\n            if (strict && enable.while !== undefined)\n                throw new Error(`Object \"${obj.id}\": \"enable.start\" and \"enable.while\" cannot be combined`);\n            if (strict && enable.end !== undefined && enable.duration !== undefined)\n                throw new Error(`Object \"${obj.id}\": \"enable.end\" and \"enable.duration\" cannot be combined`);\n        }\n        else if (enable.while !== undefined) {\n            if (strict && enable.end !== undefined)\n                throw new Error(`Object \"${obj.id}\": \"enable.while\" and \"enable.end\" cannot be combined`);\n            if (strict && enable.duration !== undefined)\n                throw new Error(`Object \"${obj.id}\": \"enable.while\" and \"enable.duration\" cannot be combined`);\n        }\n        else\n            throw new Error(`Object \"${obj.id}\": \"enable.start\" or \"enable.while\" must be set`);\n    }\n    if (obj.keyframes) {\n        for (let i = 0; i < obj.keyframes.length; i++) {\n            const keyframe = obj.keyframes[i];\n            try {\n                validateKeyframe0(keyframe, strict, uniqueIds);\n            }\n            catch (e) {\n                throw new Error(`Object \"${obj.id}\" keyframe[${i}]: ${e}`);\n            }\n        }\n    }\n    if (obj.classes) {\n        for (let i = 0; i < obj.classes.length; i++) {\n            const className = obj.classes[i];\n            if (className && typeof className !== 'string')\n                throw new Error(`Object \"${obj.id}\": \"classes[${i}]\" is not a string`);\n        }\n    }\n    if (obj.children && !obj.isGroup)\n        throw new Error(`Object \"${obj.id}\": attribute \"children\" is set but \"isGroup\" is not`);\n    if (obj.isGroup && !obj.children)\n        throw new Error(`Object \"${obj.id}\": attribute \"isGroup\" is set but \"children\" missing`);\n    if (obj.children) {\n        for (let i = 0; i < obj.children.length; i++) {\n            const child = obj.children[i];\n            try {\n                validateObject0(child, strict, uniqueIds);\n            }\n            catch (e) {\n                throw new Error(`Object \"${obj.id}\" child[${i}]: ${e}`);\n            }\n        }\n    }\n    if (obj.priority !== undefined && !_.isNumber(obj.priority))\n        throw new Error(`Object \"${obj.id}\": attribute \"priority\" is not a number`);\n}\nfunction validateKeyframe0(keyframe, strict, uniqueIds) {\n    if (!uniqueIds)\n        uniqueIds = {};\n    if (!keyframe)\n        throw new Error(`Keyframe is undefined`);\n    if (typeof keyframe !== 'object')\n        throw new Error(`Keyframe is not an object`);\n    if (!keyframe.id)\n        throw new Error(`Keyframe missing id attribute`);\n    if (typeof keyframe.id !== 'string')\n        throw new Error(`Keyframe id attribute is not a string: \"${keyframe.id}\"`);\n    if (uniqueIds[keyframe.id])\n        throw new Error(`Keyframe id \"${keyframe.id}\" is not unique`);\n    uniqueIds[keyframe.id] = true;\n    if (!keyframe.content)\n        throw new Error(`Keyframe \"${keyframe.id}\": \"content\" attribute must be set`);\n    if (!keyframe.enable)\n        throw new Error(`Keyframe \"${keyframe.id}\": \"enable\" attribute must be set`);\n    const enables = _.isArray(keyframe.enable) ? keyframe.enable : [keyframe.enable];\n    for (let i = 0; i < enables.length; i++) {\n        const enable = enables[i];\n        if (enable.start !== undefined) {\n            if (strict && enable.while !== undefined)\n                throw new Error(`Keyframe \"${keyframe.id}\": \"enable.start\" and \"enable.while\" cannot be combined`);\n            if (strict && enable.end !== undefined && enable.duration !== undefined)\n                throw new Error(`Keyframe \"${keyframe.id}\": \"enable.end\" and \"enable.duration\" cannot be combined`);\n        }\n        else if (enable.while !== undefined) {\n            if (strict && enable.end !== undefined)\n                throw new Error(`Keyframe \"${keyframe.id}\": \"enable.while\" and \"enable.end\" cannot be combined`);\n            if (strict && enable.duration !== undefined)\n                throw new Error(`Keyframe \"${keyframe.id}\": \"enable.while\" and \"enable.duration\" cannot be combined`);\n        }\n        else\n            throw new Error(`Keyframe \"${keyframe.id}\": \"enable.start\" or \"enable.while\" must be set`);\n    }\n    if (keyframe.classes) {\n        for (let i = 0; i < keyframe.classes.length; i++) {\n            const className = keyframe.classes[i];\n            if (className && !_.isString(className))\n                throw new Error(`Keyframe \"${keyframe.id}\": \"classes[${i}]\" is not a string`);\n        }\n    }\n}\n/**\n * Validates all objects in the timeline. Throws an error if something's wrong\n * @param timeline The timeline to validate\n * @param strict Set to true to enable some strict rules (rules that can possibly be ignored)\n */\nfunction validateTimeline(timeline, strict) {\n    const uniqueIds = {};\n    for (let i = 0; i < timeline.length; i++) {\n        const obj = timeline[i];\n        validateObject0(obj, strict, uniqueIds);\n    }\n}\nexports.validateTimeline = validateTimeline;\n/**\n * Validates a Timeline-object. Throws an error if something's wrong\n * @param timeline The timeline to validate\n * @param strict Set to true to enable some strict rules (rules that can possibly be ignored)\n */\nfunction validateObject(obj, strict) {\n    validateObject0(obj, strict);\n}\nexports.validateObject = validateObject;\n/**\n * Validates a Timeline-keyframe. Throws an error if something's wrong\n * @param timeline The timeline to validate\n * @param strict Set to true to enable some strict rules (rules that can possibly be ignored)\n */\nfunction validateKeyframe(keyframe, strict) {\n    validateKeyframe0(keyframe, strict);\n}\nexports.validateKeyframe = validateKeyframe;\n//# sourceMappingURL=validate.js.map","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global global, define, System, Reflect, Promise */\r\nvar __extends;\r\nvar __assign;\r\nvar __rest;\r\nvar __decorate;\r\nvar __param;\r\nvar __metadata;\r\nvar __awaiter;\r\nvar __generator;\r\nvar __exportStar;\r\nvar __values;\r\nvar __read;\r\nvar __spread;\r\nvar __spreadArrays;\r\nvar __spreadArray;\r\nvar __await;\r\nvar __asyncGenerator;\r\nvar __asyncDelegator;\r\nvar __asyncValues;\r\nvar __makeTemplateObject;\r\nvar __importStar;\r\nvar __importDefault;\r\nvar __classPrivateFieldGet;\r\nvar __classPrivateFieldSet;\r\nvar __classPrivateFieldIn;\r\nvar __createBinding;\r\n(function (factory) {\r\n    var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"tslib\", [\"exports\"], function (exports) { factory(createExporter(root, createExporter(exports))); });\r\n    }\r\n    else if (typeof module === \"object\" && typeof module.exports === \"object\") {\r\n        factory(createExporter(root, createExporter(module.exports)));\r\n    }\r\n    else {\r\n        factory(createExporter(root));\r\n    }\r\n    function createExporter(exports, previous) {\r\n        if (exports !== root) {\r\n            if (typeof Object.create === \"function\") {\r\n                Object.defineProperty(exports, \"__esModule\", { value: true });\r\n            }\r\n            else {\r\n                exports.__esModule = true;\r\n            }\r\n        }\r\n        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };\r\n    }\r\n})\r\n(function (exporter) {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\r\n    __extends = function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n\r\n    __assign = Object.assign || function (t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n\r\n    __rest = function (s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                    t[p[i]] = s[p[i]];\r\n            }\r\n        return t;\r\n    };\r\n\r\n    __decorate = function (decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    };\r\n\r\n    __param = function (paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    };\r\n\r\n    __metadata = function (metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    };\r\n\r\n    __awaiter = function (thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    };\r\n\r\n    __generator = function (thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    };\r\n\r\n    __exportStar = function(m, o) {\r\n        for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n    };\r\n\r\n    __createBinding = Object.create ? (function(o, m, k, k2) {\r\n        if (k2 === undefined) k2 = k;\r\n        var desc = Object.getOwnPropertyDescriptor(m, k);\r\n        if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n            desc = { enumerable: true, get: function() { return m[k]; } };\r\n        }\r\n        Object.defineProperty(o, k2, desc);\r\n    }) : (function(o, m, k, k2) {\r\n        if (k2 === undefined) k2 = k;\r\n        o[k2] = m[k];\r\n    });\r\n\r\n    __values = function (o) {\r\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n        if (m) return m.call(o);\r\n        if (o && typeof o.length === \"number\") return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n    };\r\n\r\n    __read = function (o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    };\r\n\r\n    /** @deprecated */\r\n    __spread = function () {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    };\r\n\r\n    /** @deprecated */\r\n    __spreadArrays = function () {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    };\r\n\r\n    __spreadArray = function (to, from, pack) {\r\n        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n            if (ar || !(i in from)) {\r\n                if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n                ar[i] = from[i];\r\n            }\r\n        }\r\n        return to.concat(ar || Array.prototype.slice.call(from));\r\n    };\r\n\r\n    __await = function (v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    };\r\n\r\n    __asyncGenerator = function (thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    };\r\n\r\n    __asyncDelegator = function (o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n    };\r\n\r\n    __asyncValues = function (o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n    };\r\n\r\n    __makeTemplateObject = function (cooked, raw) {\r\n        if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n        return cooked;\r\n    };\r\n\r\n    var __setModuleDefault = Object.create ? (function(o, v) {\r\n        Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n    }) : function(o, v) {\r\n        o[\"default\"] = v;\r\n    };\r\n\r\n    __importStar = function (mod) {\r\n        if (mod && mod.__esModule) return mod;\r\n        var result = {};\r\n        if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n        __setModuleDefault(result, mod);\r\n        return result;\r\n    };\r\n\r\n    __importDefault = function (mod) {\r\n        return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n    };\r\n\r\n    __classPrivateFieldGet = function (receiver, state, kind, f) {\r\n        if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n        if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n        return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n    };\r\n\r\n    __classPrivateFieldSet = function (receiver, state, value, kind, f) {\r\n        if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n        if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n        if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n        return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n    };\r\n\r\n    __classPrivateFieldIn = function (state, receiver) {\r\n        if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n        return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n    };\r\n\r\n    exporter(\"__extends\", __extends);\r\n    exporter(\"__assign\", __assign);\r\n    exporter(\"__rest\", __rest);\r\n    exporter(\"__decorate\", __decorate);\r\n    exporter(\"__param\", __param);\r\n    exporter(\"__metadata\", __metadata);\r\n    exporter(\"__awaiter\", __awaiter);\r\n    exporter(\"__generator\", __generator);\r\n    exporter(\"__exportStar\", __exportStar);\r\n    exporter(\"__createBinding\", __createBinding);\r\n    exporter(\"__values\", __values);\r\n    exporter(\"__read\", __read);\r\n    exporter(\"__spread\", __spread);\r\n    exporter(\"__spreadArrays\", __spreadArrays);\r\n    exporter(\"__spreadArray\", __spreadArray);\r\n    exporter(\"__await\", __await);\r\n    exporter(\"__asyncGenerator\", __asyncGenerator);\r\n    exporter(\"__asyncDelegator\", __asyncDelegator);\r\n    exporter(\"__asyncValues\", __asyncValues);\r\n    exporter(\"__makeTemplateObject\", __makeTemplateObject);\r\n    exporter(\"__importStar\", __importStar);\r\n    exporter(\"__importDefault\", __importDefault);\r\n    exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet);\r\n    exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet);\r\n    exporter(\"__classPrivateFieldIn\", __classPrivateFieldIn);\r\n});\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\n/* global global, define, System, Reflect, Promise */\r\nvar __extends;\r\nvar __assign;\r\nvar __rest;\r\nvar __decorate;\r\nvar __param;\r\nvar __metadata;\r\nvar __awaiter;\r\nvar __generator;\r\nvar __exportStar;\r\nvar __values;\r\nvar __read;\r\nvar __spread;\r\nvar __spreadArrays;\r\nvar __await;\r\nvar __asyncGenerator;\r\nvar __asyncDelegator;\r\nvar __asyncValues;\r\nvar __makeTemplateObject;\r\nvar __importStar;\r\nvar __importDefault;\r\nvar __classPrivateFieldGet;\r\nvar __classPrivateFieldSet;\r\nvar __createBinding;\r\n(function (factory) {\r\n    var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"tslib\", [\"exports\"], function (exports) { factory(createExporter(root, createExporter(exports))); });\r\n    }\r\n    else if (typeof module === \"object\" && typeof module.exports === \"object\") {\r\n        factory(createExporter(root, createExporter(module.exports)));\r\n    }\r\n    else {\r\n        factory(createExporter(root));\r\n    }\r\n    function createExporter(exports, previous) {\r\n        if (exports !== root) {\r\n            if (typeof Object.create === \"function\") {\r\n                Object.defineProperty(exports, \"__esModule\", { value: true });\r\n            }\r\n            else {\r\n                exports.__esModule = true;\r\n            }\r\n        }\r\n        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };\r\n    }\r\n})\r\n(function (exporter) {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\n    __extends = function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n\r\n    __assign = Object.assign || function (t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n\r\n    __rest = function (s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                    t[p[i]] = s[p[i]];\r\n            }\r\n        return t;\r\n    };\r\n\r\n    __decorate = function (decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    };\r\n\r\n    __param = function (paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    };\r\n\r\n    __metadata = function (metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    };\r\n\r\n    __awaiter = function (thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    };\r\n\r\n    __generator = function (thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    };\r\n\r\n    __createBinding = function(o, m, k, k2) {\r\n        if (k2 === undefined) k2 = k;\r\n        o[k2] = m[k];\r\n    };\r\n\r\n    __exportStar = function (m, exports) {\r\n        for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    };\r\n\r\n    __values = function (o) {\r\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n        if (m) return m.call(o);\r\n        if (o && typeof o.length === \"number\") return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n    };\r\n\r\n    __read = function (o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    };\r\n\r\n    __spread = function () {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    };\r\n\r\n    __spreadArrays = function () {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    };\r\n\r\n    __await = function (v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    };\r\n\r\n    __asyncGenerator = function (thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    };\r\n\r\n    __asyncDelegator = function (o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n    };\r\n\r\n    __asyncValues = function (o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n    };\r\n\r\n    __makeTemplateObject = function (cooked, raw) {\r\n        if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n        return cooked;\r\n    };\r\n\r\n    __importStar = function (mod) {\r\n        if (mod && mod.__esModule) return mod;\r\n        var result = {};\r\n        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n        result[\"default\"] = mod;\r\n        return result;\r\n    };\r\n\r\n    __importDefault = function (mod) {\r\n        return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n    };\r\n\r\n    __classPrivateFieldGet = function (receiver, privateMap) {\r\n        if (!privateMap.has(receiver)) {\r\n            throw new TypeError(\"attempted to get private field on non-instance\");\r\n        }\r\n        return privateMap.get(receiver);\r\n    };\r\n\r\n    __classPrivateFieldSet = function (receiver, privateMap, value) {\r\n        if (!privateMap.has(receiver)) {\r\n            throw new TypeError(\"attempted to set private field on non-instance\");\r\n        }\r\n        privateMap.set(receiver, value);\r\n        return value;\r\n    };\r\n\r\n    exporter(\"__extends\", __extends);\r\n    exporter(\"__assign\", __assign);\r\n    exporter(\"__rest\", __rest);\r\n    exporter(\"__decorate\", __decorate);\r\n    exporter(\"__param\", __param);\r\n    exporter(\"__metadata\", __metadata);\r\n    exporter(\"__awaiter\", __awaiter);\r\n    exporter(\"__generator\", __generator);\r\n    exporter(\"__exportStar\", __exportStar);\r\n    exporter(\"__createBinding\", __createBinding);\r\n    exporter(\"__values\", __values);\r\n    exporter(\"__read\", __read);\r\n    exporter(\"__spread\", __spread);\r\n    exporter(\"__spreadArrays\", __spreadArrays);\r\n    exporter(\"__await\", __await);\r\n    exporter(\"__asyncGenerator\", __asyncGenerator);\r\n    exporter(\"__asyncDelegator\", __asyncDelegator);\r\n    exporter(\"__asyncValues\", __asyncValues);\r\n    exporter(\"__makeTemplateObject\", __makeTemplateObject);\r\n    exporter(\"__importStar\", __importStar);\r\n    exporter(\"__importDefault\", __importDefault);\r\n    exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet);\r\n    exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet);\r\n});\r\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define('underscore', factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (function () {\n    var current = global._;\n    var exports = global._ = factory();\n    exports.noConflict = function () { global._ = current; return exports; };\n  }()));\n}(this, (function () {\n  //     Underscore.js 1.13.4\n  //     https://underscorejs.org\n  //     (c) 2009-2022 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters & Editors\n  //     Underscore may be freely distributed under the MIT license.\n\n  // Current version.\n  var VERSION = '1.13.4';\n\n  // Establish the root object, `window` (`self`) in the browser, `global`\n  // on the server, or `this` in some virtual machines. We use `self`\n  // instead of `window` for `WebWorker` support.\n  var root = (typeof self == 'object' && self.self === self && self) ||\n            (typeof global == 'object' && global.global === global && global) ||\n            Function('return this')() ||\n            {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype;\n  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n\n  // Modern feature detection.\n  var supportsArrayBuffer = typeof ArrayBuffer !== 'undefined',\n      supportsDataView = typeof DataView !== 'undefined';\n\n  // All **ECMAScript 5+** native function implementations that we hope to use\n  // are declared here.\n  var nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeCreate = Object.create,\n      nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;\n\n  // Create references to these builtin functions because we override them.\n  var _isNaN = isNaN,\n      _isFinite = isFinite;\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  // The largest integer that can be represented exactly.\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\n  // Some functions take a variable number of arguments, or a few expected\n  // arguments at the beginning and then a variable number of values to operate\n  // on. This helper accumulates all remaining arguments past the function’s\n  // argument length (or an explicit `startIndex`), into an array that becomes\n  // the last argument. Similar to ES6’s \"rest parameter\".\n  function restArguments(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n      var length = Math.max(arguments.length - startIndex, 0),\n          rest = Array(length),\n          index = 0;\n      for (; index < length; index++) {\n        rest[index] = arguments[index + startIndex];\n      }\n      switch (startIndex) {\n        case 0: return func.call(this, rest);\n        case 1: return func.call(this, arguments[0], rest);\n        case 2: return func.call(this, arguments[0], arguments[1], rest);\n      }\n      var args = Array(startIndex + 1);\n      for (index = 0; index < startIndex; index++) {\n        args[index] = arguments[index];\n      }\n      args[startIndex] = rest;\n      return func.apply(this, args);\n    };\n  }\n\n  // Is a given variable an object?\n  function isObject(obj) {\n    var type = typeof obj;\n    return type === 'function' || (type === 'object' && !!obj);\n  }\n\n  // Is a given value equal to null?\n  function isNull(obj) {\n    return obj === null;\n  }\n\n  // Is a given variable undefined?\n  function isUndefined(obj) {\n    return obj === void 0;\n  }\n\n  // Is a given value a boolean?\n  function isBoolean(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  }\n\n  // Is a given value a DOM element?\n  function isElement(obj) {\n    return !!(obj && obj.nodeType === 1);\n  }\n\n  // Internal function for creating a `toString`-based type tester.\n  function tagTester(name) {\n    var tag = '[object ' + name + ']';\n    return function(obj) {\n      return toString.call(obj) === tag;\n    };\n  }\n\n  var isString = tagTester('String');\n\n  var isNumber = tagTester('Number');\n\n  var isDate = tagTester('Date');\n\n  var isRegExp = tagTester('RegExp');\n\n  var isError = tagTester('Error');\n\n  var isSymbol = tagTester('Symbol');\n\n  var isArrayBuffer = tagTester('ArrayBuffer');\n\n  var isFunction = tagTester('Function');\n\n  // Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old\n  // v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).\n  var nodelist = root.document && root.document.childNodes;\n  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {\n    isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  var isFunction$1 = isFunction;\n\n  var hasObjectTag = tagTester('Object');\n\n  // In IE 10 - Edge 13, `DataView` has string tag `'[object Object]'`.\n  // In IE 11, the most common among them, this problem also applies to\n  // `Map`, `WeakMap` and `Set`.\n  var hasStringTagBug = (\n        supportsDataView && hasObjectTag(new DataView(new ArrayBuffer(8)))\n      ),\n      isIE11 = (typeof Map !== 'undefined' && hasObjectTag(new Map));\n\n  var isDataView = tagTester('DataView');\n\n  // In IE 10 - Edge 13, we need a different heuristic\n  // to determine whether an object is a `DataView`.\n  function ie10IsDataView(obj) {\n    return obj != null && isFunction$1(obj.getInt8) && isArrayBuffer(obj.buffer);\n  }\n\n  var isDataView$1 = (hasStringTagBug ? ie10IsDataView : isDataView);\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native `Array.isArray`.\n  var isArray = nativeIsArray || tagTester('Array');\n\n  // Internal function to check whether `key` is an own property name of `obj`.\n  function has$1(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  }\n\n  var isArguments = tagTester('Arguments');\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  (function() {\n    if (!isArguments(arguments)) {\n      isArguments = function(obj) {\n        return has$1(obj, 'callee');\n      };\n    }\n  }());\n\n  var isArguments$1 = isArguments;\n\n  // Is a given object a finite number?\n  function isFinite$1(obj) {\n    return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));\n  }\n\n  // Is the given value `NaN`?\n  function isNaN$1(obj) {\n    return isNumber(obj) && _isNaN(obj);\n  }\n\n  // Predicate-generating function. Often useful outside of Underscore.\n  function constant(value) {\n    return function() {\n      return value;\n    };\n  }\n\n  // Common internal logic for `isArrayLike` and `isBufferLike`.\n  function createSizePropertyCheck(getSizeProperty) {\n    return function(collection) {\n      var sizeProperty = getSizeProperty(collection);\n      return typeof sizeProperty == 'number' && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;\n    }\n  }\n\n  // Internal helper to generate a function to obtain property `key` from `obj`.\n  function shallowProperty(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  }\n\n  // Internal helper to obtain the `byteLength` property of an object.\n  var getByteLength = shallowProperty('byteLength');\n\n  // Internal helper to determine whether we should spend extensive checks against\n  // `ArrayBuffer` et al.\n  var isBufferLike = createSizePropertyCheck(getByteLength);\n\n  // Is a given value a typed array?\n  var typedArrayPattern = /\\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\\]/;\n  function isTypedArray(obj) {\n    // `ArrayBuffer.isView` is the most future-proof, so use it when available.\n    // Otherwise, fall back on the above regular expression.\n    return nativeIsView ? (nativeIsView(obj) && !isDataView$1(obj)) :\n                  isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));\n  }\n\n  var isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);\n\n  // Internal helper to obtain the `length` property of an object.\n  var getLength = shallowProperty('length');\n\n  // Internal helper to create a simple lookup structure.\n  // `collectNonEnumProps` used to depend on `_.contains`, but this led to\n  // circular imports. `emulatedSet` is a one-off solution that only works for\n  // arrays of strings.\n  function emulatedSet(keys) {\n    var hash = {};\n    for (var l = keys.length, i = 0; i < l; ++i) hash[keys[i]] = true;\n    return {\n      contains: function(key) { return hash[key] === true; },\n      push: function(key) {\n        hash[key] = true;\n        return keys.push(key);\n      }\n    };\n  }\n\n  // Internal helper. Checks `keys` for the presence of keys in IE < 9 that won't\n  // be iterated by `for key in ...` and thus missed. Extends `keys` in place if\n  // needed.\n  function collectNonEnumProps(obj, keys) {\n    keys = emulatedSet(keys);\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = (isFunction$1(constructor) && constructor.prototype) || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (has$1(obj, prop) && !keys.contains(prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) {\n        keys.push(prop);\n      }\n    }\n  }\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`.\n  function keys(obj) {\n    if (!isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (has$1(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  }\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  function isEmpty(obj) {\n    if (obj == null) return true;\n    // Skip the more expensive `toString`-based type checks if `obj` has no\n    // `.length`.\n    var length = getLength(obj);\n    if (typeof length == 'number' && (\n      isArray(obj) || isString(obj) || isArguments$1(obj)\n    )) return length === 0;\n    return getLength(keys(obj)) === 0;\n  }\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  function isMatch(object, attrs) {\n    var _keys = keys(attrs), length = _keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = _keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  }\n\n  // If Underscore is called as a function, it returns a wrapped object that can\n  // be used OO-style. This wrapper holds altered versions of all functions added\n  // through `_.mixin`. Wrapped objects may be chained.\n  function _$1(obj) {\n    if (obj instanceof _$1) return obj;\n    if (!(this instanceof _$1)) return new _$1(obj);\n    this._wrapped = obj;\n  }\n\n  _$1.VERSION = VERSION;\n\n  // Extracts the result from a wrapped and chained object.\n  _$1.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxies for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;\n\n  _$1.prototype.toString = function() {\n    return String(this._wrapped);\n  };\n\n  // Internal function to wrap or shallow-copy an ArrayBuffer,\n  // typed array or DataView to a new view, reusing the buffer.\n  function toBufferView(bufferSource) {\n    return new Uint8Array(\n      bufferSource.buffer || bufferSource,\n      bufferSource.byteOffset || 0,\n      getByteLength(bufferSource)\n    );\n  }\n\n  // We use this string twice, so give it a name for minification.\n  var tagDataView = '[object DataView]';\n\n  // Internal recursive comparison function for `_.isEqual`.\n  function eq(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // `null` or `undefined` only equal to itself (strict comparison).\n    if (a == null || b == null) return false;\n    // `NaN`s are equivalent, but non-reflexive.\n    if (a !== a) return b !== b;\n    // Exhaust primitive checks\n    var type = typeof a;\n    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\n    return deepEq(a, b, aStack, bStack);\n  }\n\n  // Internal recursive comparison function for `_.isEqual`.\n  function deepEq(a, b, aStack, bStack) {\n    // Unwrap any wrapped objects.\n    if (a instanceof _$1) a = a._wrapped;\n    if (b instanceof _$1) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    // Work around a bug in IE 10 - Edge 13.\n    if (hasStringTagBug && className == '[object Object]' && isDataView$1(a)) {\n      if (!isDataView$1(b)) return false;\n      className = tagDataView;\n    }\n    switch (className) {\n      // These types are compared by value.\n      case '[object RegExp]':\n        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN.\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n      case '[object Symbol]':\n        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\n      case '[object ArrayBuffer]':\n      case tagDataView:\n        // Coerce to typed array so we can fall through.\n        return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays && isTypedArray$1(a)) {\n        var byteLength = getByteLength(a);\n        if (byteLength !== getByteLength(b)) return false;\n        if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;\n        areArrays = true;\n    }\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor &&\n                               isFunction$1(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var _keys = keys(a), key;\n      length = _keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = _keys[length];\n        if (!(has$1(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  }\n\n  // Perform a deep comparison to check if two objects are equal.\n  function isEqual(a, b) {\n    return eq(a, b);\n  }\n\n  // Retrieve all the enumerable property names of an object.\n  function allKeys(obj) {\n    if (!isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  }\n\n  // Since the regular `Object.prototype.toString` type tests don't work for\n  // some types in IE 11, we use a fingerprinting heuristic instead, based\n  // on the methods. It's not great, but it's the best we got.\n  // The fingerprint method lists are defined below.\n  function ie11fingerprint(methods) {\n    var length = getLength(methods);\n    return function(obj) {\n      if (obj == null) return false;\n      // `Map`, `WeakMap` and `Set` have no enumerable keys.\n      var keys = allKeys(obj);\n      if (getLength(keys)) return false;\n      for (var i = 0; i < length; i++) {\n        if (!isFunction$1(obj[methods[i]])) return false;\n      }\n      // If we are testing against `WeakMap`, we need to ensure that\n      // `obj` doesn't have a `forEach` method in order to distinguish\n      // it from a regular `Map`.\n      return methods !== weakMapMethods || !isFunction$1(obj[forEachName]);\n    };\n  }\n\n  // In the interest of compact minification, we write\n  // each string in the fingerprints only once.\n  var forEachName = 'forEach',\n      hasName = 'has',\n      commonInit = ['clear', 'delete'],\n      mapTail = ['get', hasName, 'set'];\n\n  // `Map`, `WeakMap` and `Set` each have slightly different\n  // combinations of the above sublists.\n  var mapMethods = commonInit.concat(forEachName, mapTail),\n      weakMapMethods = commonInit.concat(mapTail),\n      setMethods = ['add'].concat(commonInit, forEachName, hasName);\n\n  var isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester('Map');\n\n  var isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester('WeakMap');\n\n  var isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester('Set');\n\n  var isWeakSet = tagTester('WeakSet');\n\n  // Retrieve the values of an object's properties.\n  function values(obj) {\n    var _keys = keys(obj);\n    var length = _keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[_keys[i]];\n    }\n    return values;\n  }\n\n  // Convert an object into a list of `[key, value]` pairs.\n  // The opposite of `_.object` with one argument.\n  function pairs(obj) {\n    var _keys = keys(obj);\n    var length = _keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [_keys[i], obj[_keys[i]]];\n    }\n    return pairs;\n  }\n\n  // Invert the keys and values of an object. The values must be serializable.\n  function invert(obj) {\n    var result = {};\n    var _keys = keys(obj);\n    for (var i = 0, length = _keys.length; i < length; i++) {\n      result[obj[_keys[i]]] = _keys[i];\n    }\n    return result;\n  }\n\n  // Return a sorted list of the function names available on the object.\n  function functions(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (isFunction$1(obj[key])) names.push(key);\n    }\n    return names.sort();\n  }\n\n  // An internal function for creating assigner functions.\n  function createAssigner(keysFunc, defaults) {\n    return function(obj) {\n      var length = arguments.length;\n      if (defaults) obj = Object(obj);\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!defaults || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  }\n\n  // Extend a given object with all the properties in passed-in object(s).\n  var extend = createAssigner(allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in\n  // object(s).\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  var extendOwn = createAssigner(keys);\n\n  // Fill in a given object with default properties.\n  var defaults = createAssigner(allKeys, true);\n\n  // Create a naked function reference for surrogate-prototype-swapping.\n  function ctor() {\n    return function(){};\n  }\n\n  // An internal function for creating a new object that inherits from another.\n  function baseCreate(prototype) {\n    if (!isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    var Ctor = ctor();\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  }\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  function create(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) extendOwn(result, props);\n    return result;\n  }\n\n  // Create a (shallow-cloned) duplicate of an object.\n  function clone(obj) {\n    if (!isObject(obj)) return obj;\n    return isArray(obj) ? obj.slice() : extend({}, obj);\n  }\n\n  // Invokes `interceptor` with the `obj` and then returns `obj`.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  function tap(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  }\n\n  // Normalize a (deep) property `path` to array.\n  // Like `_.iteratee`, this function can be customized.\n  function toPath$1(path) {\n    return isArray(path) ? path : [path];\n  }\n  _$1.toPath = toPath$1;\n\n  // Internal wrapper for `_.toPath` to enable minification.\n  // Similar to `cb` for `_.iteratee`.\n  function toPath(path) {\n    return _$1.toPath(path);\n  }\n\n  // Internal function to obtain a nested property in `obj` along `path`.\n  function deepGet(obj, path) {\n    var length = path.length;\n    for (var i = 0; i < length; i++) {\n      if (obj == null) return void 0;\n      obj = obj[path[i]];\n    }\n    return length ? obj : void 0;\n  }\n\n  // Get the value of the (deep) property on `path` from `object`.\n  // If any property in `path` does not exist or if the value is\n  // `undefined`, return `defaultValue` instead.\n  // The `path` is normalized through `_.toPath`.\n  function get(object, path, defaultValue) {\n    var value = deepGet(object, toPath(path));\n    return isUndefined(value) ? defaultValue : value;\n  }\n\n  // Shortcut function for checking if an object has a given property directly on\n  // itself (in other words, not on a prototype). Unlike the internal `has`\n  // function, this public version can also traverse nested properties.\n  function has(obj, path) {\n    path = toPath(path);\n    var length = path.length;\n    for (var i = 0; i < length; i++) {\n      var key = path[i];\n      if (!has$1(obj, key)) return false;\n      obj = obj[key];\n    }\n    return !!length;\n  }\n\n  // Keep the identity function around for default iteratees.\n  function identity(value) {\n    return value;\n  }\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  function matcher(attrs) {\n    attrs = extendOwn({}, attrs);\n    return function(obj) {\n      return isMatch(obj, attrs);\n    };\n  }\n\n  // Creates a function that, when passed an object, will traverse that object’s\n  // properties down the given `path`, specified as an array of keys or indices.\n  function property(path) {\n    path = toPath(path);\n    return function(obj) {\n      return deepGet(obj, path);\n    };\n  }\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  function optimizeCb(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      // The 2-argument case is omitted because we’re not using it.\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  }\n\n  // An internal function to generate callbacks that can be applied to each\n  // element in a collection, returning the desired result — either `_.identity`,\n  // an arbitrary callback, a property matcher, or a property accessor.\n  function baseIteratee(value, context, argCount) {\n    if (value == null) return identity;\n    if (isFunction$1(value)) return optimizeCb(value, context, argCount);\n    if (isObject(value) && !isArray(value)) return matcher(value);\n    return property(value);\n  }\n\n  // External wrapper for our callback generator. Users may customize\n  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.\n  // This abstraction hides the internal-only `argCount` argument.\n  function iteratee(value, context) {\n    return baseIteratee(value, context, Infinity);\n  }\n  _$1.iteratee = iteratee;\n\n  // The function we call internally to generate a callback. It invokes\n  // `_.iteratee` if overridden, otherwise `baseIteratee`.\n  function cb(value, context, argCount) {\n    if (_$1.iteratee !== iteratee) return _$1.iteratee(value, context);\n    return baseIteratee(value, context, argCount);\n  }\n\n  // Returns the results of applying the `iteratee` to each element of `obj`.\n  // In contrast to `_.map` it returns an object.\n  function mapObject(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var _keys = keys(obj),\n        length = _keys.length,\n        results = {};\n    for (var index = 0; index < length; index++) {\n      var currentKey = _keys[index];\n      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  }\n\n  // Predicate-generating function. Often useful outside of Underscore.\n  function noop(){}\n\n  // Generates a function for a given object that returns a given property.\n  function propertyOf(obj) {\n    if (obj == null) return noop;\n    return function(path) {\n      return get(obj, path);\n    };\n  }\n\n  // Run a function **n** times.\n  function times(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  }\n\n  // Return a random integer between `min` and `max` (inclusive).\n  function random(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  }\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  var now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n  // Internal helper to generate functions for escaping and unescaping strings\n  // to/from HTML interpolation.\n  function createEscaper(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped.\n    var source = '(?:' + keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  }\n\n  // Internal list of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n\n  // Function for escaping strings to HTML interpolation.\n  var _escape = createEscaper(escapeMap);\n\n  // Internal list of HTML entities for unescaping.\n  var unescapeMap = invert(escapeMap);\n\n  // Function for unescaping strings from HTML interpolation.\n  var _unescape = createEscaper(unescapeMap);\n\n  // By default, Underscore uses ERB-style template delimiters. Change the\n  // following template settings to use alternative delimiters.\n  var templateSettings = _$1.templateSettings = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape: /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `_.templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\": \"'\",\n    '\\\\': '\\\\',\n    '\\r': 'r',\n    '\\n': 'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escapeRegExp = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  function escapeChar(match) {\n    return '\\\\' + escapes[match];\n  }\n\n  // In order to prevent third-party code injection through\n  // `_.templateSettings.variable`, we test it against the following regular\n  // expression. It is intentionally a bit more liberal than just matching valid\n  // identifiers, but still prevents possible loopholes through defaults or\n  // destructuring assignment.\n  var bareIdentifier = /^\\s*(\\w|\\$)+\\s*$/;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  function template(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = defaults({}, settings, _$1.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offset.\n      return match;\n    });\n    source += \"';\\n\";\n\n    var argument = settings.variable;\n    if (argument) {\n      // Insure against third-party code injection. (CVE-2021-23358)\n      if (!bareIdentifier.test(argument)) throw new Error(\n        'variable is not a bare identifier: ' + argument\n      );\n    } else {\n      // If a variable is not specified, place data values in local scope.\n      source = 'with(obj||{}){\\n' + source + '}\\n';\n      argument = 'obj';\n    }\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    var render;\n    try {\n      render = new Function(argument, '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _$1);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  }\n\n  // Traverses the children of `obj` along `path`. If a child is a function, it\n  // is invoked with its parent as context. Returns the value of the final\n  // child, or `fallback` if any child is undefined.\n  function result(obj, path, fallback) {\n    path = toPath(path);\n    var length = path.length;\n    if (!length) {\n      return isFunction$1(fallback) ? fallback.call(obj) : fallback;\n    }\n    for (var i = 0; i < length; i++) {\n      var prop = obj == null ? void 0 : obj[path[i]];\n      if (prop === void 0) {\n        prop = fallback;\n        i = length; // Ensure we don't continue iterating.\n      }\n      obj = isFunction$1(prop) ? prop.call(obj) : prop;\n    }\n    return obj;\n  }\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  function uniqueId(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  }\n\n  // Start chaining a wrapped Underscore object.\n  function chain(obj) {\n    var instance = _$1(obj);\n    instance._chain = true;\n    return instance;\n  }\n\n  // Internal function to execute `sourceFunc` bound to `context` with optional\n  // `args`. Determines whether to execute a function as a constructor or as a\n  // normal function.\n  function executeBound(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (isObject(result)) return result;\n    return self;\n  }\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. `_` acts\n  // as a placeholder by default, allowing any combination of arguments to be\n  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.\n  var partial = restArguments(function(func, boundArgs) {\n    var placeholder = partial.placeholder;\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  });\n\n  partial.placeholder = _$1;\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally).\n  var bind = restArguments(function(func, context, args) {\n    if (!isFunction$1(func)) throw new TypeError('Bind must be called on a function');\n    var bound = restArguments(function(callArgs) {\n      return executeBound(func, bound, context, this, args.concat(callArgs));\n    });\n    return bound;\n  });\n\n  // Internal helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object.\n  // Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var isArrayLike = createSizePropertyCheck(getLength);\n\n  // Internal implementation of a recursive `flatten` function.\n  function flatten$1(input, depth, strict, output) {\n    output = output || [];\n    if (!depth && depth !== 0) {\n      depth = Infinity;\n    } else if (depth <= 0) {\n      return output.concat(input);\n    }\n    var idx = output.length;\n    for (var i = 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {\n        // Flatten current level of array or arguments object.\n        if (depth > 1) {\n          flatten$1(value, depth - 1, strict, output);\n          idx = output.length;\n        } else {\n          var j = 0, len = value.length;\n          while (j < len) output[idx++] = value[j++];\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  }\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  var bindAll = restArguments(function(obj, keys) {\n    keys = flatten$1(keys, false, false);\n    var index = keys.length;\n    if (index < 1) throw new Error('bindAll must be passed function names');\n    while (index--) {\n      var key = keys[index];\n      obj[key] = bind(obj[key], obj);\n    }\n    return obj;\n  });\n\n  // Memoize an expensive function by storing its results.\n  function memoize(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!has$1(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  }\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  var delay = restArguments(function(func, wait, args) {\n    return setTimeout(function() {\n      return func.apply(null, args);\n    }, wait);\n  });\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  var defer = partial(delay, _$1, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  function throttle(func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function() {\n      previous = options.leading === false ? 0 : now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function() {\n      var _now = now();\n      if (!previous && options.leading === false) previous = _now;\n      var remaining = wait - (_now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = _now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n\n    throttled.cancel = function() {\n      clearTimeout(timeout);\n      previous = 0;\n      timeout = context = args = null;\n    };\n\n    return throttled;\n  }\n\n  // When a sequence of calls of the returned function ends, the argument\n  // function is triggered. The end of a sequence is defined by the `wait`\n  // parameter. If `immediate` is passed, the argument function will be\n  // triggered at the beginning of the sequence instead of at the end.\n  function debounce(func, wait, immediate) {\n    var timeout, previous, args, result, context;\n\n    var later = function() {\n      var passed = now() - previous;\n      if (wait > passed) {\n        timeout = setTimeout(later, wait - passed);\n      } else {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n        // This check is needed because `func` can recursively invoke `debounced`.\n        if (!timeout) args = context = null;\n      }\n    };\n\n    var debounced = restArguments(function(_args) {\n      context = this;\n      args = _args;\n      previous = now();\n      if (!timeout) {\n        timeout = setTimeout(later, wait);\n        if (immediate) result = func.apply(context, args);\n      }\n      return result;\n    });\n\n    debounced.cancel = function() {\n      clearTimeout(timeout);\n      timeout = args = context = null;\n    };\n\n    return debounced;\n  }\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  function wrap(func, wrapper) {\n    return partial(wrapper, func);\n  }\n\n  // Returns a negated version of the passed-in predicate.\n  function negate(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  }\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  function compose() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  }\n\n  // Returns a function that will only be executed on and after the Nth call.\n  function after(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  }\n\n  // Returns a function that will only be executed up to (but not including) the\n  // Nth call.\n  function before(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  }\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  var once = partial(before, 2);\n\n  // Returns the first key on an object that passes a truth test.\n  function findKey(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var _keys = keys(obj), key;\n    for (var i = 0, length = _keys.length; i < length; i++) {\n      key = _keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  }\n\n  // Internal function to generate `_.findIndex` and `_.findLastIndex`.\n  function createPredicateIndexFinder(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  }\n\n  // Returns the first index on an array-like that passes a truth test.\n  var findIndex = createPredicateIndexFinder(1);\n\n  // Returns the last index on an array-like that passes a truth test.\n  var findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  function sortedIndex(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  }\n\n  // Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.\n  function createIndexFinder(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n          i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), isNaN$1);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  }\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  var indexOf = createIndexFinder(1, findIndex, sortedIndex);\n\n  // Return the position of the last occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  var lastIndexOf = createIndexFinder(-1, findLastIndex);\n\n  // Return the first value which passes a truth test.\n  function find(obj, predicate, context) {\n    var keyFinder = isArrayLike(obj) ? findIndex : findKey;\n    var key = keyFinder(obj, predicate, context);\n    if (key !== void 0 && key !== -1) return obj[key];\n  }\n\n  // Convenience version of a common use case of `_.find`: getting the first\n  // object containing specific `key:value` pairs.\n  function findWhere(obj, attrs) {\n    return find(obj, matcher(attrs));\n  }\n\n  // The cornerstone for collection functions, an `each`\n  // implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  function each(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var _keys = keys(obj);\n      for (i = 0, length = _keys.length; i < length; i++) {\n        iteratee(obj[_keys[i]], _keys[i], obj);\n      }\n    }\n    return obj;\n  }\n\n  // Return the results of applying the iteratee to each element.\n  function map(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var _keys = !isArrayLike(obj) && keys(obj),\n        length = (_keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = _keys ? _keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  }\n\n  // Internal helper to create a reducing function, iterating left or right.\n  function createReduce(dir) {\n    // Wrap code that reassigns argument variables in a separate function than\n    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)\n    var reducer = function(obj, iteratee, memo, initial) {\n      var _keys = !isArrayLike(obj) && keys(obj),\n          length = (_keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      if (!initial) {\n        memo = obj[_keys ? _keys[index] : index];\n        index += dir;\n      }\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = _keys ? _keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    };\n\n    return function(obj, iteratee, memo, context) {\n      var initial = arguments.length >= 3;\n      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);\n    };\n  }\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  var reduce = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  var reduceRight = createReduce(-1);\n\n  // Return all the elements that pass a truth test.\n  function filter(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  }\n\n  // Return all the elements for which a truth test fails.\n  function reject(obj, predicate, context) {\n    return filter(obj, negate(cb(predicate)), context);\n  }\n\n  // Determine whether all of the elements pass a truth test.\n  function every(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var _keys = !isArrayLike(obj) && keys(obj),\n        length = (_keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = _keys ? _keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  }\n\n  // Determine if at least one element in the object passes a truth test.\n  function some(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var _keys = !isArrayLike(obj) && keys(obj),\n        length = (_keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = _keys ? _keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  }\n\n  // Determine if the array or object contains a given item (using `===`).\n  function contains(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return indexOf(obj, item, fromIndex) >= 0;\n  }\n\n  // Invoke a method (with arguments) on every item in a collection.\n  var invoke = restArguments(function(obj, path, args) {\n    var contextPath, func;\n    if (isFunction$1(path)) {\n      func = path;\n    } else {\n      path = toPath(path);\n      contextPath = path.slice(0, -1);\n      path = path[path.length - 1];\n    }\n    return map(obj, function(context) {\n      var method = func;\n      if (!method) {\n        if (contextPath && contextPath.length) {\n          context = deepGet(context, contextPath);\n        }\n        if (context == null) return void 0;\n        method = context[path];\n      }\n      return method == null ? method : method.apply(context, args);\n    });\n  });\n\n  // Convenience version of a common use case of `_.map`: fetching a property.\n  function pluck(obj, key) {\n    return map(obj, property(key));\n  }\n\n  // Convenience version of a common use case of `_.filter`: selecting only\n  // objects containing specific `key:value` pairs.\n  function where(obj, attrs) {\n    return filter(obj, matcher(attrs));\n  }\n\n  // Return the maximum element (or element-based computation).\n  function max(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {\n      obj = isArrayLike(obj) ? obj : values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      each(obj, function(v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed > lastComputed || (computed === -Infinity && result === -Infinity)) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  }\n\n  // Return the minimum element (or element-based computation).\n  function min(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {\n      obj = isArrayLike(obj) ? obj : values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      each(obj, function(v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed < lastComputed || (computed === Infinity && result === Infinity)) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  }\n\n  // Safely create a real, live array from anything iterable.\n  var reStrSymbol = /[^\\ud800-\\udfff]|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff]/g;\n  function toArray(obj) {\n    if (!obj) return [];\n    if (isArray(obj)) return slice.call(obj);\n    if (isString(obj)) {\n      // Keep surrogate pair characters together.\n      return obj.match(reStrSymbol);\n    }\n    if (isArrayLike(obj)) return map(obj, identity);\n    return values(obj);\n  }\n\n  // Sample **n** random values from a collection using the modern version of the\n  // [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `_.map`.\n  function sample(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = values(obj);\n      return obj[random(obj.length - 1)];\n    }\n    var sample = toArray(obj);\n    var length = getLength(sample);\n    n = Math.max(Math.min(n, length), 0);\n    var last = length - 1;\n    for (var index = 0; index < n; index++) {\n      var rand = random(index, last);\n      var temp = sample[index];\n      sample[index] = sample[rand];\n      sample[rand] = temp;\n    }\n    return sample.slice(0, n);\n  }\n\n  // Shuffle a collection.\n  function shuffle(obj) {\n    return sample(obj, Infinity);\n  }\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  function sortBy(obj, iteratee, context) {\n    var index = 0;\n    iteratee = cb(iteratee, context);\n    return pluck(map(obj, function(value, key, list) {\n      return {\n        value: value,\n        index: index++,\n        criteria: iteratee(value, key, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  }\n\n  // An internal function used for aggregate \"group by\" operations.\n  function group(behavior, partition) {\n    return function(obj, iteratee, context) {\n      var result = partition ? [[], []] : {};\n      iteratee = cb(iteratee, context);\n      each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  }\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  var groupBy = group(function(result, value, key) {\n    if (has$1(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `_.groupBy`, but for\n  // when you know that your index values will be unique.\n  var indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  var countBy = group(function(result, value, key) {\n    if (has$1(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Split a collection into two arrays: one whose elements all pass the given\n  // truth test, and one whose elements all do not pass the truth test.\n  var partition = group(function(result, value, pass) {\n    result[pass ? 0 : 1].push(value);\n  }, true);\n\n  // Return the number of elements in a collection.\n  function size(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : keys(obj).length;\n  }\n\n  // Internal `_.pick` helper function to determine whether `key` is an enumerable\n  // property name of `obj`.\n  function keyInObj(value, key, obj) {\n    return key in obj;\n  }\n\n  // Return a copy of the object only containing the allowed properties.\n  var pick = restArguments(function(obj, keys) {\n    var result = {}, iteratee = keys[0];\n    if (obj == null) return result;\n    if (isFunction$1(iteratee)) {\n      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);\n      keys = allKeys(obj);\n    } else {\n      iteratee = keyInObj;\n      keys = flatten$1(keys, false, false);\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  });\n\n  // Return a copy of the object without the disallowed properties.\n  var omit = restArguments(function(obj, keys) {\n    var iteratee = keys[0], context;\n    if (isFunction$1(iteratee)) {\n      iteratee = negate(iteratee);\n      if (keys.length > 1) context = keys[1];\n    } else {\n      keys = map(flatten$1(keys, false, false), String);\n      iteratee = function(value, key) {\n        return !contains(keys, key);\n      };\n    }\n    return pick(obj, iteratee, context);\n  });\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  function initial(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  }\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  function first(array, n, guard) {\n    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];\n    if (n == null || guard) return array[0];\n    return initial(array, array.length - n);\n  }\n\n  // Returns everything but the first entry of the `array`. Especially useful on\n  // the `arguments` object. Passing an **n** will return the rest N values in the\n  // `array`.\n  function rest(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  }\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  function last(array, n, guard) {\n    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];\n    if (n == null || guard) return array[array.length - 1];\n    return rest(array, Math.max(0, array.length - n));\n  }\n\n  // Trim out all falsy values from an array.\n  function compact(array) {\n    return filter(array, Boolean);\n  }\n\n  // Flatten out an array, either recursively (by default), or up to `depth`.\n  // Passing `true` or `false` as `depth` means `1` or `Infinity`, respectively.\n  function flatten(array, depth) {\n    return flatten$1(array, depth, false);\n  }\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  var difference = restArguments(function(array, rest) {\n    rest = flatten$1(rest, true, true);\n    return filter(array, function(value){\n      return !contains(rest, value);\n    });\n  });\n\n  // Return a version of the array that does not contain the specified value(s).\n  var without = restArguments(function(array, otherArrays) {\n    return difference(array, otherArrays);\n  });\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // The faster algorithm will not work with an iteratee if the iteratee\n  // is not a one-to-one function, so providing an iteratee will disable\n  // the faster algorithm.\n  function uniq(array, isSorted, iteratee, context) {\n    if (!isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted && !iteratee) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  }\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  var union = restArguments(function(arrays) {\n    return uniq(flatten$1(arrays, true, true));\n  });\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  function intersection(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (contains(result, item)) continue;\n      var j;\n      for (j = 1; j < argsLength; j++) {\n        if (!contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  }\n\n  // Complement of zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices.\n  function unzip(array) {\n    var length = (array && max(array, getLength).length) || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = pluck(array, index);\n    }\n    return result;\n  }\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  var zip = restArguments(unzip);\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values. Passing by pairs is the reverse of `_.pairs`.\n  function object(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  }\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](https://docs.python.org/library/functions.html#range).\n  function range(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    if (!step) {\n      step = stop < start ? -1 : 1;\n    }\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  }\n\n  // Chunk a single array into multiple arrays, each containing `count` or fewer\n  // items.\n  function chunk(array, count) {\n    if (count == null || count < 1) return [];\n    var result = [];\n    var i = 0, length = array.length;\n    while (i < length) {\n      result.push(slice.call(array, i, i += count));\n    }\n    return result;\n  }\n\n  // Helper function to continue chaining intermediate results.\n  function chainResult(instance, obj) {\n    return instance._chain ? _$1(obj).chain() : obj;\n  }\n\n  // Add your own custom functions to the Underscore object.\n  function mixin(obj) {\n    each(functions(obj), function(name) {\n      var func = _$1[name] = obj[name];\n      _$1.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return chainResult(this, func.apply(_$1, args));\n      };\n    });\n    return _$1;\n  }\n\n  // Add all mutator `Array` functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _$1.prototype[name] = function() {\n      var obj = this._wrapped;\n      if (obj != null) {\n        method.apply(obj, arguments);\n        if ((name === 'shift' || name === 'splice') && obj.length === 0) {\n          delete obj[0];\n        }\n      }\n      return chainResult(this, obj);\n    };\n  });\n\n  // Add all accessor `Array` functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _$1.prototype[name] = function() {\n      var obj = this._wrapped;\n      if (obj != null) obj = method.apply(obj, arguments);\n      return chainResult(this, obj);\n    };\n  });\n\n  // Named Exports\n\n  var allExports = {\n    __proto__: null,\n    VERSION: VERSION,\n    restArguments: restArguments,\n    isObject: isObject,\n    isNull: isNull,\n    isUndefined: isUndefined,\n    isBoolean: isBoolean,\n    isElement: isElement,\n    isString: isString,\n    isNumber: isNumber,\n    isDate: isDate,\n    isRegExp: isRegExp,\n    isError: isError,\n    isSymbol: isSymbol,\n    isArrayBuffer: isArrayBuffer,\n    isDataView: isDataView$1,\n    isArray: isArray,\n    isFunction: isFunction$1,\n    isArguments: isArguments$1,\n    isFinite: isFinite$1,\n    isNaN: isNaN$1,\n    isTypedArray: isTypedArray$1,\n    isEmpty: isEmpty,\n    isMatch: isMatch,\n    isEqual: isEqual,\n    isMap: isMap,\n    isWeakMap: isWeakMap,\n    isSet: isSet,\n    isWeakSet: isWeakSet,\n    keys: keys,\n    allKeys: allKeys,\n    values: values,\n    pairs: pairs,\n    invert: invert,\n    functions: functions,\n    methods: functions,\n    extend: extend,\n    extendOwn: extendOwn,\n    assign: extendOwn,\n    defaults: defaults,\n    create: create,\n    clone: clone,\n    tap: tap,\n    get: get,\n    has: has,\n    mapObject: mapObject,\n    identity: identity,\n    constant: constant,\n    noop: noop,\n    toPath: toPath$1,\n    property: property,\n    propertyOf: propertyOf,\n    matcher: matcher,\n    matches: matcher,\n    times: times,\n    random: random,\n    now: now,\n    escape: _escape,\n    unescape: _unescape,\n    templateSettings: templateSettings,\n    template: template,\n    result: result,\n    uniqueId: uniqueId,\n    chain: chain,\n    iteratee: iteratee,\n    partial: partial,\n    bind: bind,\n    bindAll: bindAll,\n    memoize: memoize,\n    delay: delay,\n    defer: defer,\n    throttle: throttle,\n    debounce: debounce,\n    wrap: wrap,\n    negate: negate,\n    compose: compose,\n    after: after,\n    before: before,\n    once: once,\n    findKey: findKey,\n    findIndex: findIndex,\n    findLastIndex: findLastIndex,\n    sortedIndex: sortedIndex,\n    indexOf: indexOf,\n    lastIndexOf: lastIndexOf,\n    find: find,\n    detect: find,\n    findWhere: findWhere,\n    each: each,\n    forEach: each,\n    map: map,\n    collect: map,\n    reduce: reduce,\n    foldl: reduce,\n    inject: reduce,\n    reduceRight: reduceRight,\n    foldr: reduceRight,\n    filter: filter,\n    select: filter,\n    reject: reject,\n    every: every,\n    all: every,\n    some: some,\n    any: some,\n    contains: contains,\n    includes: contains,\n    include: contains,\n    invoke: invoke,\n    pluck: pluck,\n    where: where,\n    max: max,\n    min: min,\n    shuffle: shuffle,\n    sample: sample,\n    sortBy: sortBy,\n    groupBy: groupBy,\n    indexBy: indexBy,\n    countBy: countBy,\n    partition: partition,\n    toArray: toArray,\n    size: size,\n    pick: pick,\n    omit: omit,\n    first: first,\n    head: first,\n    take: first,\n    initial: initial,\n    last: last,\n    rest: rest,\n    tail: rest,\n    drop: rest,\n    compact: compact,\n    flatten: flatten,\n    without: without,\n    uniq: uniq,\n    unique: uniq,\n    union: union,\n    intersection: intersection,\n    difference: difference,\n    unzip: unzip,\n    transpose: unzip,\n    zip: zip,\n    object: object,\n    range: range,\n    chunk: chunk,\n    mixin: mixin,\n    'default': _$1\n  };\n\n  // Default Export\n\n  // Add all of the Underscore functions to the wrapper object.\n  var _ = mixin(allExports);\n  // Legacy Node.js API.\n  _._ = _;\n\n  return _;\n\n})));\n//# sourceMappingURL=underscore-umd.js.map\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2luZGV4LmpzIiwiZGlzdC9saWIvdGltZWxpbmVWaXN1YWxpemVyLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmlzZXF1YWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvZGlzdC9hcGkvYXBpLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyZmx5LXRpbWVsaW5lL2Rpc3QvYXBpL2VudW1zLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyZmx5LXRpbWVsaW5lL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvZGlzdC9saWIuanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvZGlzdC9yZXNvbHZlci9jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L3Jlc29sdmVyL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L3Jlc29sdmVyL2V4cHJlc3Npb24uanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvZGlzdC9yZXNvbHZlci9yZXNvbHZlci5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L3Jlc29sdmVyL3N0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyZmx5LXRpbWVsaW5lL2Rpc3QvcmVzb2x2ZXIvdmFsaWRhdGUuanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzIiwibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS11bWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25pQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3h6REE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdm5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvdGltZWxpbmVWaXN1YWxpemVyXCIpLCBleHBvcnRzKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5UaW1lbGluZVZpc3VhbGl6ZXIgPSB2b2lkIDA7XHJcbmNvbnN0IGlzRXF1YWwgPSByZXF1aXJlKFwibG9kYXNoLmlzZXF1YWxcIik7XHJcbmNvbnN0IHN1cGVyZmx5X3RpbWVsaW5lXzEgPSByZXF1aXJlKFwic3VwZXJmbHktdGltZWxpbmVcIik7XHJcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcclxuLyoqIFN0ZXAgc2l6ZS8gdGltZSBzdGVwLiAqL1xyXG5jb25zdCBERUZBVUxUX1NURVBfU0laRSA9IDE7XHJcbi8qKiBXaWR0aCBvZiBsYWJlbCBjb2x1bW4uICovXHJcbmNvbnN0IExBQkVMX1dJRFRIX09GX1RJTUVMSU5FID0gMC4yNTtcclxuLyoqIERlZmF1bHQgem9vbSAqL1xyXG5jb25zdCBERUZBVUxUX1pPT01fVkFMVUUgPSAxMDA7XHJcbi8qKiBGYWN0b3IgdG8gem9vbSBieSAqL1xyXG5jb25zdCBaT09NX0ZBQ1RPUiA9IDEuMDAxO1xyXG4vKiogRmFjdG9yIHRvIHBhbiBieSAocGFuID0gUEFOX0ZBQ1RPUiAqIFNURVBfU0laRSkgKi9cclxuY29uc3QgUEFOX0ZBQ1RPUiA9IDEwO1xyXG4vKiogTWF4aW11bSBsYXllciBoZWlnaHQgKi9cclxuY29uc3QgTUFYX0xBWUVSX0hFSUdIVCA9IDYwO1xyXG4vKiogQW1vdW50IHRvIG1vdmUgcGxheWhlYWQgcGVyIHNlY29uZC4gKi9cclxuY29uc3QgREVGQVVMVF9QTEFZSEVBRF9TUEVFRCA9IDE7XHJcbi8qKiBCRUdJTiBTVFlMSU5HIFZBTFVFUyAqL1xyXG4vKiogVGltZWxpbmUgYmFja2dyb3VuZCBjb2xvci4gKi9cclxuY29uc3QgQ09MT1JfQkFDS0dST1VORCA9ICcjMzMzMzMzJztcclxuLyoqIExheWVyIGxhYmVsIGJhY2tncm91bmQgY29sb3IuICovXHJcbmNvbnN0IENPTE9SX0xBQkVMX0JBQ0tHUk9VTkQgPSAnIzY2NjY2Nic7XHJcbi8qKiBDb2xvciBvZiB0aGUgcnVsZXIgbGluZXMgKi9cclxuY29uc3QgUlVMRVJfTElORV9DT0xPUiA9ICcjOTk5OTk5JztcclxuLyoqIFdpZHRoIG9mIHRoZSBydWxlciBsaW5lcyAqL1xyXG5jb25zdCBSVUxFUl9MSU5FX1dJRFRIID0gMTtcclxuLyoqIFBsYXloZWFkIGNvbG9yLiAqL1xyXG5jb25zdCBDT0xPUl9QTEFZSEVBRCA9ICdyZ2JhKDI1NSwgMCwgMCwgMC41KSc7XHJcbi8qKiBQbGF5aGVhZCB0aGlja25lc3MuICovXHJcbmNvbnN0IFRISUNLTkVTU19QTEFZSEVBRCA9IDU7XHJcbi8qKiBDb2xvciBvZiBsaW5lIHNlcGFyYXRpbmcgdGltZWxpbmUgcm93cy4gKi9cclxuY29uc3QgQ09MT1JfTElORSA9ICdibGFjayc7XHJcbi8qKiBIZWlnaHQgb2YgbGluZSBzZXBhcmF0aW5nIHJvd3MuICovXHJcbmNvbnN0IFRISUNLTkVTU19MSU5FID0gMTtcclxuLyoqIFRleHQgcHJvcGVydGllcy4gKi9cclxuY29uc3QgVEVYVF9GT05UX0ZBTUlMWSA9ICdDYWxpYnJpJztcclxuY29uc3QgVEVYVF9GT05UX1NJWkUgPSAxNjtcclxuY29uc3QgVEVYVF9DT0xPUiA9ICd3aGl0ZSc7XHJcbi8qKiBUaW1lbGluZSBvYmplY3QgcHJvcGVydGllcy4gKi9cclxuY29uc3QgQ09MT1JfVElNRUxJTkVfT0JKRUNUX0ZJTEwgPSAncmdiKDIyLCAxMDIsIDI0NywgMC43NSknO1xyXG5jb25zdCBDT0xPUl9USU1FTElORV9PQkpFQ1RfQk9SREVSID0gJ3JnYmEoMjMyLCAyNDAsIDI1NSwgMC44NSknO1xyXG5jb25zdCBUSElDS05FU1NfVElNRUxJTkVfT0JKRUNUX0JPUkRFUiA9IDE7XHJcbi8qKiBUaW1lbGluZSBvYmplY3QgaGVpZ2h0IGFzIGEgcHJvcG9ydGlvbiBvZiB0aGUgcm93IGhlaWdodC4gKi9cclxuY29uc3QgVElNRUxJTkVfT0JKRUNUX0hFSUdIVCA9IDE7XHJcbi8qKiBFTkQgU1RZTElORyBWQUxVRVMgKi9cclxuLyoqIEJFR0lOIENPTlNUQU5UUyBGT1IgU1RBVEUgTUFOQUdFTUVOVCAqL1xyXG5jb25zdCBNT1VTRUlOID0gMDtcclxuY29uc3QgTU9VU0VPVVQgPSAxO1xyXG5jbGFzcyBUaW1lbGluZVZpc3VhbGl6ZXIgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2FudmFzSWQgVGhlIElEIG9mIHRoZSBjYW52YXMgb2JqZWN0IHRvIGRyYXcgd2l0aGluLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjYW52YXNJZCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAvLyBTdGVwIHNpemUuXHJcbiAgICAgICAgdGhpcy5zdGVwU2l6ZSA9IERFRkFVTFRfU1RFUF9TSVpFO1xyXG4gICAgICAgIC8qKiBAcHJpdmF0ZSBAcmVhZG9ubHkgUHJvcG9ydGlvbiBvZiB0aGUgY2FudmFzIHRvIGJlIHVzZWQgZm9yIHRoZSBsYXllciBsYWJlbHMgY29sdW1uLiAqL1xyXG4gICAgICAgIHRoaXMuX2xheWVyTGFiZWxXaWR0aFByb3BvcnRpb25PZkNhbnZhcyA9IExBQkVMX1dJRFRIX09GX1RJTUVMSU5FO1xyXG4gICAgICAgIC8qKiBMYXllcnMgb24gdGltZWxpbmUuICovXHJcbiAgICAgICAgdGhpcy5fbGF5ZXJMYWJlbHMgPSB7fTtcclxuICAgICAgICAvKiogU3RhdGUgb2YgdGhlIHRpbWVsaW5lLiAqL1xyXG4gICAgICAgIHRoaXMuX3RpbWVsaW5lU3RhdGUgPSB7fTtcclxuICAgICAgICAvKiogTWFwIG9mIG9iamVjdHMgZm9yIGRldGVybWluaW5nIGhvdmVyZWQgb2JqZWN0ICovXHJcbiAgICAgICAgdGhpcy5faG92ZXJlZE9iamVjdE1hcCA9IHt9O1xyXG4gICAgICAgIC8qKiBTdGFydCB0aW1lIG9mIHRoZSBjdXJyZW50IHZpZXcuIERlZmluZXMgdGhlIG9iamVjdHMgd2l0aGluIHZpZXcgb24gdGhlIHRpbWVsaW5lIFt0aW1lXSAqL1xyXG4gICAgICAgIHRoaXMuX3ZpZXdTdGFydFRpbWUgPSAwO1xyXG4gICAgICAgIC8qKiBSYW5nZSBvZiB0aGUgY3VycmVudCB2aWV3IFt0aW1lXSAqL1xyXG4gICAgICAgIC8vIHByaXZhdGUgX3ZpZXdUaW1lUmFuZ2U6IG51bWJlciA9IDFcclxuICAgICAgICAvLyBwcml2YXRlIF9kcmF3VGltZUVuZDogbnVtYmVyXHJcbiAgICAgICAgLyoqIFN0b3JlIHdoZXRoZXIgdGhlIG1vdXNlIGlzIGhlbGQgZG93biwgZm9yIHNjcm9sbGluZy4gKi9cclxuICAgICAgICB0aGlzLl9tb3VzZURvd24gPSBmYWxzZTtcclxuICAgICAgICAvKiogQ3VycmVudCB6b29tIGFtb3VudC4gKi9cclxuICAgICAgICB0aGlzLl90aW1lbGluZVpvb20gPSBERUZBVUxUX1pPT01fVkFMVUU7XHJcbiAgICAgICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBwbGF5aGVhZCBzaG91bGQgbW92ZS4gKi9cclxuICAgICAgICB0aGlzLl9wbGF5SGVhZFBsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICAvKiogU3BlZWQgb2YgdGhlIHBsYXloZWFkIFt1bml0cyAvIHNlY29uZF0gKi9cclxuICAgICAgICB0aGlzLl9wbGF5U3BlZWQgPSBERUZBVUxUX1BMQVlIRUFEX1NQRUVEO1xyXG4gICAgICAgIC8qKiBUaGUgY3VycmVudCB0aW1lIHBvc2l0aW9uIG9mIHRoZSBwbGF5aGVhZC4gKi9cclxuICAgICAgICB0aGlzLl9wbGF5SGVhZFRpbWUgPSAwO1xyXG4gICAgICAgIC8qKiBUaGUgbGFzdCB0aW1lIHVwZGF0ZURyYXcoKSBkaWQgYSBkcmF3LiAqL1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZURyYXdMYXN0VGltZSA9IDA7XHJcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIG1vdXNlIGxhc3QgbW92ZWQgb3ZlciBhbiBvYmplY3Qgb3Igb3V0LiAqL1xyXG4gICAgICAgIHRoaXMuX2xhc3RIb3ZlckFjdGlvbiA9IE1PVVNFT1VUO1xyXG4gICAgICAgIC8qKiBOYW1lIG9mIG9iamVjdCB0aGF0IHdhcyBsYXN0IGhvdmVyZWQgb3Zlci4gKi9cclxuICAgICAgICB0aGlzLl9sYXN0SG92ZXJlZEhhc2ggPSAnJztcclxuICAgICAgICAvKiogSWYgdGhlIHZpc3VhbGl6ZXIgYXV0b21hdGljYWxseSBzaG91bGQgcmUtcmVzb2x2ZSB0aGUgdGltZWxpbmUgd2hlbiBuYXZpZ2F0aW5nIHRoZSB2aWV3cG9ydCAqL1xyXG4gICAgICAgIHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUF1dG8gPSBmYWxzZTtcclxuICAgICAgICAvKiogQXQgd2hhdCB0aW1lIHRoZSB0aW1lbGluZSB3YXMgcmVzb2x2ZWQgW3RpbWVdICovXHJcbiAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlU3RhcnQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUVuZCA9IDA7XHJcbiAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlWm9vbSA9IDE7XHJcbiAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlQ291bnQgPSAxMDA7XHJcbiAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlQ291bnRBZGp1c3QgPSAxO1xyXG4gICAgICAgIC8qKiBIb3cgbXVjaCBleHRyYSAob3V0c2lkZSB0aGUgY3VycmVudCB2aWV3cG9ydCkgdGhlIHRpbWVsaW5lIHNob3VsZCBiZSByZXNvbHZlZCB0byBbcmF0aW9dICovXHJcbiAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlRXhwYW5kID0gMztcclxuICAgICAgICB0aGlzLmxhdGVzdFVwZGF0ZVRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMucmVyZXNvbHZlVGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbWVyZ2VJdGVyYXRvciA9IDA7XHJcbiAgICAgICAgLy8gSW5pdGlhbGlzZSBvdGhlciB2YWx1ZXMuXHJcbiAgICAgICAgdGhpcy5fY2FudmFzSWQgPSBjYW52YXNJZDtcclxuICAgICAgICB0aGlzLmluaXRDYW52YXMoKTtcclxuICAgICAgICB0aGlzLl9kcmF3UGxheWhlYWQgPSAhIW9wdGlvbnMuZHJhd1BsYXloZWFkO1xyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB3aWR0aCBvZiBsYWJlbCBjb2x1bW4uXHJcbiAgICAgICAgdGhpcy5fbGF5ZXJMYWJlbFdpZHRoID0gdGhpcy5fY2FudmFzV2lkdGggKiB0aGlzLl9sYXllckxhYmVsV2lkdGhQcm9wb3J0aW9uT2ZDYW52YXM7XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRpbWVsaW5lIHdpZHRoIGFuZCBzdGFydCBwb2ludC5cclxuICAgICAgICB0aGlzLl92aWV3RHJhd1ggPSB0aGlzLl9sYXllckxhYmVsV2lkdGg7XHJcbiAgICAgICAgdGhpcy5fdmlld0RyYXdXaWR0aCA9IHRoaXMuX2NhbnZhc1dpZHRoIC0gdGhpcy5fbGF5ZXJMYWJlbFdpZHRoO1xyXG4gICAgICAgIC8vIERyYXcgYmFja2dyb3VuZC5cclxuICAgICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XHJcbiAgICAgICAgLy8gRHJhdyBwbGF5aGVhZC5cclxuICAgICAgICB0aGlzLmRyYXdQbGF5aGVhZCgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRHJhdygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXNlcyB0aGUgY2FudmFzIGFuZCByZWdpc3RlcnMgY2FudmFzIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgaW5pdENhbnZhcygpIHtcclxuICAgICAgICAvLyBDcmVhdGUgbmV3IGNhbnZhcyBvYmplY3QuXHJcbiAgICAgICAgdGhpcy5fY2FudmFzQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fY2FudmFzSWQpO1xyXG4gICAgICAgIGlmICghdGhpcy5fY2FudmFzQ29udGFpbmVyKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbnZhcyBcIiR7dGhpcy5fY2FudmFzSWR9XCIgbm90IGZvdW5kYCk7XHJcbiAgICAgICAgLy8gR2V0IHJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IHRoaXMuX2NhbnZhc0NvbnRhaW5lci5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIC8vIFJlZ2lzdGVyIGNhbnZhcyBpbnRlcmFjdGlvbiBldmVudCBoYW5kbGVycy5cclxuICAgICAgICB0aGlzLl9jYW52YXNDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGV2ZW50KSA9PiB0aGlzLmNhbnZhc01vdXNlRG93bihldmVudCkpO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhc0NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKGV2ZW50KSA9PiB0aGlzLmNhbnZhc01vdXNlVXAoZXZlbnQpKTtcclxuICAgICAgICB0aGlzLl9jYW52YXNDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGV2ZW50KSA9PiB0aGlzLmNhbnZhc01vdXNlTW92ZShldmVudCkpO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhc0NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIChldmVudCkgPT4gdGhpcy5jYW52YXNTY3JvbGxXaGVlbChldmVudCkpO1xyXG4gICAgICAgIC8vIEdldCB3aWR0aCBhbmQgaGVpZ2h0IG9mIGNhbnZhcy5cclxuICAgICAgICB0aGlzLl9jYW52YXNXaWR0aCA9IHRoaXMuX2NhbnZhc0NvbnRhaW5lci53aWR0aDtcclxuICAgICAgICB0aGlzLl9jYW52YXNIZWlnaHQgPSB0aGlzLl9jYW52YXNDb250YWluZXIuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB0aW1lbGluZSwgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIGFjdGlvbnMgYXJlIGFkZGVkL3JlbW92ZWQgZnJvbSBhIHRpbWVsaW5lXHJcbiAgICAgKiBidXQgdGhlIHNhbWUgdGltZWxpbmUgaXMgYmVpbmcgZHJhd24uXHJcbiAgICAgKiBAcGFyYW0ge1RpbWVsaW5lT2JqZWN0W119IHRpbWVsaW5lIFRpbWVsaW5lIHRvIGRyYXcuXHJcbiAgICAgKiBAcGFyYW0ge1Jlc29sdmVPcHRpb25zfSBvcHRpb25zIFJlc29sdmUgb3B0aW9ucy5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlVGltZWxpbmUodGltZWxpbmUsIG9wdGlvbnMpIHtcclxuICAgICAgICAvLyBJZiBvcHRpb25zIGhhdmUgbm90IGJlZW4gc3BlY2lmaWVkIHNldCB0aW1lIHRvIDAuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgdGltZTogMCxcclxuICAgICAgICAgICAgICAgIGxpbWl0Q291bnQ6IDEwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGF0ZXN0VGltZWxpbmUgPSB0aW1lbGluZTtcclxuICAgICAgICB0aGlzLmxhdGVzdE9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIGlmICghb3B0aW9ucy5saW1pdFRpbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlQXV0byA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lbGluZVJlc29sdmVBdXRvID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMyID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUF1dG8pIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVUaW1lbGluZVJlc29sdmVXaW5kb3coKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkU3RhdGVzID09PSB1bmRlZmluZWQpIHsgLy8gSWYgZmlyc3QgdGltZSB0aGlzIHJ1bnNcclxuICAgICAgICAgICAgLy8gU2V0IHRpbWVsaW5lIHN0YXJ0IGFuZCBlbmQgdGltZXMuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zMi50aW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdTdGFydFRpbWUgPSBvcHRpb25zMi50aW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE1vdmUgcGxheWhlYWQgdG8gc3RhcnQgdGltZS5cclxuICAgICAgICAgICAgdGhpcy5fcGxheUhlYWRUaW1lID0gdGhpcy5fdmlld1N0YXJ0VGltZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlVGltZWxpbmUodHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlVGltZWxpbmUoZnJvbU5ld1RpbWVsaW5lID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zMiA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMubGF0ZXN0T3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUF1dG8pIHtcclxuICAgICAgICAgICAgb3B0aW9uczIudGltZSA9IHRoaXMuX3RpbWVsaW5lUmVzb2x2ZVN0YXJ0O1xyXG4gICAgICAgICAgICBvcHRpb25zMi5saW1pdFRpbWUgPSB0aGlzLl90aW1lbGluZVJlc29sdmVFbmQ7XHJcbiAgICAgICAgICAgIG9wdGlvbnMyLmxpbWl0Q291bnQgPSBNYXRoLmNlaWwodGhpcy5fdGltZWxpbmVSZXNvbHZlQ291bnQgKiB0aGlzLl90aW1lbGluZVJlc29sdmVDb3VudEFkanVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZSBwbGF5aGVhZCBpcyBiZWluZyBkcmF3biwgdGhlIHJlc29sdmUgdGltZSBzaG91bGQgYmUgYXQgdGhlIHBsYXloZWFkIHRpbWUuXHJcbiAgICAgICAgaWYgKHRoaXMuX2RyYXdQbGF5aGVhZCAmJiB0aGlzLl9wbGF5SGVhZFRpbWUgPiBvcHRpb25zMi50aW1lKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMyLnRpbWUgPSB0aGlzLl9wbGF5SGVhZFRpbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlc29sdmUgdGhlIHRpbWVsaW5lLlxyXG4gICAgICAgIGNvbnN0IHN0YXJ0UmVzb2x2ZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRUaW1lbGluZSA9IHN1cGVyZmx5X3RpbWVsaW5lXzEuUmVzb2x2ZXIucmVzb2x2ZVRpbWVsaW5lKHRoaXMubGF0ZXN0VGltZWxpbmUsIG9wdGlvbnMyKTtcclxuICAgICAgICBsZXQgbmV3UmVzb2x2ZWRTdGF0ZXMgPSBzdXBlcmZseV90aW1lbGluZV8xLlJlc29sdmVyLnJlc29sdmVBbGxTdGF0ZXMocmVzb2x2ZWRUaW1lbGluZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkU3RhdGVzID09PSB1bmRlZmluZWQpIHsgLy8gSWYgZmlyc3QgdGltZSB0aGlzIHJ1bnNcclxuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWRTdGF0ZXMgPSBuZXdSZXNvbHZlZFN0YXRlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3UGxheWhlYWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRyaW0gdGhlIGN1cnJlbnQgdGltZWxpbmU6XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3UmVzb2x2ZWRTdGF0ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNZXJnZSB0aGUgdGltZWxpbmVzLlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVkU3RhdGVzID0gdGhpcy5tZXJnZVRpbWVsaW5lT2JqZWN0cyh0aGlzLl9yZXNvbHZlZFN0YXRlcywgbmV3UmVzb2x2ZWRTdGF0ZXMsIGZyb21OZXdUaW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2Ugb25seSBzZWUgb25lIHRpbWVsaW5lIGF0IGEgdGltZS5cclxuICAgICAgICAgICAgICAgIC8vIE92ZXJ3cml0ZSB0aGUgcHJldmlvdXMgdGltZWxpbmU6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlZFN0YXRlcyA9IG5ld1Jlc29sdmVkU3RhdGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBsYXllcnMuXHJcbiAgICAgICAgdGhpcy51cGRhdGVMYXllckxhYmVscygpO1xyXG4gICAgICAgIHRoaXMubGF0ZXN0VXBkYXRlVGltZSA9IERhdGUubm93KCkgLSBzdGFydFJlc29sdmU7XHJcbiAgICAgICAgLy8gUmVkcmF3IHRoZSB0aW1lbGluZS5cclxuICAgICAgICB0aGlzLnJlZHJhd1RpbWVsaW5lKCk7XHJcbiAgICAgICAgdGhpcy5sYXRlc3RVcGRhdGVUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0UmVzb2x2ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmlld3BvcnQgdG8gYSBwb3NpdGlvbiwgem9vbSwgYW5kIHBsYXliYWNrIHNwZWVkLlxyXG4gICAgICogUGxheWJhY2sgc3BlZWQgY3VycmVudGx5IG5vdCBpbXBsZW1lbnRlZC5cclxuICAgICAqIEBwYXJhbSB2aWV3UG9ydCBPYmplY3QgdG8gdXBkYXRlIHZpZXdwb3J0IHdpdGguXHJcbiAgICAgKi9cclxuICAgIHNldFZpZXdQb3J0KHZpZXdQb3J0KSB7XHJcbiAgICAgICAgLy8gV2hldGhlciB0aGUgdmlld3BvcnQgaGFzIGNoYW5nZWQuXHJcbiAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICAvLyBJZiB6b29tIGhhcyBiZWVuIHNwZWNpZmllZC5cclxuICAgICAgICBpZiAodmlld1BvcnQuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIFpvb20gdG8gc3BlY2lmaWVkIHpvb20uXHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lWm9vbSA9IHZpZXdQb3J0Lnpvb207XHJcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aW1lc3RhbXAgaGFzIGJlZW4gc3BlY2lmaWVkLlxyXG4gICAgICAgIGlmICh2aWV3UG9ydC50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBTZXQgc3RhcnQgdGltZSB0byBzcGVjaWZpZWQgdGltZS5cclxuICAgICAgICAgICAgaWYgKHZpZXdQb3J0LnRpbWVzdGFtcCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdTdGFydFRpbWUgPSB2aWV3UG9ydC50aW1lc3RhbXA7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmlld1BvcnQucGxheVZpZXdQb3J0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGxheVZpZXdQb3J0ID0gdmlld1BvcnQucGxheVZpZXdQb3J0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGUgcGxheWJhY2sgc3BlZWQgaGFzIGJlZW4gc2V0LCBzZXQgdGhlIG5ldyBwbGF5YmFjayBzcGVlZC5cclxuICAgICAgICBpZiAodmlld1BvcnQucGxheVNwZWVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kcmF3UGxheWhlYWQpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFZpZXdQb3J0OiB2aWV3UG9ydC5wbGF5U3BlZWQgd2FzIHNldCwgYnV0IGRyYXdQbGF5aGVhZCB3YXMgbm90IHNldCBpbiBjb25zdHJ1Y3RvcicpO1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5U3BlZWQgPSB2aWV3UG9ydC5wbGF5U3BlZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNldCBwbGF5aGVhZCBwbGF5aW5nLyBub3QgcGxheWluZy5cclxuICAgICAgICBpZiAodmlld1BvcnQucGxheVBsYXloZWFkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kcmF3UGxheWhlYWQpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFZpZXdQb3J0OiB2aWV3UG9ydC5wbGF5UGxheWhlYWQgd2FzIHNldCwgYnV0IGRyYXdQbGF5aGVhZCB3YXMgbm90IHNldCBpbiBjb25zdHJ1Y3RvcicpO1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5SGVhZFBsYXlpbmcgPSB2aWV3UG9ydC5wbGF5UGxheWhlYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2aWV3UG9ydC5wbGF5aGVhZFRpbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RyYXdQbGF5aGVhZClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0Vmlld1BvcnQ6IHZpZXdQb3J0LnBsYXloZWFkVGltZSB3YXMgc2V0LCBidXQgZHJhd1BsYXloZWFkIHdhcyBub3Qgc2V0IGluIGNvbnN0cnVjdG9yJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlIZWFkVGltZSA9IE1hdGgubWF4KDAsIHZpZXdQb3J0LnBsYXloZWFkVGltZSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9wbGF5SGVhZFRpbWUgPiAwKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRHJhd0xhc3RUaW1lID0gdGhpcy5fcGxheUhlYWRUaW1lO1xyXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVkcmF3IHRpbWVsaW5lIGlmIGFueXRoaW5nIGhhcyBjaGFuZ2VkLlxyXG4gICAgICAgIGlmIChjaGFuZ2VkID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVkcmF3VGltZWxpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFjY2Vzc29yIGZvciBwb2xsaW5nIHRoZSBjdXJyZW50bHkgaG92ZXJlZCBvdmVyIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgZ2V0SG92ZXJlZE9iamVjdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faG92ZXJlZE92ZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGhlaWdodCB0byBnaXZlIHRvIGVhY2ggcm93IHRvIGZpdCBhbGwgbGF5ZXJzIG9uIHNjcmVlbi5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGxheWVycyBNYXAgb2YgbGF5ZXJzIHRvIHVzZS5cclxuICAgICAqIEByZXR1cm5zIEhlaWdodCBvZiByb3dzLlxyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGVSb3dIZWlnaHQobGF5ZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1BWF9MQVlFUl9IRUlHSFQsIHRoaXMuX2NhbnZhc0hlaWdodCAvIE9iamVjdC5rZXlzKGxheWVycykubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUxheWVyTGFiZWxzKCkge1xyXG4gICAgICAgIC8vIFN0b3JlIGxheWVycyB0byBkcmF3LlxyXG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLmdldExheWVyc1RvRHJhdygpO1xyXG4gICAgICAgIGlmICghaXNFcXVhbCh0aGlzLl9sYXllckxhYmVscywgby5sYXllcnMpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyTGFiZWxzID0gby5sYXllcnM7XHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSByb3cgaGVpZ2h0LlxyXG4gICAgICAgICAgICB0aGlzLl9yb3dIZWlnaHQgPSB0aGlzLmNhbGN1bGF0ZVJvd0hlaWdodCh0aGlzLl9sYXllckxhYmVscyk7XHJcbiAgICAgICAgICAgIC8vIFNldCB0aW1lbGluZSBvYmplY3QgaGVpZ2h0LlxyXG4gICAgICAgICAgICB0aGlzLl90aW1lbGluZU9iamVjdEhlaWdodCA9IHRoaXMuX3Jvd0hlaWdodCAqIFRJTUVMSU5FX09CSkVDVF9IRUlHSFQ7XHJcbiAgICAgICAgICAgIHRoaXMuX251bWJlck9mTGF5ZXJzID0gT2JqZWN0LmtleXModGhpcy5fbGF5ZXJMYWJlbHMpLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5fcm93c1RvdGFsSGVpZ2h0ID0gdGhpcy5fcm93SGVpZ2h0ICogdGhpcy5fbnVtYmVyT2ZMYXllcnM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0TGF5ZXJzKCkge1xyXG4gICAgICAgIGNvbnN0IGxheWVycyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuX2xheWVyTGFiZWxzKTtcclxuICAgICAgICBsYXllcnMuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pO1xyXG4gICAgICAgIHJldHVybiBsYXllcnMubWFwKGwgPT4gbFswXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIHRoZSBsYXllciBsYWJlbHMgdG8gdGhlIGNhbnZhcy5cclxuICAgICAqL1xyXG4gICAgZHJhd0xheWVyTGFiZWxzKCkge1xyXG4gICAgICAgIGxldCByb3cgPSAwO1xyXG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBsYXllcnMuXHJcbiAgICAgICAgZm9yIChsZXQgbGF5ZXJOYW1lIG9mIHRoaXMuZ2V0TGF5ZXJzKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxTdHlsZSA9IENPTE9SX0xBQkVMX0JBQ0tHUk9VTkQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsUmVjdCgwLCByb3cgKiB0aGlzLl9yb3dIZWlnaHQsIHRoaXMuX2xheWVyTGFiZWxXaWR0aCwgdGhpcy5fcm93SGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxTdHlsZSA9IFRFWFRfQ09MT1I7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5mb250ID0gVEVYVF9GT05UX1NJWkUudG9TdHJpbmcoKSArICdweCAnICsgVEVYVF9GT05UX0ZBTUlMWTtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuZmlsbFRleHQobGF5ZXJOYW1lLCAwLCAocm93ICogdGhpcy5fcm93SGVpZ2h0KSArICh0aGlzLl9yb3dIZWlnaHQgLyAyKSwgdGhpcy5fbGF5ZXJMYWJlbFdpZHRoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVyTGFiZWxzW2xheWVyTmFtZV0gIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsU3R5bGUgPSBDT0xPUl9MSU5FO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxSZWN0KHRoaXMuX2xheWVyTGFiZWxXaWR0aCwgcm93ICogdGhpcy5fcm93SGVpZ2h0LCB0aGlzLl92aWV3RHJhd1dpZHRoLCBUSElDS05FU1NfTElORSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcm93Kys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgdGltZWxpbmUgYmFja2dyb3VuZC5cclxuICAgICAqL1xyXG4gICAgZHJhd0JhY2tncm91bmQoKSB7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxTdHlsZSA9IENPTE9SX0JBQ0tHUk9VTkQ7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxSZWN0KDAsIDAsIHRoaXMuX2NhbnZhc1dpZHRoLCB0aGlzLl9jYW52YXNIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuZHJhd0JhY2tncm91bmRSdWxlcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgcnVsZXIgb24gdG9wIG9mIGJhY2tncm91bmRcclxuICAgICAqL1xyXG4gICAgZHJhd0JhY2tncm91bmRSdWxlcigpIHtcclxuICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMudmlld1JhbmdlO1xyXG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSB0aGlzLnZpZXdFbmRUaW1lO1xyXG4gICAgICAgIGNvbnN0IGNpcmNhTnVtYmVyT2ZMaW5lcyA9IDU7XHJcbiAgICAgICAgY29uc3Qgcm91bmRlciA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nMTAocmFuZ2UgLyBjaXJjYU51bWJlck9mTGluZXMpKSk7IC8vIFdoYXQgdG8gcm91bmQgdGhlIHJ1bGVyIHRvXHJcbiAgICAgICAgY29uc3Qgcm91bmRlck5leHQgPSByb3VuZGVyICogMTA7XHJcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZMaW5lcyA9IE1hdGguZmxvb3IocmFuZ2UgLyByb3VuZGVyKTtcclxuICAgICAgICBjb25zdCBydWxlckRpZmYgPSByb3VuZGVyO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IE1hdGguZmxvb3IodGhpcy5fdmlld1N0YXJ0VGltZSAvIHJvdW5kZXIpICogcm91bmRlcjtcclxuICAgICAgICBjb25zdCBvcGFjaXR5ID0gKE1hdGgubWluKDEsIGNpcmNhTnVtYmVyT2ZMaW5lcyAvIG51bWJlck9mTGluZXMpKTtcclxuICAgICAgICBpZiAocnVsZXJEaWZmKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHJva2VTdHlsZSA9IFJVTEVSX0xJTkVfQ09MT1I7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5saW5lV2lkdGggPSBSVUxFUl9MSU5FX1dJRFRIO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBydWxlclRpbWUgPSBzdGFydFRpbWU7IHJ1bGVyVGltZSA8IGVuZFRpbWU7IHJ1bGVyVGltZSArPSBydWxlckRpZmYpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGxldCB4ID0gdGhpcy50aW1lVG9YQ29vcmQocnVsZXJUaW1lKTtcclxuICAgICAgICAgICAgICAgIGxldCBkaXN0YW5jZVRvTmV4dCA9IChydWxlclRpbWUgLyByb3VuZGVyTmV4dCkgJSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlVG9OZXh0ID4gMC41KVxyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlVG9OZXh0IC09IDE7XHJcbiAgICAgICAgICAgICAgICBkaXN0YW5jZVRvTmV4dCA9IE1hdGguYWJzKGRpc3RhbmNlVG9OZXh0KTtcclxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZVRvTmV4dCA8IDAuMDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJcyBhIHNpZ25pZmljYW50IGxpbmVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuZ2xvYmFsQWxwaGEgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLmdsb2JhbEFscGhhID0gb3BhY2l0eTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh4ID49IHRoaXMuX3ZpZXdEcmF3WCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5tb3ZlVG8oeCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLmxpbmVUbyh4LCB0aGlzLl9jYW52YXNIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0cm9rZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5nbG9iYWxBbHBoYSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgcGxheWhlYWQgaW5pdGlhbGx5LlxyXG4gICAgICovXHJcbiAgICBkcmF3UGxheWhlYWQoKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIHBsYXloZWFkIHNob3VsZCBiZSBkcmF3LlxyXG4gICAgICAgIGlmICh0aGlzLl9kcmF3UGxheWhlYWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXN0aW1lSW5WaWV3KHRoaXMuX3BsYXlIZWFkVGltZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsU3R5bGUgPSBDT0xPUl9QTEFZSEVBRDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsUmVjdCh0aGlzLnRpbWVUb1hDb29yZCh0aGlzLl9wbGF5SGVhZFRpbWUpLCAwLCBUSElDS05FU1NfUExBWUhFQUQsIHRoaXMuX2NhbnZhc0hlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGxheWVycyB0byBkcmF3IGZyb20gdGhlIHRpbWVsaW5lLlxyXG4gICAgICovXHJcbiAgICBnZXRMYXllcnNUb0RyYXcoKSB7XHJcbiAgICAgICAgdGhpcy5faG92ZXJlZE9iamVjdE1hcCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGxheWVyc0FycmF5ID0gdGhpcy5fcmVzb2x2ZWRTdGF0ZXMgPyBPYmplY3Qua2V5cyh0aGlzLl9yZXNvbHZlZFN0YXRlcy5sYXllcnMpIDogW107XHJcbiAgICAgICAgbGF5ZXJzQXJyYXkuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYSA+IGIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgaWYgKGEgPCBiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGxheWVycyA9IHt9O1xyXG4gICAgICAgIGxheWVyc0FycmF5LmZvckVhY2goKGxheWVyTmFtZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgbGF5ZXJzW2xheWVyTmFtZV0gPSBpbmRleDtcclxuICAgICAgICAgICAgdGhpcy5faG92ZXJlZE9iamVjdE1hcFtsYXllck5hbWVdID0gW107XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbGF5ZXJzOiBsYXllcnMsXHJcbiAgICAgICAgICAgIGxheWVyc0FycmF5OiBsYXllcnNBcnJheVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZHJhd3MgdGhlIHRpbWVsaW5lIHRvIHRoZSBjYW52YXMuXHJcbiAgICAgKi9cclxuICAgIHJlZHJhd1RpbWVsaW5lKCkge1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY2FudmFzV2lkdGgsIHRoaXMuX2NhbnZhc0hlaWdodCk7XHJcbiAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xyXG4gICAgICAgIHRoaXMuZHJhd0xheWVyTGFiZWxzKCk7XHJcbiAgICAgICAgLy8gUmVjb21wdXRlIG9iamVjdHMgcG9zaXRpb25zXHJcbiAgICAgICAgdGhpcy5fdGltZWxpbmVTdGF0ZSA9IHRoaXMuZ2V0VGltZWxpbmVEcmF3U3RhdGUodGhpcy5fcmVzb2x2ZWRTdGF0ZXMpO1xyXG4gICAgICAgIC8vIERyYXcgdGhlIGN1cnJlbnQgc3RhdGUuXHJcbiAgICAgICAgdGhpcy5kcmF3VGltZWxpbmVTdGF0ZSh0aGlzLl90aW1lbGluZVN0YXRlKTtcclxuICAgICAgICB0aGlzLmRyYXdQbGF5aGVhZCgpO1xyXG4gICAgICAgIHRoaXMuY2hlY2tBdXRvbWF0aWNSZXJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYSB0aW1lbGluZSBzdGF0ZSB0byB0aGUgY2FudmFzLlxyXG4gICAgICogQHBhcmFtIHtUaW1lbGluZURyYXdTdGF0ZX0gY3VycmVudERyYXdTdGF0ZSBTdGF0ZSB0byBkcmF3LlxyXG4gICAgICovXHJcbiAgICBkcmF3VGltZWxpbmVTdGF0ZShjdXJyZW50RHJhd1N0YXRlKSB7XHJcbiAgICAgICAgZm9yIChsZXQgZWxlbWVudCBpbiBjdXJyZW50RHJhd1N0YXRlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRyYXdTdGF0ZSA9IGN1cnJlbnREcmF3U3RhdGVbZWxlbWVudF07XHJcbiAgICAgICAgICAgIGlmIChkcmF3U3RhdGUudmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxTdHlsZSA9IENPTE9SX1RJTUVMSU5FX09CSkVDVF9GSUxMO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxSZWN0KGRyYXdTdGF0ZS5sZWZ0LCBkcmF3U3RhdGUudG9wLCBkcmF3U3RhdGUud2lkdGgsIGRyYXdTdGF0ZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0cm9rZVN0eWxlID0gQ09MT1JfVElNRUxJTkVfT0JKRUNUX0JPUkRFUjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5saW5lV2lkdGggPSBUSElDS05FU1NfVElNRUxJTkVfT0JKRUNUX0JPUkRFUjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHJva2VSZWN0KGRyYXdTdGF0ZS5sZWZ0LCBkcmF3U3RhdGUudG9wLCBkcmF3U3RhdGUud2lkdGgsIGRyYXdTdGF0ZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxTdHlsZSA9IFRFWFRfQ09MT1I7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuZm9udCA9IFRFWFRfRk9OVF9TSVpFLnRvU3RyaW5nKCkgKyAncHggJyArIFRFWFRfRk9OVF9GQU1JTFk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMudGV4dEJhc2VsaW5lID0gJ3RvcCc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuZmlsbFRleHQoZHJhd1N0YXRlLnRpdGxlLCBkcmF3U3RhdGUubGVmdCwgZHJhd1N0YXRlLnRvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRyYXcgc3RhdGVzIGZvciBhbGwgdGltZWxpbmUgb2JqZWN0cy5cclxuICAgICAqIEBwYXJhbSB7UmVzb2x2ZWRTdGF0ZXN9IHRpbWVsaW5lIFRpbWVsaW5lIHRvIGRyYXcuXHJcbiAgICAgKiBAcmV0dXJucyB7VGltZWxpbmVEcmF3U3RhdGV9IFN0YXRlIG9mIHRpbWUtYmFzZWQgb2JqZWN0cy5cclxuICAgICAqL1xyXG4gICAgZ2V0VGltZWxpbmVEcmF3U3RhdGUodGltZWxpbmUpIHtcclxuICAgICAgICBsZXQgY3VycmVudERyYXdTdGF0ZSA9IHt9O1xyXG4gICAgICAgIGlmICh0aW1lbGluZSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBvYmpJZCBpbiB0aW1lbGluZS5vYmplY3RzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGltZWxpbmVPYmogPSB0aW1lbGluZS5vYmplY3RzW29iaklkXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IF9pID0gMDsgX2kgPCB0aW1lbGluZU9iai5yZXNvbHZlZC5pbnN0YW5jZXMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluc3RhbmNlT2JqID0gdGltZWxpbmVPYmoucmVzb2x2ZWQuaW5zdGFuY2VzW19pXTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9ICd0aW1lbGluZU9iamVjdDonICsgb2JqSWQgKyAnOicgKyBpbnN0YW5jZU9iai5pZDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHJhd1N0YXRlW25hbWVdID0gdGhpcy5jcmVhdGVTdGF0ZUZvck9iamVjdCh0aW1lbGluZU9iaiwgaW5zdGFuY2VPYmouc3RhcnQsIGluc3RhbmNlT2JqLmVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnREcmF3U3RhdGVbbmFtZV0udmlzaWJsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2hvdmVyZWRPYmplY3RNYXBbdGltZWxpbmVPYmoubGF5ZXIgKyAnJ10pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ob3ZlcmVkT2JqZWN0TWFwW3RpbWVsaW5lT2JqLmxheWVyICsgJyddID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hvdmVyZWRPYmplY3RNYXBbdGltZWxpbmVPYmoubGF5ZXIgKyAnJ10ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFg6IGN1cnJlbnREcmF3U3RhdGVbbmFtZV0ubGVmdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFg6IGN1cnJlbnREcmF3U3RhdGVbbmFtZV0ubGVmdCArIGN1cnJlbnREcmF3U3RhdGVbbmFtZV0ud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RSZWZJZDogb2JqSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkOiBpbnN0YW5jZU9iai5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0aW1lbGluZU9iamVjdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VycmVudERyYXdTdGF0ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGRyYXcgc3RhdGUgZm9yIGEgdGltZWxpbmUgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyIE9iamVjdCdzIGxheWVyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IHRpbWUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCB0aW1lLlxyXG4gICAgICogQHJldHVybnMge0RyYXdTdGF0ZX0gU3RhdGUgb2YgdGhlIG9iamVjdCB0byBkcmF3LlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVTdGF0ZUZvck9iamVjdChvYmosIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAvLyBEZWZhdWx0IHN0YXRlIChoaWRkZW4pLlxyXG4gICAgICAgIGxldCBzdGF0ZSA9IHtcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxyXG4gICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgdGl0bGU6ICdOL0EnXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBTdGF0ZSBzaG91bGQgYmUgZGVmYXVsdCBpZiB0aGUgb2JqZWN0IGlzIG5vdCBiZWluZyBzaG93bi5cclxuICAgICAgICBpZiAodGhpcy5zaG93T25UaW1lbGluZShzdGFydCwgZW5kKSkge1xyXG4gICAgICAgICAgICAvLyBHZXQgb2JqZWN0IGRpbWVuc2lvbnMgYW5kIHBvc2l0aW9uLlxyXG4gICAgICAgICAgICBsZXQgb2JqZWN0V2lkdGggPSB0aGlzLmdldE9iamVjdFdpZHRoKHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgICAgICBsZXQgeENvb3JkID0gdGhpcy5jYXBYY29vcmRUb1ZpZXcodGhpcy50aW1lVG9YQ29vcmQoc3RhcnQpKTtcclxuICAgICAgICAgICAgbGV0IG9iamVjdFRvcCA9IHRoaXMuZ2V0T2JqZWN0T2Zmc2V0RnJvbVRvcChvYmoubGF5ZXIgKyAnJyk7XHJcbiAgICAgICAgICAgIC8vIFNldCBzdGF0ZSBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICBzdGF0ZS5oZWlnaHQgPSB0aGlzLl90aW1lbGluZU9iamVjdEhlaWdodDtcclxuICAgICAgICAgICAgc3RhdGUubGVmdCA9IHhDb29yZDtcclxuICAgICAgICAgICAgc3RhdGUudG9wID0gb2JqZWN0VG9wO1xyXG4gICAgICAgICAgICBzdGF0ZS53aWR0aCA9IG9iamVjdFdpZHRoO1xyXG4gICAgICAgICAgICBzdGF0ZS52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgc3RhdGUudGl0bGUgPSBvYmouaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgb2Zmc2V0LCBpbiBwaXhlbHMgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHRpbWVsaW5lIGZvciBhbiBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgc3RhcnQgdGltZSBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gT2Zmc2V0IGluIHBpeGVscy5cclxuICAgICAqL1xyXG4gICAgLy8gcHJpdmF0ZSBnZXRPYmplY3RPZmZzZXRGcm9tVGltZWxpbmVTdGFydCAoc3RhcnQ6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAvLyBcdC8vIENhbGN1bGF0ZSBvZmZzZXQuXHJcbiAgICAvLyBcdGxldCBvZmZzZXQgPSAoc3RhcnQgLSB0aGlzLl92aWV3U3RhcnRUaW1lKSAqIHRoaXMucGl4ZWxzV2lkdGhQZXJVbml0VGltZVxyXG4gICAgLy8gXHQvLyBPZmZzZXQgY2Fubm90IGJlIHRvIHRoZSBsZWZ0IG9mIHRoZSB0aW1lbGluZSBzdGFydCBwb3NpdGlvbi5cclxuICAgIC8vIFx0aWYgKG9mZnNldCA8IDApIHtcclxuICAgIC8vIFx0XHRvZmZzZXQgPSAwXHJcbiAgICAvLyBcdH1cclxuICAgIC8vIFx0cmV0dXJuIG9mZnNldFxyXG4gICAgLy8gfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB3aWR0aCwgaW4gcGl4ZWxzLCBvZiBhbiBvYmplY3QgYmFzZWQgb24gaXRzIGR1cmF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IHRpbWUgb2YgdGhlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kIHRpbWUgb2YgdGhlIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFdpZHRoIGluIHBpeGVscy5cclxuICAgICAqL1xyXG4gICAgZ2V0T2JqZWN0V2lkdGgoc3RhcnRUaW1lLCBlbmRUaW1lKSB7XHJcbiAgICAgICAgaWYgKCFlbmRUaW1lKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzV2lkdGg7XHJcbiAgICAgICAgLy8gSWYgdGhlIHN0YXJ0IHRpbWUgaXMgbGVzcyB0aGFuIHRoZSB0aW1lbGluZSBzdGFydCwgc2V0IHRvIHRpbWVsaW5lIHN0YXJ0LlxyXG4gICAgICAgIGlmIChzdGFydFRpbWUgPCB0aGlzLl92aWV3U3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0VGltZSA9IHRoaXMuX3ZpZXdTdGFydFRpbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBkdXJhdGlvbiBvZiB0aGUgb2JqZWN0IHJlbWFpbmluZyBvbiB0aGUgdGltZWxpbmUuXHJcbiAgICAgICAgbGV0IGR1cmF0aW9uID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcclxuICAgICAgICAvLyBSZXR1cm4gZW5kIHBvaW50IHBvc2l0aW9uIGluIHBpeGVscy5cclxuICAgICAgICByZXR1cm4gZHVyYXRpb24gKiB0aGlzLnBpeGVsc1dpZHRoUGVyVW5pdFRpbWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0byBzaG93IGFuIG9iamVjdCBvbiB0aGUgdGltZWxpbmUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgT2JqZWN0IHN0YXJ0IHRpbWUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIE9iamVjdCBlbmQgdGltZS5cclxuICAgICAqIEByZXR1cm5zIHt0cnVlfSBpZiBvYmplY3Qgc2hvdWxkIGJlIHNob3duIG9uIHRoZSB0aW1lbGluZS5cclxuICAgICAqL1xyXG4gICAgc2hvd09uVGltZWxpbmUoc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIGxldCBpc0FmdGVyID0gc3RhcnQgPj0gdGhpcy52aWV3RW5kVGltZTtcclxuICAgICAgICBsZXQgaXNCZWZvcmUgPSAoZW5kIHx8IEluZmluaXR5KSA8PSB0aGlzLl92aWV3U3RhcnRUaW1lO1xyXG4gICAgICAgIHJldHVybiAhaXNBZnRlciAmJiAhaXNCZWZvcmU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSBwb3NpdGlvbiBvZiBvYmplY3QgaW5zdGFuY2UgZnJvbSB0b3Agb2YgdGltZWxpbmUgYWNjb3JkaW5nIHRvIGl0cyBsYXllci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciBPYmplY3QncyBsYXllci5cclxuICAgICAqIEByZXR1cm5zIFBvc2l0aW9uIHJlbGF0aXZlIHRvIHRvcCBvZiBjYW52YXMgaW4gcGl4ZWxzLlxyXG4gICAgICovXHJcbiAgICBnZXRPYmplY3RPZmZzZXRGcm9tVG9wKGxheWVyTmFtZSkge1xyXG4gICAgICAgIGxldCB0b3AgPSB0aGlzLl9sYXllckxhYmVsc1tsYXllck5hbWVdO1xyXG4gICAgICAgIHJldHVybiB0b3AgKiB0aGlzLl9yb3dIZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIHRoZSBwbGF5aGVhZC4gQ2FsbGVkIHBlcmlvZGljYWxseS5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlRHJhdygpIHtcclxuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIC8vIEhvdyBsb25nIHRpbWUgc2luY2UgbGFzdCB1cGRhdGU6XHJcbiAgICAgICAgY29uc3QgZHQgPSAodGhpcy5fdXBkYXRlRHJhd0xhc3RUaW1lID4gMCA/XHJcbiAgICAgICAgICAgIG5vdyAtIHRoaXMuX3VwZGF0ZURyYXdMYXN0VGltZSA6XHJcbiAgICAgICAgICAgIDEpIC8gMTAwMDtcclxuICAgICAgICB0aGlzLl91cGRhdGVEcmF3TGFzdFRpbWUgPSBub3c7XHJcbiAgICAgICAgY29uc3QgZGVsdGFUaW1lID0gdGhpcy5fcGxheVNwZWVkICogZHQ7XHJcbiAgICAgICAgLy8gQ2hlY2sgcGxheWhlYWQgc2hvdWxkIGJlIGRyYXduLlxyXG4gICAgICAgIGxldCBuZWVkUmVkcmF3ID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BsYXlIZWFkUGxheWluZyAmJiB0aGlzLl9kcmF3UGxheWhlYWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3BsYXlWaWV3UG9ydCAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc3RpbWVJblZpZXcodGhpcy5fcGxheUhlYWRUaW1lKSAvLyBPbmx5IHBsYXkgaWYgcGxheWhlYWQgaXMgaW4gdmlld1xyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdTdGFydFRpbWUgKz0gZGVsdGFUaW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE1vdmUgcGxheWhlYWQgZm9yd2FyZFxyXG4gICAgICAgICAgICB0aGlzLl9wbGF5SGVhZFRpbWUgKz0gZGVsdGFUaW1lO1xyXG4gICAgICAgICAgICBuZWVkUmVkcmF3ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5lZWRSZWRyYXcpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWRyYXdUaW1lbGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYWxsIHRoaXMgZnVuY3Rpb24gb24gbmV4dCBmcmFtZVxyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy51cGRhdGVEcmF3KCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIG1vdXNlIGRvd24gZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZXZlbnQgTW91c2UgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIGNhbnZhc01vdXNlRG93bihldmVudCkge1xyXG4gICAgICAgIC8vIFN0b3JlIG1vdXNlIGlzIGRvd24uXHJcbiAgICAgICAgdGhpcy5fbW91c2VEb3duID0gdHJ1ZTtcclxuICAgICAgICAvLyBTdG9yZSBYIHBvc2l0aW9uIG9mIG1vdXNlIG9uIGNsaWNrLlxyXG4gICAgICAgIHRoaXMuX21vdXNlTGFzdFggPSBldmVudC5jbGllbnRYO1xyXG4gICAgICAgIC8vIFByZXZlbnQgZXZlbnQuXHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyBtb3VzZSB1cCBldmVudC5cclxuICAgICAqIEBwYXJhbSBldmVudCBNb3VzZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgY2FudmFzTW91c2VVcChldmVudCkge1xyXG4gICAgICAgIC8vIE1vdXNlIG5vIGxvbmdlciBkb3duLlxyXG4gICAgICAgIHRoaXMuX21vdXNlRG93biA9IGZhbHNlO1xyXG4gICAgICAgIC8vIFJlc2V0IHNjcm9sbCBkaXJlY3Rpb24uXHJcbiAgICAgICAgdGhpcy5fbGFzdFNjcm9sbERpcmVjdGlvbiA9IDA7XHJcbiAgICAgICAgLy8gUHJldmVudCBldmVudC5cclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIG1vdXNlIG1vdmVtZW50IG9uIGNhbnZhcy5cclxuICAgICAqIEBwYXJhbSBldmVudCBNb3VzZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgY2FudmFzTW91c2VNb3ZlKGV2ZW50KSB7XHJcbiAgICAgICAgLy8gSWYgbW91c2UgaXMgZG93bi5cclxuICAgICAgICBpZiAodGhpcy5fbW91c2VEb3duKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBiZWdpbm5pbmcgc2Nyb2xsaW5nLCB3ZSBjYW4gbW92ZSBmcmVlbHkuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0U2Nyb2xsRGlyZWN0aW9uID09PSB1bmRlZmluZWQgfHwgdGhpcy5fbGFzdFNjcm9sbERpcmVjdGlvbiA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgY3VycmVudCBtb3VzZSBYLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VMYXN0WCA9IGV2ZW50LmNsaWVudFg7XHJcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgY2hhbmdlIGluIFguXHJcbiAgICAgICAgICAgICAgICBsZXQgZGVsdGFYID0gZXZlbnQuY2xpZW50WCAtIHRoaXMuX21vdXNlTGFzdFg7XHJcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBzY3JvbGxpbmcgZGlyZWN0aW9uLlxyXG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhWCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0U2Nyb2xsRGlyZWN0aW9uID0gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0U2Nyb2xsRGlyZWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFNjcm9sbCB0byBuZXcgWCBwb3NpdGlvbi5cclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2Nyb2xsQnlEZWx0YVgoLWRlbHRhWCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgc2Nyb2xsIGRpcmVjdGlvbi5cclxuICAgICAgICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSB0aGlzLl9tb3VzZUxhc3RYIC0gZXZlbnQuY2xpZW50WDtcclxuICAgICAgICAgICAgICAgIC8vIElmIGNoYW5naW5nIGRpcmVjdGlvbiwgc3RvcmUgbmV3IGRpcmVjdGlvbiBidXQgZG9uJ3Qgc2Nyb2xsLlxyXG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA8IDAgJiYgdGhpcy5fbGFzdFNjcm9sbERpcmVjdGlvbiA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlTGFzdFggPSBldmVudC5jbGllbnRYO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RTY3JvbGxEaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA+IDAgJiYgdGhpcy5fbGFzdFNjcm9sbERpcmVjdGlvbiA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZUxhc3RYID0gZXZlbnQuY2xpZW50WDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0U2Nyb2xsRGlyZWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBjaGFuZ2UgaW4gWC5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGVsdGFYID0gZXZlbnQuY2xpZW50WCAtIHRoaXMuX21vdXNlTGFzdFg7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgbGFzdCBYIHBvc2l0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlTGFzdFggPSBldmVudC5jbGllbnRYO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgYnkgY2hhbmdlIGluIFguXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTY3JvbGxCeURlbHRhWCgtZGVsdGFYKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZWRyYXcgdGltZWxpbmUuXHJcbiAgICAgICAgICAgIHRoaXMucmVkcmF3VGltZWxpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFdoZXRoZXIgYW4gb2JqZWN0IGlzIHVuZGVyIHRoZSBjdXJzb3IuXHJcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBvYmplY3QgdGhhdCBpcyBjdXJyZW50bHkgaG92ZXJlZCBvdmVyLlxyXG4gICAgICAgICAgICBsZXQgbW91c2VQb3MgPSB0aGlzLmdldE1vdXNlUG9zKHRoaXMuX2NhbnZhc0NvbnRhaW5lciwgZXZlbnQpO1xyXG4gICAgICAgICAgICBpZiAobW91c2VQb3MueCA+IHRoaXMuX3ZpZXdEcmF3WCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vdXNlUG9zLnkgPCB0aGlzLl9yb3dzVG90YWxIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0ZWRSb3cgPSBNYXRoLmZsb29yKChtb3VzZVBvcy55IC8gdGhpcy5fcm93c1RvdGFsSGVpZ2h0KSAqIHRoaXMuX251bWJlck9mTGF5ZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGF5ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5fbGF5ZXJMYWJlbHMpLmZvckVhY2gobGF5ZXJOYW1lID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVyTGFiZWxzW2xheWVyTmFtZV0gPT09IHNlbGVjdGVkUm93KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIgPSBsYXllck5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhvdmVyTWFwRGF0YSA9IChsYXllciA/IHRoaXMuX2hvdmVyZWRPYmplY3RNYXBbbGF5ZXJdIDogW10pIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGhvdmVyTWFwRGF0YS5mb3JFYWNoKG9iamVjdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3Quc3RhcnRYIDw9IG1vdXNlUG9zLnggJiYgb2JqZWN0LmVuZFggPj0gbW91c2VQb3MueCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaG92ZXJIYXNoID0gb2JqZWN0LnR5cGUgKyBvYmplY3Qub2JqZWN0UmVmSWQgKyBvYmplY3QuaW5zdGFuY2VJZDsgLy8gaGFzaC1pc2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0SG92ZXJlZEhhc2ggIT09IGhvdmVySGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBvYmplY3QgbWV0YWRhdGEgZnJvbSB0aGUgb2JqZWN0IG5hbWUgb2YgdGhlIGhvdmVyZWQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBob3ZlcmluZyBvdmVyIGEgdGltZWxpbmUgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3QudHlwZSA9PT0gJ3RpbWVsaW5lT2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRpbWVsaW5lIG9iamVjdCBhbmQgdGhlIGluc3RhbmNlIGJlaW5nIGhvdmVyZWQgb3Zlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkU3RhdGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGltZWxpbmVPYmplY3QgPSB0aGlzLl9yZXNvbHZlZFN0YXRlcy5vYmplY3RzW29iamVjdC5vYmplY3RSZWZJZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aW1lbGluZU9iamVjdC5yZXNvbHZlZC5pbnN0YW5jZXMuZmluZChpbnN0YW5jZSA9PiBpbnN0YW5jZS5pZCA9PT0gb2JqZWN0Lmluc3RhbmNlSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IGhvdmVyIGluZm8uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhvdmVySW5mbyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aW1lbGluZU9iamVjdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyOiB7IHhQb3N0aW9uOiBtb3VzZVBvcy54LCB5UG9zaXRpb246IG1vdXNlUG9zLnkgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGN1cnJlbnRseSBob3ZlcmVkIG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ob3ZlcmVkT3ZlciA9IGhvdmVySW5mbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbWl0IGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndGltZWxpbmU6aG92ZXInLCB7IGRldGFpbDogdGhpcy5faG92ZXJlZE92ZXIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSBsYXN0IGl0ZW1zLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdEhvdmVyQWN0aW9uID0gTU9VU0VJTjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RIb3ZlcmVkSGFzaCA9IGhvdmVySGFzaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEVtaXQgdW5kZWZpbmVkIHdoZW4gbW91c2Ugb3V0LlxyXG4gICAgICAgICAgICBpZiAoIWZvdW5kICYmIHRoaXMuX2xhc3RIb3ZlckFjdGlvbiA9PT0gTU9VU0VJTikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd0aW1lbGluZTpob3ZlcicsIHsgZGV0YWlsOiB1bmRlZmluZWQgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0SG92ZXJBY3Rpb24gPSBNT1VTRU9VVDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyBzY3JvbGwgd2hlZWwgZXZlbnRzIG9uIHRoZSBjYW52YXMuXHJcbiAgICAgKiBAcGFyYW0gZXZlbnQgU2Nyb2xsIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBjYW52YXNTY3JvbGxXaGVlbChldmVudCkge1xyXG4gICAgICAgIC8vIEdldCBtb3VzZSBwb2ludGVyIGNvb3JkaW5hdGVzIG9uIGNhbnZhcy5cclxuICAgICAgICBsZXQgY2FudmFzQ29vcmQgPSB0aGlzLmdldE1vdXNlUG9zKHRoaXMuX2NhbnZhc0NvbnRhaW5lciwgZXZlbnQpO1xyXG4gICAgICAgIC8vIERvbid0IHNjcm9sbCBpZiBtb3VzZSBpcyBub3Qgb3ZlciB0aW1lbGluZS5cclxuICAgICAgICBpZiAoY2FudmFzQ29vcmQueCA8PSB0aGlzLl92aWV3RHJhd1gpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIENUUkwgKyBzY3JvbGwgdG8gem9vbS5cclxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQuZGVsdGFZKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHpvb21GYWN0b3IgPSBNYXRoLnBvdyhaT09NX0ZBQ1RPUiwgLWV2ZW50LmRlbHRhWSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21VbmRlckN1cnNvcihjYW52YXNDb29yZC54LCB6b29tRmFjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChldmVudC5kZWx0YVggIT09IDApIHsgLy8gU2Nyb2xsIG9uIHgtYXhpc1xyXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gUGFuLlxyXG4gICAgICAgICAgICB0aGlzLmNhbnZhc1Njcm9sbEJ5RGVsdGFYKChldmVudC5kZWx0YVggKiAoUEFOX0ZBQ1RPUiAqIHRoaXMuc3RlcFNpemUpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmRlbHRhWSAhPT0gMCAmJiBldmVudC5hbHRLZXkgPT09IHRydWUpIHsgLy8gQWxzbyBzY3JvbGwgb24gYWx0LWtleSArIHNjcm9sbCB5LWF4aXNcclxuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIFBhbi5cclxuICAgICAgICAgICAgdGhpcy5jYW52YXNTY3JvbGxCeURlbHRhWCgoZXZlbnQuZGVsdGFZICogKFBBTl9GQUNUT1IgKiB0aGlzLnN0ZXBTaXplKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcmV2ZW50IGV2ZW50LlxyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgICAgICAgLy8gUmVkcmF3IHRpbWVsaW5lLlxyXG4gICAgICAgICAgICB0aGlzLnJlZHJhd1RpbWVsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTY3JvbGwgYWNyb3NzIHRoZSBjYW52YXMgYnkgYSBzcGVjaWZpZWQgWCB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVggVmFsdWUgdG8gbW92ZSBieS5cclxuICAgICAqL1xyXG4gICAgY2FudmFzU2Nyb2xsQnlEZWx0YVgoZGVsdGFYKSB7XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBzdGFydGluZyB0aW1lLlxyXG4gICAgICAgIGxldCB0YXJnZXRTdGFydCA9IHRoaXMuX3ZpZXdTdGFydFRpbWUgKyAoZGVsdGFYIC8gdGhpcy5waXhlbHNXaWR0aFBlclVuaXRUaW1lKTtcclxuICAgICAgICAvLyBTdGFydGluZyB0aW1lIGNhbm5vdCBiZSA8IDAuXHJcbiAgICAgICAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xyXG4gICAgICAgICAgICB0YXJnZXRTdGFydCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE9wdGltaXNhdGlvbiwgZG9uJ3QgcmVkcmF3IGlmIG5vdGhpbmcgaGFzIGNoYW5nZWQuXHJcbiAgICAgICAgaWYgKHRhcmdldFN0YXJ0ID09PSB0aGlzLl92aWV3U3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdmlld1N0YXJ0VGltZSA9IHRhcmdldFN0YXJ0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBab29tcyBpbnRvL291dCBvZiB0aW1lbGluZSwga2VlcGluZyB0aGUgdGltZSB1bmRlciB0aGUgY3Vyc29yIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gICAgICogQHBhcmFtIGN1cnNvclggUG9zaXRpb24gb2YgbW91c2UgY3Vyc29yLlxyXG4gICAgICovXHJcbiAgICB6b29tVW5kZXJDdXJzb3IoY3Vyc29yWCwgem9vbUZhY3Rvcikge1xyXG4gICAgICAgIC8vIFBvaW50IGluIHRpbWUgb2YgdGhlIGN1cnNvclxyXG4gICAgICAgIGxldCBjdXJzb3JUaW1lID0gdGhpcy54Q29vcmRUb1RpbWUoY3Vyc29yWCk7XHJcbiAgICAgICAgLy8gUmF0aW8gKGluIHZpZXcgcmFuZ2UpIG9mIHRoZSBjdXJzb3JcclxuICAgICAgICBsZXQgY3Vyc29yUmF0aW8gPSB0aGlzLnRpbWVUb1JhdGlvKGN1cnNvclRpbWUpO1xyXG4gICAgICAgIC8vIENoYW5nZSB6b29tOlxyXG4gICAgICAgIHRoaXMuX3RpbWVsaW5lWm9vbSA9IHRoaXMuX3RpbWVsaW5lWm9vbSAqIHpvb21GYWN0b3I7XHJcbiAgICAgICAgLy8gTGltaXQgd2l0aGluIGN1cnJlbnQgdmlld1xyXG4gICAgICAgIGN1cnNvclJhdGlvID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgY3Vyc29yUmF0aW8pKTtcclxuICAgICAgICAvLyBDYWxjdWxhdGUgc3RhcnRcclxuICAgICAgICBsZXQgdGFyZ2V0U3RhcnQgPSBjdXJzb3JUaW1lIC0gKGN1cnNvclJhdGlvICogdGhpcy52aWV3UmFuZ2UpO1xyXG4gICAgICAgIC8vIFN0YXJ0IGNhbm5vdCBiZSBsZXNzIHRoYW4gMFxyXG4gICAgICAgIGlmICh0YXJnZXRTdGFydCA8IDApIHtcclxuICAgICAgICAgICAgdGFyZ2V0U3RhcnQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTZXQgZHJhdyB0aW1lXHJcbiAgICAgICAgdGhpcy5fdmlld1N0YXJ0VGltZSA9IHRhcmdldFN0YXJ0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgb2YgdGhlIGNhbnZhcyBbcGl4ZWxzXVxyXG4gICAgICogQHBhcmFtIGNhbnZhc1xyXG4gICAgICogQHBhcmFtIGV2dFxyXG4gICAgICogQHJldHVybnMge3g6IG51bWJlciwgeTogbnVtYmVyfSBQb3NpdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0TW91c2VQb3MoY2FudmFzLCBldnQpIHtcclxuICAgICAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IGV2dC5jbGllbnRYIC0gcmVjdC5sZWZ0LFxyXG4gICAgICAgICAgICB5OiBldnQuY2xpZW50WSAtIHJlY3QudG9wXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJpbXMgYSB0aW1lbGluZSBzbyB0aGF0IG9iamVjdHMgb25seSBleGlzdCB3aXRoaW4gYSBzcGVjaWZpZWQgdGltZSBwZXJpb2QuXHJcbiAgICAgKiBAcGFyYW0gdGltZWxpbmUgVGltZWxpbmUgdG8gdHJpbS5cclxuICAgICAqIEBwYXJhbSB0cmltIFRpbWVzIHRvIHRyaW0gYmV0d2Vlbi5cclxuICAgICAqL1xyXG4gICAgdHJpbVRpbWVsaW5lKHRpbWVsaW5lLCB0cmltKSB7XHJcbiAgICAgICAgLy8gVGhlIG5ldyByZXNvbHZlZCBvYmplY3RzLlxyXG4gICAgICAgIGxldCBuZXdPYmplY3RzID0ge307XHJcbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHJlc29sdmVkIG9iamVjdHMuXHJcbiAgICAgICAgT2JqZWN0LmtleXModGltZWxpbmUub2JqZWN0cykuZm9yRWFjaCgob2JqSWQpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb2JqID0gdGltZWxpbmUub2JqZWN0c1tvYmpJZF07XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdGluZ0luc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgICAgICBvYmoucmVzb2x2ZWQuaW5zdGFuY2VzLmZvckVhY2goaW5zdGFuY2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gV2hldGhlciB0byBpbnNlcnQgdGhpcyBvYmplY3QgaW50byB0aGUgbmV3IHRpbWVsaW5lLlxyXG4gICAgICAgICAgICAgICAgbGV0IHVzZUluc3RhbmNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3SW5zdGFuY2UgPSBPYmplY3QuYXNzaWduKHt9LCBpbnN0YW5jZSk7IC8vIGNsb25lXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0cmltbWluZyB0aGUgc3RhcnQgdGltZS5cclxuICAgICAgICAgICAgICAgIGlmICh0cmltLnN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBlbmRzIGFmdGVyIHRoZSB0cmltIHN0YXJ0IHRpbWUuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChpbnN0YW5jZS5lbmQgfHwgSW5maW5pdHkpID4gdHJpbS5zdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VJbnN0YW5jZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdJbnN0YW5jZS5zdGFydCA8IHRyaW0uc3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luc3RhbmNlLnN0YXJ0ID0gdHJpbS5zdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIElmIHRyaW1taW5nIHRoZSBlbmQgdGltZS5cclxuICAgICAgICAgICAgICAgIGlmICh0cmltLmVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3Qgc3RhcnRzIGJlZm9yZSB0aGUgdHJpbSBlbmQgdGltZS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhcnQgPCB0cmltLmVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VJbnN0YW5jZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobmV3SW5zdGFuY2UuZW5kIHx8IEluZmluaXR5KSA+IHRyaW0uZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJbnN0YW5jZS5lbmQgPSB0cmltLmVuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghdHJpbS5zdGFydCAmJiAhdHJpbS5lbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICB1c2VJbnN0YW5jZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodXNlSW5zdGFuY2UgJiZcclxuICAgICAgICAgICAgICAgICAgICBuZXdJbnN0YW5jZS5zdGFydCA8IChuZXdJbnN0YW5jZS5lbmQgfHwgSW5maW5pdHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSW5zdGFuY2VzLnB1c2gobmV3SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXNuJ3QgYSByZXNvbHZlZCBvYmplY3QgZm9yIHRoZSBuZXcgaW5zdGFuY2UsIGNyZWF0ZSBpdC5cclxuICAgICAgICAgICAgaWYgKCFuZXdPYmplY3RzW29iaklkXSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5ld09iamVjdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBvYmouY29udGVudCxcclxuICAgICAgICAgICAgICAgICAgICBlbmFibGU6IG9iai5lbmFibGUsXHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG9iai5pZCxcclxuICAgICAgICAgICAgICAgICAgICBsYXllcjogb2JqLmxheWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsRGVlcDogb2JqLnJlc29sdmVkLmxldmVsRGVlcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQ6IG9iai5yZXNvbHZlZC5yZXNvbHZlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2aW5nOiBvYmoucmVzb2x2ZWQucmVzb2x2aW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RSZWZlcmVuY2VzOiBvYmoucmVzb2x2ZWQuZGlyZWN0UmVmZXJlbmNlcyxcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgbmV3T2JqZWN0c1tvYmpJZF0gPSBuZXdPYmplY3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV3T2JqZWN0c1tvYmpJZF0ucmVzb2x2ZWQuaW5zdGFuY2VzID0gcmVzdWx0aW5nSW5zdGFuY2VzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNsYXNzZXM6IHRpbWVsaW5lLmNsYXNzZXMsXHJcbiAgICAgICAgICAgIGxheWVyczogdGltZWxpbmUubGF5ZXJzLFxyXG4gICAgICAgICAgICBvYmplY3RzOiBuZXdPYmplY3RzLFxyXG4gICAgICAgICAgICBvcHRpb25zOiB0aW1lbGluZS5vcHRpb25zLFxyXG4gICAgICAgICAgICBzdGF0aXN0aWNzOiB0aW1lbGluZS5zdGF0aXN0aWNzLFxyXG4gICAgICAgICAgICBzdGF0ZTogdGltZWxpbmUuc3RhdGUsXHJcbiAgICAgICAgICAgIG5leHRFdmVudHM6IHRpbWVsaW5lLm5leHRFdmVudHNcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXJnZXMgdHdvIHRpbWVsaW5lcyBieSBtZXJnaW5nIGluc3RhbmNlcyBvZiBvYmplY3RzIHRoYXQgaW50ZXJzZWN0IGVhY2ggb3RoZXIuXHJcbiAgICAgKiBAcGFyYW0gcGFzdCBPbGRlciB0aW1lbGluZS5cclxuICAgICAqIEBwYXJhbSBwcmVzZW50IE5ld2VyIHRpbWVsaW5lLlxyXG4gICAgICogQHJldHVybnMge1Jlc29sdmVkVGltZWxpbmV9IGNvbnRhaW5pbmcgbWVyZ2VkIHRpbWVsaW5lcy5cclxuICAgICAqL1xyXG4gICAgbWVyZ2VUaW1lbGluZU9iamVjdHMocGFzdCwgcHJlc2VudCwgZnJvbU5ld1RpbWVsaW5lKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0aW5nT2JqZWN0cyA9IHt9O1xyXG4gICAgICAgIGlmIChmcm9tTmV3VGltZWxpbmUpIHtcclxuICAgICAgICAgICAgcGFzdCA9IHRoaXMudHJpbVRpbWVsaW5lKHBhc3QsIHsgZW5kOiB0aGlzLl9wbGF5SGVhZFRpbWUgfSk7XHJcbiAgICAgICAgICAgIHByZXNlbnQgPSB0aGlzLnRyaW1UaW1lbGluZShwcmVzZW50LCB7IHN0YXJ0OiB0aGlzLl9wbGF5SGVhZFRpbWUgfSk7XHJcbiAgICAgICAgICAgIC8vIEJlY2F1c2Ugd2Ugd2FudCB0byBrZWVwIG9sZCBvYmplY3RzLCB0aGlzIGl0ZXJhdG9yIGlzIHVzZWQgdG8gY3JlYXRlIHVuaXF1ZSBvbGQgaWRzIGZvciB0aGVtXHJcbiAgICAgICAgICAgIHRoaXMuX21lcmdlSXRlcmF0b3IrKztcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMocGFzdC5vYmplY3RzKS5mb3JFYWNoKChvYmpJZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFzdE9iaiA9IHBhc3Qub2JqZWN0c1tvYmpJZF07XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlOiBoYWNrIHRvIG1hcmsgaXQgYXMgYSBcInBhc3Qgb2JqZWN0XCJcclxuICAgICAgICAgICAgICAgIGlmIChwYXN0T2JqLl9fcGFzdE9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvcHkgb3ZlciBpdCByaWdodCBhd2F5LCBpdCdzIG9sZC4gRG9uJ3QgZG8gYW55dGhpbmcgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ09iamVjdHNbb2JqSWRdID0gcGFzdE9iajtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBhbiBvYmplY3QgZXhpc3RzIGluIGJvdGggdGltZWxpbmVzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVzZW50T2JqID0gcHJlc2VudC5vYmplY3RzW29iaklkXTtcclxuICAgICAgICAgICAgICAgIGlmIChwcmVzZW50T2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgdGhlIG9iamVjdHMsIG9ubHkgbG9vayBpbnRvIG1lcmdpbmcgdGhlbSBpZiB0aGV5IGxvb2sgaWRlbnRpY2FsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFcXVhbChPYmplY3QuYXNzaWduKHt9LCBwYXN0T2JqLCB7IHJlc29sdmVkOiBudWxsIH0pLCBPYmplY3QuYXNzaWduKHt9LCBwcmVzZW50T2JqLCB7IHJlc29sdmVkOiBudWxsIH0pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCBhbGwgcGFzdCBpbnN0YW5jZXMgc3RvcCBhdCBhIGNlcnRhaW4gdGltZSBhdCB0aGUgdmVyeSBsYXRlc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGF0IGFsbCBuZXcgaW5zdGFuY2VzIHN0YXJ0IGF0IHRoYXQgdGltZSBhdCB0aGUgdmVyeSBlYXJsaWVzdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBpbnN0YW5jZXMgb2YgdGhvc2Ugb2JqZWN0cy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsSW5zdGFuY2VzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3RPYmoucmVzb2x2ZWQuaW5zdGFuY2VzLmZvckVhY2gocGFzdEluc3RhbmNlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEluc3RhbmNlc1twYXN0SW5zdGFuY2UuZW5kICsgJyddID0gcGFzdEluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudE9iai5yZXNvbHZlZC5pbnN0YW5jZXMuZm9yRWFjaChwcmVzZW50SW5zdGFuY2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsbEluc3RhbmNlc1twcmVzZW50SW5zdGFuY2Uuc3RhcnQgKyAnJ10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgaW5zdGFuY2VzIGFyZSBuZXh0IHRvIGVhY2ggb3RoZXIsIG1lcmdlIHRoZW0gaW50byBvbmU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsSW5zdGFuY2VzW3ByZXNlbnRJbnN0YW5jZS5zdGFydCArICcnXS5lbmQgPSBwcmVzZW50SW5zdGFuY2UuZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsSW5zdGFuY2VzW3ByZXNlbnRJbnN0YW5jZS5zdGFydCArICcnXSA9IHByZXNlbnRJbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnRPYmoucmVzb2x2ZWQuaW5zdGFuY2VzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGFsbEluc3RhbmNlcykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBhbGxJbnN0YW5jZXNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnRPYmoucmVzb2x2ZWQuaW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBvdmVyIHRoZSBuZXcgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ09iamVjdHNbb2JqSWRdID0gcHJlc2VudE9iajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBkb24ndCBjb3B5IG92ZXIgb2xkIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9iamVjdHMgZG9lc24ndCBsb29rIGlkZW50aWNhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IG92ZXIgdGhlIG5ldyBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nT2JqZWN0c1tvYmpJZF0gPSBwcmVzZW50T2JqO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvbGQgb2JqZWN0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIG5ldyB0aW1lbGluZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZTogaGFjayB0byBtYXJrIGl0IGFzIGEgXCJwYXN0IG9iamVjdFwiXHJcbiAgICAgICAgICAgICAgICBwYXN0T2JqLl9fcGFzdE9iaiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyBDb3B5IG92ZXIgdGhlIG9sZCBvYmplY3RcclxuICAgICAgICAgICAgICAgIHJlc3VsdGluZ09iamVjdHNbdGhpcy5fbWVyZ2VJdGVyYXRvciArICdfXycgKyBvYmpJZF0gPSBwYXN0T2JqO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBuZXh0IG9iamVjdHNcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMocHJlc2VudC5vYmplY3RzKS5mb3JFYWNoKChvYmpJZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJlc2VudE9iaiA9IHByZXNlbnQub2JqZWN0c1tvYmpJZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhc3Qub2JqZWN0c1tvYmpJZF0pIHsgLy8gKGlmIGl0IGRpZCBleGlzdGVkIGluIHRoZSBwYXN0LCBpdCBoYXMgYWxyZWFkeSBiZWVuIGhhbmRsZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCBjb3B5IG92ZXIgdGhlIG5ldyBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdPYmplY3RzW29iaklkXSA9IHByZXNlbnRPYmo7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTm8gbmV3IHRpbWVsaW5lLCBvYmplY3RzIGFuZCBpbnN0YW5jZXMgYXJlIG9ubHkgYWRkZWRcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMocGFzdC5vYmplY3RzKS5mb3JFYWNoKChvYmpJZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFzdE9iaiA9IHBhc3Qub2JqZWN0c1tvYmpJZF07XHJcbiAgICAgICAgICAgICAgICByZXN1bHRpbmdPYmplY3RzW29iaklkXSA9IHBhc3RPYmo7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwcmVzZW50Lm9iamVjdHMpLmZvckVhY2goKG9iaklkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVzZW50T2JqID0gcHJlc2VudC5vYmplY3RzW29iaklkXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nT2JqID0gcmVzdWx0aW5nT2JqZWN0c1tvYmpJZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdPYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSB3aXRoIG9sZCBpbnN0YW5jZXNcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0luc3RhbmNlcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nT2JqLnJlc29sdmVkLmluc3RhbmNlcy5mb3JFYWNoKGluc3RhbmNlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdJbnN0YW5jZXNbaW5zdGFuY2Uuc3RhcnQgKyAnXycgKyBpbnN0YW5jZS5lbmRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBwcmVzZW50T2JqLnJlc29sdmVkLmluc3RhbmNlcy5mb3JFYWNoKGluc3RhbmNlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBwdXNoIGluc3RhbmNlcyB0aGF0IGFyZW4ndCBhbHJlYWR5IHByZXNlbnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmdJbnN0YW5jZXNbaW5zdGFuY2Uuc3RhcnQgKyAnXycgKyBpbnN0YW5jZS5lbmRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ09iai5yZXNvbHZlZC5pbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ09iamVjdHNbb2JqSWRdID0gcHJlc2VudE9iajtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdGluZ0xheWVycyA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHJlc3VsdGluZ09iamVjdHMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb2JqID0gcmVzdWx0aW5nT2JqZWN0c1trZXldO1xyXG4gICAgICAgICAgICBjb25zdCBsYXllciA9IG9iai5sYXllciArICcnO1xyXG4gICAgICAgICAgICBpZiAoIXJlc3VsdGluZ0xheWVyc1tsYXllcl0pXHJcbiAgICAgICAgICAgICAgICByZXN1bHRpbmdMYXllcnNbbGF5ZXJdID0gW107XHJcbiAgICAgICAgICAgIHJlc3VsdGluZ0xheWVyc1tsYXllcl0ucHVzaChrZXkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXNlbnQpLCB7IG9iamVjdHM6IHJlc3VsdGluZ09iamVjdHMsIGxheWVyczogcmVzdWx0aW5nTGF5ZXJzIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlVGltZWxpbmVSZXNvbHZlV2luZG93KCkge1xyXG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5nZXRFeHBhbmRlZFN0YXJ0RW5kVGltZSgxKTtcclxuICAgICAgICB0aGlzLl90aW1lbGluZVJlc29sdmVTdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUVuZCA9IGVuZDtcclxuICAgICAgICB0aGlzLl90aW1lbGluZVJlc29sdmVab29tID0gdGhpcy5fdGltZWxpbmVab29tO1xyXG4gICAgICAgIGlmICh0aGlzLmxhdGVzdFVwZGF0ZVRpbWUpIHtcclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGFuIG9wdGltYWwgbnVtYmVyIG9mIG9iamVjdHMgdG8gY3JlYXRlLCBzbyB0aGF0IHRoZSBkcmF3aW5nIHN0aWxsIHJ1bnMgc21vb3RobHkuXHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFJlc29sdmVUaW1lID0gNTA7IC8vIG1zXHJcbiAgICAgICAgICAgIGxldCByYXRpbyA9IHRhcmdldFJlc29sdmVUaW1lIC8gdGhpcy5sYXRlc3RVcGRhdGVUaW1lO1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lbGluZVJlc29sdmVDb3VudEFkanVzdCA9IE1hdGgubWF4KDAuMSwgTWF0aC5taW4oMTAsICgxICsgKHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUNvdW50QWRqdXN0ICogcmF0aW8pKSAvIDIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRFeHBhbmRlZFN0YXJ0RW5kVGltZShtdWx0aXBsaWVyID0gMSkge1xyXG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuX3ZpZXdTdGFydFRpbWU7XHJcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMudmlld0VuZFRpbWU7XHJcbiAgICAgICAgbGV0IGR1cmF0aW9uID0gZW5kIC0gc3RhcnQ7XHJcbiAgICAgICAgbGV0IGV4cGFuZCA9IGR1cmF0aW9uICogKHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUV4cGFuZCAtIDEpICogbXVsdGlwbGllcjtcclxuICAgICAgICBzdGFydCAtPSBleHBhbmQgKiAwLjMzO1xyXG4gICAgICAgIGVuZCArPSBleHBhbmQgKiAwLjY2OyAvLyBleHBhbmQgbW9yZSBpbnRvIHRoZSBmdXR1cmVcclxuICAgICAgICBzdGFydCA9IE1hdGgubWF4KDAsIHN0YXJ0KTtcclxuICAgICAgICBlbmQgPSBNYXRoLm1heCgwLCBlbmQpO1xyXG4gICAgICAgIGNvbnN0IHpvb21EaWZmID0gTWF0aC5tYXgodGhpcy5fdGltZWxpbmVSZXNvbHZlWm9vbSwgdGhpcy5fdGltZWxpbmVab29tKSAvXHJcbiAgICAgICAgICAgIE1hdGgubWluKHRoaXMuX3RpbWVsaW5lUmVzb2x2ZVpvb20sIHRoaXMuX3RpbWVsaW5lWm9vbSk7XHJcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCwgem9vbURpZmYgfTtcclxuICAgIH1cclxuICAgIGNoZWNrQXV0b21hdGljUmVyZXNvbHZlKCkge1xyXG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgem9vbURpZmYgfSA9IHRoaXMuZ2V0RXhwYW5kZWRTdGFydEVuZFRpbWUoMC4yKTtcclxuICAgICAgICBpZiAodGhpcy5fdGltZWxpbmVSZXNvbHZlQXV0byAmJiAoc3RhcnQgPCB0aGlzLl90aW1lbGluZVJlc29sdmVTdGFydCB8fFxyXG4gICAgICAgICAgICBlbmQgPiB0aGlzLl90aW1lbGluZVJlc29sdmVFbmQgfHxcclxuICAgICAgICAgICAgem9vbURpZmYgPiAzKSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVyZXNvbHZlVGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXJlc29sdmVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXJlc29sdmVUaW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRpbWVsaW5lUmVzb2x2ZVdpbmRvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRpbWVsaW5lKCk7XHJcbiAgICAgICAgICAgICAgICB9LCBNYXRoLm1heCgxMDAsIHRoaXMubGF0ZXN0VXBkYXRlVGltZSAqIDUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSBDb252ZXJzaW9ucyBiZXR3ZWVuIHBvc2l0aW9uICYgdGltZSAtLS0tLS0tLS0tLS0tXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSB0aGUgWCBjb29yZGluYXRlIG9mIGEgdGltZSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFRoZSB0aW1lIHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB0aW1lLlxyXG4gICAgICovXHJcbiAgICB0aW1lVG9YQ29vcmQodGltZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3RHJhd1ggKyAoKHRpbWUgLSB0aGlzLl92aWV3U3RhcnRUaW1lKSAqIHRoaXMucGl4ZWxzV2lkdGhQZXJVbml0VGltZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSB0aGUgdGltZSBvZiBhIFggY29vcmRpbmF0ZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFRoZSBYIGNvb3JkaW5hdGUgdG8gY29udmVydC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0aW1lIG9mIHRoZSBYIGNvb3JkaW5hdGUuXHJcbiAgICAgKi9cclxuICAgIHhDb29yZFRvVGltZShwb3NpdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3U3RhcnRUaW1lICsgKChwb3NpdGlvbiAtIHRoaXMuX3ZpZXdEcmF3WCkgLyB0aGlzLnBpeGVsc1dpZHRoUGVyVW5pdFRpbWUpO1xyXG4gICAgfVxyXG4gICAgLyoqIENhbGN1bGF0ZSB0aGUgcmF0aW8gb2YgdGhlIHRpbWUgaW4gY3VycmVudCB2aWV3ICgwIGkgYmVnaW5uaW5nLCAxIGlzIGVuZCkgICovXHJcbiAgICB0aW1lVG9SYXRpbyh0aW1lKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aW1lIC0gdGhpcy5fdmlld1N0YXJ0VGltZSkgLyB0aGlzLnZpZXdSYW5nZTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvc2l0aW9uIGlzIHdpdGhpbiB0aGUgY3VycmVudCB2aWV3ICAqL1xyXG4gICAgaXN0aW1lSW5WaWV3KHRpbWUpIHtcclxuICAgICAgICBjb25zdCByYXRpbyA9IHRoaXMudGltZVRvUmF0aW8odGltZSk7XHJcbiAgICAgICAgcmV0dXJuIHJhdGlvID49IDAgJiYgcmF0aW8gPCAxO1xyXG4gICAgfVxyXG4gICAgY2FwWGNvb3JkVG9WaWV3KHBvc2l0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuX3ZpZXdEcmF3WCwgTWF0aC5taW4odGhpcy5fdmlld0RyYXdYICsgdGhpcy5fdmlld0RyYXdXaWR0aCwgcG9zaXRpb24pKTtcclxuICAgIH1cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tIEdldHRlcnMgLyBDb252ZW5pZW5jZSBmdW5jdGlvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvKiogWm9vbSBmYWN0b3IgW3BpeGVscyAvIHRpbWVdICovXHJcbiAgICBnZXQgcGl4ZWxzV2lkdGhQZXJVbml0VGltZSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX3RpbWVsaW5lWm9vbSAvIDEwMCk7XHJcbiAgICB9XHJcbiAgICAvKiogVGhlIHJhbmdlIG9mIHRoZSB2aWV3IFt0aW1lXSAqL1xyXG4gICAgZ2V0IHZpZXdSYW5nZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlld0RyYXdXaWR0aCAvIHRoaXMucGl4ZWxzV2lkdGhQZXJVbml0VGltZTtcclxuICAgIH1cclxuICAgIC8qKiBUaGUgZW5kIHRpbWUgb2YgdGhlIHZpZXcgW3RpbWVdICovXHJcbiAgICBnZXQgdmlld0VuZFRpbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdTdGFydFRpbWUgKyB0aGlzLnZpZXdSYW5nZTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlRpbWVsaW5lVmlzdWFsaXplciA9IFRpbWVsaW5lVmlzdWFsaXplcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZWxpbmVWaXN1YWxpemVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBvYmplY3RDcmVhdGVQb2x5ZmlsbFxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBvYmplY3RLZXlzUG9seWZpbGxcbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgZnVuY3Rpb25CaW5kUG9seWZpbGxcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfZXZlbnRzJykpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxudmFyIGhhc0RlZmluZVByb3BlcnR5O1xudHJ5IHtcbiAgdmFyIG8gPSB7fTtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sICd4JywgeyB2YWx1ZTogMCB9KTtcbiAgaGFzRGVmaW5lUHJvcGVydHkgPSBvLnggPT09IDA7XG59IGNhdGNoIChlcnIpIHsgaGFzRGVmaW5lUHJvcGVydHkgPSBmYWxzZSB9XG5pZiAoaGFzRGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgaW5wdXQgaXMgYSBwb3NpdGl2ZSBudW1iZXIgKHdob3NlIHZhbHVlIGlzIHplcm8gb3JcbiAgICAgIC8vIGdyZWF0ZXIgYW5kIG5vdCBhIE5hTikuXG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBhcmcgIT09IGFyZylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xufVxuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiblwiIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuLy8gVGhlc2Ugc3RhbmRhbG9uZSBlbWl0KiBmdW5jdGlvbnMgYXJlIHVzZWQgdG8gb3B0aW1pemUgY2FsbGluZyBvZiBldmVudFxuLy8gaGFuZGxlcnMgZm9yIGZhc3QgY2FzZXMgYmVjYXVzZSBlbWl0KCkgaXRzZWxmIG9mdGVuIGhhcyBhIHZhcmlhYmxlIG51bWJlciBvZlxuLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmVcbi8vIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHRodXMgZG8gbm90IGdldCBkZW9wdGltaXplZCwgc28gdGhlIGNvZGVcbi8vIGluc2lkZSB0aGVtIGNhbiBleGVjdXRlIGZhc3Rlci5cbmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSkge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmdzKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBldmVudHM7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cylcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09IG51bGwpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmICghaGFuZGxlcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGlzRm4gPSB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJztcbiAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgc3dpdGNoIChsZW4pIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICBjYXNlIDE6XG4gICAgICBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICBkZWZhdWx0OlxuICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKCFldmVudHMpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmICghZXhpc3RpbmcpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSkge1xuICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgXCInICsgU3RyaW5nKHR5cGUpICsgJ1wiIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQuJyk7XG4gICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCclczogJXMnLCB3Lm5hbWUsIHcubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMl0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gYmluZC5jYWxsKG9uY2VXcmFwcGVyLCBzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKCFsaXN0KVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoIWV2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoIWV2ZW50cylcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmICghZXZsaXN0ZW5lcilcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0Lm93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpLlxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSlcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvYmplY3RDcmVhdGVQb2x5ZmlsbChwcm90bykge1xuICB2YXIgRiA9IGZ1bmN0aW9uKCkge307XG4gIEYucHJvdG90eXBlID0gcHJvdG87XG4gIHJldHVybiBuZXcgRjtcbn1cbmZ1bmN0aW9uIG9iamVjdEtleXNQb2x5ZmlsbChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIgayBpbiBvYmopIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrKSkge1xuICAgIGtleXMucHVzaChrKTtcbiAgfVxuICByZXR1cm4gaztcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQmluZFBvbHlmaWxsKGNvbnRleHQpIHtcbiAgdmFyIGZuID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiIsIi8qKlxuICogTG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pzLmZvdW5kYXRpb24vPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXG4gICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyksXG4gICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcbiAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAqIGVxdWl2YWxlbnQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIG9iamVjdCA9PT0gb3RoZXI7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VxdWFsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV2ZW50VHlwZSA9IHZvaWQgMDtcbnZhciBFdmVudFR5cGU7XG4oZnVuY3Rpb24gKEV2ZW50VHlwZSkge1xuICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJTVEFSVFwiXSA9IDBdID0gXCJTVEFSVFwiO1xuICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJFTkRcIl0gPSAxXSA9IFwiRU5EXCI7XG4gICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIktFWUZSQU1FXCJdID0gMl0gPSBcIktFWUZSQU1FXCI7XG59KShFdmVudFR5cGUgPSBleHBvcnRzLkV2ZW50VHlwZSB8fCAoZXhwb3J0cy5FdmVudFR5cGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlS2V5ZnJhbWUgPSBleHBvcnRzLnZhbGlkYXRlT2JqZWN0ID0gZXhwb3J0cy52YWxpZGF0ZVRpbWVsaW5lID0gZXhwb3J0cy5SZXNvbHZlciA9IHZvaWQgMDtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL2FwaS9lbnVtc1wiKSwgZXhwb3J0cyk7XG4oMCwgdHNsaWJfMS5fX2V4cG9ydFN0YXIpKHJlcXVpcmUoXCIuL2FwaS9hcGlcIiksIGV4cG9ydHMpO1xudmFyIHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlci9yZXNvbHZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlc29sdmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlcl8xLlJlc29sdmVyOyB9IH0pO1xudmFyIHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlci92YWxpZGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhbGlkYXRlVGltZWxpbmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlXzEudmFsaWRhdGVUaW1lbGluZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhbGlkYXRlT2JqZWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWxpZGF0ZV8xLnZhbGlkYXRlT2JqZWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmFsaWRhdGVLZXlmcmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfMS52YWxpZGF0ZUtleWZyYW1lOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNsZWFuQ2FjaGVSZXN1bHQgPSBleHBvcnRzLmNhY2hlUmVzdWx0ID0gZXhwb3J0cy5hcHBseVBhcmVudEluc3RhbmNlcyA9IGV4cG9ydHMuc2V0SW5zdGFuY2VTdGFydFRpbWUgPSBleHBvcnRzLnNldEluc3RhbmNlRW5kVGltZSA9IGV4cG9ydHMucmVzZXRJZCA9IGV4cG9ydHMuZ2V0SWQgPSBleHBvcnRzLmpvaW5DYXBzID0gZXhwb3J0cy5hZGRDYXBzVG9SZXN1bWluZyA9IGV4cG9ydHMuam9pblJlZmVyZW5jZXMgPSBleHBvcnRzLmlzUmVmZXJlbmNlID0gZXhwb3J0cy5jYXBJbnN0YW5jZXMgPSBleHBvcnRzLmFwcGx5UmVwZWF0aW5nSW5zdGFuY2VzID0gZXhwb3J0cy5vcGVyYXRlT25BcnJheXMgPSBleHBvcnRzLmludmVydEluc3RhbmNlcyA9IGV4cG9ydHMuY29udmVydEV2ZW50c1RvSW5zdGFuY2VzID0gZXhwb3J0cy5jbGVhbkluc3RhbmNlcyA9IGV4cG9ydHMuc29ydEV2ZW50cyA9IGV4cG9ydHMuaXNOdW1lcmljID0gZXhwb3J0cy5pc0NvbnN0YW50ID0gZXhwb3J0cy5leHRlbmRNYW5kYWRvcnkgPSB2b2lkIDA7XG5jb25zdCBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG4vKipcbiAqIFNvbWV3aGF0IGxpa2UgXy5leHRlbmQsIGJ1dCB3aXRoIHN0cm9uZyB0eXBlcyAmIG1hbmRhdGVkIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogQHBhcmFtIG9yaWdpbmFsIE9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIGV4dGVuZE9iaiBwcm9wZXJ0aWVzIHRvIGFkZFxuICovXG5mdW5jdGlvbiBleHRlbmRNYW5kYWRvcnkob3JpZ2luYWwsIGV4dGVuZE9iaikge1xuICAgIHJldHVybiBfLmV4dGVuZChvcmlnaW5hbCwgZXh0ZW5kT2JqKTtcbn1cbmV4cG9ydHMuZXh0ZW5kTWFuZGFkb3J5ID0gZXh0ZW5kTWFuZGFkb3J5O1xuZnVuY3Rpb24gaXNDb25zdGFudChzdHIpIHtcbiAgICByZXR1cm4gISEoaXNOdW1lcmljKHN0cikgfHwgKF8uaXNTdHJpbmcoc3RyKSAmJiAoc3RyLm1hdGNoKC9edHJ1ZSQvKSB8fCBzdHIubWF0Y2goL15mYWxzZSQvKSkpKTtcbn1cbmV4cG9ydHMuaXNDb25zdGFudCA9IGlzQ29uc3RhbnQ7XG5mdW5jdGlvbiBpc051bWVyaWMoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChfLmlzTnVtYmVyKHN0cikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChfLmlzU3RyaW5nKHN0cikpXG4gICAgICAgIHJldHVybiAhIShzdHIubWF0Y2goL15bLStdP1swLTkuXSskLykgJiYgIV8uaXNOYU4ocGFyc2VGbG9hdChzdHIpKSk7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc051bWVyaWMgPSBpc051bWVyaWM7XG5mdW5jdGlvbiBzb3J0RXZlbnRzKGV2ZW50cykge1xuICAgIHJldHVybiBldmVudHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBpZiAoYS50aW1lID4gYi50aW1lKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhLnRpbWUgPCBiLnRpbWUpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGNvbnN0IGFJZCA9IGEuZGF0YSAmJiAoYS5kYXRhLmlkIHx8IChhLmRhdGEuaW5zdGFuY2UgJiYgYS5kYXRhLmluc3RhbmNlLmlkKSk7XG4gICAgICAgIGNvbnN0IGJJZCA9IGIuZGF0YSAmJiAoYi5kYXRhLmlkIHx8IChiLmRhdGEuaW5zdGFuY2UgJiYgYi5kYXRhLmluc3RhbmNlLmlkKSk7XG4gICAgICAgIGlmIChhSWQgJiYgYklkICYmIGFJZCA9PT0gYklkKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZXZlbnQgcmVmZXIgdG8gdGhlIHNhbWUgSUQsIGxldCB0aGUgZW5kaW5nIGV2ZW50IGJlIGZpcnN0OlxuICAgICAgICAgICAgaWYgKGEudmFsdWUgJiYgIWIudmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKCFhLnZhbHVlICYmIGIudmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEudmFsdWUgJiYgIWIudmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKCFhLnZhbHVlICYmIGIudmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0pO1xufVxuZXhwb3J0cy5zb3J0RXZlbnRzID0gc29ydEV2ZW50cztcbi8qKlxuICogQ2xlYW4gdXAgaW5zdGFuY2VzLCBqb2luIG92ZXJsYXBwaW5nIGV0Yy4uXG4gKiBAcGFyYW0gaW5zdGFuY2VzXG4gKi9cbmZ1bmN0aW9uIGNsZWFuSW5zdGFuY2VzKGluc3RhbmNlcywgYWxsb3dNZXJnZSwgYWxsb3daZXJvR2FwcyA9IGZhbHNlKSB7XG4gICAgLy8gRmlyc3QsIG9wdGltaXplIGZvciBjZXJ0YWluIGNvbW1vbiBzaXR1YXRpb25zOlxuICAgIGlmIChpbnN0YW5jZXMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gW107XG4gICAgaWYgKGluc3RhbmNlcy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBpbnN0YW5jZXM7XG4gICAgY29uc3QgZXZlbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaV07XG4gICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIHRpbWU6IGluc3RhbmNlLnN0YXJ0LFxuICAgICAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgICAgICBkYXRhOiB7IGluc3RhbmNlOiBpbnN0YW5jZSB9LFxuICAgICAgICAgICAgcmVmZXJlbmNlczogaW5zdGFuY2UucmVmZXJlbmNlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbnN0YW5jZS5lbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0aW1lOiBpbnN0YW5jZS5lbmQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHsgaW5zdGFuY2U6IGluc3RhbmNlIH0sXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogaW5zdGFuY2UucmVmZXJlbmNlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0RXZlbnRzVG9JbnN0YW5jZXMoZXZlbnRzLCBhbGxvd01lcmdlLCBhbGxvd1plcm9HYXBzKTtcbn1cbmV4cG9ydHMuY2xlYW5JbnN0YW5jZXMgPSBjbGVhbkluc3RhbmNlcztcbmZ1bmN0aW9uIGNvbnZlcnRFdmVudHNUb0luc3RhbmNlcyhldmVudHMsIGFsbG93TWVyZ2UsIGFsbG93WmVyb0dhcHMgPSBmYWxzZSkge1xuICAgIHNvcnRFdmVudHMoZXZlbnRzKTtcbiAgICBjb25zdCBhY3RpdmVJbnN0YW5jZXMgPSB7fTtcbiAgICBsZXQgYWN0aXZlSW5zdGFuY2VJZCA9IG51bGw7XG4gICAgbGV0IHByZXZpb3VzQWN0aXZlID0gZmFsc2U7XG4gICAgY29uc3QgbmVnYXRpdmVJbnN0YW5jZXMgPSB7fTtcbiAgICBsZXQgcHJldmlvdXNOZWdhdGl2ZSA9IGZhbHNlO1xuICAgIGxldCBuZWdhdGl2ZUluc3RhbmNlSWQgPSBudWxsO1xuICAgIGNvbnN0IHJldHVybkluc3RhbmNlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzW2ldO1xuICAgICAgICBjb25zdCBldmVudElkID0gZXZlbnQuZGF0YS5pZCB8fCBldmVudC5kYXRhLmluc3RhbmNlLmlkO1xuICAgICAgICBjb25zdCBsYXN0SW5zdGFuY2UgPSByZXR1cm5JbnN0YW5jZXNbcmV0dXJuSW5zdGFuY2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZXZlbnQudmFsdWUpIHtcbiAgICAgICAgICAgIGFjdGl2ZUluc3RhbmNlc1tldmVudElkXSA9IGV2ZW50O1xuICAgICAgICAgICAgZGVsZXRlIG5lZ2F0aXZlSW5zdGFuY2VzW2V2ZW50SWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGFjdGl2ZUluc3RhbmNlc1tldmVudElkXTtcbiAgICAgICAgICAgIG5lZ2F0aXZlSW5zdGFuY2VzW2V2ZW50SWRdID0gZXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGFjdGl2ZUluc3RhbmNlcykubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBhbiBhY3RpdmUgaW5zdGFuY2VcbiAgICAgICAgICAgIGlmICghYWxsb3dNZXJnZSAmJiAhYWxsb3daZXJvR2FwcyAmJiBsYXN0SW5zdGFuY2UgJiYgcHJldmlvdXNOZWdhdGl2ZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIHByZXZpb3VzbHkgYW4gaW5BY3RpdmUgKG5lZ2F0aXZlKSBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIGxhc3RJbnN0YW5jZS5zdGFydCA9IGV2ZW50LnRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvID0gaGFuZGxlQWN0aXZlSW5zdGFuY2VzKGV2ZW50LCBsYXN0SW5zdGFuY2UsIGFjdGl2ZUluc3RhbmNlSWQsIGV2ZW50SWQsIGFjdGl2ZUluc3RhbmNlcywgYWxsb3dNZXJnZSwgYWxsb3daZXJvR2Fwcyk7XG4gICAgICAgICAgICAgICAgYWN0aXZlSW5zdGFuY2VJZCA9IG8uYWN0aXZlSW5zdGFuY2VJZDtcbiAgICAgICAgICAgICAgICBpZiAoby5yZXR1cm5JbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5JbnN0YW5jZXMucHVzaChvLnJldHVybkluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91c0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBwcmV2aW91c05lZ2F0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBObyBpbnN0YW5jZXMgYXJlIGFjdGl2ZVxuICAgICAgICAgICAgaWYgKGxhc3RJbnN0YW5jZSAmJiBwcmV2aW91c0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGxhc3RJbnN0YW5jZS5lbmQgPSBldmVudC50aW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG5lZ2F0aXZlSW5zdGFuY2VzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSBuZWdhdGl2ZSBpbnN0YW5jZSBydW5uaW5nXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG8gPSBoYW5kbGVBY3RpdmVJbnN0YW5jZXMoZXZlbnQsIGxhc3RJbnN0YW5jZSwgbmVnYXRpdmVJbnN0YW5jZUlkLCBldmVudElkLCBuZWdhdGl2ZUluc3RhbmNlcywgYWxsb3dNZXJnZSwgYWxsb3daZXJvR2Fwcyk7XG4gICAgICAgICAgICAgICAgICAgIG5lZ2F0aXZlSW5zdGFuY2VJZCA9IG8uYWN0aXZlSW5zdGFuY2VJZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8ucmV0dXJuSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5vLnJldHVybkluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBvLnJldHVybkluc3RhbmNlLmVuZCB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogby5yZXR1cm5JbnN0YW5jZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTmVnYXRpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHVybkluc3RhbmNlcztcbn1cbmV4cG9ydHMuY29udmVydEV2ZW50c1RvSW5zdGFuY2VzID0gY29udmVydEV2ZW50c1RvSW5zdGFuY2VzO1xuZnVuY3Rpb24gaGFuZGxlQWN0aXZlSW5zdGFuY2VzKGV2ZW50LCBsYXN0SW5zdGFuY2UsIGFjdGl2ZUluc3RhbmNlSWQsIGV2ZW50SWQsIGFjdGl2ZUluc3RhbmNlcywgYWxsb3dNZXJnZSwgYWxsb3daZXJvR2FwcyA9IGZhbHNlKSB7XG4gICAgbGV0IHJldHVybkluc3RhbmNlID0gbnVsbDtcbiAgICBpZiAoIWFsbG93TWVyZ2UgJiZcbiAgICAgICAgZXZlbnQudmFsdWUgJiZcbiAgICAgICAgbGFzdEluc3RhbmNlICYmXG4gICAgICAgIGxhc3RJbnN0YW5jZS5lbmQgPT09IG51bGwgJiZcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VJZCAhPT0gbnVsbCAmJlxuICAgICAgICBhY3RpdmVJbnN0YW5jZUlkICE9PSBldmVudElkKSB7XG4gICAgICAgIC8vIFN0YXJ0IGEgbmV3IGluc3RhbmNlOlxuICAgICAgICBsYXN0SW5zdGFuY2UuZW5kID0gZXZlbnQudGltZTtcbiAgICAgICAgcmV0dXJuSW5zdGFuY2UgPSB7XG4gICAgICAgICAgICBpZDogZ2V0SWQoKSxcbiAgICAgICAgICAgIHN0YXJ0OiBldmVudC50aW1lLFxuICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgcmVmZXJlbmNlczogZXZlbnQucmVmZXJlbmNlcyxcbiAgICAgICAgICAgIG9yaWdpbmFsRW5kOiBldmVudC5kYXRhLmluc3RhbmNlLm9yaWdpbmFsRW5kLFxuICAgICAgICAgICAgb3JpZ2luYWxTdGFydDogZXZlbnQuZGF0YS5pbnN0YW5jZS5vcmlnaW5hbFN0YXJ0LFxuICAgICAgICB9O1xuICAgICAgICBhY3RpdmVJbnN0YW5jZUlkID0gZXZlbnRJZDtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFsbG93TWVyZ2UgJiYgIWV2ZW50LnZhbHVlICYmIGxhc3RJbnN0YW5jZSAmJiBhY3RpdmVJbnN0YW5jZUlkID09PSBldmVudElkKSB7XG4gICAgICAgIC8vIFRoZSBhY3RpdmUgaW5zdGFuY2Ugc3RvcHBlZCBwbGF5aW5nLCBidXQgYW5vdGhlciBpcyBzdGlsbCBwbGF5aW5nXG4gICAgICAgIGNvbnN0IGxhdGVzdEluc3RhbmNlID0gXy5yZWR1Y2UoYWN0aXZlSW5zdGFuY2VzLCAobWVtbywgaW5zdGFuY2VFdmVudCwgaWQpID0+IHtcbiAgICAgICAgICAgIGlmIChtZW1vID09PSBudWxsIHx8IG1lbW8uZXZlbnQudGltZSA8IGluc3RhbmNlRXZlbnQudGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBpbnN0YW5jZUV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9LCBudWxsKTtcbiAgICAgICAgaWYgKGxhdGVzdEluc3RhbmNlKSB7XG4gICAgICAgICAgICAvLyBSZXN0YXJ0IHRoYXQgaW5zdGFuY2Ugbm93OlxuICAgICAgICAgICAgbGFzdEluc3RhbmNlLmVuZCA9IGV2ZW50LnRpbWU7XG4gICAgICAgICAgICByZXR1cm5JbnN0YW5jZSA9IHtcbiAgICAgICAgICAgICAgICBpZDogZXZlbnRJZCArICdfJyArIGdldElkKCksXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGV2ZW50LnRpbWUsXG4gICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGxhdGVzdEluc3RhbmNlLmV2ZW50LnJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFbmQ6IGV2ZW50LmRhdGEuaW5zdGFuY2Uub3JpZ2luYWxFbmQsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydDogZXZlbnQuZGF0YS5pbnN0YW5jZS5vcmlnaW5hbFN0YXJ0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFjdGl2ZUluc3RhbmNlSWQgPSBsYXRlc3RJbnN0YW5jZS5pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhbGxvd01lcmdlICYmICFhbGxvd1plcm9HYXBzICYmIGxhc3RJbnN0YW5jZSAmJiBsYXN0SW5zdGFuY2UuZW5kID09PSBldmVudC50aW1lKSB7XG4gICAgICAgIC8vIFRoZSBwcmV2aW91c2x5IHJ1bm5pbmcgZW5kZWQganVzdCBub3dcbiAgICAgICAgLy8gcmVzdW1lIHByZXZpb3VzIGluc3RhbmNlOlxuICAgICAgICBsYXN0SW5zdGFuY2UuZW5kID0gbnVsbDtcbiAgICAgICAgbGFzdEluc3RhbmNlLnJlZmVyZW5jZXMgPSBqb2luUmVmZXJlbmNlcyhsYXN0SW5zdGFuY2UucmVmZXJlbmNlcywgZXZlbnQucmVmZXJlbmNlcyk7XG4gICAgICAgIGFkZENhcHNUb1Jlc3VtaW5nKGxhc3RJbnN0YW5jZSwgZXZlbnQuZGF0YS5pbnN0YW5jZS5jYXBzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWxhc3RJbnN0YW5jZSB8fCBsYXN0SW5zdGFuY2UuZW5kICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIHByZXZpb3VzbHkgcnVubmluZyBpbnN0YW5jZVxuICAgICAgICAvLyBTdGFydCBhIG5ldyBpbnN0YW5jZTpcbiAgICAgICAgcmV0dXJuSW5zdGFuY2UgPSB7XG4gICAgICAgICAgICBpZDogZXZlbnRJZCxcbiAgICAgICAgICAgIHN0YXJ0OiBldmVudC50aW1lLFxuICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgcmVmZXJlbmNlczogZXZlbnQucmVmZXJlbmNlcyxcbiAgICAgICAgICAgIGNhcHM6IGV2ZW50LmRhdGEuaW5zdGFuY2UuY2FwcyxcbiAgICAgICAgICAgIG9yaWdpbmFsRW5kOiBldmVudC5kYXRhLmluc3RhbmNlLm9yaWdpbmFsRW5kLFxuICAgICAgICAgICAgb3JpZ2luYWxTdGFydDogZXZlbnQuZGF0YS5pbnN0YW5jZS5vcmlnaW5hbFN0YXJ0LFxuICAgICAgICB9O1xuICAgICAgICBhY3RpdmVJbnN0YW5jZUlkID0gZXZlbnRJZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIGFscmVhZHkgYSBydW5uaW5nIGluc3RhbmNlXG4gICAgICAgIGxhc3RJbnN0YW5jZS5yZWZlcmVuY2VzID0gam9pblJlZmVyZW5jZXMobGFzdEluc3RhbmNlLnJlZmVyZW5jZXMsIGV2ZW50LnJlZmVyZW5jZXMpO1xuICAgICAgICBhZGRDYXBzVG9SZXN1bWluZyhsYXN0SW5zdGFuY2UsIGV2ZW50LmRhdGEuaW5zdGFuY2UuY2Fwcyk7XG4gICAgfVxuICAgIGlmIChsYXN0SW5zdGFuY2UgJiYgbGFzdEluc3RhbmNlLmNhcHMgJiYgIWxhc3RJbnN0YW5jZS5jYXBzLmxlbmd0aClcbiAgICAgICAgZGVsZXRlIGxhc3RJbnN0YW5jZS5jYXBzO1xuICAgIGlmIChyZXR1cm5JbnN0YW5jZSAmJlxuICAgICAgICBsYXN0SW5zdGFuY2UgJiZcbiAgICAgICAgbGFzdEluc3RhbmNlLnN0YXJ0ID09PSBsYXN0SW5zdGFuY2UuZW5kICYmXG4gICAgICAgIGxhc3RJbnN0YW5jZS5lbmQgPT09IHJldHVybkluc3RhbmNlLnN0YXJ0KSB7XG4gICAgICAgIC8vIHJlcGxhY2UgdGhlIHByZXZpb3VzIHplcm8tbGVuZ3RoIHdpdGggdGhpcyBvbmUgaW5zdGVhZFxuICAgICAgICBsYXN0SW5zdGFuY2UuaWQgPSByZXR1cm5JbnN0YW5jZS5pZDtcbiAgICAgICAgbGFzdEluc3RhbmNlLnN0YXJ0ID0gcmV0dXJuSW5zdGFuY2Uuc3RhcnQ7XG4gICAgICAgIGxhc3RJbnN0YW5jZS5lbmQgPSByZXR1cm5JbnN0YW5jZS5lbmQ7XG4gICAgICAgIGxhc3RJbnN0YW5jZS5yZWZlcmVuY2VzID0gcmV0dXJuSW5zdGFuY2UucmVmZXJlbmNlcztcbiAgICAgICAgbGFzdEluc3RhbmNlLmNhcHMgPSByZXR1cm5JbnN0YW5jZS5jYXBzO1xuICAgICAgICBsYXN0SW5zdGFuY2Uub3JpZ2luYWxTdGFydCA9IHJldHVybkluc3RhbmNlLm9yaWdpbmFsU3RhcnQ7XG4gICAgICAgIGxhc3RJbnN0YW5jZS5vcmlnaW5hbEVuZCA9IHJldHVybkluc3RhbmNlLm9yaWdpbmFsRW5kO1xuICAgICAgICByZXR1cm5JbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFjdGl2ZUluc3RhbmNlSWQsXG4gICAgICAgIHJldHVybkluc3RhbmNlLFxuICAgIH07XG59XG5mdW5jdGlvbiBpbnZlcnRJbnN0YW5jZXMoaW5zdGFuY2VzKSB7XG4gICAgaWYgKGluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgaW5zdGFuY2VzID0gY2xlYW5JbnN0YW5jZXMoaW5zdGFuY2VzLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgY29uc3QgaW52ZXJ0ZWRJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgaWYgKGluc3RhbmNlc1swXS5zdGFydCAhPT0gMCkge1xuICAgICAgICAgICAgaW52ZXJ0ZWRJbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IGdldElkKCksXG4gICAgICAgICAgICAgICAgaXNGaXJzdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogam9pblJlZmVyZW5jZXMoaW5zdGFuY2VzWzBdLnJlZmVyZW5jZXMsIGluc3RhbmNlc1swXS5pZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaV07XG4gICAgICAgICAgICBjb25zdCBsYXN0ID0gXy5sYXN0KGludmVydGVkSW5zdGFuY2VzKTtcbiAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgbGFzdC5lbmQgPSBpbnN0YW5jZS5zdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5lbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnZlcnRlZEluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGdldElkKCksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBpbnN0YW5jZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogam9pblJlZmVyZW5jZXMoaW5zdGFuY2UucmVmZXJlbmNlcywgaW5zdGFuY2UuaWQpLFxuICAgICAgICAgICAgICAgICAgICBjYXBzOiBpbnN0YW5jZS5jYXBzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnZlcnRlZEluc3RhbmNlcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IGdldElkKCksXG4gICAgICAgICAgICAgICAgaXNGaXJzdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogW10sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH1cbn1cbmV4cG9ydHMuaW52ZXJ0SW5zdGFuY2VzID0gaW52ZXJ0SW5zdGFuY2VzO1xuLyoqXG4gKiBQZXJmb3JtIGFuIGFjdGlvbiBvbiAyIGFycmF5cy4gQmVoYXZlcyBzb21ld2hhdCBsaWtlIHRoZSBcIi4qXCItb3BlcmF0b3IgaW4gTWF0bGFiXG4gKiBAcGFyYW0gYXJyYXkwXG4gKiBAcGFyYW0gYXJyYXkxXG4gKiBAcGFyYW0gb3BlcmF0ZVxuICovXG5mdW5jdGlvbiBvcGVyYXRlT25BcnJheXMoYXJyYXkwLCBhcnJheTEsIG9wZXJhdGUpIHtcbiAgICBpZiAoYXJyYXkwID09PSBudWxsIHx8IGFycmF5MSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGlzUmVmZXJlbmNlKGFycmF5MCkgJiYgaXNSZWZlcmVuY2UoYXJyYXkxKSkge1xuICAgICAgICByZXR1cm4gb3BlcmF0ZShhcnJheTAsIGFycmF5MSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IG1pbkxlbmd0aCA9IE1hdGgubWluKF8uaXNBcnJheShhcnJheTApID8gYXJyYXkwLmxlbmd0aCA6IEluZmluaXR5LCBfLmlzQXJyYXkoYXJyYXkxKSA/IGFycmF5MS5sZW5ndGggOiBJbmZpbml0eSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaW5MZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gXy5pc0FycmF5KGFycmF5MClcbiAgICAgICAgICAgID8gYXJyYXkwW2ldXG4gICAgICAgICAgICA6IHsgaWQ6ICcnLCBzdGFydDogYXJyYXkwLnZhbHVlLCBlbmQ6IGFycmF5MC52YWx1ZSwgcmVmZXJlbmNlczogYXJyYXkwLnJlZmVyZW5jZXMgfTtcbiAgICAgICAgY29uc3QgYiA9IF8uaXNBcnJheShhcnJheTEpXG4gICAgICAgICAgICA/IGFycmF5MVtpXVxuICAgICAgICAgICAgOiB7IGlkOiAnJywgc3RhcnQ6IGFycmF5MS52YWx1ZSwgZW5kOiBhcnJheTEudmFsdWUsIHJlZmVyZW5jZXM6IGFycmF5MS5yZWZlcmVuY2VzIH07XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYS5pc0ZpcnN0XG4gICAgICAgICAgICA/IHsgdmFsdWU6IGEuc3RhcnQsIHJlZmVyZW5jZXM6IGEucmVmZXJlbmNlcyB9XG4gICAgICAgICAgICA6IGIuaXNGaXJzdFxuICAgICAgICAgICAgICAgID8geyB2YWx1ZTogYi5zdGFydCwgcmVmZXJlbmNlczogYi5yZWZlcmVuY2VzIH1cbiAgICAgICAgICAgICAgICA6IG9wZXJhdGUoeyB2YWx1ZTogYS5zdGFydCwgcmVmZXJlbmNlczogam9pblJlZmVyZW5jZXMoYS5pZCwgYS5yZWZlcmVuY2VzKSB9LCB7IHZhbHVlOiBiLnN0YXJ0LCByZWZlcmVuY2VzOiBqb2luUmVmZXJlbmNlcyhiLmlkLCBiLnJlZmVyZW5jZXMpIH0pO1xuICAgICAgICBjb25zdCBlbmQgPSBhLmlzRmlyc3RcbiAgICAgICAgICAgID8gYS5lbmQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IHsgdmFsdWU6IGEuZW5kLCByZWZlcmVuY2VzOiBhLnJlZmVyZW5jZXMgfVxuICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgOiBiLmlzRmlyc3RcbiAgICAgICAgICAgICAgICA/IGIuZW5kICE9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgID8geyB2YWx1ZTogYi5lbmQsIHJlZmVyZW5jZXM6IGIucmVmZXJlbmNlcyB9XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICAgIDogb3BlcmF0ZShhLmVuZCAhPT0gbnVsbCA/IHsgdmFsdWU6IGEuZW5kLCByZWZlcmVuY2VzOiBqb2luUmVmZXJlbmNlcyhhLmlkLCBhLnJlZmVyZW5jZXMpIH0gOiBudWxsLCBiLmVuZCAhPT0gbnVsbCA/IHsgdmFsdWU6IGIuZW5kLCByZWZlcmVuY2VzOiBqb2luUmVmZXJlbmNlcyhiLmlkLCBiLnJlZmVyZW5jZXMpIH0gOiBudWxsKTtcbiAgICAgICAgaWYgKHN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IGdldElkKCksXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LnZhbHVlLFxuICAgICAgICAgICAgICAgIGVuZDogZW5kID09PSBudWxsID8gbnVsbCA6IGVuZC52YWx1ZSxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBqb2luUmVmZXJlbmNlcyhzdGFydC5yZWZlcmVuY2VzLCBlbmQgIT09IG51bGwgPyBlbmQucmVmZXJlbmNlcyA6IFtdKSxcbiAgICAgICAgICAgICAgICBjYXBzOiBqb2luQ2FwcyhhLmNhcHMsIGIuY2FwcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xlYW5JbnN0YW5jZXMocmVzdWx0LCBmYWxzZSk7XG59XG5leHBvcnRzLm9wZXJhdGVPbkFycmF5cyA9IG9wZXJhdGVPbkFycmF5cztcbmZ1bmN0aW9uIGFwcGx5UmVwZWF0aW5nSW5zdGFuY2VzKGluc3RhbmNlcywgcmVwZWF0VGltZTAsIG9wdGlvbnMpIHtcbiAgICBpZiAocmVwZWF0VGltZTAgPT09IG51bGwgfHwgIXJlcGVhdFRpbWUwLnZhbHVlKVxuICAgICAgICByZXR1cm4gaW5zdGFuY2VzO1xuICAgIGNvbnN0IHJlcGVhdFRpbWUgPSByZXBlYXRUaW1lMC52YWx1ZTtcbiAgICBpZiAoaXNSZWZlcmVuY2UoaW5zdGFuY2VzKSkge1xuICAgICAgICBpbnN0YW5jZXMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6ICcnLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBpbnN0YW5jZXMudmFsdWUsXG4gICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGluc3RhbmNlcy5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgY29uc3QgcmVwZWF0ZWRJbnN0YW5jZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlc1tpXTtcbiAgICAgICAgbGV0IHN0YXJ0VGltZSA9IE1hdGgubWF4KG9wdGlvbnMudGltZSAtICgob3B0aW9ucy50aW1lIC0gaW5zdGFuY2Uuc3RhcnQpICUgcmVwZWF0VGltZSksIGluc3RhbmNlLnN0YXJ0KTtcbiAgICAgICAgbGV0IGVuZFRpbWUgPSBpbnN0YW5jZS5lbmQgPT09IG51bGwgPyBudWxsIDogaW5zdGFuY2UuZW5kICsgKHN0YXJ0VGltZSAtIGluc3RhbmNlLnN0YXJ0KTtcbiAgICAgICAgY29uc3QgY2FwID0gKGluc3RhbmNlLmNhcHMgPyBfLmZpbmQoaW5zdGFuY2UuY2FwcywgKGNhcCkgPT4gaW5zdGFuY2UucmVmZXJlbmNlcy5pbmRleE9mKGNhcC5pZCkgIT09IC0xKSA6IG51bGwpIHx8IG51bGw7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gb3B0aW9ucy5saW1pdENvdW50IHx8IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGltaXQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGltaXRUaW1lICYmIHN0YXJ0VGltZSA+PSBvcHRpb25zLmxpbWl0VGltZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNvbnN0IGNhcHBlZFN0YXJ0VGltZSA9IGNhcCA/IE1hdGgubWF4KGNhcC5zdGFydCwgc3RhcnRUaW1lKSA6IHN0YXJ0VGltZTtcbiAgICAgICAgICAgIGNvbnN0IGNhcHBlZEVuZFRpbWUgPSBjYXAgJiYgY2FwLmVuZCAhPT0gbnVsbCAmJiBlbmRUaW1lICE9PSBudWxsID8gTWF0aC5taW4oY2FwLmVuZCwgZW5kVGltZSkgOiBlbmRUaW1lO1xuICAgICAgICAgICAgaWYgKChjYXBwZWRFbmRUaW1lICE9PSBudWxsICYmIGNhcHBlZEVuZFRpbWUgIT09IHZvaWQgMCA/IGNhcHBlZEVuZFRpbWUgOiBJbmZpbml0eSkgPiBjYXBwZWRTdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXBlYXRlZEluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGdldElkKCksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBjYXBwZWRTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogY2FwcGVkRW5kVGltZSxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogam9pblJlZmVyZW5jZXMoaW5zdGFuY2UuaWQsIGluc3RhbmNlLnJlZmVyZW5jZXMsIHJlcGVhdFRpbWUwLnJlZmVyZW5jZXMpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRUaW1lICs9IHJlcGVhdFRpbWU7XG4gICAgICAgICAgICBpZiAoZW5kVGltZSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICBlbmRUaW1lICs9IHJlcGVhdFRpbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsZWFuSW5zdGFuY2VzKHJlcGVhdGVkSW5zdGFuY2VzLCBmYWxzZSk7XG59XG5leHBvcnRzLmFwcGx5UmVwZWF0aW5nSW5zdGFuY2VzID0gYXBwbHlSZXBlYXRpbmdJbnN0YW5jZXM7XG4vKipcbiAqIENhcCBpbnN0YW5jZXMgc28gdGhhdCB0aGV5IGFyZSB3aXRoaW4gdGhlaXIgcGFyZW50SW5zdGFuY2VzXG4gKiBAcGFyYW0gaW5zdGFuY2VzXG4gKiBAcGFyYW0gcGFyZW50SW5zdGFuY2VzXG4gKi9cbmZ1bmN0aW9uIGNhcEluc3RhbmNlcyhpbnN0YW5jZXMsIHBhcmVudEluc3RhbmNlcykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIGlmIChpc1JlZmVyZW5jZShwYXJlbnRJbnN0YW5jZXMpIHx8IHBhcmVudEluc3RhbmNlcyA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlcztcbiAgICBsZXQgcmV0dXJuSW5zdGFuY2VzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2VPcmcgPSBpbnN0YW5jZXNbaV07XG4gICAgICAgIGNvbnN0IGFkZGVkSW5zdGFuY2VUaW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXJlbnRJbnN0YW5jZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHBhcmVudEluc3RhbmNlc1tqXTtcbiAgICAgICAgICAgIC8vIEZpcnN0LCBjaGVjayBpZiB0aGUgaW5zdGFuY2UgY3Jvc3NlcyB0aGUgcGFyZW50IGF0IGFsbDpcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZU9yZy5zdGFydCA8PSAoKF9hID0gcGFyZW50LmVuZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogSW5maW5pdHkpICYmICgoX2IgPSBpbnN0YW5jZU9yZy5lbmQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IEluZmluaXR5KSA+PSBwYXJlbnQuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IF8uY2xvbmUoaW5zdGFuY2VPcmcpO1xuICAgICAgICAgICAgICAgIC8vIENhcCBzdGFydFxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGFydCA8IHBhcmVudC5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRJbnN0YW5jZVN0YXJ0VGltZShpbnN0YW5jZSwgcGFyZW50LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2FwIGVuZFxuICAgICAgICAgICAgICAgIGlmICgoKF9jID0gaW5zdGFuY2UuZW5kKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBJbmZpbml0eSkgPiAoKF9kID0gcGFyZW50LmVuZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogSW5maW5pdHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEluc3RhbmNlRW5kVGltZShpbnN0YW5jZSwgcGFyZW50LmVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGFydCA+PSBwYXJlbnQuc3RhcnQgJiYgKChfZSA9IGluc3RhbmNlLmVuZCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogSW5maW5pdHkpIDw9ICgoX2YgPSBwYXJlbnQuZW5kKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBJbmZpbml0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGluc3RhbmNlIGlzIHdpdGhpbiB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGFydCA9PT0gaW5zdGFuY2UuZW5kICYmIGFkZGVkSW5zdGFuY2VUaW1lcy5oYXMoaW5zdGFuY2Uuc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBhZGQgemVyby1sZW5ndGggaW5zdGFuY2VzIGlmIHRoZXJlIGFyZSBhbHJlYWR5IGlzIGluc3RhbmNlcyBjb3ZlcmluZyB0aGF0IHRpbWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnJlZmVyZW5jZXMgPSBqb2luUmVmZXJlbmNlcyhpbnN0YW5jZS5yZWZlcmVuY2VzLCBwYXJlbnQucmVmZXJlbmNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5JbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRlZEluc3RhbmNlVGltZXMuYWRkKGluc3RhbmNlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5lbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWRJbnN0YW5jZVRpbWVzLmFkZChpbnN0YW5jZS5lbmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybkluc3RhbmNlcy5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0IC0gYi5zdGFydCk7XG4gICAgLy8gRW5zdXJlIHVuaXF1ZSBpZHM6XG4gICAgY29uc3QgaWRzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXR1cm5JbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSByZXR1cm5JbnN0YW5jZXNbaV07XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBpZiAoaWRzW2luc3RhbmNlLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5pZCA9IGluc3RhbmNlLmlkICsgKytpZHNbaW5zdGFuY2UuaWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWRzW2luc3RhbmNlLmlkXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2xlYW4gdXAgdGhlIGluc3RhbmNlcywgdG8gcmVtb3ZlIGR1cGxpY2F0ZXNcbiAgICByZXR1cm5JbnN0YW5jZXMgPSBjbGVhbkluc3RhbmNlcyhyZXR1cm5JbnN0YW5jZXMsIHRydWUsIHRydWUpO1xuICAgIHJldHVybiByZXR1cm5JbnN0YW5jZXM7XG59XG5leHBvcnRzLmNhcEluc3RhbmNlcyA9IGNhcEluc3RhbmNlcztcbmZ1bmN0aW9uIGlzUmVmZXJlbmNlKHJlZjApIHtcbiAgICBjb25zdCByZWYgPSByZWYwO1xuICAgIHJldHVybiAodHlwZW9mIHJlZiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgIV8uaXNBcnJheShyZWYpICYmXG4gICAgICAgIHJlZi52YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIF8uaXNBcnJheShyZWYucmVmZXJlbmNlcykgJiZcbiAgICAgICAgcmVmICE9PSBudWxsKTtcbn1cbmV4cG9ydHMuaXNSZWZlcmVuY2UgPSBpc1JlZmVyZW5jZTtcbmZ1bmN0aW9uIGpvaW5SZWZlcmVuY2VzKC4uLnJlZmVyZW5jZXMpIHtcbiAgICBjb25zdCByZWZNYXAgPSB7fTtcbiAgICBjb25zdCByZWZzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWZlcmVuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZSA9IHJlZmVyZW5jZXNbaV07XG4gICAgICAgIGlmIChyZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVmZXJlbmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICghcmVmTWFwW3JlZmVyZW5jZV0pXG4gICAgICAgICAgICAgICAgICAgIHJlZnMucHVzaChyZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgIHJlZk1hcFtyZWZlcmVuY2VdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVmZXJlbmNlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHJlZmVyZW5jZVtqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWZNYXBbcmVmXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZzLnB1c2gocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZk1hcFtyZWZdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVmcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGlmIChhID4gYilcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0pO1xufVxuZXhwb3J0cy5qb2luUmVmZXJlbmNlcyA9IGpvaW5SZWZlcmVuY2VzO1xuZnVuY3Rpb24gYWRkQ2Fwc1RvUmVzdW1pbmcoaW5zdGFuY2UsIC4uLmNhcHMpIHtcbiAgICBjb25zdCBjYXBzVG9BZGQgPSBbXTtcbiAgICBjb25zdCBqb2luZWRDYXBzID0gam9pbkNhcHMoLi4uY2Fwcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqb2luZWRDYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IGpvaW5lZENhcHNbaV07XG4gICAgICAgIGlmIChjYXAuZW5kICE9PSBudWxsICYmIGluc3RhbmNlLmVuZCAhPT0gbnVsbCAmJiBjYXAuZW5kID4gaW5zdGFuY2UuZW5kKSB7XG4gICAgICAgICAgICBjYXBzVG9BZGQucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IGNhcC5pZCxcbiAgICAgICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgICAgICBlbmQ6IGNhcC5lbmQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnN0YW5jZS5jYXBzID0gam9pbkNhcHMoaW5zdGFuY2UuY2FwcywgY2Fwc1RvQWRkKTtcbn1cbmV4cG9ydHMuYWRkQ2Fwc1RvUmVzdW1pbmcgPSBhZGRDYXBzVG9SZXN1bWluZztcbmZ1bmN0aW9uIGpvaW5DYXBzKC4uLmNhcHMpIHtcbiAgICBjb25zdCBjYXBNYXAgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2FwczIgPSBjYXBzW2ldO1xuICAgICAgICBpZiAoY2FwczIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2FwczIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXAyID0gY2FwczJbal07XG4gICAgICAgICAgICAgICAgY2FwTWFwW2NhcDIuaWRdID0gY2FwMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhjYXBNYXApO1xufVxuZXhwb3J0cy5qb2luQ2FwcyA9IGpvaW5DYXBzO1xubGV0IGlkQ291bnQgPSAwO1xuLyoqXG4gKiBSZXR1cm5zIGEgdW5pcXVlIGlkXG4gKi9cbmZ1bmN0aW9uIGdldElkKCkge1xuICAgIHJldHVybiAnQCcgKyAoaWRDb3VudCsrKS50b1N0cmluZygzNik7XG59XG5leHBvcnRzLmdldElkID0gZ2V0SWQ7XG5mdW5jdGlvbiByZXNldElkKCkge1xuICAgIGlkQ291bnQgPSAwO1xufVxuZXhwb3J0cy5yZXNldElkID0gcmVzZXRJZDtcbmZ1bmN0aW9uIHNldEluc3RhbmNlRW5kVGltZShpbnN0YW5jZSwgZW5kVGltZSkge1xuICAgIGluc3RhbmNlLm9yaWdpbmFsRW5kID0gaW5zdGFuY2Uub3JpZ2luYWxFbmQgIT09IHVuZGVmaW5lZCA/IGluc3RhbmNlLm9yaWdpbmFsRW5kIDogaW5zdGFuY2UuZW5kO1xuICAgIGluc3RhbmNlLmVuZCA9IGVuZFRpbWU7XG59XG5leHBvcnRzLnNldEluc3RhbmNlRW5kVGltZSA9IHNldEluc3RhbmNlRW5kVGltZTtcbmZ1bmN0aW9uIHNldEluc3RhbmNlU3RhcnRUaW1lKGluc3RhbmNlLCBzdGFydFRpbWUpIHtcbiAgICBpbnN0YW5jZS5vcmlnaW5hbFN0YXJ0ID0gaW5zdGFuY2Uub3JpZ2luYWxTdGFydCAhPT0gdW5kZWZpbmVkID8gaW5zdGFuY2Uub3JpZ2luYWxTdGFydCA6IGluc3RhbmNlLnN0YXJ0O1xuICAgIGluc3RhbmNlLnN0YXJ0ID0gc3RhcnRUaW1lO1xufVxuZXhwb3J0cy5zZXRJbnN0YW5jZVN0YXJ0VGltZSA9IHNldEluc3RhbmNlU3RhcnRUaW1lO1xuZnVuY3Rpb24gYXBwbHlQYXJlbnRJbnN0YW5jZXMocGFyZW50SW5zdGFuY2VzLCB2YWx1ZSkge1xuICAgIHJldHVybiBvcGVyYXRlT25BcnJheXMocGFyZW50SW5zdGFuY2VzLCB2YWx1ZSwgb3BlcmF0ZSk7XG59XG5leHBvcnRzLmFwcGx5UGFyZW50SW5zdGFuY2VzID0gYXBwbHlQYXJlbnRJbnN0YW5jZXM7XG5mdW5jdGlvbiBvcGVyYXRlKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gbnVsbCB8fCBiID09PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogYS52YWx1ZSArIGIudmFsdWUsXG4gICAgICAgIHJlZmVyZW5jZXM6IGpvaW5SZWZlcmVuY2VzKGEucmVmZXJlbmNlcywgYi5yZWZlcmVuY2VzKSxcbiAgICB9O1xufVxuY29uc3QgY2FjaGVSZXN1bHRDYWNoZSA9IHt9O1xubGV0IGNsZWFuQ2FjaGVSZXN1bHRUaW1lb3V0ID0gbnVsbDtcbi8qKiBDYWNoZSB0aGUgcmVzdWx0IG9mIGZ1bmN0aW9uIGZvciBhIGxpbWl0ZWQgdGltZSAqL1xuZnVuY3Rpb24gY2FjaGVSZXN1bHQobmFtZSwgZmNuLCBsaW1pdFRpbWUgPSAxMDAwKSB7XG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjAxKSB7XG4gICAgICAgIGlmIChjbGVhbkNhY2hlUmVzdWx0VGltZW91dClcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChjbGVhbkNhY2hlUmVzdWx0VGltZW91dCk7XG4gICAgICAgIGNsZWFuQ2FjaGVSZXN1bHRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjbGVhbkNhY2hlUmVzdWx0KCk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlID0gY2FjaGVSZXN1bHRDYWNoZVtuYW1lXTtcbiAgICBpZiAoIWNhY2hlIHx8IGNhY2hlLnR0bCA8IERhdGUubm93KCkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBmY24oKTtcbiAgICAgICAgY2FjaGVSZXN1bHRDYWNoZVtuYW1lXSA9IHtcbiAgICAgICAgICAgIHR0bDogRGF0ZS5ub3coKSArIGxpbWl0VGltZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLnZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuY2FjaGVSZXN1bHQgPSBjYWNoZVJlc3VsdDtcbmZ1bmN0aW9uIGNsZWFuQ2FjaGVSZXN1bHQoKSB7XG4gICAgaWYgKGNsZWFuQ2FjaGVSZXN1bHRUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChjbGVhbkNhY2hlUmVzdWx0VGltZW91dCk7XG4gICAgICAgIGNsZWFuQ2FjaGVSZXN1bHRUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgXy5lYWNoKGNhY2hlUmVzdWx0Q2FjaGUsIChjYWNoZSwgbmFtZSkgPT4ge1xuICAgICAgICBpZiAoY2FjaGUudHRsIDwgRGF0ZS5ub3coKSlcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVJlc3VsdENhY2hlW25hbWVdO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jbGVhbkNhY2hlUmVzdWx0ID0gY2xlYW5DYWNoZVJlc3VsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpYi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0T2JqZWN0UmVmZXJlbmNlcyA9IGV4cG9ydHMuaGFzaFRpbWVsaW5lT2JqZWN0ID0gZXhwb3J0cy5pbml0aWFsaXplQ2FjaGUgPSB2b2lkIDA7XG5mdW5jdGlvbiBpbml0aWFsaXplQ2FjaGUoY2FjaGVPcmcsIHJlc29sdmVkVGltZWxpbmUpIHtcbiAgICBjb25zdCBjYWNoZSA9IGNhY2hlT3JnO1xuICAgIGlmICghY2FjaGUub2JqSGFzaGVzKVxuICAgICAgICBjYWNoZS5vYmpIYXNoZXMgPSB7fTtcbiAgICBpZiAoIWNhY2hlLnJlc29sdmVkVGltZWxpbmUpXG4gICAgICAgIGNhY2hlLnJlc29sdmVkVGltZWxpbmUgPSByZXNvbHZlZFRpbWVsaW5lO1xuICAgIC8vIFRvZG86IG1ha2Ugc3RhdGlzdGljcyB3b3JrIHdoZW4gdXNpbmcgY2FjaGVcbiAgICByZXR1cm4gY2FjaGU7XG59XG5leHBvcnRzLmluaXRpYWxpemVDYWNoZSA9IGluaXRpYWxpemVDYWNoZTtcbi8qKiBSZXR1cm4gYSBcImhhc2gtc3RyaW5nXCIgd2hpY2ggY2hhbmdlcyB3aGVuZXZlciBhbnl0aGluZyB0aGF0IGFmZmVjdHMgdGltaW5nIG9mIGEgdGltZWxpbmUtb2JqZWN0IGhhcyBjaGFuZ2VkLiAqL1xuZnVuY3Rpb24gaGFzaFRpbWVsaW5lT2JqZWN0KG9iaikge1xuICAgIGNvbnN0IHRoaW5nc1RoYXRNYXR0ZXIgPSBbXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KG9iai5lbmFibGUpLFxuICAgICAgICBvYmouZGlzYWJsZWQgKyAnJyxcbiAgICAgICAgb2JqLnByaW9yaXR5ICsgJycsXG4gICAgICAgIG9iai5yZXNvbHZlZC5wYXJlbnRJZCB8fCAnJyxcbiAgICAgICAgb2JqLnJlc29sdmVkLmlzS2V5ZnJhbWUgKyAnJyxcbiAgICAgICAgb2JqLmNsYXNzZXMgPyBvYmouY2xhc3Nlcy5qb2luKCcuJykgOiAnJyxcbiAgICAgICAgb2JqLmxheWVyICsgJycsXG4gICAgICAgIG9iai5zZWFtbGVzcyArICcnLFxuICAgICAgICAvKlxuICAgICAgICBOb3RlOiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIGlnbm9yZWQsIGFzIHRoZXkgZG9uJ3QgYWZmZWN0IHRpbWluZyBvciByZXNvbHZpbmc6XG4gICAgICAgICAqIGlkXG4gICAgICAgICAqIGNoaWxkcmVuXG4gICAgICAgICAqIGtleWZyYW1lc1xuICAgICAgICAgKiBpc0dyb3VwXG4gICAgICAgICAqIGNvbnRlbnRcbiAgICAgICAgICovXG4gICAgXTtcbiAgICByZXR1cm4gdGhpbmdzVGhhdE1hdHRlci5qb2luKCcsJyk7XG59XG5leHBvcnRzLmhhc2hUaW1lbGluZU9iamVjdCA9IGhhc2hUaW1lbGluZU9iamVjdDtcbmZ1bmN0aW9uIGdldE9iamVjdFJlZmVyZW5jZXMob2JqKSB7XG4gICAgcmV0dXJuIG9iai5yZXNvbHZlZC5kaXJlY3RSZWZlcmVuY2VzO1xufVxuZXhwb3J0cy5nZXRPYmplY3RSZWZlcmVuY2VzID0gZ2V0T2JqZWN0UmVmZXJlbmNlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhY2hlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRPYmplY3RUb1Jlc29sdmVkVGltZWxpbmUgPSB2b2lkIDA7XG5mdW5jdGlvbiBhZGRPYmplY3RUb1Jlc29sdmVkVGltZWxpbmUocmVzb2x2ZWRUaW1lbGluZSwgb2JqKSB7XG4gICAgcmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzW29iai5pZF0gPSBvYmo7XG4gICAgaWYgKG9iai5jbGFzc2VzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IG9iai5jbGFzc2VzW2ldO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZWRUaW1lbGluZS5jbGFzc2VzW2NsYXNzTmFtZV0pXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkVGltZWxpbmUuY2xhc3Nlc1tjbGFzc05hbWVdID0gW107XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRUaW1lbGluZS5jbGFzc2VzW2NsYXNzTmFtZV0ucHVzaChvYmouaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvYmoubGF5ZXIpIHtcbiAgICAgICAgaWYgKCFyZXNvbHZlZFRpbWVsaW5lLmxheWVyc1tvYmoubGF5ZXJdKVxuICAgICAgICAgICAgcmVzb2x2ZWRUaW1lbGluZS5sYXllcnNbb2JqLmxheWVyXSA9IFtdO1xuICAgICAgICByZXNvbHZlZFRpbWVsaW5lLmxheWVyc1tvYmoubGF5ZXJdLnB1c2gob2JqLmlkKTtcbiAgICB9XG59XG5leHBvcnRzLmFkZE9iamVjdFRvUmVzb2x2ZWRUaW1lbGluZSA9IGFkZE9iamVjdFRvUmVzb2x2ZWRUaW1lbGluZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVFeHByZXNzaW9uID0gZXhwb3J0cy53cmFwSW5uZXJFeHByZXNzaW9ucyA9IGV4cG9ydHMuc2ltcGxpZnlFeHByZXNzaW9uID0gZXhwb3J0cy5pbnRlcnByZXRFeHByZXNzaW9uID0gZXhwb3J0cy5PUEVSQVRPUlMgPSB2b2lkIDA7XG5jb25zdCBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuLi9saWJcIik7XG5leHBvcnRzLk9QRVJBVE9SUyA9IFsnJicsICd8JywgJysnLCAnLScsICcqJywgJy8nLCAnJScsICchJ107XG5jb25zdCBSRUdFWFBfT1BFUkFUT1JTID0gXy5tYXAoZXhwb3J0cy5PUEVSQVRPUlMsIChvKSA9PiAnXFxcXCcgKyBvKS5qb2luKCcnKTtcbmZ1bmN0aW9uIGludGVycHJldEV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICAgIGlmICgoMCwgbGliXzEuaXNOdW1lcmljKShleHByZXNzaW9uKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChleHByZXNzaW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXy5pc1N0cmluZyhleHByZXNzaW9uKSkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uU3RyaW5nID0gZXhwcmVzc2lvbjtcbiAgICAgICAgcmV0dXJuICgwLCBsaWJfMS5jYWNoZVJlc3VsdCkoZXhwcmVzc2lvblN0cmluZywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhwciA9IGV4cHJlc3Npb25TdHJpbmcucmVwbGFjZShuZXcgUmVnRXhwKCcoWycgKyBSRUdFWFBfT1BFUkFUT1JTICsgJ1xcXFwoXFxcXCldKScsICdnJyksICcgJDEgJyk7IC8vIE1ha2Ugc3VyZSB0aGVyZSdzIGEgc3BhY2UgYmV0d2VlbiBldmVyeSBvcGVyYXRvciAmIG9wZXJhbmRcbiAgICAgICAgICAgIGNvbnN0IHdvcmRzID0gXy5jb21wYWN0KGV4cHIuc3BsaXQoJyAnKSk7XG4gICAgICAgICAgICBpZiAod29yZHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBlbXB0eSBleHByZXNzaW9uXG4gICAgICAgICAgICAvLyBGaXggc3BlY2lhbCBjYXNlOiBhICsgLSBiXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gd29yZHMubGVuZ3RoIC0gMjsgaSA+PSAxOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoKHdvcmRzW2ldID09PSAnLScgfHwgd29yZHNbaV0gPT09ICcrJykgJiYgd29yZElzT3BlcmF0b3IoZXhwb3J0cy5PUEVSQVRPUlMsIHdvcmRzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd29yZHNbaV0gPSB3b3Jkc1tpXSArIHdvcmRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgd29yZHMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbm5lckV4cHJlc3Npb24gPSB3cmFwSW5uZXJFeHByZXNzaW9ucyh3b3Jkcyk7XG4gICAgICAgICAgICBpZiAoaW5uZXJFeHByZXNzaW9uLnJlc3QubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW50ZXJwcmV0RXhwcmVzc2lvbjogc3ludGF4IGVycm9yOiBwYXJlbnRoZXNlcyBkb25cXCd0IGFkZCB1cCBpbiBcIicgKyBleHByICsgJ1wiLicpO1xuICAgICAgICAgICAgaWYgKGlubmVyRXhwcmVzc2lvbi5pbm5lci5sZW5ndGggJSAyICE9PSAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW50ZXJwcmV0RXhwcmVzc2lvbjogb3BlcmFuZHMgJiBvcGVyYXRvcnMgZG9uXFwndCBhZGQgdXA6IFwiJyArXG4gICAgICAgICAgICAgICAgICAgIGlubmVyRXhwcmVzc2lvbi5pbm5lci5qb2luKCcgJykgK1xuICAgICAgICAgICAgICAgICAgICAnXCIuJyk7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gd29yZHMyRXhwcmVzc2lvbihleHBvcnRzLk9QRVJBVE9SUywgaW5uZXJFeHByZXNzaW9uLmlubmVyKTtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwcmVzc2lvbihleHBvcnRzLk9QRVJBVE9SUywgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgICAgfSwgMTAwICogMTAwMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICB9XG59XG5leHBvcnRzLmludGVycHJldEV4cHJlc3Npb24gPSBpbnRlcnByZXRFeHByZXNzaW9uO1xuLyoqIFRyeSB0byBzaW1wbGlmeSBhbiBleHByZXNzaW9uLCB0aGlzIGluY2x1ZGVzOlxuICogKiBDb21iaW5lIGNvbnN0YW50IG9wZXJhbmRzLCB1c2luZyBhcml0aG1ldGljIG9wZXJhdG9yc1xuICogLi4ubW9yZSB0byBjb21lP1xuICovXG5mdW5jdGlvbiBzaW1wbGlmeUV4cHJlc3Npb24oZXhwcjApIHtcbiAgICBjb25zdCBleHByID0gXy5pc1N0cmluZyhleHByMCkgPyBpbnRlcnByZXRFeHByZXNzaW9uKGV4cHIwKSA6IGV4cHIwO1xuICAgIGlmICghZXhwcilcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgaWYgKGlzRXhwcmVzc2lvbk9iamVjdChleHByKSkge1xuICAgICAgICBjb25zdCBsID0gc2ltcGxpZnlFeHByZXNzaW9uKGV4cHIubCk7XG4gICAgICAgIGNvbnN0IG8gPSBleHByLm87XG4gICAgICAgIGNvbnN0IHIgPSBzaW1wbGlmeUV4cHJlc3Npb24oZXhwci5yKTtcbiAgICAgICAgaWYgKCgwLCBsaWJfMS5pc0NvbnN0YW50KShsKSAmJiAoMCwgbGliXzEuaXNDb25zdGFudCkocikgJiYgXy5pc051bWJlcihsKSAmJiBfLmlzTnVtYmVyKHIpKSB7XG4gICAgICAgICAgICAvLyBUaGUgb3BlcmFuZHMgY2FuIGJlIGNvbWJpbmVkOlxuICAgICAgICAgICAgcmV0dXJuIG8gPT09ICcrJ1xuICAgICAgICAgICAgICAgID8gbCArIHJcbiAgICAgICAgICAgICAgICA6IG8gPT09ICctJ1xuICAgICAgICAgICAgICAgICAgICA/IGwgLSByXG4gICAgICAgICAgICAgICAgICAgIDogbyA9PT0gJyonXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGwgKiByXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG8gPT09ICcvJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbCAvIHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG8gPT09ICclJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGwgJSByXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeyBsLCBvLCByIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbCwgbywgciB9O1xuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbn1cbmV4cG9ydHMuc2ltcGxpZnlFeHByZXNzaW9uID0gc2ltcGxpZnlFeHByZXNzaW9uO1xuZnVuY3Rpb24gaXNFeHByZXNzaW9uT2JqZWN0KGV4cHIpIHtcbiAgICByZXR1cm4gdHlwZW9mIGV4cHIgPT09ICdvYmplY3QnICYmIF8uaGFzKGV4cHIsICdsJykgJiYgXy5oYXMoZXhwciwgJ28nKSAmJiBfLmhhcyhleHByLCAncicpO1xufVxuZnVuY3Rpb24gd29yZElzT3BlcmF0b3Iob3BlcmF0b3JMaXN0LCB3b3JkKSB7XG4gICAgaWYgKG9wZXJhdG9yTGlzdC5pbmRleE9mKHdvcmQpICE9PSAtMSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gVHVybnMgWydhJywgJygnLCAnYicsICdjJywgJyknXSBpbnRvIFsnYScsIFsnYicsICdjJ11dXG4vLyBvciBbJ2EnLCAnJicsICchJywgJ2InXSBpbnRvIFsnYScsICcmJywgWycnLCAnIScsICdiJ11dXG5mdW5jdGlvbiB3cmFwSW5uZXJFeHByZXNzaW9ucyh3b3Jkcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHdvcmRzW2ldID09PSAnKCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IHdyYXBJbm5lckV4cHJlc3Npb25zKHdvcmRzLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAvLyBpbnNlcnQgaW5uZXIgZXhwcmVzc2lvbiBhbmQgcmVtb3ZlIHRoYVxuICAgICAgICAgICAgd29yZHNbaV0gPSB0bXAuaW5uZXI7XG4gICAgICAgICAgICB3b3Jkcy5zcGxpY2UoaSArIDEsIDk5OTk5LCAuLi50bXAucmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod29yZHNbaV0gPT09ICcpJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbm5lcjogd29yZHMuc2xpY2UoMCwgaSksXG4gICAgICAgICAgICAgICAgcmVzdDogd29yZHMuc2xpY2UoaSArIDEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3b3Jkc1tpXSA9PT0gJyEnKSB7XG4gICAgICAgICAgICBjb25zdCB0bXAgPSB3cmFwSW5uZXJFeHByZXNzaW9ucyh3b3Jkcy5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGlubmVyIGV4cHJlc3Npb24gYWZ0ZXIgdGhlICchJ1xuICAgICAgICAgICAgd29yZHNbaV0gPSBbJycsICchJ10uY29uY2F0KHRtcC5pbm5lcik7XG4gICAgICAgICAgICB3b3Jkcy5zcGxpY2UoaSArIDEsIDk5OTk5LCAuLi50bXAucmVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5uZXI6IHdvcmRzLFxuICAgICAgICByZXN0OiBbXSxcbiAgICB9O1xufVxuZXhwb3J0cy53cmFwSW5uZXJFeHByZXNzaW9ucyA9IHdyYXBJbm5lckV4cHJlc3Npb25zO1xuZnVuY3Rpb24gd29yZHMyRXhwcmVzc2lvbihvcGVyYXRvckxpc3QsIHdvcmRzKSB7XG4gICAgaWYgKCF3b3JkcyB8fCAhd29yZHMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dvcmRzMkV4cHJlc3Npb246IHN5bnRheCBlcnJvcjogdW5iYWxhbmNlZCBleHByZXNzaW9uJyk7XG4gICAgd2hpbGUgKHdvcmRzLmxlbmd0aCA9PT0gMSAmJiBfLmlzQXJyYXkod29yZHNbMF0pKVxuICAgICAgICB3b3JkcyA9IHdvcmRzWzBdO1xuICAgIGlmICh3b3Jkcy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiB3b3Jkc1swXTtcbiAgICAvLyBGaW5kIHRoZSBvcGVyYXRvciB3aXRoIHRoZSBoaWdoZXN0IHByaW9yaXR5OlxuICAgIGxldCBvcGVyYXRvckkgPSAtMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wZXJhdG9yTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvcGVyYXRvciA9IG9wZXJhdG9yTGlzdFtpXTtcbiAgICAgICAgaWYgKG9wZXJhdG9ySSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG9wZXJhdG9ySSA9IHdvcmRzLmxhc3RJbmRleE9mKG9wZXJhdG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3BlcmF0b3JJICE9PSAtMSkge1xuICAgICAgICBjb25zdCBsID0gd29yZHMuc2xpY2UoMCwgb3BlcmF0b3JJKTtcbiAgICAgICAgY29uc3QgciA9IHdvcmRzLnNsaWNlKG9wZXJhdG9ySSArIDEpO1xuICAgICAgICBjb25zdCBleHByID0ge1xuICAgICAgICAgICAgbDogd29yZHMyRXhwcmVzc2lvbihvcGVyYXRvckxpc3QsIGwpLFxuICAgICAgICAgICAgbzogd29yZHNbb3BlcmF0b3JJXSxcbiAgICAgICAgICAgIHI6IHdvcmRzMkV4cHJlc3Npb24ob3BlcmF0b3JMaXN0LCByKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3b3JkczJFeHByZXNzaW9uOiBzeW50YXggZXJyb3I6IG9wZXJhdG9yIG5vdCBmb3VuZDogXCInICsgd29yZHMuam9pbignICcpICsgJ1wiJyk7XG59XG4vKiogVmFsaWRhdGVzIGFuIGV4cHJlc3Npb24uIFJldHVybnMgdHJ1ZSBvbiBzdWNjZXNzLCB0aHJvd3MgZXJyb3IgaWYgbm90ICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cHJlc3Npb24ob3BlcmF0b3JMaXN0LCBleHByMCwgYnJlYWRjcnVtYnMpIHtcbiAgICBpZiAoIWJyZWFkY3J1bWJzKVxuICAgICAgICBicmVhZGNydW1icyA9ICdST09UJztcbiAgICBpZiAoXy5pc09iamVjdChleHByMCkgJiYgIV8uaXNBcnJheShleHByMCkpIHtcbiAgICAgICAgY29uc3QgZXhwciA9IGV4cHIwO1xuICAgICAgICBpZiAoIV8uaGFzKGV4cHIsICdsJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbGlkYXRlRXhwcmVzc2lvbjogJHticmVhZGNydW1ic30ubCBtaXNzaW5nIGluICR7SlNPTi5zdHJpbmdpZnkoZXhwcil9YCk7XG4gICAgICAgIGlmICghXy5oYXMoZXhwciwgJ28nKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsaWRhdGVFeHByZXNzaW9uOiAke2JyZWFkY3J1bWJzfS5vIG1pc3NpbmcgaW4gJHtKU09OLnN0cmluZ2lmeShleHByKX1gKTtcbiAgICAgICAgaWYgKCFfLmhhcyhleHByLCAncicpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YWxpZGF0ZUV4cHJlc3Npb246ICR7YnJlYWRjcnVtYnN9LnIgbWlzc2luZyBpbiAke0pTT04uc3RyaW5naWZ5KGV4cHIpfWApO1xuICAgICAgICBpZiAoIV8uaXNTdHJpbmcoZXhwci5vKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsaWRhdGVFeHByZXNzaW9uOiAke2JyZWFkY3J1bWJzfS5vIG5vdCBhIHN0cmluZ2ApO1xuICAgICAgICBpZiAoIXdvcmRJc09wZXJhdG9yKG9wZXJhdG9yTGlzdCwgZXhwci5vKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihicmVhZGNydW1icyArICcubyBub3QgdmFsaWQ6IFwiJyArIGV4cHIubyArICdcIicpO1xuICAgICAgICByZXR1cm4gKHZhbGlkYXRlRXhwcmVzc2lvbihvcGVyYXRvckxpc3QsIGV4cHIubCwgYnJlYWRjcnVtYnMgKyAnLmwnKSAmJlxuICAgICAgICAgICAgdmFsaWRhdGVFeHByZXNzaW9uKG9wZXJhdG9yTGlzdCwgZXhwci5yLCBicmVhZGNydW1icyArICcucicpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIV8uaXNOdWxsKGV4cHIwKSAmJiAhXy5pc1N0cmluZyhleHByMCkgJiYgIV8uaXNOdW1iZXIoZXhwcjApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsaWRhdGVFeHByZXNzaW9uOiAke2JyZWFkY3J1bWJzfSBpcyBvZiBpbnZhbGlkIHR5cGVgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLnZhbGlkYXRlRXhwcmVzc2lvbiA9IHZhbGlkYXRlRXhwcmVzc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cHJlc3Npb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmxvb2t1cEV4cHJlc3Npb24gPSBleHBvcnRzLnJlc29sdmVUaW1lbGluZU9iaiA9IGV4cG9ydHMuUmVzb2x2ZXIgPSB2b2lkIDA7XG5jb25zdCBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuLi9saWJcIik7XG5jb25zdCB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGVcIik7XG5jb25zdCBleHByZXNzaW9uXzEgPSByZXF1aXJlKFwiLi9leHByZXNzaW9uXCIpO1xuY29uc3Qgc3RhdGVfMSA9IHJlcXVpcmUoXCIuL3N0YXRlXCIpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG5jb25zdCBjYWNoZV8xID0gcmVxdWlyZShcIi4vY2FjaGVcIik7XG5jbGFzcyBSZXNvbHZlciB7XG4gICAgLyoqXG4gICAgICogR28gdGhyb3VnaCBhbGwgb2JqZWN0cyBvbiB0aGUgdGltZWxpbmUgYW5kIGNhbGN1bGF0ZSBhbGwgdGhlIHRpbWluZ3MuXG4gICAgICogUmV0dXJucyBhIFJlc29sdmVkVGltZWxpbmUgd2hpY2ggY2FuIGJlIHBpcGVkIGludG8gUmVzb2x2ZXIuZ2V0U3RhdGUoKVxuICAgICAqIEBwYXJhbSB0aW1lbGluZSBBcnJheSBvZiB0aW1lbGluZSBvYmplY3RzXG4gICAgICogQHBhcmFtIG9wdGlvbnMgUmVzb2x2ZSBvcHRpb25zXG4gICAgICovXG4gICAgc3RhdGljIHJlc29sdmVUaW1lbGluZSh0aW1lbGluZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIV8uaXNBcnJheSh0aW1lbGluZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc29sdmVUaW1lbGluZTogcGFyYW1ldGVyIHRpbWVsaW5lIG1pc3NpbmcnKTtcbiAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXNvbHZlVGltZWxpbmU6IHBhcmFtZXRlciBvcHRpb25zIG1pc3NpbmcnKTtcbiAgICAgICAgKDAsIHZhbGlkYXRlXzEudmFsaWRhdGVUaW1lbGluZSkodGltZWxpbmUsIGZhbHNlKTtcbiAgICAgICAgKDAsIGxpYl8xLnJlc2V0SWQpKCk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkVGltZWxpbmUgPSB7XG4gICAgICAgICAgICBvcHRpb25zOiB7IC4uLm9wdGlvbnMgfSxcbiAgICAgICAgICAgIG9iamVjdHM6IHt9LFxuICAgICAgICAgICAgY2xhc3Nlczoge30sXG4gICAgICAgICAgICBsYXllcnM6IHt9LFxuICAgICAgICAgICAgc3RhdGlzdGljczoge1xuICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRDb3VudDogMCxcbiAgICAgICAgICAgICAgICByZXNvbHZlZENvdW50OiAwLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkSW5zdGFuY2VDb3VudDogMCxcbiAgICAgICAgICAgICAgICByZXNvbHZlZE9iamVjdENvdW50OiAwLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkR3JvdXBDb3VudDogMCxcbiAgICAgICAgICAgICAgICByZXNvbHZlZEtleWZyYW1lQ291bnQ6IDAsXG4gICAgICAgICAgICAgICAgcmVzb2x2aW5nQ291bnQ6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBTdGVwIDE6IHByZS1wb3B1bGF0ZSByZXNvbHZlZFRpbWVsaW5lIHdpdGggb2JqZWN0c1xuICAgICAgICBjb25zdCBhZGRUb1Jlc29sdmVkVGltZWxpbmUgPSAob2JqLCBsZXZlbERlZXAsIHBhcmVudElkLCBpc0tleWZyYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzW29iai5pZF0pXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEFsbCB0aW1lbGluZU9iamVjdHMgbXVzdCBiZSB1bmlxdWUhIChkdXBsaWNhdGU6IFwiJHtvYmouaWR9XCIpYCk7XG4gICAgICAgICAgICBjb25zdCBvID0gKDAsIGxpYl8xLmV4dGVuZE1hbmRhZG9yeSkoXy5jbG9uZShvYmopLCB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBsZXZlbERlZXA6IGxldmVsRGVlcCxcbiAgICAgICAgICAgICAgICAgICAgaXNTZWxmUmVmZXJlbmNpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3RSZWZlcmVuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICBvLnJlc29sdmVkLnBhcmVudElkID0gcGFyZW50SWQ7XG4gICAgICAgICAgICAgICAgby5yZXNvbHZlZC5kaXJlY3RSZWZlcmVuY2VzLnB1c2gocGFyZW50SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzS2V5ZnJhbWUpXG4gICAgICAgICAgICAgICAgby5yZXNvbHZlZC5pc0tleWZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hZGRPYmplY3RUb1Jlc29sdmVkVGltZWxpbmUpKHJlc29sdmVkVGltZWxpbmUsIG8pO1xuICAgICAgICAgICAgLy8gQWRkIGNoaWxkcmVuOlxuICAgICAgICAgICAgaWYgKG9iai5pc0dyb3VwICYmIG9iai5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gb2JqLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBhZGRUb1Jlc29sdmVkVGltZWxpbmUoY2hpbGQsIGxldmVsRGVlcCArIDEsIG9iai5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIGtleWZyYW1lczpcbiAgICAgICAgICAgIGlmIChvYmoua2V5ZnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoua2V5ZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleWZyYW1lID0gb2JqLmtleWZyYW1lc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2YyID0gKDAsIGxpYl8xLmV4dGVuZE1hbmRhZG9yeSkoXy5jbG9uZShrZXlmcmFtZSksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRvUmVzb2x2ZWRUaW1lbGluZShrZjIsIGxldmVsRGVlcCArIDEsIG9iai5pZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBvYmogPSB0aW1lbGluZVtpXTtcbiAgICAgICAgICAgIGFkZFRvUmVzb2x2ZWRUaW1lbGluZShvYmosIDApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0ZXAgMjogZ28gdGhvdWdoIGFuZCByZXNvbHZlIHRoZSBvYmplY3RzXG4gICAgICAgIGlmIChvcHRpb25zLmNhY2hlKSB7XG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIG9iamVjdHMgaGFzIGNoYW5nZWQgc2luY2UgbGFzdCB0aW1lXG4gICAgICAgICAgICBjb25zdCBjYWNoZSA9ICgwLCBjYWNoZV8xLmluaXRpYWxpemVDYWNoZSkob3B0aW9ucy5jYWNoZSwgcmVzb2x2ZWRUaW1lbGluZSk7XG4gICAgICAgICAgICAvLyBHbyB0aHJvdWdoIGFsbCBuZXcgb2JqZWN0cywgYW5kIGRldGVybWluZSB3aGV0aGVyIHRoZXkgaGF2ZSBjaGFuZ2VkOlxuICAgICAgICAgICAgY29uc3QgYWxsTmV3T2JqZWN0cyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlZFJlZmVyZW5jZXMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGdldEFsbFJlZmVyZW5jZXNUaGlzT2JqZWN0QWZmZWN0cyA9IChuZXdPYmopID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWZlcmVuY2VzID0gWycjJyArIG5ld09iai5pZF07XG4gICAgICAgICAgICAgICAgaWYgKG5ld09iai5jbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2xhc3NOYW1lIG9mIG5ld09iai5jbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goJy4nICsgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3T2JqLmxheWVyKVxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goJyQnICsgbmV3T2JqLmxheWVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmZXJlbmNlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBhZGRDaGFuZ2VkT2JqZWN0ID0gKG9iaikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZXMgPSBnZXRBbGxSZWZlcmVuY2VzVGhpc09iamVjdEFmZmVjdHMob2JqKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRSZWZlcmVuY2VzW3JlZl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9iaiBvZiBPYmplY3QudmFsdWVzKHJlc29sdmVkVGltZWxpbmUub2JqZWN0cykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRIYXNoID0gY2FjaGUub2JqSGFzaGVzW29iai5pZF07XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SGFzaCA9ICgwLCBjYWNoZV8xLmhhc2hUaW1lbGluZU9iamVjdCkob2JqKTtcbiAgICAgICAgICAgICAgICBhbGxOZXdPYmplY3RzW29iai5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghb2xkSGFzaCB8fCBvbGRIYXNoICE9PSBuZXdIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLm9iakhhc2hlc1tvYmouaWRdID0gbmV3SGFzaDtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2hhbmdlZE9iamVjdChvYmopO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRPYmogPSBjYWNoZS5yZXNvbHZlZFRpbWVsaW5lLm9iamVjdHNbb2JqLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZE9iailcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENoYW5nZWRPYmplY3Qob2xkT2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHRpbWluZy1hZmZlY3RpbmcgY2hhbmdlcyBkZXRlY3RlZFxuICAgICAgICAgICAgICAgICAgICAvLyBFdmVuIHRob3VnaCB0aGUgdGltZWxpbmUtcHJvcGVydGllcyBoYXNuJ3QgY2hhbmdlZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNvbnRlbnQgKGFuZCBvdGhlciBwcm9wZXJ0aWVzKSBtaWdodCBoYXZlOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRPYmogPSBjYWNoZS5yZXNvbHZlZFRpbWVsaW5lLm9iamVjdHNbb2JqLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUucmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzW29iai5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vYmosXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZDogb2xkT2JqLnJlc29sdmVkLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWNoZS5oYXNPbGREYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBhbGwgb2xkIGhhc2hlcywgcmVtb3ZpbmcgdGhlIG9uZXMgdGhhdCBkb2Vzbid0IGV4aXN0IGFueW1vcmVcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG9iaklkIGluIGNhY2hlLnJlc29sdmVkVGltZWxpbmUub2JqZWN0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbE5ld09iamVjdHNbb2JqSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvYmogPSBjYWNoZS5yZXNvbHZlZFRpbWVsaW5lLm9iamVjdHNbb2JqSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlLm9iakhhc2hlc1tvYmpJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDaGFuZ2VkT2JqZWN0KG9iaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSBvYmplY3RzLCBieSBncmFkdWFsbHkgcmVtb3ZpbmcgdGhlIGludmFsaWRhdGVkIG9uZXMgZnJvbSB2YWxpZE9iamVjdHNcbiAgICAgICAgICAgICAgICAvLyBQcmVwYXJlIHZhbGlkT2JqZWN0czpcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZE9iamVjdHMgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG9iaiBvZiBPYmplY3QudmFsdWVzKHJlc29sdmVkVGltZWxpbmUub2JqZWN0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRPYmplY3RzW29iai5pZF0gPSBvYmo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qKiBBbGwgcmVmZXJlbmNlcyB0aGF0IGRlcGVuZCBvbiBhbm90aGVyIHJlZmVyZW5jZSAoaWUgb2JqZWN0cywgY2xhc3NzIG9yIGxheWVycyk6ICovXG4gICAgICAgICAgICAgICAgY29uc3QgYWZmZWN0UmVmZXJlbmNlTWFwID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBvYmogb2YgT2JqZWN0LnZhbHVlcyhyZXNvbHZlZFRpbWVsaW5lLm9iamVjdHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBldmVyeXRoaW5nIHRoYXQgdGhpcyBvYmplY3QgYWZmZWN0czpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkT2JqID0gY2FjaGUucmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzW29iai5pZF07XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZmZlY3RlZFJlZmVyZW5jZXMgPSBnZXRBbGxSZWZlcmVuY2VzVGhpc09iamVjdEFmZmVjdHMob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRSZWZlcmVuY2VzID0gXy51bmlxKGFmZmVjdGVkUmVmZXJlbmNlcy5jb25jYXQoZ2V0QWxsUmVmZXJlbmNlc1RoaXNPYmplY3RBZmZlY3RzKGNhY2hlZE9iaikpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFmZmVjdGVkUmVmZXJlbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gYWZmZWN0ZWRSZWZlcmVuY2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqUmVmID0gJyMnICsgb2JqLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZiAhPT0gb2JqUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhZmZlY3RSZWZlcmVuY2VNYXBbb2JqUmVmXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0UmVmZXJlbmNlTWFwW29ialJlZl0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RSZWZlcmVuY2VNYXBbb2JqUmVmXS5wdXNoKHJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGV2ZXJ5dGhpbmcgdGhhdCB0aGlzIG9iamVjdCBpcyBhZmZlY3RlZCBieTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZWRSZWZlcmVuY2VzWycjJyArIG9iai5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvYmplY3QgaXMgZGlyZWN0bHkgc2FpZCB0byBiZSBpbnZhbGlkLCBubyBuZWVkIHRvIGFkZCBpdCB0byByZWZlcmVuY2luZ09iamVjdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBpdCdsbCBiZSBlYXNpbHkgaW52YWxpZGF0ZWQgYW55d2F5IGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiB3ZSBvbmx5IGhhdmUgdG8gY2hlY2sgZm9yIHRoZSBPTEQgb2JqZWN0LCBzaW5jZSBpZiB0aGUgb2xkIGFuZCB0aGUgbmV3IG9iamVjdCBkaWZmZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCB3b3VsZCBtZWFuIGl0J2xsIGJlIGRpcmVjdGx5IGludmFsaWRhdGVkIGFueXdheS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWRPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGZXRjaCBhbGwgcmVmZXJlbmNlcyBmb3IgdGhlIG9iamVjdCBmcm9tIHRoZSBsYXN0IHRpbWUgaXQgd2FzIHJlc29sdmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IFRoaXMgY2FuIGJlIGRvbmUsIHNpbmNlIF9pZl8gdGhlIG9iamVjdCB3YXMgY2hhbmdlZCBpbiBhbnkgd2F5IHNpbmNlIGxhc3QgcmVzb2x2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J2xsIGJlIGludmFsaWRhdGVkIGFueXdheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlcGVuZE9uUmVmZXJlbmNlcyA9ICgwLCBjYWNoZV8xLmdldE9iamVjdFJlZmVyZW5jZXMpKGNhY2hlZE9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBlbmRPblJlZmVyZW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gZGVwZW5kT25SZWZlcmVuY2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFmZmVjdFJlZmVyZW5jZU1hcFtyZWZdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0UmVmZXJlbmNlTWFwW3JlZl0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0UmVmZXJlbmNlTWFwW3JlZl0ucHVzaCgnIycgKyBvYmouaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJbnZhbGlkYXRlIGFsbCBjaGFuZ2VkIG9iamVjdHMsIGFuZCByZWN1cnNpdmVseSBpbnZhbGlkYXRlIGFsbCBvYmplY3RzIHRoYXQgcmVmZXJlbmNlIHRob3NlIG9iamVjdHM6XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlZFJlZmVyZW5jZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlZmVyZW5jZSBvZiBPYmplY3Qua2V5cyhjaGFuZ2VkUmVmZXJlbmNlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZGF0ZU9iamVjdHNXaXRoUmVmZXJlbmNlKGhhbmRsZWRSZWZlcmVuY2VzLCByZWZlcmVuY2UsIGFmZmVjdFJlZmVyZW5jZU1hcCwgdmFsaWRPYmplY3RzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlIG9iamVjdHMgdGhhdCBhcmUgbGVmdCBpbiB2YWxpZE9iamVjdHMgYXQgdGhpcyBwb2ludCBhcmUgc3RpbGwgdmFsaWQuXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIHJldXNlIHRoZSBvbGQgcmVzb2x2aW5nIGZvciB0aG9zZTpcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG9iaiBvZiBPYmplY3QudmFsdWVzKHZhbGlkT2JqZWN0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWNoZS5yZXNvbHZlZFRpbWVsaW5lLm9iamVjdHNbb2JqLmlkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU29tZXRoaW5nIHdlbnQgd3Jvbmc6IFwiJHtvYmouaWR9XCIgZG9lcyBub3QgZXhpc3QgaW4gY2FjaGUucmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzYCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkVGltZWxpbmUub2JqZWN0c1tvYmouaWRdID0gY2FjaGUucmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzW29iai5pZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBvYmogb2YgT2JqZWN0LnZhbHVlcyhyZXNvbHZlZFRpbWVsaW5lLm9iamVjdHMpKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVRpbWVsaW5lT2JqKHJlc29sdmVkVGltZWxpbmUsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTYXZlIGZvciBuZXh0IHRpbWU6XG4gICAgICAgICAgICBjYWNoZS5yZXNvbHZlZFRpbWVsaW5lID0gcmVzb2x2ZWRUaW1lbGluZTtcbiAgICAgICAgICAgIGNhY2hlLmhhc09sZERhdGEgPSB0cnVlO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHN0YXRpc3RpY3MsIHNpbmNlIHRoYXQncyBub3QgYWNjdXJhdGUgYWZ0ZXIgaGF2aW5nIHVzZWQgdGhlIGNhY2hlOlxuICAgICAgICAgICAgcmVzb2x2ZWRUaW1lbGluZS5zdGF0aXN0aWNzLnVucmVzb2x2ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICByZXNvbHZlZFRpbWVsaW5lLnN0YXRpc3RpY3MucmVzb2x2ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICByZXNvbHZlZFRpbWVsaW5lLnN0YXRpc3RpY3MucmVzb2x2ZWRJbnN0YW5jZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHJlc29sdmVkVGltZWxpbmUuc3RhdGlzdGljcy5yZXNvbHZlZE9iamVjdENvdW50ID0gMDtcbiAgICAgICAgICAgIHJlc29sdmVkVGltZWxpbmUuc3RhdGlzdGljcy5yZXNvbHZlZEdyb3VwQ291bnQgPSAwO1xuICAgICAgICAgICAgcmVzb2x2ZWRUaW1lbGluZS5zdGF0aXN0aWNzLnJlc29sdmVkS2V5ZnJhbWVDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9iaiBvZiBPYmplY3QudmFsdWVzKHJlc29sdmVkVGltZWxpbmUub2JqZWN0cykpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVTdGF0aXN0aWNzKHJlc29sdmVkVGltZWxpbmUsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRUaW1lbGluZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBjYWNoZSBwcm92aWRlZCwganVzdCByZXNvbHZlIGFsbCBvYmplY3RzOlxuICAgICAgICAgICAgZm9yIChjb25zdCBvYmogb2YgT2JqZWN0LnZhbHVlcyhyZXNvbHZlZFRpbWVsaW5lLm9iamVjdHMpKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVRpbWVsaW5lT2JqKHJlc29sdmVkVGltZWxpbmUsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRUaW1lbGluZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQ2FsY3VsYXRlIHRoZSBzdGF0ZSBmb3IgYWxsIHBvaW50cyBpbiB0aW1lLiAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZUFsbFN0YXRlcyhyZXNvbHZlZFRpbWVsaW5lLCBjYWNoZSkge1xuICAgICAgICByZXR1cm4gKDAsIHN0YXRlXzEucmVzb2x2ZVN0YXRlcykocmVzb2x2ZWRUaW1lbGluZSwgY2FjaGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHN0YXRlIGF0IGEgZ2l2ZW4gcG9pbnQgaW4gdGltZS5cbiAgICAgKiBVc2luZyBhIFJlc29sdmVkVGltZWxpbmUgY2FsY3VsYXRlZCBieSBSZXNvbHZlci5yZXNvbHZlVGltZWxpbmUoKSBvclxuICAgICAqIGEgUmVzb2x2ZWRTdGF0ZXMgY2FsY3VsYXRlZCBieSBSZXNvbHZlci5yZXNvbHZlQWxsU3RhdGVzKClcbiAgICAgKiBAcGFyYW0gcmVzb2x2ZWQgUmVzb2x2ZWRUaW1lbGluZSBjYWxjdWxhdGVkIGJ5IFJlc29sdmVyLnJlc29sdmVUaW1lbGluZS5cbiAgICAgKiBAcGFyYW0gdGltZSBUaGUgcG9pbnQgaW4gdGltZSB3aGVyZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlXG4gICAgICogQHBhcmFtIGV2ZW50TGltaXQgKE9wdGlvbmFsKSBMaW1pdHMgdGhlIG51bWJlciBvZiByZXR1cm5lZCB1cGNvbWluZyBldmVudHMuXG4gICAgICovXG4gICAgc3RhdGljIGdldFN0YXRlKHJlc29sdmVkLCB0aW1lLCBldmVudExpbWl0KSB7XG4gICAgICAgIHJldHVybiAoMCwgc3RhdGVfMS5nZXRTdGF0ZSkocmVzb2x2ZWQsIHRpbWUsIGV2ZW50TGltaXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzb2x2ZXIgPSBSZXNvbHZlcjtcbmZ1bmN0aW9uIHJlc29sdmVUaW1lbGluZU9iaihyZXNvbHZlZFRpbWVsaW5lLCBvYmopIHtcbiAgICBpZiAob2JqLnJlc29sdmVkLnJlc29sdmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKG9iai5yZXNvbHZlZC5yZXNvbHZpbmcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2lyY3VsYXIgZGVwZW5kZW5jeSB3aGVuIHRyeWluZyB0byByZXNvbHZlIFwiJHtvYmouaWR9XCJgKTtcbiAgICBvYmoucmVzb2x2ZWQucmVzb2x2aW5nID0gdHJ1ZTtcbiAgICByZXNvbHZlZFRpbWVsaW5lLnN0YXRpc3RpY3MucmVzb2x2aW5nQ291bnQrKztcbiAgICBsZXQgaW5zdGFuY2VzID0gW107XG4gICAgbGV0IGRpcmVjdFJlZmVyZW5jZXMgPSBbXTtcbiAgICBjb25zdCBlbmFibGVzID0gXy5pc0FycmF5KG9iai5lbmFibGUpID8gb2JqLmVuYWJsZSA6IFtvYmouZW5hYmxlXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZW5hYmxlID0gZW5hYmxlc1tpXTtcbiAgICAgICAgbGV0IG5ld0luc3RhbmNlcyA9IFtdO1xuICAgICAgICBjb25zdCByZXBlYXRpbmdFeHByID0gZW5hYmxlLnJlcGVhdGluZyAhPT0gdW5kZWZpbmVkID8gKDAsIGV4cHJlc3Npb25fMS5pbnRlcnByZXRFeHByZXNzaW9uKShlbmFibGUucmVwZWF0aW5nKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGxvb2tlZFJlcGVhdGluZyA9IGxvb2t1cEV4cHJlc3Npb24ocmVzb2x2ZWRUaW1lbGluZSwgb2JqLCByZXBlYXRpbmdFeHByLCAnZHVyYXRpb24nKTtcbiAgICAgICAgY29uc3QgbG9va2VkdXBSZXBlYXRpbmcgPSBsb29rZWRSZXBlYXRpbmcuaW5zdGFuY2VzO1xuICAgICAgICBkaXJlY3RSZWZlcmVuY2VzID0gZGlyZWN0UmVmZXJlbmNlcy5jb25jYXQobG9va2VkUmVwZWF0aW5nLmFsbFJlZmVyZW5jZXMpO1xuICAgICAgICBpZiAoXy5pc0FycmF5KGxvb2tlZHVwUmVwZWF0aW5nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb29rdXBFeHByZXNzaW9uIHNob3VsZCBuZXZlciByZXR1cm4gYW4gYXJyYXkgZm9yIC5kdXJhdGlvbiBsb29rdXBgKTsgLy8gcGVyaGFwcyB0bXA/IG1heWJlIHJldmlzaXQgdGhpcyBhdCBzb21lIHBvaW50XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gZW5hYmxlLndoaWxlICE9PSB1bmRlZmluZWQgPyBlbmFibGUud2hpbGUgOiBlbmFibGUuc3RhcnQgIT09IHVuZGVmaW5lZCA/IGVuYWJsZS5zdGFydCA6ICcnO1xuICAgICAgICBpZiAoZW5hYmxlLndoaWxlICsgJycgPT09ICcxJykge1xuICAgICAgICAgICAgc3RhcnQgPSAndHJ1ZSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW5hYmxlLndoaWxlICsgJycgPT09ICcwJykge1xuICAgICAgICAgICAgc3RhcnQgPSAnZmFsc2UnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0RXhwciA9ICgwLCBleHByZXNzaW9uXzEuc2ltcGxpZnlFeHByZXNzaW9uKShzdGFydCk7XG4gICAgICAgIGxldCBwYXJlbnRJbnN0YW5jZXMgPSBudWxsO1xuICAgICAgICBsZXQgaGFzUGFyZW50ID0gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydFJlZmVyc1RvUGFyZW50ID0gZmFsc2U7XG4gICAgICAgIGlmIChvYmoucmVzb2x2ZWQucGFyZW50SWQpIHtcbiAgICAgICAgICAgIGhhc1BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBsb29rdXAgPSBsb29rdXBFeHByZXNzaW9uKHJlc29sdmVkVGltZWxpbmUsIG9iaiwgKDAsIGV4cHJlc3Npb25fMS5pbnRlcnByZXRFeHByZXNzaW9uKShgIyR7b2JqLnJlc29sdmVkLnBhcmVudElkfWApLCAnc3RhcnQnKTtcbiAgICAgICAgICAgIHBhcmVudEluc3RhbmNlcyA9IGxvb2t1cC5pbnN0YW5jZXM7IC8vIGEgc3RhcnQtcmVmZXJlbmNlIHdpbGwgYWx3YXlzIHJldHVybiBhbiBhcnJheSwgb3IgbnVsbFxuICAgICAgICAgICAgZGlyZWN0UmVmZXJlbmNlcyA9IGRpcmVjdFJlZmVyZW5jZXMuY29uY2F0KGxvb2t1cC5hbGxSZWZlcmVuY2VzKTtcbiAgICAgICAgICAgIGlmICgoMCwgbGliXzEuaXNDb25zdGFudCkoc3RhcnRFeHByKSkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgdXNlIHBhcmVudCBpZiB0aGUgZXhwcmVzc2lvbiByZXNvbHZlcyB0byBhIG51bWJlciAoaWUgZG9lc24ndCBjb250YWluIGFueSByZWZlcmVuY2VzKVxuICAgICAgICAgICAgICAgIHN0YXJ0UmVmZXJzVG9QYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvb2t1cFN0YXJ0ID0gbG9va3VwRXhwcmVzc2lvbihyZXNvbHZlZFRpbWVsaW5lLCBvYmosIHN0YXJ0RXhwciwgJ3N0YXJ0Jyk7XG4gICAgICAgIGxldCBsb29rZWR1cFN0YXJ0cyA9IGxvb2t1cFN0YXJ0Lmluc3RhbmNlcztcbiAgICAgICAgZGlyZWN0UmVmZXJlbmNlcyA9IGRpcmVjdFJlZmVyZW5jZXMuY29uY2F0KGxvb2t1cFN0YXJ0LmFsbFJlZmVyZW5jZXMpO1xuICAgICAgICBpZiAoc3RhcnRSZWZlcnNUb1BhcmVudCkge1xuICAgICAgICAgICAgbG9va2VkdXBTdGFydHMgPSAoMCwgbGliXzEuYXBwbHlQYXJlbnRJbnN0YW5jZXMpKHBhcmVudEluc3RhbmNlcywgbG9va2VkdXBTdGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmFibGUud2hpbGUpIHtcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkobG9va2VkdXBTdGFydHMpKSB7XG4gICAgICAgICAgICAgICAgbmV3SW5zdGFuY2VzID0gbG9va2VkdXBTdGFydHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsb29rZWR1cFN0YXJ0cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ld0luc3RhbmNlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICgwLCBsaWJfMS5nZXRJZCkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBsb29rZWR1cFN0YXJ0cy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGxvb2tlZHVwU3RhcnRzLnJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IGlTdGFydCA9IDA7XG4gICAgICAgICAgICBsZXQgaUVuZCA9IDA7XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KGxvb2tlZHVwU3RhcnRzKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9va2VkdXBTdGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBsb29rZWR1cFN0YXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogaW5zdGFuY2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgaW5zdGFuY2U6IGluc3RhbmNlLCBpZDogb2JqLmlkICsgJ18nICsgaVN0YXJ0KysgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGluc3RhbmNlLnJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxvb2tlZHVwU3RhcnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiBsb29rZWR1cFN0YXJ0cy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICgwLCBsaWJfMS5nZXRJZCkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbG9va2VkdXBTdGFydHMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGxvb2tlZHVwU3RhcnRzLnJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG9iai5pZCArICdfJyArIGlTdGFydCsrLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBsb29rZWR1cFN0YXJ0cy5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuYWJsZS5lbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZEV4cHIgPSAoMCwgZXhwcmVzc2lvbl8xLmludGVycHJldEV4cHJlc3Npb24pKGVuYWJsZS5lbmQpO1xuICAgICAgICAgICAgICAgIGxldCBlbmRSZWZlcnNUb1BhcmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChvYmoucmVzb2x2ZWQucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBsaWJfMS5pc0NvbnN0YW50KShlbmRFeHByKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSB1c2UgcGFyZW50IGlmIHRoZSBleHByZXNzaW9uIHJlc29sdmVzIHRvIGEgbnVtYmVyIChpZSBkb2Vzbid0IGNvbnRhaW4gYW55IHJlZmVyZW5jZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRSZWZlcnNUb1BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbG9va2VkdXBFbmRzIHdpbGwgY29udGFpbiBhbiBpbnZlcnRlZCBsaXN0IG9mIGluc3RhbmNlcy4gVGhlcmVmb3JlIC5zdGFydCBtZWFucyBhbiBlbmRcbiAgICAgICAgICAgICAgICBjb25zdCBsb29rdXBFbmQgPSBlbmRFeHByID8gbG9va3VwRXhwcmVzc2lvbihyZXNvbHZlZFRpbWVsaW5lLCBvYmosIGVuZEV4cHIsICdlbmQnKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGxvb2tlZHVwRW5kcyA9IGxvb2t1cEVuZCA/IGxvb2t1cEVuZC5pbnN0YW5jZXMgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChsb29rdXBFbmQpXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdFJlZmVyZW5jZXMgPSBkaXJlY3RSZWZlcmVuY2VzLmNvbmNhdChsb29rdXBFbmQuYWxsUmVmZXJlbmNlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZFJlZmVyc1RvUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvb2tlZHVwRW5kcyA9ICgwLCBsaWJfMS5hcHBseVBhcmVudEluc3RhbmNlcykocGFyZW50SW5zdGFuY2VzLCBsb29rZWR1cEVuZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXy5pc0FycmF5KGxvb2tlZHVwRW5kcykpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb29rZWR1cEVuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gbG9va2VkdXBFbmRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IGluc3RhbmNlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IGluc3RhbmNlOiBpbnN0YW5jZSwgaWQ6IG9iai5pZCArICdfJyArIGlFbmQrKyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGluc3RhbmNlLnJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb29rZWR1cEVuZHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogbG9va2VkdXBFbmRzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAoMCwgbGliXzEuZ2V0SWQpKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBsb29rZWR1cEVuZHMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogbG9va2VkdXBFbmRzLnJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogb2JqLmlkICsgJ18nICsgaUVuZCsrLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGxvb2tlZHVwRW5kcy5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmFibGUuZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uRXhwciA9ICgwLCBleHByZXNzaW9uXzEuaW50ZXJwcmV0RXhwcmVzc2lvbikoZW5hYmxlLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb29rdXBEdXJhdGlvbiA9IGxvb2t1cEV4cHJlc3Npb24ocmVzb2x2ZWRUaW1lbGluZSwgb2JqLCBkdXJhdGlvbkV4cHIsICdkdXJhdGlvbicpO1xuICAgICAgICAgICAgICAgIGxldCBsb29rZWR1cER1cmF0aW9uID0gbG9va3VwRHVyYXRpb24uaW5zdGFuY2VzO1xuICAgICAgICAgICAgICAgIGRpcmVjdFJlZmVyZW5jZXMgPSBkaXJlY3RSZWZlcmVuY2VzLmNvbmNhdChsb29rdXBEdXJhdGlvbi5hbGxSZWZlcmVuY2VzKTtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc0FycmF5KGxvb2tlZHVwRHVyYXRpb24pICYmIGxvb2tlZHVwRHVyYXRpb24ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvb2tlZHVwRHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbG9va2VkdXBEdXJhdGlvblswXS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGxvb2tlZHVwRHVyYXRpb25bMF0ucmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNBcnJheShsb29rZWR1cER1cmF0aW9uKSAmJiAhbG9va2VkdXBEdXJhdGlvbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGxvb2tlZHVwRHVyYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkobG9va2VkdXBEdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb29rdXBFeHByZXNzaW9uIHNob3VsZCBuZXZlciByZXR1cm4gYW4gYXJyYXkgZm9yIC5kdXJhdGlvbiBsb29rdXBgKTsgLy8gcGVyaGFwcyB0bXA/IG1heWJlIHJldmlzaXQgdGhpcyBhdCBzb21lIHBvaW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvb2tlZHVwRHVyYXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvb2tlZHVwUmVwZWF0aW5nICE9PSBudWxsICYmIGxvb2tlZHVwRHVyYXRpb24udmFsdWUgPiBsb29rZWR1cFJlcGVhdGluZy52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb2tlZHVwRHVyYXRpb24udmFsdWUgPSBsb29rZWR1cFJlcGVhdGluZy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1wTG9va2VkdXBEdXJhdGlvbiA9IGxvb2tlZHVwRHVyYXRpb247IC8vIGNhc3QgdHlwZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGV2ZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZSA9IGUudGltZSArIHRtcExvb2tlZHVwRHVyYXRpb24udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlcyA9ICgwLCBsaWJfMS5qb2luUmVmZXJlbmNlcykoZS5yZWZlcmVuY2VzLCB0bXBMb29rZWR1cER1cmF0aW9uLnJlZmVyZW5jZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogdGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogZS5kYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogZS5kYXRhLmluc3RhbmNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiByZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogcmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0luc3RhbmNlcyA9ICgwLCBsaWJfMS5jb252ZXJ0RXZlbnRzVG9JbnN0YW5jZXMpKGV2ZW50cywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNQYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIGZpZ3VyZSBvdXQgd2hhdCBwYXJlbnQtaW5zdGFuY2UgdGhlIGluc3RhbmNlcyBhcmUgdGllZCB0bywgYW5kIGNhcCB0aGVtXG4gICAgICAgICAgICBjb25zdCBjYXBwZWRJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3SW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXdJbnN0YW5jZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZlcnJlZFBhcmVudEluc3RhbmNlID0gXy5maW5kKHBhcmVudEluc3RhbmNlcywgKHBhcmVudEluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UucmVmZXJlbmNlcy5pbmRleE9mKHBhcmVudEluc3RhbmNlLmlkKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmZXJyZWRQYXJlbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNoaWxkIHJlZmVycyB0byBpdHMgcGFyZW50LCB0aGVyZSBzaG91bGQgYmUgb25lIHNwZWNpZmljIGluc3RhbmNlIHRvIGNhcCBpbnRvXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXBwZWRJbnN0YW5jZSA9ICgwLCBsaWJfMS5jYXBJbnN0YW5jZXMpKFtpbnN0YW5jZV0sIFtyZWZlcnJlZFBhcmVudEluc3RhbmNlXSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FwcGVkSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhcHBlZEluc3RhbmNlLmNhcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcHBlZEluc3RhbmNlLmNhcHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXBwZWRJbnN0YW5jZS5jYXBzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcmVmZXJyZWRQYXJlbnRJbnN0YW5jZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHJlZmVycmVkUGFyZW50SW5zdGFuY2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcmVmZXJyZWRQYXJlbnRJbnN0YW5jZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwcGVkSW5zdGFuY2VzLnB1c2goY2FwcGVkSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNoaWxkIGRvZXNuJ3QgcmVmZXIgdG8gaXRzIHBhcmVudCwgaXQgc2hvdWxkIGJlIGNhcHBlZCB3aXRoaW4gYWxsIG9mIGl0cyBwYXJlbnQgaW5zdGFuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudEluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudEluc3RhbmNlID0gcGFyZW50SW5zdGFuY2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhcHBlZEluc3RhbmNlID0gKDAsIGxpYl8xLmNhcEluc3RhbmNlcykoW2luc3RhbmNlXSwgW3BhcmVudEluc3RhbmNlXSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhcHBlZEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYXBwZWRJbnN0YW5jZS5jYXBzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcHBlZEluc3RhbmNlLmNhcHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcHBlZEluc3RhbmNlLmNhcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHBhcmVudEluc3RhbmNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwYXJlbnRJbnN0YW5jZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHBhcmVudEluc3RhbmNlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcHBlZEluc3RhbmNlcy5wdXNoKGNhcHBlZEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdJbnN0YW5jZXMgPSBjYXBwZWRJbnN0YW5jZXM7XG4gICAgICAgIH1cbiAgICAgICAgbmV3SW5zdGFuY2VzID0gKDAsIGxpYl8xLmFwcGx5UmVwZWF0aW5nSW5zdGFuY2VzKShuZXdJbnN0YW5jZXMsIGxvb2tlZHVwUmVwZWF0aW5nLCByZXNvbHZlZFRpbWVsaW5lLm9wdGlvbnMpO1xuICAgICAgICBpbnN0YW5jZXMgPSBpbnN0YW5jZXMuY29uY2F0KG5ld0luc3RhbmNlcyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgaW5zdGFuY2UgaWRzIGFyZSB1bmlxdWU6XG4gICAgY29uc3QgaWRzID0ge307XG4gICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICAgICAgaWYgKGlkc1tpbnN0YW5jZS5pZF0pIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmlkID0gYCR7aW5zdGFuY2UuaWR9XyR7KDAsIGxpYl8xLmdldElkKSgpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWRzW2luc3RhbmNlLmlkXSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvYmouc2VhbWxlc3MgJiYgaW5zdGFuY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaW5zdGFuY2VzID0gKDAsIGxpYl8xLmNsZWFuSW5zdGFuY2VzKShpbnN0YW5jZXMsIHRydWUsIGZhbHNlKTtcbiAgICB9XG4gICAgb2JqLnJlc29sdmVkLnJlc29sdmVkID0gdHJ1ZTtcbiAgICBvYmoucmVzb2x2ZWQucmVzb2x2aW5nID0gZmFsc2U7XG4gICAgb2JqLnJlc29sdmVkLmluc3RhbmNlcyA9IGluc3RhbmNlcztcbiAgICBvYmoucmVzb2x2ZWQuZGlyZWN0UmVmZXJlbmNlcyA9IGRpcmVjdFJlZmVyZW5jZXM7XG4gICAgdXBkYXRlU3RhdGlzdGljcyhyZXNvbHZlZFRpbWVsaW5lLCBvYmopO1xufVxuZXhwb3J0cy5yZXNvbHZlVGltZWxpbmVPYmogPSByZXNvbHZlVGltZWxpbmVPYmo7XG5mdW5jdGlvbiB1cGRhdGVTdGF0aXN0aWNzKHJlc29sdmVkVGltZWxpbmUsIG9iaikge1xuICAgIGlmIChvYmoucmVzb2x2ZWQuaW5zdGFuY2VzLmxlbmd0aCkge1xuICAgICAgICByZXNvbHZlZFRpbWVsaW5lLnN0YXRpc3RpY3MucmVzb2x2ZWRJbnN0YW5jZUNvdW50ICs9IG9iai5yZXNvbHZlZC5pbnN0YW5jZXMubGVuZ3RoO1xuICAgICAgICByZXNvbHZlZFRpbWVsaW5lLnN0YXRpc3RpY3MucmVzb2x2ZWRDb3VudCArPSAxO1xuICAgICAgICBpZiAob2JqLmlzR3JvdXApIHtcbiAgICAgICAgICAgIHJlc29sdmVkVGltZWxpbmUuc3RhdGlzdGljcy5yZXNvbHZlZEdyb3VwQ291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnJlc29sdmVkLmlzS2V5ZnJhbWUpIHtcbiAgICAgICAgICAgIHJlc29sdmVkVGltZWxpbmUuc3RhdGlzdGljcy5yZXNvbHZlZEtleWZyYW1lQ291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmVkVGltZWxpbmUuc3RhdGlzdGljcy5yZXNvbHZlZE9iamVjdENvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc29sdmVkVGltZWxpbmUuc3RhdGlzdGljcy51bnJlc29sdmVkQ291bnQgKz0gMTtcbiAgICB9XG59XG4vKiogSW52YWxpZGF0ZSBhbGwgY2hhbmdlZCBvYmplY3RzLCBhbmQgcmVjdXJzaXZlbHkgaW52YWxpZGF0ZSBhbGwgb2JqZWN0cyB0aGF0IHJlZmVyZW5jZSB0aG9zZSBvYmplY3RzICovXG5mdW5jdGlvbiBpbnZhbGlkYXRlT2JqZWN0c1dpdGhSZWZlcmVuY2UoaGFuZGxlZFJlZmVyZW5jZXMsIHJlZmVyZW5jZSwgYWZmZWN0UmVmZXJlbmNlTWFwLCB2YWxpZE9iamVjdHMpIHtcbiAgICBpZiAoaGFuZGxlZFJlZmVyZW5jZXNbcmVmZXJlbmNlXSlcbiAgICAgICAgcmV0dXJuOyAvLyB0byBhdm9pZCBpbmZpbml0ZSBsb29wc1xuICAgIGhhbmRsZWRSZWZlcmVuY2VzW3JlZmVyZW5jZV0gPSB0cnVlO1xuICAgIGlmIChyZWZlcmVuY2VbMF0gPT09ICcjJykge1xuICAgICAgICAvLyBhbiBpZFxuICAgICAgICBjb25zdCBvYmpJZCA9IHJlZmVyZW5jZS5zbGljZSgxKTtcbiAgICAgICAgaWYgKHZhbGlkT2JqZWN0c1tvYmpJZF0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB2YWxpZE9iamVjdHNbb2JqSWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEludmFsaWRhdGUgYWxsIG9iamVjdHMgdGhhdCBkZXBlbmQgb24gYW55IG9mIHRoZSByZWZlcmVuY2VzIHRoYXQgdGhpcyByZWZlcmVuY2UgYWZmZWN0czpcbiAgICBjb25zdCBhZmZlY3RlZFJlZmVyZW5jZXMgPSBhZmZlY3RSZWZlcmVuY2VNYXBbcmVmZXJlbmNlXTtcbiAgICBpZiAoYWZmZWN0ZWRSZWZlcmVuY2VzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWZmZWN0ZWRSZWZlcmVuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByZWZlcmVuY2luZ1JlZmVyZW5jZSA9IGFmZmVjdGVkUmVmZXJlbmNlc1tpXTtcbiAgICAgICAgICAgIGludmFsaWRhdGVPYmplY3RzV2l0aFJlZmVyZW5jZShoYW5kbGVkUmVmZXJlbmNlcywgcmVmZXJlbmNpbmdSZWZlcmVuY2UsIGFmZmVjdFJlZmVyZW5jZU1hcCwgdmFsaWRPYmplY3RzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogTG9vayB1cCBhIHJlZmVyZW5jZSBvbiB0aGUgdGltZWxpbmVcbiAqIFJldHVybiB2YWx1ZXM6XG4gKiBBcnJheTxUaW1lbGluZU9iamVjdEluc3RhbmNlPjogSW5zdGFuY2VzIG9uIHRoZSB0aW1lbGluZSB3aGVyZSB0aGUgcmVmZXJlbmNlIGV4cHJlc3Npb24gaXMgdHJ1ZVxuICogVmFsdWVXaXRoUmVmZXJlbmNlOiBBIHNpbmd1bGFyIHZhbHVlIHdoaWNoIGNhbiBiZSBjb21iaW5lZCBhcml0aG1ldGljYWxseSB3aXRoIEluc3RhbmNlc1xuICogbnVsbDogTWVhbnMgXCJzb21ldGhpbmcgaXMgaW52YWxpZFwiLCBhbiBudWxsLXZhbHVlIHdpbGwgYWx3YXlzIHJldHVybiBudWxsIHdoZW4gY29tYmluZWQgd2l0aCBvdGhlciB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0gcmVzb2x2ZWRUaW1lbGluZVxuICogQHBhcmFtIG9ialxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGxvb2t1cEV4cHJlc3Npb24ocmVzb2x2ZWRUaW1lbGluZSwgb2JqLCBleHByLCBjb250ZXh0KSB7XG4gICAgaWYgKGV4cHIgPT09IG51bGwpXG4gICAgICAgIHJldHVybiB7IGluc3RhbmNlczogbnVsbCwgYWxsUmVmZXJlbmNlczogW10gfTtcbiAgICBpZiAoXy5pc1N0cmluZyhleHByKSAmJiAoMCwgbGliXzEuaXNOdW1lcmljKShleHByKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5zdGFuY2VzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQoZXhwciksXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogW10sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWxsUmVmZXJlbmNlczogW10sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKF8uaXNOdW1iZXIoZXhwcikpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluc3RhbmNlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBleHByLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IFtdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsbFJlZmVyZW5jZXM6IFtdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChfLmlzU3RyaW5nKGV4cHIpKSB7XG4gICAgICAgIGV4cHIgPSBleHByLnRyaW0oKTtcbiAgICAgICAgaWYgKCgwLCBsaWJfMS5pc0NvbnN0YW50KShleHByKSkge1xuICAgICAgICAgICAgaWYgKGV4cHIubWF0Y2goL150cnVlJC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYWxsUmVmZXJlbmNlczogW10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV4cHIubWF0Y2goL15mYWxzZSQvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBhbGxSZWZlcmVuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIExvb2sgdXAgc3RyaW5nXG4gICAgICAgIGxldCBpbnZlcnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGlnbm9yZUZpcnN0SWZaZXJvID0gZmFsc2U7XG4gICAgICAgIGxldCByZWZlcmVuY2VkT2JqcyA9IFtdO1xuICAgICAgICBsZXQgcmVmID0gY29udGV4dDtcbiAgICAgICAgbGV0IHJlc3QgPSAnJztcbiAgICAgICAgbGV0IG9iaklkc1RvUmVmZXJlbmNlID0gW107XG4gICAgICAgIGNvbnN0IGFsbFJlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgbGV0IHJlZmVyZW5jZUlzT2sgPSBmYWxzZTtcbiAgICAgICAgLy8gTWF0Y2ggaWQsIGV4YW1wbGU6IFwiI29iamVjdElkLnN0YXJ0XCJcbiAgICAgICAgY29uc3QgbSA9IGV4cHIubWF0Y2goL15cXFcqIyhbXi5dKykoLiopLyk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IG1bMV07XG4gICAgICAgICAgICByZXN0ID0gbVsyXTtcbiAgICAgICAgICAgIHJlZmVyZW5jZUlzT2sgPSB0cnVlO1xuICAgICAgICAgICAgb2JqSWRzVG9SZWZlcmVuY2UgPSBbaWRdO1xuICAgICAgICAgICAgYWxsUmVmZXJlbmNlcy5wdXNoKCcjJyArIGlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE1hdGNoIGNsYXNzLCBleGFtcGxlOiBcIi5jbGFzc05hbWUuc3RhcnRcIlxuICAgICAgICAgICAgY29uc3QgbSA9IGV4cHIubWF0Y2goL15cXFcqXFwuKFteLl0rKSguKikvKTtcbiAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gbVsxXTtcbiAgICAgICAgICAgICAgICByZXN0ID0gbVsyXTtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VJc09rID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBvYmpJZHNUb1JlZmVyZW5jZSA9IHJlc29sdmVkVGltZWxpbmUuY2xhc3Nlc1tjbGFzc05hbWVdIHx8IFtdO1xuICAgICAgICAgICAgICAgIGFsbFJlZmVyZW5jZXMucHVzaCgnLicgKyBjbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWF0Y2ggbGF5ZXIsIGV4YW1wbGU6IFwiJGxheWVyXCJcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gZXhwci5tYXRjaCgvXlxcVypcXCQoW14uXSspKC4qKS8pO1xuICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyID0gbVsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdCA9IG1bMl07XG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZUlzT2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvYmpJZHNUb1JlZmVyZW5jZSA9IHJlc29sdmVkVGltZWxpbmUubGF5ZXJzW2xheWVyXSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsUmVmZXJlbmNlcy5wdXNoKCckJyArIGxheWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmpJZHNUb1JlZmVyZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcmVmT2JqSWQgPSBvYmpJZHNUb1JlZmVyZW5jZVtpXTtcbiAgICAgICAgICAgIGlmIChyZWZPYmpJZCAhPT0gb2JqLmlkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmT2JqID0gcmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzW3JlZk9iaklkXTtcbiAgICAgICAgICAgICAgICBpZiAocmVmT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZWRPYmpzLnB1c2gocmVmT2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMb29rcyBsaWtlIHRoZSBvYmplY3QgaXMgcmVmZXJlbmNpbmcgaXRzZWxmIVxuICAgICAgICAgICAgICAgIGlmIChvYmoucmVzb2x2ZWQucmVzb2x2aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5yZXNvbHZlZC5pc1NlbGZSZWZlcmVuY2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVmZXJlbmNlSXNPaykge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW5zdGFuY2VzOiBudWxsLCBhbGxSZWZlcmVuY2VzOiBbXSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoucmVzb2x2ZWQuaXNTZWxmUmVmZXJlbmNpbmcpIHtcbiAgICAgICAgICAgIC8vIEV4Y2x1ZGUgYW55IHNlbGYtcmVmZXJlbmNpbmcgb2JqZWN0czpcbiAgICAgICAgICAgIHJlZmVyZW5jZWRPYmpzID0gXy5maWx0ZXIocmVmZXJlbmNlZE9ianMsIChyZWZPYmopID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXJlZk9iai5yZXNvbHZlZC5pc1NlbGZSZWZlcmVuY2luZztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZlcmVuY2VkT2Jqcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChyZXN0Lm1hdGNoKC9zdGFydC8pKVxuICAgICAgICAgICAgICAgIHJlZiA9ICdzdGFydCc7XG4gICAgICAgICAgICBpZiAocmVzdC5tYXRjaCgvZW5kLykpXG4gICAgICAgICAgICAgICAgcmVmID0gJ2VuZCc7XG4gICAgICAgICAgICBpZiAocmVzdC5tYXRjaCgvZHVyYXRpb24vKSlcbiAgICAgICAgICAgICAgICByZWYgPSAnZHVyYXRpb24nO1xuICAgICAgICAgICAgaWYgKHJlZiA9PT0gJ2R1cmF0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIER1cmF0aW9uIHJlZmVycyB0byB0aGUgZmlyc3Qgb2JqZWN0IG9uIHRoZSByZXNvbHZlZCB0aW1lbGluZVxuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlRHVyYXRpb25zID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWZlcmVuY2VkT2Jqcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZlcmVuY2VkT2JqID0gcmVmZXJlbmNlZE9ianNbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVUaW1lbGluZU9iaihyZXNvbHZlZFRpbWVsaW5lLCByZWZlcmVuY2VkT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZmVyZW5jZWRPYmoucmVzb2x2ZWQucmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmoucmVzb2x2ZWQuaXNTZWxmUmVmZXJlbmNpbmcgJiYgcmVmZXJlbmNlZE9iai5yZXNvbHZlZC5pc1NlbGZSZWZlcmVuY2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBxdWVyeWluZyBvYmplY3QgaXMgc2VsZi1yZWZlcmVuY2luZywgZXhjbHVkZSBhbnkgb3RoZXIgc2VsZi1yZWZlcmVuY2luZyBvYmplY3RzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEluc3RhbmNlID0gXy5maXJzdChyZWZlcmVuY2VkT2JqLnJlc29sdmVkLmluc3RhbmNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBmaXJzdEluc3RhbmNlLmVuZCAhPT0gbnVsbCA/IGZpcnN0SW5zdGFuY2UuZW5kIC0gZmlyc3RJbnN0YW5jZS5zdGFydCA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VEdXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6ICgwLCBsaWJfMS5qb2luUmVmZXJlbmNlcykocmVmZXJlbmNlZE9iai5pZCwgZmlyc3RJbnN0YW5jZS5yZWZlcmVuY2VzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBmaXJzdER1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RhbmNlRHVyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBpbnN0YW5jZUR1cmF0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0RHVyYXRpb24gPT09IG51bGwgfHwgZC52YWx1ZSA8IGZpcnN0RHVyYXRpb24udmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdER1cmF0aW9uID0gZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaW5zdGFuY2VzOiBmaXJzdER1cmF0aW9uLCBhbGxSZWZlcmVuY2VzOiBhbGxSZWZlcmVuY2VzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcmV0dXJuSW5zdGFuY2VzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHJlZiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJ0ID0gIWludmVydDtcbiAgICAgICAgICAgICAgICAgICAgaWdub3JlRmlyc3RJZlplcm8gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBVbmtub3duIHJlZjogXCIke3JlZn1cImApO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVmZXJlbmNlZE9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlZE9iaiA9IHJlZmVyZW5jZWRPYmpzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlVGltZWxpbmVPYmoocmVzb2x2ZWRUaW1lbGluZSwgcmVmZXJlbmNlZE9iaik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZlcmVuY2VkT2JqLnJlc29sdmVkLnJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLnJlc29sdmVkLmlzU2VsZlJlZmVyZW5jaW5nICYmIHJlZmVyZW5jZWRPYmoucmVzb2x2ZWQuaXNTZWxmUmVmZXJlbmNpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcXVlcnlpbmcgb2JqZWN0IGlzIHNlbGYtcmVmZXJlbmNpbmcsIGV4Y2x1ZGUgYW55IG90aGVyIHNlbGYtcmVmZXJlbmNpbmcgb2JqZWN0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuSW5zdGFuY2VzID0gcmV0dXJuSW5zdGFuY2VzLmNvbmNhdChyZWZlcmVuY2VkT2JqLnJlc29sdmVkLmluc3RhbmNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybkluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludmVydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuSW5zdGFuY2VzID0gKDAsIGxpYl8xLmludmVydEluc3RhbmNlcykocmV0dXJuSW5zdGFuY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkluc3RhbmNlcyA9ICgwLCBsaWJfMS5jbGVhbkluc3RhbmNlcykocmV0dXJuSW5zdGFuY2VzLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlRmlyc3RJZlplcm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gXy5maXJzdChyZXR1cm5JbnN0YW5jZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0ICYmIGZpcnN0LnN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuSW5zdGFuY2VzLnNwbGljZSgwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBpbnN0YW5jZXM6IHJldHVybkluc3RhbmNlcywgYWxsUmVmZXJlbmNlczogYWxsUmVmZXJlbmNlcyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaW5zdGFuY2VzOiBbXSwgYWxsUmVmZXJlbmNlczogYWxsUmVmZXJlbmNlcyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGluc3RhbmNlczogW10sIGFsbFJlZmVyZW5jZXM6IGFsbFJlZmVyZW5jZXMgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGV4cHIpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBsb29rdXBFeHByZXNzaW9uKHJlc29sdmVkVGltZWxpbmUsIG9iaiwgZXhwci5sLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBsb29rdXBFeHByZXNzaW9uKHJlc29sdmVkVGltZWxpbmUsIG9iaiwgZXhwci5yLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGxvb2t1cEV4cHIgPSB7XG4gICAgICAgICAgICAgICAgbDogbC5pbnN0YW5jZXMsXG4gICAgICAgICAgICAgICAgbzogZXhwci5vLFxuICAgICAgICAgICAgICAgIHI6IHIuaW5zdGFuY2VzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGFsbFJlZmVyZW5jZXMgPSBsLmFsbFJlZmVyZW5jZXMuY29uY2F0KHIuYWxsUmVmZXJlbmNlcyk7XG4gICAgICAgICAgICBpZiAobG9va3VwRXhwci5vID09PSAnIScpIHtcbiAgICAgICAgICAgICAgICAvLyBEaXNjYXJkIGwsIGludmVydCBhbmQgcmV0dXJuIHI6XG4gICAgICAgICAgICAgICAgaWYgKGxvb2t1cEV4cHIuciAmJiBfLmlzQXJyYXkobG9va3VwRXhwci5yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VzOiAoMCwgbGliXzEuaW52ZXJ0SW5zdGFuY2VzKShsb29rdXBFeHByLnIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsUmVmZXJlbmNlczogYWxsUmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IGludmVydCBhIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXM6IGxvb2t1cEV4cHIucixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbFJlZmVyZW5jZXM6IGFsbFJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNOdWxsKGxvb2t1cEV4cHIubCkgfHwgXy5pc051bGwobG9va3VwRXhwci5yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBpbnN0YW5jZXM6IG51bGwsIGFsbFJlZmVyZW5jZXM6IGFsbFJlZmVyZW5jZXMgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxvb2t1cEV4cHIubyA9PT0gJyYnIHx8IGxvb2t1cEV4cHIubyA9PT0gJ3wnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBldmVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkRXZlbnRzID0gKGluc3RhbmNlcywgbGVmdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhcnQgIT09IGluc3RhbmNlLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBldmVudCBkb2Vzbid0IGFjdHVhbGx5IGV4aXN0Li4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBpbnN0YW5jZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmVuZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogaW5zdGFuY2UuZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uaXNBcnJheShsb29rdXBFeHByLmwpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRXZlbnRzKGxvb2t1cEV4cHIubCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkobG9va3VwRXhwci5yKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEV2ZW50cyhsb29rdXBFeHByLnIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzID0gKDAsIGxpYl8xLnNvcnRFdmVudHMpKGV2ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGNSZXN1bHQgPSBsb29rdXBFeHByLm8gPT09ICcmJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAobGVmdCwgcmlnaHQpID0+ICEhKGxlZnQgJiYgcmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGxvb2t1cEV4cHIubyA9PT0gJ3wnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAobGVmdCwgcmlnaHQpID0+ICEhKGxlZnQgfHwgcmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGVmdFZhbHVlID0gKDAsIGxpYl8xLmlzUmVmZXJlbmNlKShsb29rdXBFeHByLmwpID8gISFsb29rdXBFeHByLmwudmFsdWUgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0VmFsdWUgPSAoMCwgbGliXzEuaXNSZWZlcmVuY2UpKGxvb2t1cEV4cHIucikgPyAhIWxvb2t1cEV4cHIuci52YWx1ZSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGVmdEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0SW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0VmFsdWUgPSBjYWxjUmVzdWx0KGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVJbnN0YW5jZSA9ICh0aW1lLCB2YWx1ZSwgcmVmZXJlbmNlcywgY2FwcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogKDAsIGxpYl8xLmdldElkKSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogdGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiByZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXBzOiBjYXBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IF8ubGFzdChpbnN0YW5jZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QuZW5kID0gdGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgdXBkYXRlIHJlZmVyZW5jZSBvbiBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUluc3RhbmNlKDAsIHJlc3VsdFZhbHVlLCAoMCwgbGliXzEuam9pblJlZmVyZW5jZXMpKCgwLCBsaWJfMS5pc1JlZmVyZW5jZSkobG9va3VwRXhwci5sKSA/IGxvb2t1cEV4cHIubC5yZWZlcmVuY2VzIDogW10sICgwLCBsaWJfMS5pc1JlZmVyZW5jZSkobG9va3VwRXhwci5yKSA/IGxvb2t1cEV4cHIuci5yZWZlcmVuY2VzIDogW10pLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gZXZlbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IGV2ZW50c1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFZhbHVlID0gZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0SW5zdGFuY2UgPSBlLmluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRWYWx1ZSA9IGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRJbnN0YW5jZSA9IGUuaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dC50aW1lICE9PSBlLnRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdSZXN1bHRWYWx1ZSA9IGNhbGNSZXN1bHQobGVmdFZhbHVlLCByaWdodFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRDYXBzID0gKGxlZnRJbnN0YW5jZSA/IGxlZnRJbnN0YW5jZS5jYXBzIHx8IFtdIDogW10pLmNvbmNhdChyaWdodEluc3RhbmNlID8gcmlnaHRJbnN0YW5jZS5jYXBzIHx8IFtdIDogW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdSZXN1bHRWYWx1ZSAhPT0gcmVzdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSW5zdGFuY2UoZS50aW1lLCBuZXdSZXN1bHRWYWx1ZSwgKDAsIGxpYl8xLmpvaW5SZWZlcmVuY2VzKShsZWZ0SW5zdGFuY2UgPyBsZWZ0SW5zdGFuY2UucmVmZXJlbmNlcyA6IFtdLCByaWdodEluc3RhbmNlID8gcmlnaHRJbnN0YW5jZS5yZWZlcmVuY2VzIDogW10pLCByZXN1bHRDYXBzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0VmFsdWUgPSBuZXdSZXN1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaW5zdGFuY2VzOiBpbnN0YW5jZXMsIGFsbFJlZmVyZW5jZXM6IGFsbFJlZmVyZW5jZXMgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGVJbm5lciA9IGxvb2t1cEV4cHIubyA9PT0gJysnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGEudmFsdWUgKyBiLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiAoMCwgbGliXzEuam9pblJlZmVyZW5jZXMpKGEucmVmZXJlbmNlcywgYi5yZWZlcmVuY2VzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBsb29rdXBFeHByLm8gPT09ICctJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhLnZhbHVlIC0gYi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6ICgwLCBsaWJfMS5qb2luUmVmZXJlbmNlcykoYS5yZWZlcmVuY2VzLCBiLnJlZmVyZW5jZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGxvb2t1cEV4cHIubyA9PT0gJyonXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGEudmFsdWUgKiBiLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6ICgwLCBsaWJfMS5qb2luUmVmZXJlbmNlcykoYS5yZWZlcmVuY2VzLCBiLnJlZmVyZW5jZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGxvb2t1cEV4cHIubyA9PT0gJy8nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGEudmFsdWUgLyBiLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiAoMCwgbGliXzEuam9pblJlZmVyZW5jZXMpKGEucmVmZXJlbmNlcywgYi5yZWZlcmVuY2VzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBsb29rdXBFeHByLm8gPT09ICclJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhLnZhbHVlICUgYi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6ICgwLCBsaWJfMS5qb2luUmVmZXJlbmNlcykoYS5yZWZlcmVuY2VzLCBiLnJlZmVyZW5jZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICgpID0+IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGUgPSAoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRlSW5uZXIoYSwgYik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBsaWJfMS5vcGVyYXRlT25BcnJheXMpKGxvb2t1cEV4cHIubCwgbG9va3VwRXhwci5yLCBvcGVyYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaW5zdGFuY2VzOiByZXN1bHQsIGFsbFJlZmVyZW5jZXM6IGFsbFJlZmVyZW5jZXMgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgaW5zdGFuY2VzOiBudWxsLCBhbGxSZWZlcmVuY2VzOiBbXSB9O1xufVxuZXhwb3J0cy5sb29rdXBFeHByZXNzaW9uID0gbG9va3VwRXhwcmVzc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hcHBseUtleWZyYW1lQ29udGVudCA9IGV4cG9ydHMucmVzb2x2ZVN0YXRlcyA9IGV4cG9ydHMuZ2V0U3RhdGUgPSB2b2lkIDA7XG5jb25zdCBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi4vYXBpL2VudW1zXCIpO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi4vbGliXCIpO1xuZnVuY3Rpb24gZ2V0U3RhdGUocmVzb2x2ZWQsIHRpbWUsIGV2ZW50TGltaXQgPSAwKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRTdGF0ZXMgPSBpc1Jlc29sdmVkU3RhdGVzKHJlc29sdmVkKSA/IHJlc29sdmVkIDogcmVzb2x2ZVN0YXRlcyhyZXNvbHZlZCk7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgIGxheWVyczoge30sXG4gICAgICAgIG5leHRFdmVudHM6IF8uZmlsdGVyKHJlc29sdmVkU3RhdGVzLm5leHRFdmVudHMsIChlKSA9PiBlLnRpbWUgPiB0aW1lKSxcbiAgICB9O1xuICAgIGlmIChldmVudExpbWl0KVxuICAgICAgICBzdGF0ZS5uZXh0RXZlbnRzID0gc3RhdGUubmV4dEV2ZW50cy5zbGljZSgwLCBldmVudExpbWl0KTtcbiAgICBjb25zdCBsYXllcktleXMgPSBPYmplY3Qua2V5cyhyZXNvbHZlZFN0YXRlcy5sYXllcnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGF5ZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxheWVyID0gbGF5ZXJLZXlzW2ldO1xuICAgICAgICBjb25zdCBvID0gZ2V0U3RhdGVBdFRpbWUocmVzb2x2ZWRTdGF0ZXMuc3RhdGUsIGxheWVyLCB0aW1lKTtcbiAgICAgICAgaWYgKG8pXG4gICAgICAgICAgICBzdGF0ZS5sYXllcnNbbGF5ZXJdID0gbztcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuZXhwb3J0cy5nZXRTdGF0ZSA9IGdldFN0YXRlO1xuZnVuY3Rpb24gcmVzb2x2ZVN0YXRlcyhyZXNvbHZlZCwgY2FjaGUpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgIGNvbnN0IHJlc29sdmVkU3RhdGVzID0ge1xuICAgICAgICBvcHRpb25zOiByZXNvbHZlZC5vcHRpb25zLFxuICAgICAgICBzdGF0aXN0aWNzOiByZXNvbHZlZC5zdGF0aXN0aWNzLFxuICAgICAgICAvLyBUaGVzZSB3aWxsIGJlIHJlLWNyZWF0ZWQgZHVyaW5nIHRoZSBzdGF0ZS1yZXNvbHZpbmc6XG4gICAgICAgIG9iamVjdHM6IHt9LFxuICAgICAgICBjbGFzc2VzOiB7fSxcbiAgICAgICAgbGF5ZXJzOiB7fSxcbiAgICAgICAgc3RhdGU6IHt9LFxuICAgICAgICBuZXh0RXZlbnRzOiBbXSxcbiAgICB9O1xuICAgIGlmIChjYWNoZSAmJiByZXNvbHZlZC5zdGF0aXN0aWNzLnJlc29sdmluZ0NvdW50ID09PSAwICYmIGNhY2hlLnJlc29sdmVkU3RhdGVzKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgaGFzIGNoYW5nZWQgc2luY2UgbGFzdCB0aW1lLCBqdXN0IHJldHVybiB0aGUgc3RhdGVzIHJpZ2h0IGF3YXk6XG4gICAgICAgIHJldHVybiBjYWNoZS5yZXNvbHZlZFN0YXRlcztcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRPYmplY3RzID0gXy52YWx1ZXMocmVzb2x2ZWQub2JqZWN0cyk7XG4gICAgLy8gU29ydCB0byBtYWtlIHN1cmUgcGFyZW50IGdyb3VwcyBhcmUgZXZhbHVhdGVkIGJlZm9yZSB0aGVpciBjaGlsZHJlbjpcbiAgICByZXNvbHZlZE9iamVjdHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBpZiAoKGEucmVzb2x2ZWQubGV2ZWxEZWVwIHx8IDApID4gKGIucmVzb2x2ZWQubGV2ZWxEZWVwIHx8IDApKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmICgoYS5yZXNvbHZlZC5sZXZlbERlZXAgfHwgMCkgPCAoYi5yZXNvbHZlZC5sZXZlbERlZXAgfHwgMCkpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhLmlkID4gYi5pZClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoYS5pZCA8IGIuaWQpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICAgIC8vIFN0ZXAgMTogQ29sbGVjdCBhbGwgcG9pbnRzLW9mLWludGVyZXN0ICh3aGljaCBwb2ludHMgaW4gdGltZSB3ZSB3YW50IHRvIGV2YWx1YXRlKVxuICAgIC8vIGFuZCB3aGljaCBpbnN0YW5jZXMgdGhhdCBhcmUgaW50ZXJlc3RpbmdcbiAgICBjb25zdCBwb2ludHNJblRpbWUgPSB7fTtcbiAgICBjb25zdCBhZGRQb2ludEluVGltZSA9ICh0aW1lLCBjaGVja0lkLCBvcmRlciwgb2JqLCBpbnN0YW5jZSkgPT4ge1xuICAgICAgICAvLyBOb3RlIG9uIG9yZGVyOiBFbmRpbmcgZXZlbnRzIGNvbWUgYmVmb3JlIHN0YXJ0aW5nIGV2ZW50c1xuICAgICAgICBpZiAoIXBvaW50c0luVGltZVt0aW1lICsgJyddKVxuICAgICAgICAgICAgcG9pbnRzSW5UaW1lW3RpbWUgKyAnJ10gPSBbXTtcbiAgICAgICAgcG9pbnRzSW5UaW1lW3RpbWUgKyAnJ10ucHVzaCh7IG9iaiwgaW5zdGFuY2UsIGNoZWNrSWQsIG9yZGVyIH0pO1xuICAgIH07XG4gICAgZm9yIChjb25zdCBvYmogb2YgcmVzb2x2ZWRPYmplY3RzKSB7XG4gICAgICAgIGlmICghb2JqLmRpc2FibGVkICYmIG9iai5yZXNvbHZlZC5yZXNvbHZlZCkge1xuICAgICAgICAgICAgaWYgKCFvYmoucmVzb2x2ZWQuaXNLZXlmcmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFRpbWVzID0gZ2V0VGltZXNGcm9tUGFyZW50cyhyZXNvbHZlZCwgb2JqKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqLmxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGxheWVyIGlzIGVtcHR5LCBkb24ndCBwdXQgaW4gc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBvYmoucmVzb2x2ZWQuaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lRXZlbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lRXZlbnRzLnB1c2goeyB0aW1lOiBpbnN0YW5jZS5zdGFydCwgZW5hYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmVuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lRXZlbnRzLnB1c2goeyB0aW1lOiBpbnN0YW5jZS5lbmQsIGVuYWJsZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHNvIGluY2x1ZGUgdGltZXMgZnJvbSBwYXJlbnRzLCBhcyB0aGV5IGNvdWxkIGFmZmVjdCB0aGUgc3RhdGUgb2YgdGhpcyBpbnN0YW5jZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50VGltZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRUaW1lID0gcGFyZW50VGltZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFRpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VGltZS50aW1lID4gKGluc3RhbmNlLnN0YXJ0IHx8IDApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFRpbWUudGltZSA8ICgoX2EgPSBpbnN0YW5jZS5lbmQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IEluZmluaXR5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lRXZlbnRzLnB1c2gocGFyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSBhIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlIG9uIGFsbCBwb2ludHMgaW4gdGltZSB0aGF0IGNvdWxkIGFmZmVjdCBpdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZUV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVFdmVudCA9IHRpbWVFdmVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVFdmVudC5lbmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUG9pbnRJblRpbWUodGltZUV2ZW50LnRpbWUsICdzdGFydCcsIDEsIG9iaiwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUG9pbnRJblRpbWUodGltZUV2ZW50LnRpbWUsICdlbmQnLCAwLCBvYmosIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvYmoucmVzb2x2ZWQuaXNLZXlmcmFtZSAmJiBvYmoucmVzb2x2ZWQucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlmcmFtZSA9IG9iajtcbiAgICAgICAgICAgICAgICAvLyBBbHNvIGFkZCBrZXlmcmFtZXMgdG8gcG9pbnRzSW5UaW1lOlxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2Yga2V5ZnJhbWUucmVzb2x2ZWQuaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEtleWZyYW1lIHN0YXJ0IHRpbWVcbiAgICAgICAgICAgICAgICAgICAgYWRkUG9pbnRJblRpbWUoaW5zdGFuY2Uuc3RhcnQsICdzdGFydCcsIDEsIGtleWZyYW1lLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEtleWZyYW1lIGVuZCB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5lbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBvaW50SW5UaW1lKGluc3RhbmNlLmVuZCwgJ2VuZCcsIDAsIGtleWZyYW1lLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3RlcCAyOiBSZXNvbHZlIHRoZSBzdGF0ZSBmb3IgdGhlIHBvaW50cy1vZi1pbnRlcmVzdFxuICAgIC8vIFRoaXMgaXMgZG9uZSBieSBzd2VlcGluZyB0aGUgcG9pbnRzLW9mLWludGVyZXN0IGNocm9ub2xvZ2ljYWxseSxcbiAgICAvLyBkZXRlcm1pbmluZyB0aGUgc3RhdGUgZm9yIGV2ZXJ5IHBvaW50IGluIHRpbWUgYnkgYWRkaW5nICYgcmVtb3Zpbmcgb2JqZWN0cyBmcm9tIGFzcGlyaW5nSW5zdGFuY2VzXG4gICAgLy8gVGhlbiBzb3J0aW5nIGl0IHRvIGRldGVybWluZSB3aG8gdGFrZXMgcHJlY2VkZW5jZVxuICAgIGNvbnN0IGV2ZW50T2JqZWN0VGltZXMgPSB7fTtcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB7fTtcbiAgICBjb25zdCBhY3RpdmVPYmpJZHMgPSB7fTtcbiAgICBjb25zdCBhY3RpdmVLZXlmcmFtZXMgPSB7fTtcbiAgICBjb25zdCBhY3RpdmVLZXlmcmFtZXNDaGVja2VkID0ge307XG4gICAgLyoqIFRoZSBvYmplY3RzIGluIGFzcGlyaW5nSW5zdGFuY2VzICAqL1xuICAgIGNvbnN0IGFzcGlyaW5nSW5zdGFuY2VzID0ge307XG4gICAgY29uc3Qga2V5ZnJhbWVFdmVudHMgPSBbXTtcbiAgICBjb25zdCB0aW1lcyA9IE9iamVjdC5rZXlzKHBvaW50c0luVGltZSlcbiAgICAgICAgLm1hcCgodGltZSkgPT4gcGFyc2VGbG9hdCh0aW1lKSlcbiAgICAgICAgLy8gU29ydCBjaHJvbm9sb2dpY2FsbHk6XG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBwb2ludHMtb2YtaW50ZXJlc3QgdGltZXM6XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0aW1lID0gdGltZXNbaV07XG4gICAgICAgIGNvbnN0IGluc3RhbmNlc1RvQ2hlY2sgPSBwb2ludHNJblRpbWVbdGltZV07XG4gICAgICAgIGNvbnN0IGNoZWNrZWRPYmplY3RzVGhpc1RpbWUgPSB7fTtcbiAgICAgICAgaW5zdGFuY2VzVG9DaGVjay5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBpZiAoYS5vYmoucmVzb2x2ZWQgJiYgYi5vYmoucmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBLZXlmcmFtZXMgY29tZXMgZmlyc3Q6XG4gICAgICAgICAgICAgICAgaWYgKGEub2JqLnJlc29sdmVkLmlzS2V5ZnJhbWUgJiYgIWIub2JqLnJlc29sdmVkLmlzS2V5ZnJhbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoIWEub2JqLnJlc29sdmVkLmlzS2V5ZnJhbWUgJiYgYi5vYmoucmVzb2x2ZWQuaXNLZXlmcmFtZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgaWYgKGEub3JkZXIgPiBiLm9yZGVyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICBpZiAoYS5vcmRlciA8IGIub3JkZXIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAvLyBEZWVwZXIgb2JqZWN0cyAoY2hpbGRyZW4gaW4gZ3JvdXBzKSBjb21lcyBsYXRlciwgd2Ugd2FudCB0byBjaGVjayB0aGUgcGFyZW50IGdyb3VwcyBmaXJzdDpcbiAgICAgICAgICAgICAgICBpZiAoKGEub2JqLnJlc29sdmVkLmxldmVsRGVlcCB8fCAwKSA+IChiLm9iai5yZXNvbHZlZC5sZXZlbERlZXAgfHwgMCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIGlmICgoYS5vYmoucmVzb2x2ZWQubGV2ZWxEZWVwIHx8IDApIDwgKGIub2JqLnJlc29sdmVkLmxldmVsRGVlcCB8fCAwKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluc3RhbmNlc1RvQ2hlY2subGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG8gPSBpbnN0YW5jZXNUb0NoZWNrW2pdO1xuICAgICAgICAgICAgY29uc3Qgb2JqID0gby5vYmo7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG8uaW5zdGFuY2U7XG4gICAgICAgICAgICBsZXQgdG9CZUVuYWJsZWQgPSAoaW5zdGFuY2Uuc3RhcnQgfHwgMCkgPD0gdGltZSAmJiAoKF9iID0gaW5zdGFuY2UuZW5kKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBJbmZpbml0eSkgPiB0aW1lO1xuICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSBvYmoubGF5ZXIgKyAnJztcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBvYmouaWQgKyAnXycgKyBpbnN0YW5jZS5pZCArICdfJyArIG8uY2hlY2tJZDtcbiAgICAgICAgICAgIGlmICghY2hlY2tlZE9iamVjdHNUaGlzVGltZVtpZGVudGlmaWVyXSkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgY2hlY2sgZWFjaCBvYmplY3QgYW5kIGV2ZW50LXR5cGUgb25jZSBmb3IgZXZlcnkgcG9pbnQgaW4gdGltZVxuICAgICAgICAgICAgICAgIGNoZWNrZWRPYmplY3RzVGhpc1RpbWVbaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghb2JqLnJlc29sdmVkLmlzS2V5ZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgb2JqZWN0IGhhcyBhIHBhcmVudCwgb25seSBzZXQgaWYgcGFyZW50IGlzIG9uIGEgbGF5ZXIgKGlmIGxheWVyIGlzIHNldCBmb3IgcGFyZW50KVxuICAgICAgICAgICAgICAgICAgICBpZiAodG9CZUVuYWJsZWQgJiYgb2JqLnJlc29sdmVkLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRPYmogPSBvYmoucmVzb2x2ZWQucGFyZW50SWQgPyByZXNvbHZlZC5vYmplY3RzW29iai5yZXNvbHZlZC5wYXJlbnRJZF0gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9CZUVuYWJsZWQgPSAhIShwYXJlbnRPYmogJiYgKCFwYXJlbnRPYmoubGF5ZXIgfHwgYWN0aXZlT2JqSWRzW3BhcmVudE9iai5pZF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFzcGlyaW5nSW5zdGFuY2VzW29iai5sYXllcl0pXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3BpcmluZ0luc3RhbmNlc1tvYmoubGF5ZXJdID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b0JlRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGluc3RhbmNlIHdhbnRzIHRvIGJlIGVuYWJsZWQgKGlzIHN0YXJ0aW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIGFzcGlyaW5nSW5zdGFuY2VzOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXNwaXJpbmdJbnN0YW5jZXNbb2JqLmxheWVyXS5wdXNoKHsgb2JqLCBpbnN0YW5jZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBpbnN0YW5jZSBkb2Vzbid0IHdhbnQgdG8gYmUgZW5hYmxlZCAoaXMgZW5kaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gYXNwaXJpbmdJbnN0YW5jZXM6XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3BpcmluZ0luc3RhbmNlc1tsYXllcl0gPSBfLnJlamVjdChhc3BpcmluZ0luc3RhbmNlc1tsYXllcl0gfHwgW10sIChvKSA9PiBvLm9iai5pZCA9PT0gb2JqLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFdmFsdWF0ZSB0aGUgbGF5ZXIgdG8gZGV0ZXJtaW5lIHdobyBoYXMgdGhlIHRocm9uZTpcbiAgICAgICAgICAgICAgICAgICAgYXNwaXJpbmdJbnN0YW5jZXNbbGF5ZXJdLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB3aG8gdGFrZXMgcHJlY2VkZW5jZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0LCBzb3J0IHVzaW5nIHByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGEub2JqLnByaW9yaXR5IHx8IDApIDwgKGIub2JqLnByaW9yaXR5IHx8IDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChhLm9iai5wcmlvcml0eSB8fCAwKSA+IChiLm9iai5wcmlvcml0eSB8fCAwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVuLCBzb3J0IHVzaW5nIHRoZSBzdGFydCB0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGEuaW5zdGFuY2Uuc3RhcnQgfHwgMCkgPCAoYi5pbnN0YW5jZS5zdGFydCB8fCAwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYS5pbnN0YW5jZS5zdGFydCB8fCAwKSA+IChiLmluc3RhbmNlLnN0YXJ0IHx8IDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExhc3QgcmVzb3J0OiBzb3J0IHVzaW5nIGlkOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEub2JqLmlkID4gYi5vYmouaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS5vYmouaWQgPCBiLm9iai5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdywgdGhlIG9uZSBvbiB0b3AgaGFzIHRoZSB0aHJvbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGN1cnJlbnQgc3RhdGU6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRPblRvcE9mTGF5ZXIgPSBhc3BpcmluZ0luc3RhbmNlc1tsYXllcl1bMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZPYmogPSBjdXJyZW50U3RhdGVbbGF5ZXJdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlT2xkT2JqID0gY3VycmVudE9uVG9wT2ZMYXllciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFwcmV2T2JqIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldk9iai5pZCAhPT0gY3VycmVudE9uVG9wT2ZMYXllci5vYmouaWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2T2JqLmluc3RhbmNlLmlkICE9PSBjdXJyZW50T25Ub3BPZkxheWVyLmluc3RhbmNlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlT2xkT2JqID0gIWN1cnJlbnRPblRvcE9mTGF5ZXIgJiYgcHJldk9iajtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VPbGRPYmogfHwgcmVtb3ZlT2xkT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldk9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhcCB0aGUgb2xkIGluc3RhbmNlLCBzbyBpdCdsbCBlbmQgYXQgdGhpcyBwb2ludCBpbiB0aW1lOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBsaWJfMS5zZXRJbnN0YW5jZUVuZFRpbWUpKHByZXZPYmouaW5zdGFuY2UsIHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBhY3RpdmVPYmpJZHM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFjdGl2ZU9iaklkc1twcmV2T2JqLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdG8gbmV4dEV2ZW50czpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFN0YXRlcy5uZXh0RXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBlbnVtc18xLkV2ZW50VHlwZS5FTkQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaklkOiBwcmV2T2JqLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50T2JqZWN0VGltZXNbaW5zdGFuY2UuZW5kICsgJyddID0gZW51bXNfMS5FdmVudFR5cGUuRU5EO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlT2xkT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIG5ldyBvYmplY3QgdG8gU3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCBhIG5ldyBvYmplY3QgY2xvbmU6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3T2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkU3RhdGVzLm9iamVjdHNbY3VycmVudE9uVG9wT2ZMYXllci5vYmouaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBhbHJlYWR5IGV4aXN0aW5nIG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld09iaiA9IHJlc29sdmVkU3RhdGVzLm9iamVjdHNbY3VycmVudE9uVG9wT2ZMYXllci5vYmouaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3T2JqID0gXy5jbG9uZShjdXJyZW50T25Ub3BPZkxheWVyLm9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3T2JqLmNvbnRlbnQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG5ld09iai5jb250ZW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3T2JqLnJlc29sdmVkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4obmV3T2JqLnJlc29sdmVkIHx8IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBjb21tb25fMS5hZGRPYmplY3RUb1Jlc29sdmVkVGltZWxpbmUpKHJlc29sdmVkU3RhdGVzLCBuZXdPYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SW5zdGFuY2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3VycmVudE9uVG9wT2ZMYXllci5pbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSdyZSBzZXR0aW5nIG5ldyBzdGFydCAmIGVuZCB0aW1lcyBzbyB0aGV5IG1hdGNoIHVwIHdpdGggdGhlIHN0YXRlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tSW5zdGFuY2VJZDogY3VycmVudE9uVG9wT2ZMYXllci5pbnN0YW5jZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZDogY3VycmVudE9uVG9wT2ZMYXllci5pbnN0YW5jZS5vcmlnaW5hbEVuZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY3VycmVudE9uVG9wT2ZMYXllci5pbnN0YW5jZS5vcmlnaW5hbEVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGN1cnJlbnRPblRvcE9mTGF5ZXIuaW5zdGFuY2UuZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnQ6IGN1cnJlbnRPblRvcE9mTGF5ZXIuaW5zdGFuY2Uub3JpZ2luYWxTdGFydCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY3VycmVudE9uVG9wT2ZMYXllci5pbnN0YW5jZS5vcmlnaW5hbFN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VycmVudE9uVG9wT2ZMYXllci5pbnN0YW5jZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHRoZSBpbnN0YW5jZSBpZCB1bmlxdWU6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld09iai5yZXNvbHZlZC5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3T2JqLnJlc29sdmVkLmluc3RhbmNlc1tpXS5pZCA9PT0gbmV3SW5zdGFuY2UuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5zdGFuY2UuaWQgPSBuZXdJbnN0YW5jZS5pZCArICdfJCcgKyBuZXdPYmoucmVzb2x2ZWQuaW5zdGFuY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdPYmoucmVzb2x2ZWQuaW5zdGFuY2VzLnB1c2gobmV3SW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3T2JqSW5zdGFuY2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubmV3T2JqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBuZXdJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHRvIGN1cnJlbnQgc3RhdGU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGVbbGF5ZXJdID0gbmV3T2JqSW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYWN0aXZlT2JqSWRzOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlT2JqSWRzW25ld09iakluc3RhbmNlLmlkXSA9IG5ld09iakluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIG5leHRFdmVudHM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFN0YXRlcy5uZXh0RXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGVudW1zXzEuRXZlbnRUeXBlLlNUQVJULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ld0luc3RhbmNlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaklkOiBvYmouaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50T2JqZWN0VGltZXNbbmV3SW5zdGFuY2Uuc3RhcnQgKyAnJ10gPSBlbnVtc18xLkV2ZW50VHlwZS5TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlbW92ZU9sZE9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gY3VycmVudCBzdGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjdXJyZW50U3RhdGVbbGF5ZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsc28gbWFrZSBzdXJlIGFueSBjaGlsZHJlbiBhcmUgdXBkYXRlZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIG9iamVjdCBvbiBoYW5kLCBidXQgYWxzbyB0aGUgb25lIGluIHRoZSBjdXJyZW50U3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudHNUb0NoZWNrID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmlzR3JvdXApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50c1RvQ2hlY2sucHVzaChvYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfYyA9IGN1cnJlbnRTdGF0ZVtsYXllcl0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pc0dyb3VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHNUb0NoZWNrLnB1c2goY3VycmVudFN0YXRlW2xheWVyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcmVudCBvZiBwYXJlbnRzVG9DaGVjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2QgPSBwYXJlbnQuY2hpbGRyZW4pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZDAgb2YgcGFyZW50LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHJlc29sdmVkLm9iamVjdHNbY2hpbGQwLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgY2hpbGQucmVzb2x2ZWQuaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXJ0IDw9IHRpbWUgJiYgKChfZSA9IGluc3RhbmNlLmVuZCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogSW5maW5pdHkpID4gdGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGNoaWxkIGluc3RhbmNlLCBiZWNhdXNlIHRoYXQgbWlnaHQgYmUgYWZmZWN0ZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBvaW50SW5UaW1lKHRpbWUsICdjaGlsZCcsIDk5LCBjaGlsZCwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXMgYSBrZXlmcmFtZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlmcmFtZSA9IG9iajtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGtleWZyYW1lIHRvIHJlc29sdmVkU3RhdGVzLm9iamVjdHM6XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkU3RhdGVzLm9iamVjdHNba2V5ZnJhbWUuaWRdID0ga2V5ZnJhbWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvQmVFbmFibGVkID0gKGluc3RhbmNlLnN0YXJ0IHx8IDApIDw9IHRpbWUgJiYgKChfZiA9IGluc3RhbmNlLmVuZCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogSW5maW5pdHkpID4gdGltZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvQmVFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdPYmpJbnN0YW5jZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5rZXlmcmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlS2V5ZnJhbWVzW2tleWZyYW1lLmlkXSA9IG5ld09iakluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFjdGl2ZUtleWZyYW1lc1trZXlmcmFtZS5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYWN0aXZlS2V5ZnJhbWVzQ2hlY2tlZFtrZXlmcmFtZS5pZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gR28gdGhyb3VnaCBrZXlmcmFtZXM6XG4gICAgICAgIGNvbnN0IGFjdGl2ZUtleWZyYW1lc09iaklkcyA9IE9iamVjdC5rZXlzKGFjdGl2ZUtleWZyYW1lcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlS2V5ZnJhbWVzT2JqSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBvYmpJZCA9IGFjdGl2ZUtleWZyYW1lc09iaklkc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IG9iakluc3RhbmNlID0gYWN0aXZlS2V5ZnJhbWVzW29iaklkXTtcbiAgICAgICAgICAgIGNvbnN0IGtleWZyYW1lID0gb2JqSW5zdGFuY2U7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG9iakluc3RhbmNlLmluc3RhbmNlO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGtleWZyYW1lJ3MgcGFyZW50IGlzIGN1cnJlbnRseSBhY3RpdmU/XG4gICAgICAgICAgICBpZiAoa2V5ZnJhbWUucmVzb2x2ZWQucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRPYmogPSBhY3RpdmVPYmpJZHNba2V5ZnJhbWUucmVzb2x2ZWQucGFyZW50SWRdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRPYmogJiYgcGFyZW50T2JqLmxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtleWZyYW1lIGlzIG9uIGFuIGFjdGl2ZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50T2JqSW5zdGFuY2UgPSBjdXJyZW50U3RhdGVbcGFyZW50T2JqLmxheWVyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudE9iakluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFjdGl2ZUtleWZyYW1lc0NoZWNrZWRbb2JqSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFzbid0IHN0YXJ0ZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlS2V5ZnJhbWVzQ2hlY2tlZFtvYmpJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IFRoZSBrZXlmcmFtZXMgYXJlIGEgbGl0dGxlIGJpdCBzcGVjaWFsLCBzaW5jZSB0aGVpciBjb250ZW50cyBhcmUgYXBwbGllZCB0byB0aGVpciBwYXJlbnRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoYXQgYXBwbGljYXRpb24gaXMgZG9uZSBpbiB0aGUgZ2V0U3RhdGVBdFRpbWUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGtleWZyYW1lIHRvIG5leHRFdmVudHM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ZnJhbWVFdmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGVudW1zXzEuRXZlbnRUeXBlLktFWUZSQU1FLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBpbnN0YW5jZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqSWQ6IGtleWZyYW1lLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhcCBlbmQgd2l0aGluIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZUVuZCA9IE1hdGgubWluKChfZyA9IGluc3RhbmNlLmVuZCkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogSW5maW5pdHksIChfaCA9IHBhcmVudE9iakluc3RhbmNlLmluc3RhbmNlLmVuZCkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogSW5maW5pdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZUVuZCA9PT0gSW5maW5pdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlRW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2VFbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ZnJhbWVFdmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBlbnVtc18xLkV2ZW50VHlwZS5LRVlGUkFNRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IGluc3RhbmNlRW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqSWQ6IGtleWZyYW1lLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2U6IHRoZSBrZXlmcmFtZTpzIHBhcmVudCBpc24ndCBhY3RpdmUsIHJlbW92ZS9zdG9wIHRoZSBrZXlmcmFtZSB0aGVuOlxuICAgICAgICAgICAgZGVsZXRlIGFjdGl2ZUtleWZyYW1lc0NoZWNrZWRbb2JqSWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBpbnN0YW5jZXMgb2YgYWxsIG9iamVjdHMgKGV4Y2x1ZGluZyBrZXlmcmFtZXMpIGFyZSBwcm9wZXJseSBjYWxjdWxhdGVkLFxuICAgIC8vIHRha2luZyBpbnRvIGFjY291bnQgcHJpb3JpdGllcywgY2xhc2hlcyBldGMuXG4gICAgLy8gQ2FwIGNoaWxkcmVuIGluc2lkZSB0aGVpciBwYXJlbnRzOlxuICAgIHtcbiAgICAgICAgY29uc3QgYWxsQ2hpbGRyZW4gPSBPYmplY3QudmFsdWVzKHJlc29sdmVkU3RhdGVzLm9iamVjdHMpXG4gICAgICAgICAgICAuZmlsdGVyKChvYmopID0+ICEhb2JqLnJlc29sdmVkLnBhcmVudElkKVxuICAgICAgICAgICAgLy8gU29ydCwgc28gdGhhdCB0aGUgb3V0ZXJtb3N0IGFyZSBoYW5kbGVkIGZpcnN0OlxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICByZXR1cm4gKChfYSA9IGEucmVzb2x2ZWQubGV2ZWxEZWVwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSAtICgoX2IgPSBiLnJlc29sdmVkLmxldmVsRGVlcCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IG9iaiBvZiBhbGxDaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKG9iai5yZXNvbHZlZC5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHJlc29sdmVkU3RhdGVzLm9iamVjdHNbb2JqLnJlc29sdmVkLnBhcmVudElkXTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5yZXNvbHZlZC5pbnN0YW5jZXMgPSAoMCwgbGliXzEuY2xlYW5JbnN0YW5jZXMpKCgwLCBsaWJfMS5jYXBJbnN0YW5jZXMpKG9iai5yZXNvbHZlZC5pbnN0YW5jZXMsIHBhcmVudC5yZXNvbHZlZC5pbnN0YW5jZXMpLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBdCB0aGlzIHBvaW50LCBhbGwgaW5zdGFuY2VzIG9mIHRoZSBvYmplY3RzIHNob3VsZCBiZSBwcm9wZXJseSBjYWxjdWxhdGVkLlxuICAgIC8vIEdvIHRocm91Z2ggYWxsIGluc3RhbmNlcyBvZiBhbGwgb2JqZWN0cyB0byBjcmVhdGUgdGVtcG9yYXJ5IHN0YXRlcyBvZiBhbGwgbGF5ZXJzIGFuZCB0aW1lczpcbiAgICB7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIE9iamVjdC5rZXlzKHJlc29sdmVkU3RhdGVzLm9iamVjdHMpKSB7XG4gICAgICAgICAgICBjb25zdCBvYmogPSByZXNvbHZlZFN0YXRlcy5vYmplY3RzW2lkXTtcbiAgICAgICAgICAgIGNvbnN0IGxheWVyID0gYCR7b2JqLmxheWVyfWA7XG4gICAgICAgICAgICBpZiAoIXN0YXRlc1tsYXllcl0pXG4gICAgICAgICAgICAgICAgc3RhdGVzW2xheWVyXSA9IHt9O1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVMYXllciA9IHN0YXRlc1tsYXllcl07XG4gICAgICAgICAgICBpZiAoIW9iai5yZXNvbHZlZC5pc0tleWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBvYmoucmVzb2x2ZWQuaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IGluc3RhbmNlLnN0YXJ0ICsgJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGVMYXllcltzdGFydFRpbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUxheWVyW3N0YXJ0VGltZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDb3VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRDb3VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RJbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3T2JqSW5zdGFuY2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vYmosXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlTGF5ZXJbc3RhcnRUaW1lXS5zdGFydENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlTGF5ZXJbc3RhcnRUaW1lXS5vYmplY3RJbnN0YW5jZSA9IG5ld09iakluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuZW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmRUaW1lID0gaW5zdGFuY2UuZW5kICsgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlTGF5ZXJbZW5kVGltZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUxheWVyW2VuZFRpbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydENvdW50OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRDb3VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0SW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTGF5ZXJbZW5kVGltZV0uZW5kQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBHbyB0aHJvdWdoIHRoZSB0ZW1wb3Jhcnkgc3RhdGVzIGFuZCBhcHBseSB0aGUgY2hhbmdlcyB0byB0aGUgcmVzb2x2ZWRTdGF0ZXMuc3RhdGU6XG4gICAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgT2JqZWN0LmtleXMoc3RhdGVzKSkge1xuICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICBjb25zdCB0aW1lcyA9IE9iamVjdC5rZXlzKHN0YXRlc1tsYXllcl0pXG4gICAgICAgICAgICAgICAgLm1hcCgodGltZSkgPT4gcGFyc2VGbG9hdCh0aW1lKSlcbiAgICAgICAgICAgICAgICAvLyBTb3J0IGNocm9ub2xvZ2ljYWxseTpcbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWUgPSB0aW1lc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gc3RhdGVzW2xheWVyXVtgJHt0aW1lfWBdO1xuICAgICAgICAgICAgICAgIHN1bSArPSBzLnN0YXJ0Q291bnQ7XG4gICAgICAgICAgICAgICAgc3VtIC09IHMuZW5kQ291bnQ7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGZhdGFsIGJ1Z3M6XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHN1bSBpcyBsYXJnZXIgdGhhbiBvbmUsIG1vcmUgdGhhbiBvbmUgc3RhcnQgd2FzIGZvdW5kIGF0IHRoZSBzYW1lIHRpbWUsIHdoaWNoIHNob3VsZCBub3QgYmUgcG9zc2libGUuXG4gICAgICAgICAgICAgICAgaWYgKHN1bSA+IDEpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vIG1hbnkgc3RhcnQgZXZlbnRzIGF0ICR7bGF5ZXJ9ICR7dGltZX06ICR7c3VtfWApO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzdW0gaXMgbGVzcyB0aGFuIHplcm8sIHRoZXJlIGhhdmUgYmVlbiBtb3JlIGVuZHMgdGhhbiBzdGFydHMsIHdoaWNoIHNob3VsZCBub3QgYmUgcG9zc2libGUuXG4gICAgICAgICAgICAgICAgaWYgKHN1bSA8IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vIG1hbnkgZW5kIGV2ZW50cyBhdCAke2xheWVyfSAke3RpbWV9OiAke3N1bX1gKTtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSB0aGUgc3RhdGU6XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlZFN0YXRlcy5zdGF0ZVtsYXllcl0pXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkU3RhdGVzLnN0YXRlW2xheWVyXSA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChzdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHRoZSBvYmplY3QgaGFzIHN0YXJ0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzLm9iamVjdEluc3RhbmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvYmplY3RJbnN0YW5jZSBub3Qgc2V0LCBldmVudCB0aG91Z2ggc3VtPSR7c3VtfSBhdCAke2xheWVyfSAke3RpbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkU3RhdGVzLnN0YXRlW2xheWVyXVt0aW1lXSA9IFtzLm9iamVjdEluc3RhbmNlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgb2JqZWN0IGhhcyBlbmRlZFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFN0YXRlcy5zdGF0ZVtsYXllcl1bdGltZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYXAga2V5ZnJhbWVzIGluc2lkZSB0aGVpciBwYXJlbnRzOlxuICAgIGZvciAoY29uc3QgaWQgb2YgT2JqZWN0LmtleXMocmVzb2x2ZWRTdGF0ZXMub2JqZWN0cykpIHtcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qga2V5ZnJhbWUgPSByZXNvbHZlZFN0YXRlcy5vYmplY3RzW2lkXTtcbiAgICAgICAgICAgIGlmIChrZXlmcmFtZS5yZXNvbHZlZC5pc0tleWZyYW1lICYmIGtleWZyYW1lLnJlc29sdmVkLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gcmVzb2x2ZWRTdGF0ZXMub2JqZWN0c1trZXlmcmFtZS5yZXNvbHZlZC5wYXJlbnRJZF07XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYXAgdGhlIGtleWZyYW1lIGluc3RhbmNlcyB3aXRoaW4gaXRzIHBhcmVudHMgaW5zdGFuY2VzOlxuICAgICAgICAgICAgICAgICAgICBrZXlmcmFtZS5yZXNvbHZlZC5pbnN0YW5jZXMgPSAoMCwgbGliXzEuY2FwSW5zdGFuY2VzKShrZXlmcmFtZS5yZXNvbHZlZC5pbnN0YW5jZXMsIHBhcmVudC5yZXNvbHZlZC5pbnN0YW5jZXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgc3VyZSB0aGUgaW5zdGFuY2VzIGFyZSBpbiB0aGUgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlmcmFtZS5yZXNvbHZlZC5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0ga2V5ZnJhbWUucmVzb2x2ZWQuaW5zdGFuY2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ZnJhbWVJbnN0YW5jZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5rZXlmcmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNLZXlmcmFtZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlmcmFtZUVuZFRpbWU6IGluc3RhbmNlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQga2V5ZnJhbWUgdG8gdGhlIHRyYWNraW5nIHN0YXRlOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZnJhbWVBdFRpbWUocmVzb2x2ZWRTdGF0ZXMuc3RhdGUsIHBhcmVudC5sYXllciArICcnLCBpbnN0YW5jZS5zdGFydCwga2V5ZnJhbWVJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRml4IChtZXJnZSkgaW5zdGFuY2VzIG9mIHNlYW1sZXNzIG9iamVjdHM6XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHJlc29sdmVkU3RhdGVzLm9iamVjdHNbaWRdO1xuICAgICAgICAgICAgaWYgKG9iai5zZWFtbGVzcyAmJiBvYmoucmVzb2x2ZWQuaW5zdGFuY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBvYmoucmVzb2x2ZWQuaW5zdGFuY2VzID0gKDAsIGxpYl8xLmNsZWFuSW5zdGFuY2VzKShvYmoucmVzb2x2ZWQuaW5zdGFuY2VzLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXQgdGhpcyBwb2ludCwgQUxMIGluc3RhbmNlcyBhcmUgcHJvcGVybHkgY2FsY3VsYXRlZC5cbiAgICAvLyBHbyB0aHJvdWdoIHRoZSBrZXlmcmFtZSBldmVudHMgYW5kIGFkZCB0aGVtIHRvIG5leHRFdmVudHM6XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlmcmFtZUV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXlmcmFtZUV2ZW50ID0ga2V5ZnJhbWVFdmVudHNbaV07XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBpZiAoZXZlbnRPYmplY3RUaW1lc1trZXlmcmFtZUV2ZW50LnRpbWUgKyAnJ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBwdXQgYSBrZXlmcmFtZSBldmVudCBpZiB0aGVyZSdzIGFscmVhZHkgYW5vdGhlciBldmVudCB0aGVyZVxuICAgICAgICAgICAgcmVzb2x2ZWRTdGF0ZXMubmV4dEV2ZW50cy5wdXNoKGtleWZyYW1lRXZlbnQpO1xuICAgICAgICAgICAgZXZlbnRPYmplY3RUaW1lc1trZXlmcmFtZUV2ZW50LnRpbWUgKyAnJ10gPSBlbnVtc18xLkV2ZW50VHlwZS5LRVlGUkFNRTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNvbHZlZFN0YXRlcy5uZXh0RXZlbnRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgaWYgKGEudGltZSA+IGIudGltZSlcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoYS50aW1lIDwgYi50aW1lKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYS50eXBlID4gYi50eXBlKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYS50eXBlIDwgYi50eXBlKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhLm9iaklkIDwgYi5vYmpJZClcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEub2JqSWQgPiBiLm9iaklkKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgICBjYWNoZS5yZXNvbHZlZFN0YXRlcyA9IHJlc29sdmVkU3RhdGVzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZWRTdGF0ZXM7XG59XG5leHBvcnRzLnJlc29sdmVTdGF0ZXMgPSByZXNvbHZlU3RhdGVzO1xuZnVuY3Rpb24gYXBwbHlLZXlmcmFtZUNvbnRlbnQocGFyZW50Q29udGVudCwga2V5ZnJhbWVDb250ZW50KSB7XG4gICAgZm9yIChjb25zdCBbYXR0ciwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGtleWZyYW1lQ29udGVudCkpIHtcbiAgICAgICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghXy5pc0FycmF5KHBhcmVudENvbnRlbnRbYXR0cl0pKVxuICAgICAgICAgICAgICAgIHBhcmVudENvbnRlbnRbYXR0cl0gPSBbXTtcbiAgICAgICAgICAgIGFwcGx5S2V5ZnJhbWVDb250ZW50KHBhcmVudENvbnRlbnRbYXR0cl0sIHZhbHVlKTtcbiAgICAgICAgICAgIHBhcmVudENvbnRlbnRbYXR0cl0uc3BsaWNlKHZhbHVlLmxlbmd0aCwgOTk5OTkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIV8uaXNPYmplY3QocGFyZW50Q29udGVudFthdHRyXSkgfHwgXy5pc0FycmF5KHBhcmVudENvbnRlbnRbYXR0cl0pKVxuICAgICAgICAgICAgICAgIHBhcmVudENvbnRlbnRbYXR0cl0gPSB7fTtcbiAgICAgICAgICAgIGFwcGx5S2V5ZnJhbWVDb250ZW50KHBhcmVudENvbnRlbnRbYXR0cl0sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudENvbnRlbnRbYXR0cl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuYXBwbHlLZXlmcmFtZUNvbnRlbnQgPSBhcHBseUtleWZyYW1lQ29udGVudDtcbmZ1bmN0aW9uIGdldFRpbWVzRnJvbVBhcmVudHMocmVzb2x2ZWQsIG9iaikge1xuICAgIGxldCB0aW1lcyA9IFtdO1xuICAgIGNvbnN0IHBhcmVudE9iaiA9IG9iai5yZXNvbHZlZC5wYXJlbnRJZCA/IHJlc29sdmVkLm9iamVjdHNbb2JqLnJlc29sdmVkLnBhcmVudElkXSA6IG51bGw7XG4gICAgaWYgKHBhcmVudE9iaiAmJiBwYXJlbnRPYmoucmVzb2x2ZWQucmVzb2x2ZWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBwYXJlbnRPYmoucmVzb2x2ZWQuaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICB0aW1lcy5wdXNoKHsgdGltZTogaW5zdGFuY2Uuc3RhcnQsIGVuYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5lbmQpXG4gICAgICAgICAgICAgICAgdGltZXMucHVzaCh7IHRpbWU6IGluc3RhbmNlLmVuZCwgZW5hYmxlOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lcyA9IHRpbWVzLmNvbmNhdChnZXRUaW1lc0Zyb21QYXJlbnRzKHJlc29sdmVkLCBwYXJlbnRPYmopKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVzO1xufVxuZnVuY3Rpb24gYWRkS2V5ZnJhbWVBdFRpbWUoc3RhdGVzLCBsYXllciwgdGltZSwgb2JqSW5zdGFuY2VLZikge1xuICAgIGlmICghc3RhdGVzW2xheWVyXSlcbiAgICAgICAgc3RhdGVzW2xheWVyXSA9IHt9O1xuICAgIGNvbnN0IGlubmVyID0gc3RhdGVzW2xheWVyXVt0aW1lICsgJyddO1xuICAgIGlmICghaW5uZXIpIHtcbiAgICAgICAgc3RhdGVzW2xheWVyXVt0aW1lICsgJyddID0gW29iakluc3RhbmNlS2ZdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaW5uZXIucHVzaChvYmpJbnN0YW5jZUtmKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTdGF0ZUF0VGltZShzdGF0ZXMsIGxheWVyLCByZXF1ZXN0VGltZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsYXllclN0YXRlcyA9IHN0YXRlc1tsYXllcl0gfHwge307XG4gICAgY29uc3QgdGltZXMgPSBPYmplY3Qua2V5cyhsYXllclN0YXRlcylcbiAgICAgICAgLm1hcCgodGltZSkgPT4gcGFyc2VGbG9hdCh0aW1lKSlcbiAgICAgICAgLy8gU29ydCBjaHJvbm9sb2dpY2FsbHk6XG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9KTtcbiAgICBsZXQgc3RhdGUgPSBudWxsO1xuICAgIGxldCBpc0Nsb25lZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdGltZSA9IHRpbWVzW2ldO1xuICAgICAgICBpZiAodGltZSA8PSByZXF1ZXN0VGltZSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0YXRlSW5zdGFuY2VzID0gbGF5ZXJTdGF0ZXNbdGltZSArICcnXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGVJbnN0YW5jZXMgJiYgY3VycmVudFN0YXRlSW5zdGFuY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleWZyYW1lcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudFN0YXRlSW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRTdGF0ZUluc3RhbmNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSAmJiBjdXJyZW50U3RhdGUuaXNLZXlmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ZnJhbWVzLnB1c2goY3VycmVudFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gY3VycmVudFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNDbG9uZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlmcmFtZSA9IGtleWZyYW1lc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlICYmIGtleWZyYW1lLnJlc29sdmVkLnBhcmVudElkID09PSBzdGF0ZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoX2EgPSBrZXlmcmFtZS5rZXlmcmFtZUVuZFRpbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IEluZmluaXR5KSA+IHJlcXVlc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Nsb25lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0Nsb25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHN0YXRlLmNvbnRlbnQpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgdGhlIGtleWZyYW1lIG9uIHRoZSBzdGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseUtleWZyYW1lQ29udGVudChzdGF0ZS5jb250ZW50LCBrZXlmcmFtZS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpc0Nsb25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gaXNSZXNvbHZlZFN0YXRlcyhyZXNvbHZlZCkge1xuICAgIHJldHVybiAhIShyZXNvbHZlZCAmJiB0eXBlb2YgcmVzb2x2ZWQgPT09ICdvYmplY3QnICYmIHJlc29sdmVkLm9iamVjdHMgJiYgcmVzb2x2ZWQuc3RhdGUgJiYgcmVzb2x2ZWQubmV4dEV2ZW50cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVLZXlmcmFtZSA9IGV4cG9ydHMudmFsaWRhdGVPYmplY3QgPSBleHBvcnRzLnZhbGlkYXRlVGltZWxpbmUgPSB2b2lkIDA7XG5jb25zdCBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG5mdW5jdGlvbiB2YWxpZGF0ZU9iamVjdDAob2JqLCBzdHJpY3QsIHVuaXF1ZUlkcykge1xuICAgIGlmICghdW5pcXVlSWRzKVxuICAgICAgICB1bmlxdWVJZHMgPSB7fTtcbiAgICBpZiAoIW9iailcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgaXMgdW5kZWZpbmVkYCk7XG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBpcyBub3QgYW4gb2JqZWN0YCk7XG4gICAgaWYgKCFvYmouaWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IG1pc3NpbmcgXCJpZFwiIGF0dHJpYnV0ZWApO1xuICAgIGlmICh0eXBlb2Ygb2JqLmlkICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgXCJpZFwiIGF0dHJpYnV0ZSBpcyBub3QgYSBzdHJpbmc6IFwiJHtvYmouaWR9XCJgKTtcbiAgICBpZiAodW5pcXVlSWRzW29iai5pZF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IGlkIFwiJHtvYmouaWR9XCIgaXMgbm90IHVuaXF1ZWApO1xuICAgIHVuaXF1ZUlkc1tvYmouaWRdID0gdHJ1ZTtcbiAgICBpZiAob2JqLmxheWVyID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IFwiJHtvYmouaWR9XCI6IFwibGF5ZXJcIiBhdHRyaWJ1dGUgaXMgdW5kZWZpbmVkYCk7XG4gICAgaWYgKCFvYmouY29udGVudClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgXCIke29iai5pZH1cIjogXCJjb250ZW50XCIgYXR0cmlidXRlIG11c3QgYmUgc2V0YCk7XG4gICAgaWYgKCFvYmouZW5hYmxlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBcIiR7b2JqLmlkfVwiOiBcImVuYWJsZVwiIGF0dHJpYnV0ZSBtdXN0IGJlIHNldGApO1xuICAgIGNvbnN0IGVuYWJsZXMgPSBfLmlzQXJyYXkob2JqLmVuYWJsZSkgPyBvYmouZW5hYmxlIDogW29iai5lbmFibGVdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5hYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbmFibGUgPSBlbmFibGVzW2ldO1xuICAgICAgICBpZiAoZW5hYmxlLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZW5hYmxlLndoaWxlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgXCIke29iai5pZH1cIjogXCJlbmFibGUuc3RhcnRcIiBhbmQgXCJlbmFibGUud2hpbGVcIiBjYW5ub3QgYmUgY29tYmluZWRgKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZW5hYmxlLmVuZCAhPT0gdW5kZWZpbmVkICYmIGVuYWJsZS5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IFwiJHtvYmouaWR9XCI6IFwiZW5hYmxlLmVuZFwiIGFuZCBcImVuYWJsZS5kdXJhdGlvblwiIGNhbm5vdCBiZSBjb21iaW5lZGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVuYWJsZS53aGlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGVuYWJsZS5lbmQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBcIiR7b2JqLmlkfVwiOiBcImVuYWJsZS53aGlsZVwiIGFuZCBcImVuYWJsZS5lbmRcIiBjYW5ub3QgYmUgY29tYmluZWRgKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZW5hYmxlLmR1cmF0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgXCIke29iai5pZH1cIjogXCJlbmFibGUud2hpbGVcIiBhbmQgXCJlbmFibGUuZHVyYXRpb25cIiBjYW5ub3QgYmUgY29tYmluZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBcIiR7b2JqLmlkfVwiOiBcImVuYWJsZS5zdGFydFwiIG9yIFwiZW5hYmxlLndoaWxlXCIgbXVzdCBiZSBzZXRgKTtcbiAgICB9XG4gICAgaWYgKG9iai5rZXlmcmFtZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoua2V5ZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlmcmFtZSA9IG9iai5rZXlmcmFtZXNbaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlS2V5ZnJhbWUwKGtleWZyYW1lLCBzdHJpY3QsIHVuaXF1ZUlkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IFwiJHtvYmouaWR9XCIga2V5ZnJhbWVbJHtpfV06ICR7ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2JqLmNsYXNzZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmouY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gb2JqLmNsYXNzZXNbaV07XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lICYmIHR5cGVvZiBjbGFzc05hbWUgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IFwiJHtvYmouaWR9XCI6IFwiY2xhc3Nlc1ske2l9XVwiIGlzIG5vdCBhIHN0cmluZ2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvYmouY2hpbGRyZW4gJiYgIW9iai5pc0dyb3VwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBcIiR7b2JqLmlkfVwiOiBhdHRyaWJ1dGUgXCJjaGlsZHJlblwiIGlzIHNldCBidXQgXCJpc0dyb3VwXCIgaXMgbm90YCk7XG4gICAgaWYgKG9iai5pc0dyb3VwICYmICFvYmouY2hpbGRyZW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IFwiJHtvYmouaWR9XCI6IGF0dHJpYnV0ZSBcImlzR3JvdXBcIiBpcyBzZXQgYnV0IFwiY2hpbGRyZW5cIiBtaXNzaW5nYCk7XG4gICAgaWYgKG9iai5jaGlsZHJlbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBvYmouY2hpbGRyZW5baV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlT2JqZWN0MChjaGlsZCwgc3RyaWN0LCB1bmlxdWVJZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBcIiR7b2JqLmlkfVwiIGNoaWxkWyR7aX1dOiAke2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iai5wcmlvcml0eSAhPT0gdW5kZWZpbmVkICYmICFfLmlzTnVtYmVyKG9iai5wcmlvcml0eSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IFwiJHtvYmouaWR9XCI6IGF0dHJpYnV0ZSBcInByaW9yaXR5XCIgaXMgbm90IGEgbnVtYmVyYCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUtleWZyYW1lMChrZXlmcmFtZSwgc3RyaWN0LCB1bmlxdWVJZHMpIHtcbiAgICBpZiAoIXVuaXF1ZUlkcylcbiAgICAgICAgdW5pcXVlSWRzID0ge307XG4gICAgaWYgKCFrZXlmcmFtZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXlmcmFtZSBpcyB1bmRlZmluZWRgKTtcbiAgICBpZiAodHlwZW9mIGtleWZyYW1lICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXlmcmFtZSBpcyBub3QgYW4gb2JqZWN0YCk7XG4gICAgaWYgKCFrZXlmcmFtZS5pZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXlmcmFtZSBtaXNzaW5nIGlkIGF0dHJpYnV0ZWApO1xuICAgIGlmICh0eXBlb2Yga2V5ZnJhbWUuaWQgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleWZyYW1lIGlkIGF0dHJpYnV0ZSBpcyBub3QgYSBzdHJpbmc6IFwiJHtrZXlmcmFtZS5pZH1cImApO1xuICAgIGlmICh1bmlxdWVJZHNba2V5ZnJhbWUuaWRdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleWZyYW1lIGlkIFwiJHtrZXlmcmFtZS5pZH1cIiBpcyBub3QgdW5pcXVlYCk7XG4gICAgdW5pcXVlSWRzW2tleWZyYW1lLmlkXSA9IHRydWU7XG4gICAgaWYgKCFrZXlmcmFtZS5jb250ZW50KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleWZyYW1lIFwiJHtrZXlmcmFtZS5pZH1cIjogXCJjb250ZW50XCIgYXR0cmlidXRlIG11c3QgYmUgc2V0YCk7XG4gICAgaWYgKCFrZXlmcmFtZS5lbmFibGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ZnJhbWUgXCIke2tleWZyYW1lLmlkfVwiOiBcImVuYWJsZVwiIGF0dHJpYnV0ZSBtdXN0IGJlIHNldGApO1xuICAgIGNvbnN0IGVuYWJsZXMgPSBfLmlzQXJyYXkoa2V5ZnJhbWUuZW5hYmxlKSA/IGtleWZyYW1lLmVuYWJsZSA6IFtrZXlmcmFtZS5lbmFibGVdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5hYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbmFibGUgPSBlbmFibGVzW2ldO1xuICAgICAgICBpZiAoZW5hYmxlLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZW5hYmxlLndoaWxlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXlmcmFtZSBcIiR7a2V5ZnJhbWUuaWR9XCI6IFwiZW5hYmxlLnN0YXJ0XCIgYW5kIFwiZW5hYmxlLndoaWxlXCIgY2Fubm90IGJlIGNvbWJpbmVkYCk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGVuYWJsZS5lbmQgIT09IHVuZGVmaW5lZCAmJiBlbmFibGUuZHVyYXRpb24gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleWZyYW1lIFwiJHtrZXlmcmFtZS5pZH1cIjogXCJlbmFibGUuZW5kXCIgYW5kIFwiZW5hYmxlLmR1cmF0aW9uXCIgY2Fubm90IGJlIGNvbWJpbmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW5hYmxlLndoaWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZW5hYmxlLmVuZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ZnJhbWUgXCIke2tleWZyYW1lLmlkfVwiOiBcImVuYWJsZS53aGlsZVwiIGFuZCBcImVuYWJsZS5lbmRcIiBjYW5ub3QgYmUgY29tYmluZWRgKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZW5hYmxlLmR1cmF0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXlmcmFtZSBcIiR7a2V5ZnJhbWUuaWR9XCI6IFwiZW5hYmxlLndoaWxlXCIgYW5kIFwiZW5hYmxlLmR1cmF0aW9uXCIgY2Fubm90IGJlIGNvbWJpbmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXlmcmFtZSBcIiR7a2V5ZnJhbWUuaWR9XCI6IFwiZW5hYmxlLnN0YXJ0XCIgb3IgXCJlbmFibGUud2hpbGVcIiBtdXN0IGJlIHNldGApO1xuICAgIH1cbiAgICBpZiAoa2V5ZnJhbWUuY2xhc3Nlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleWZyYW1lLmNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGtleWZyYW1lLmNsYXNzZXNbaV07XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lICYmICFfLmlzU3RyaW5nKGNsYXNzTmFtZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXlmcmFtZSBcIiR7a2V5ZnJhbWUuaWR9XCI6IFwiY2xhc3Nlc1ske2l9XVwiIGlzIG5vdCBhIHN0cmluZ2ApO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYWxsIG9iamVjdHMgaW4gdGhlIHRpbWVsaW5lLiBUaHJvd3MgYW4gZXJyb3IgaWYgc29tZXRoaW5nJ3Mgd3JvbmdcbiAqIEBwYXJhbSB0aW1lbGluZSBUaGUgdGltZWxpbmUgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSBzdHJpY3QgU2V0IHRvIHRydWUgdG8gZW5hYmxlIHNvbWUgc3RyaWN0IHJ1bGVzIChydWxlcyB0aGF0IGNhbiBwb3NzaWJseSBiZSBpZ25vcmVkKVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVRpbWVsaW5lKHRpbWVsaW5lLCBzdHJpY3QpIHtcbiAgICBjb25zdCB1bmlxdWVJZHMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHRpbWVsaW5lW2ldO1xuICAgICAgICB2YWxpZGF0ZU9iamVjdDAob2JqLCBzdHJpY3QsIHVuaXF1ZUlkcyk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVRpbWVsaW5lID0gdmFsaWRhdGVUaW1lbGluZTtcbi8qKlxuICogVmFsaWRhdGVzIGEgVGltZWxpbmUtb2JqZWN0LiBUaHJvd3MgYW4gZXJyb3IgaWYgc29tZXRoaW5nJ3Mgd3JvbmdcbiAqIEBwYXJhbSB0aW1lbGluZSBUaGUgdGltZWxpbmUgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSBzdHJpY3QgU2V0IHRvIHRydWUgdG8gZW5hYmxlIHNvbWUgc3RyaWN0IHJ1bGVzIChydWxlcyB0aGF0IGNhbiBwb3NzaWJseSBiZSBpZ25vcmVkKVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmosIHN0cmljdCkge1xuICAgIHZhbGlkYXRlT2JqZWN0MChvYmosIHN0cmljdCk7XG59XG5leHBvcnRzLnZhbGlkYXRlT2JqZWN0ID0gdmFsaWRhdGVPYmplY3Q7XG4vKipcbiAqIFZhbGlkYXRlcyBhIFRpbWVsaW5lLWtleWZyYW1lLiBUaHJvd3MgYW4gZXJyb3IgaWYgc29tZXRoaW5nJ3Mgd3JvbmdcbiAqIEBwYXJhbSB0aW1lbGluZSBUaGUgdGltZWxpbmUgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSBzdHJpY3QgU2V0IHRvIHRydWUgdG8gZW5hYmxlIHNvbWUgc3RyaWN0IHJ1bGVzIChydWxlcyB0aGF0IGNhbiBwb3NzaWJseSBiZSBpZ25vcmVkKVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUtleWZyYW1lKGtleWZyYW1lLCBzdHJpY3QpIHtcbiAgICB2YWxpZGF0ZUtleWZyYW1lMChrZXlmcmFtZSwgc3RyaWN0KTtcbn1cbmV4cG9ydHMudmFsaWRhdGVLZXlmcmFtZSA9IHZhbGlkYXRlS2V5ZnJhbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0ZS5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIGdsb2JhbCwgZGVmaW5lLCBTeXN0ZW0sIFJlZmxlY3QsIFByb21pc2UgKi9cclxudmFyIF9fZXh0ZW5kcztcclxudmFyIF9fYXNzaWduO1xyXG52YXIgX19yZXN0O1xyXG52YXIgX19kZWNvcmF0ZTtcclxudmFyIF9fcGFyYW07XHJcbnZhciBfX21ldGFkYXRhO1xyXG52YXIgX19hd2FpdGVyO1xyXG52YXIgX19nZW5lcmF0b3I7XHJcbnZhciBfX2V4cG9ydFN0YXI7XHJcbnZhciBfX3ZhbHVlcztcclxudmFyIF9fcmVhZDtcclxudmFyIF9fc3ByZWFkO1xyXG52YXIgX19zcHJlYWRBcnJheXM7XHJcbnZhciBfX3NwcmVhZEFycmF5O1xyXG52YXIgX19hd2FpdDtcclxudmFyIF9fYXN5bmNHZW5lcmF0b3I7XHJcbnZhciBfX2FzeW5jRGVsZWdhdG9yO1xyXG52YXIgX19hc3luY1ZhbHVlcztcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0O1xyXG52YXIgX19pbXBvcnRTdGFyO1xyXG52YXIgX19pbXBvcnREZWZhdWx0O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQ7XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkSW47XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmc7XHJcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgdmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdHlwZW9mIHRoaXMgPT09IFwib2JqZWN0XCIgPyB0aGlzIDoge307XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoXCJ0c2xpYlwiLCBbXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAoZXhwb3J0cykgeyBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMpKSk7IH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKG1vZHVsZS5leHBvcnRzKSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFeHBvcnRlcihleHBvcnRzLCBwcmV2aW91cykge1xyXG4gICAgICAgIGlmIChleHBvcnRzICE9PSByb290KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaWQsIHYpIHsgcmV0dXJuIGV4cG9ydHNbaWRdID0gcHJldmlvdXMgPyBwcmV2aW91cyhpZCwgdikgOiB2OyB9O1xyXG4gICAgfVxyXG59KVxyXG4oZnVuY3Rpb24gKGV4cG9ydGVyKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVzdCA9IGZ1bmN0aW9uIChzLCBlKSB7XHJcbiAgICAgICAgdmFyIHQgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19kZWNvcmF0ZSA9IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgICAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcGFyYW0gPSBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fbWV0YWRhdGEgPSBmdW5jdGlvbiAobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2F3YWl0ZXIgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgX19nZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICAgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2V4cG9ydFN0YXIgPSBmdW5jdGlvbihtLCBvKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XHJcbiAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcclxuICAgICAgICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcclxuICAgIH0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgICAgICBvW2syXSA9IG1ba107XHJcbiAgICB9KTtcclxuXHJcbiAgICBfX3ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgICAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgICAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIH07XHJcblxyXG4gICAgX19yZWFkID0gZnVuY3Rpb24gKG8sIG4pIHtcclxuICAgICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICAgICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgICAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cclxuICAgIF9fc3ByZWFkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICAgICAgcmV0dXJuIGFyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cclxuICAgIF9fc3ByZWFkQXJyYXlzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH07XHJcblxyXG4gICAgX19zcHJlYWRBcnJheSA9IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jR2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgIH1cclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0RlbGVnYXRvciA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIGksIHA7XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNWYWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgICAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19tYWtlVGVtcGxhdGVPYmplY3QgPSBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcclxuICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgICAgIHJldHVybiBjb29rZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbiAgICB9KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbiAgICB9O1xyXG5cclxuICAgIF9faW1wb3J0U3RhciA9IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2ltcG9ydERlZmF1bHQgPSBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICAgICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgICAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgICAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEluID0gZnVuY3Rpb24gKHN0YXRlLCByZWNlaXZlcikge1xyXG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xyXG4gICAgICAgIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydGVyKFwiX19leHRlbmRzXCIsIF9fZXh0ZW5kcyk7XHJcbiAgICBleHBvcnRlcihcIl9fYXNzaWduXCIsIF9fYXNzaWduKTtcclxuICAgIGV4cG9ydGVyKFwiX19yZXN0XCIsIF9fcmVzdCk7XHJcbiAgICBleHBvcnRlcihcIl9fZGVjb3JhdGVcIiwgX19kZWNvcmF0ZSk7XHJcbiAgICBleHBvcnRlcihcIl9fcGFyYW1cIiwgX19wYXJhbSk7XHJcbiAgICBleHBvcnRlcihcIl9fbWV0YWRhdGFcIiwgX19tZXRhZGF0YSk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRlclwiLCBfX2F3YWl0ZXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2dlbmVyYXRvclwiLCBfX2dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fZXhwb3J0U3RhclwiLCBfX2V4cG9ydFN0YXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2NyZWF0ZUJpbmRpbmdcIiwgX19jcmVhdGVCaW5kaW5nKTtcclxuICAgIGV4cG9ydGVyKFwiX192YWx1ZXNcIiwgX192YWx1ZXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3JlYWRcIiwgX19yZWFkKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRcIiwgX19zcHJlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZEFycmF5c1wiLCBfX3NwcmVhZEFycmF5cyk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlcIiwgX19zcHJlYWRBcnJheSk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRcIiwgX19hd2FpdCk7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNHZW5lcmF0b3JcIiwgX19hc3luY0dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNEZWxlZ2F0b3JcIiwgX19hc3luY0RlbGVnYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNWYWx1ZXNcIiwgX19hc3luY1ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fbWFrZVRlbXBsYXRlT2JqZWN0XCIsIF9fbWFrZVRlbXBsYXRlT2JqZWN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19pbXBvcnRTdGFyXCIsIF9faW1wb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9faW1wb3J0RGVmYXVsdFwiLCBfX2ltcG9ydERlZmF1bHQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0XCIsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0XCIsIF9fY2xhc3NQcml2YXRlRmllbGRTZXQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkSW5cIiwgX19jbGFzc1ByaXZhdGVGaWVsZEluKTtcclxufSk7XHJcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG4vKiBnbG9iYWwgZ2xvYmFsLCBkZWZpbmUsIFN5c3RlbSwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG52YXIgX19leHRlbmRzO1xyXG52YXIgX19hc3NpZ247XHJcbnZhciBfX3Jlc3Q7XHJcbnZhciBfX2RlY29yYXRlO1xyXG52YXIgX19wYXJhbTtcclxudmFyIF9fbWV0YWRhdGE7XHJcbnZhciBfX2F3YWl0ZXI7XHJcbnZhciBfX2dlbmVyYXRvcjtcclxudmFyIF9fZXhwb3J0U3RhcjtcclxudmFyIF9fdmFsdWVzO1xyXG52YXIgX19yZWFkO1xyXG52YXIgX19zcHJlYWQ7XHJcbnZhciBfX3NwcmVhZEFycmF5cztcclxudmFyIF9fYXdhaXQ7XHJcbnZhciBfX2FzeW5jR2VuZXJhdG9yO1xyXG52YXIgX19hc3luY0RlbGVnYXRvcjtcclxudmFyIF9fYXN5bmNWYWx1ZXM7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdDtcclxudmFyIF9faW1wb3J0U3RhcjtcclxudmFyIF9faW1wb3J0RGVmYXVsdDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQ7XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0O1xyXG52YXIgX19jcmVhdGVCaW5kaW5nO1xyXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHR5cGVvZiB0aGlzID09PSBcIm9iamVjdFwiID8gdGhpcyA6IHt9O1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFwidHNsaWJcIiwgW1wiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKGV4cG9ydHMpIHsgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihleHBvcnRzKSkpOyB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihtb2R1bGUuZXhwb3J0cykpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cywgcHJldmlvdXMpIHtcclxuICAgICAgICBpZiAoZXhwb3J0cyAhPT0gcm9vdCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGlkLCB2KSB7IHJldHVybiBleHBvcnRzW2lkXSA9IHByZXZpb3VzID8gcHJldmlvdXMoaWQsIHYpIDogdjsgfTtcclxuICAgIH1cclxufSlcclxuKGZ1bmN0aW9uIChleHBvcnRlcikge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3Jlc3QgPSBmdW5jdGlvbiAocywgZSkge1xyXG4gICAgICAgIHZhciB0ID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZGVjb3JhdGUgPSBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgICAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3BhcmFtID0gZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdGVyID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZ2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgICAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgX19jcmVhdGVCaW5kaW5nID0gZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgICAgIG9bazJdID0gbVtrXTtcclxuICAgIH07XHJcblxyXG4gICAgX19leHBvcnRTdGFyID0gZnVuY3Rpb24gKG0sIGV4cG9ydHMpIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbiAgICB9O1xyXG5cclxuICAgIF9fdmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3JlYWQgPSBmdW5jdGlvbiAobywgbikge1xyXG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgICAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fc3ByZWFkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICAgICAgcmV0dXJuIGFyO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3NwcmVhZEFycmF5cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jR2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgIH1cclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0RlbGVnYXRvciA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIGksIHA7XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNWYWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgICAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19tYWtlVGVtcGxhdGVPYmplY3QgPSBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcclxuICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgICAgIHJldHVybiBjb29rZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9faW1wb3J0U3RhciA9IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgX19pbXBvcnREZWZhdWx0ID0gZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gZnVuY3Rpb24gKHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XHJcbiAgICAgICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSBmdW5jdGlvbiAocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRlcihcIl9fZXh0ZW5kc1wiLCBfX2V4dGVuZHMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2Fzc2lnblwiLCBfX2Fzc2lnbik7XHJcbiAgICBleHBvcnRlcihcIl9fcmVzdFwiLCBfX3Jlc3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2RlY29yYXRlXCIsIF9fZGVjb3JhdGUpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3BhcmFtXCIsIF9fcGFyYW0pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX21ldGFkYXRhXCIsIF9fbWV0YWRhdGEpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2F3YWl0ZXJcIiwgX19hd2FpdGVyKTtcclxuICAgIGV4cG9ydGVyKFwiX19nZW5lcmF0b3JcIiwgX19nZW5lcmF0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2V4cG9ydFN0YXJcIiwgX19leHBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX19jcmVhdGVCaW5kaW5nXCIsIF9fY3JlYXRlQmluZGluZyk7XHJcbiAgICBleHBvcnRlcihcIl9fdmFsdWVzXCIsIF9fdmFsdWVzKTtcclxuICAgIGV4cG9ydGVyKFwiX19yZWFkXCIsIF9fcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkXCIsIF9fc3ByZWFkKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheXNcIiwgX19zcHJlYWRBcnJheXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2F3YWl0XCIsIF9fYXdhaXQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jR2VuZXJhdG9yXCIsIF9fYXN5bmNHZW5lcmF0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jRGVsZWdhdG9yXCIsIF9fYXN5bmNEZWxlZ2F0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jVmFsdWVzXCIsIF9fYXN5bmNWYWx1ZXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX21ha2VUZW1wbGF0ZU9iamVjdFwiLCBfX21ha2VUZW1wbGF0ZU9iamVjdCk7XHJcbiAgICBleHBvcnRlcihcIl9faW1wb3J0U3RhclwiLCBfX2ltcG9ydFN0YXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2ltcG9ydERlZmF1bHRcIiwgX19pbXBvcnREZWZhdWx0KTtcclxuICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZEdldFwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KTtcclxuICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZFNldFwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KTtcclxufSk7XHJcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCd1bmRlcnNjb3JlJywgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50ID0gZ2xvYmFsLl87XG4gICAgdmFyIGV4cG9ydHMgPSBnbG9iYWwuXyA9IGZhY3RvcnkoKTtcbiAgICBleHBvcnRzLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7IGdsb2JhbC5fID0gY3VycmVudDsgcmV0dXJuIGV4cG9ydHM7IH07XG4gIH0oKSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkge1xuICAvLyAgICAgVW5kZXJzY29yZS5qcyAxLjEzLjRcbiAgLy8gICAgIGh0dHBzOi8vdW5kZXJzY29yZWpzLm9yZ1xuICAvLyAgICAgKGMpIDIwMDktMjAyMiBKZXJlbXkgQXNoa2VuYXMsIEp1bGlhbiBHb25nZ3JpanAsIGFuZCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAgLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICB2YXIgVkVSU0lPTiA9ICcxLjEzLjQnO1xuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIChgc2VsZmApIGluIHRoZSBicm93c2VyLCBgZ2xvYmFsYFxuICAvLyBvbiB0aGUgc2VydmVyLCBvciBgdGhpc2AgaW4gc29tZSB2aXJ0dWFsIG1hY2hpbmVzLiBXZSB1c2UgYHNlbGZgXG4gIC8vIGluc3RlYWQgb2YgYHdpbmRvd2AgZm9yIGBXZWJXb3JrZXJgIHN1cHBvcnQuXG4gIHZhciByb290ID0gKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgIEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCkgfHxcbiAgICAgICAgICAgIHt9O1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBTeW1ib2xQcm90byA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sLnByb3RvdHlwZSA6IG51bGw7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhciBwdXNoID0gQXJyYXlQcm90by5wdXNoLFxuICAgICAgc2xpY2UgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgICAgdG9TdHJpbmcgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gTW9kZXJuIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICB2YXIgc3VwcG9ydHNBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgICBzdXBwb3J0c0RhdGFWaWV3ID0gdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJztcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUrKiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXIgbmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgICBuYXRpdmVLZXlzID0gT2JqZWN0LmtleXMsXG4gICAgICBuYXRpdmVDcmVhdGUgPSBPYmplY3QuY3JlYXRlLFxuICAgICAgbmF0aXZlSXNWaWV3ID0gc3VwcG9ydHNBcnJheUJ1ZmZlciAmJiBBcnJheUJ1ZmZlci5pc1ZpZXc7XG5cbiAgLy8gQ3JlYXRlIHJlZmVyZW5jZXMgdG8gdGhlc2UgYnVpbHRpbiBmdW5jdGlvbnMgYmVjYXVzZSB3ZSBvdmVycmlkZSB0aGVtLlxuICB2YXIgX2lzTmFOID0gaXNOYU4sXG4gICAgICBfaXNGaW5pdGUgPSBpc0Zpbml0ZTtcblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIC8vIFRoZSBsYXJnZXN0IGludGVnZXIgdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgZXhhY3RseS5cbiAgdmFyIE1BWF9BUlJBWV9JTkRFWCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbiAgLy8gU29tZSBmdW5jdGlvbnMgdGFrZSBhIHZhcmlhYmxlIG51bWJlciBvZiBhcmd1bWVudHMsIG9yIGEgZmV3IGV4cGVjdGVkXG4gIC8vIGFyZ3VtZW50cyBhdCB0aGUgYmVnaW5uaW5nIGFuZCB0aGVuIGEgdmFyaWFibGUgbnVtYmVyIG9mIHZhbHVlcyB0byBvcGVyYXRlXG4gIC8vIG9uLiBUaGlzIGhlbHBlciBhY2N1bXVsYXRlcyBhbGwgcmVtYWluaW5nIGFyZ3VtZW50cyBwYXN0IHRoZSBmdW5jdGlvbuKAmXNcbiAgLy8gYXJndW1lbnQgbGVuZ3RoIChvciBhbiBleHBsaWNpdCBgc3RhcnRJbmRleGApLCBpbnRvIGFuIGFycmF5IHRoYXQgYmVjb21lc1xuICAvLyB0aGUgbGFzdCBhcmd1bWVudC4gU2ltaWxhciB0byBFUzbigJlzIFwicmVzdCBwYXJhbWV0ZXJcIi5cbiAgZnVuY3Rpb24gcmVzdEFyZ3VtZW50cyhmdW5jLCBzdGFydEluZGV4KSB7XG4gICAgc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXggPT0gbnVsbCA/IGZ1bmMubGVuZ3RoIC0gMSA6ICtzdGFydEluZGV4O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChhcmd1bWVudHMubGVuZ3RoIC0gc3RhcnRJbmRleCwgMCksXG4gICAgICAgICAgcmVzdCA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3RbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4ICsgc3RhcnRJbmRleF07XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIHJlc3QpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJndW1lbnRzWzBdLCByZXN0KTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCByZXN0KTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gQXJyYXkoc3RhcnRJbmRleCArIDEpO1xuICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgc3RhcnRJbmRleDsgaW5kZXgrKykge1xuICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICB9XG4gICAgICBhcmdzW3N0YXJ0SW5kZXhdID0gcmVzdDtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iaik7XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIGZ1bmN0aW9uIGlzTnVsbChvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xuICBmdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuICBmdW5jdGlvbiBpc0VsZW1lbnQob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgYHRvU3RyaW5nYC1iYXNlZCB0eXBlIHRlc3Rlci5cbiAgZnVuY3Rpb24gdGFnVGVzdGVyKG5hbWUpIHtcbiAgICB2YXIgdGFnID0gJ1tvYmplY3QgJyArIG5hbWUgKyAnXSc7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gdGFnO1xuICAgIH07XG4gIH1cblxuICB2YXIgaXNTdHJpbmcgPSB0YWdUZXN0ZXIoJ1N0cmluZycpO1xuXG4gIHZhciBpc051bWJlciA9IHRhZ1Rlc3RlcignTnVtYmVyJyk7XG5cbiAgdmFyIGlzRGF0ZSA9IHRhZ1Rlc3RlcignRGF0ZScpO1xuXG4gIHZhciBpc1JlZ0V4cCA9IHRhZ1Rlc3RlcignUmVnRXhwJyk7XG5cbiAgdmFyIGlzRXJyb3IgPSB0YWdUZXN0ZXIoJ0Vycm9yJyk7XG5cbiAgdmFyIGlzU3ltYm9sID0gdGFnVGVzdGVyKCdTeW1ib2wnKTtcblxuICB2YXIgaXNBcnJheUJ1ZmZlciA9IHRhZ1Rlc3RlcignQXJyYXlCdWZmZXInKTtcblxuICB2YXIgaXNGdW5jdGlvbiA9IHRhZ1Rlc3RlcignRnVuY3Rpb24nKTtcblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgYHR5cGVvZmAgYnVncyBpbiBvbGRcbiAgLy8gdjgsIElFIDExICgjMTYyMSksIFNhZmFyaSA4ICgjMTkyOSksIGFuZCBQaGFudG9tSlMgKCMyMjM2KS5cbiAgdmFyIG5vZGVsaXN0ID0gcm9vdC5kb2N1bWVudCAmJiByb290LmRvY3VtZW50LmNoaWxkTm9kZXM7XG4gIGlmICh0eXBlb2YgLy4vICE9ICdmdW5jdGlvbicgJiYgdHlwZW9mIEludDhBcnJheSAhPSAnb2JqZWN0JyAmJiB0eXBlb2Ygbm9kZWxpc3QgIT0gJ2Z1bmN0aW9uJykge1xuICAgIGlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBpc0Z1bmN0aW9uJDEgPSBpc0Z1bmN0aW9uO1xuXG4gIHZhciBoYXNPYmplY3RUYWcgPSB0YWdUZXN0ZXIoJ09iamVjdCcpO1xuXG4gIC8vIEluIElFIDEwIC0gRWRnZSAxMywgYERhdGFWaWV3YCBoYXMgc3RyaW5nIHRhZyBgJ1tvYmplY3QgT2JqZWN0XSdgLlxuICAvLyBJbiBJRSAxMSwgdGhlIG1vc3QgY29tbW9uIGFtb25nIHRoZW0sIHRoaXMgcHJvYmxlbSBhbHNvIGFwcGxpZXMgdG9cbiAgLy8gYE1hcGAsIGBXZWFrTWFwYCBhbmQgYFNldGAuXG4gIHZhciBoYXNTdHJpbmdUYWdCdWcgPSAoXG4gICAgICAgIHN1cHBvcnRzRGF0YVZpZXcgJiYgaGFzT2JqZWN0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoOCkpKVxuICAgICAgKSxcbiAgICAgIGlzSUUxMSA9ICh0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJyAmJiBoYXNPYmplY3RUYWcobmV3IE1hcCkpO1xuXG4gIHZhciBpc0RhdGFWaWV3ID0gdGFnVGVzdGVyKCdEYXRhVmlldycpO1xuXG4gIC8vIEluIElFIDEwIC0gRWRnZSAxMywgd2UgbmVlZCBhIGRpZmZlcmVudCBoZXVyaXN0aWNcbiAgLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGEgYERhdGFWaWV3YC5cbiAgZnVuY3Rpb24gaWUxMElzRGF0YVZpZXcob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGlzRnVuY3Rpb24kMShvYmouZ2V0SW50OCkgJiYgaXNBcnJheUJ1ZmZlcihvYmouYnVmZmVyKTtcbiAgfVxuXG4gIHZhciBpc0RhdGFWaWV3JDEgPSAoaGFzU3RyaW5nVGFnQnVnID8gaWUxMElzRGF0YVZpZXcgOiBpc0RhdGFWaWV3KTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgYEFycmF5LmlzQXJyYXlgLlxuICB2YXIgaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgdGFnVGVzdGVyKCdBcnJheScpO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRvIGNoZWNrIHdoZXRoZXIgYGtleWAgaXMgYW4gb3duIHByb3BlcnR5IG5hbWUgb2YgYG9iamAuXG4gIGZ1bmN0aW9uIGhhcyQxKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9XG5cbiAgdmFyIGlzQXJndW1lbnRzID0gdGFnVGVzdGVyKCdBcmd1bWVudHMnKTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIChmdW5jdGlvbigpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICAgIGlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBoYXMkMShvYmosICdjYWxsZWUnKTtcbiAgICAgIH07XG4gICAgfVxuICB9KCkpO1xuXG4gIHZhciBpc0FyZ3VtZW50cyQxID0gaXNBcmd1bWVudHM7XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBmdW5jdGlvbiBpc0Zpbml0ZSQxKG9iaikge1xuICAgIHJldHVybiAhaXNTeW1ib2wob2JqKSAmJiBfaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfVxuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD9cbiAgZnVuY3Rpb24gaXNOYU4kMShvYmopIHtcbiAgICByZXR1cm4gaXNOdW1iZXIob2JqKSAmJiBfaXNOYU4ob2JqKTtcbiAgfVxuXG4gIC8vIFByZWRpY2F0ZS1nZW5lcmF0aW5nIGZ1bmN0aW9uLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gQ29tbW9uIGludGVybmFsIGxvZ2ljIGZvciBgaXNBcnJheUxpa2VgIGFuZCBgaXNCdWZmZXJMaWtlYC5cbiAgZnVuY3Rpb24gY3JlYXRlU2l6ZVByb3BlcnR5Q2hlY2soZ2V0U2l6ZVByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBzaXplUHJvcGVydHkgPSBnZXRTaXplUHJvcGVydHkoY29sbGVjdGlvbik7XG4gICAgICByZXR1cm4gdHlwZW9mIHNpemVQcm9wZXJ0eSA9PSAnbnVtYmVyJyAmJiBzaXplUHJvcGVydHkgPj0gMCAmJiBzaXplUHJvcGVydHkgPD0gTUFYX0FSUkFZX0lOREVYO1xuICAgIH1cbiAgfVxuXG4gIC8vIEludGVybmFsIGhlbHBlciB0byBnZW5lcmF0ZSBhIGZ1bmN0aW9uIHRvIG9idGFpbiBwcm9wZXJ0eSBga2V5YCBmcm9tIGBvYmpgLlxuICBmdW5jdGlvbiBzaGFsbG93UHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8vIEludGVybmFsIGhlbHBlciB0byBvYnRhaW4gdGhlIGBieXRlTGVuZ3RoYCBwcm9wZXJ0eSBvZiBhbiBvYmplY3QuXG4gIHZhciBnZXRCeXRlTGVuZ3RoID0gc2hhbGxvd1Byb3BlcnR5KCdieXRlTGVuZ3RoJyk7XG5cbiAgLy8gSW50ZXJuYWwgaGVscGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHdlIHNob3VsZCBzcGVuZCBleHRlbnNpdmUgY2hlY2tzIGFnYWluc3RcbiAgLy8gYEFycmF5QnVmZmVyYCBldCBhbC5cbiAgdmFyIGlzQnVmZmVyTGlrZSA9IGNyZWF0ZVNpemVQcm9wZXJ0eUNoZWNrKGdldEJ5dGVMZW5ndGgpO1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSB0eXBlZCBhcnJheT9cbiAgdmFyIHR5cGVkQXJyYXlQYXR0ZXJuID0gL1xcW29iamVjdCAoKEl8VWkpbnQoOHwxNnwzMil8RmxvYXQoMzJ8NjQpfFVpbnQ4Q2xhbXBlZHxCaWcoSXxVaSludDY0KUFycmF5XFxdLztcbiAgZnVuY3Rpb24gaXNUeXBlZEFycmF5KG9iaikge1xuICAgIC8vIGBBcnJheUJ1ZmZlci5pc1ZpZXdgIGlzIHRoZSBtb3N0IGZ1dHVyZS1wcm9vZiwgc28gdXNlIGl0IHdoZW4gYXZhaWxhYmxlLlxuICAgIC8vIE90aGVyd2lzZSwgZmFsbCBiYWNrIG9uIHRoZSBhYm92ZSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgcmV0dXJuIG5hdGl2ZUlzVmlldyA/IChuYXRpdmVJc1ZpZXcob2JqKSAmJiAhaXNEYXRhVmlldyQxKG9iaikpIDpcbiAgICAgICAgICAgICAgICAgIGlzQnVmZmVyTGlrZShvYmopICYmIHR5cGVkQXJyYXlQYXR0ZXJuLnRlc3QodG9TdHJpbmcuY2FsbChvYmopKTtcbiAgfVxuXG4gIHZhciBpc1R5cGVkQXJyYXkkMSA9IHN1cHBvcnRzQXJyYXlCdWZmZXIgPyBpc1R5cGVkQXJyYXkgOiBjb25zdGFudChmYWxzZSk7XG5cbiAgLy8gSW50ZXJuYWwgaGVscGVyIHRvIG9idGFpbiB0aGUgYGxlbmd0aGAgcHJvcGVydHkgb2YgYW4gb2JqZWN0LlxuICB2YXIgZ2V0TGVuZ3RoID0gc2hhbGxvd1Byb3BlcnR5KCdsZW5ndGgnKTtcblxuICAvLyBJbnRlcm5hbCBoZWxwZXIgdG8gY3JlYXRlIGEgc2ltcGxlIGxvb2t1cCBzdHJ1Y3R1cmUuXG4gIC8vIGBjb2xsZWN0Tm9uRW51bVByb3BzYCB1c2VkIHRvIGRlcGVuZCBvbiBgXy5jb250YWluc2AsIGJ1dCB0aGlzIGxlZCB0b1xuICAvLyBjaXJjdWxhciBpbXBvcnRzLiBgZW11bGF0ZWRTZXRgIGlzIGEgb25lLW9mZiBzb2x1dGlvbiB0aGF0IG9ubHkgd29ya3MgZm9yXG4gIC8vIGFycmF5cyBvZiBzdHJpbmdzLlxuICBmdW5jdGlvbiBlbXVsYXRlZFNldChrZXlzKSB7XG4gICAgdmFyIGhhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBsID0ga2V5cy5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgKytpKSBoYXNoW2tleXNbaV1dID0gdHJ1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGFpbnM6IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaGFzaFtrZXldID09PSB0cnVlOyB9LFxuICAgICAgcHVzaDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGhhc2hba2V5XSA9IHRydWU7XG4gICAgICAgIHJldHVybiBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgaGVscGVyLiBDaGVja3MgYGtleXNgIGZvciB0aGUgcHJlc2VuY2Ugb2Yga2V5cyBpbiBJRSA8IDkgdGhhdCB3b24ndFxuICAvLyBiZSBpdGVyYXRlZCBieSBgZm9yIGtleSBpbiAuLi5gIGFuZCB0aHVzIG1pc3NlZC4gRXh0ZW5kcyBga2V5c2AgaW4gcGxhY2UgaWZcbiAgLy8gbmVlZGVkLlxuICBmdW5jdGlvbiBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cykge1xuICAgIGtleXMgPSBlbXVsYXRlZFNldChrZXlzKTtcbiAgICB2YXIgbm9uRW51bUlkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGg7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90byA9IChpc0Z1bmN0aW9uJDEoY29uc3RydWN0b3IpICYmIGNvbnN0cnVjdG9yLnByb3RvdHlwZSkgfHwgT2JqUHJvdG87XG5cbiAgICAvLyBDb25zdHJ1Y3RvciBpcyBhIHNwZWNpYWwgY2FzZS5cbiAgICB2YXIgcHJvcCA9ICdjb25zdHJ1Y3Rvcic7XG4gICAgaWYgKGhhcyQxKG9iaiwgcHJvcCkgJiYgIWtleXMuY29udGFpbnMocHJvcCkpIGtleXMucHVzaChwcm9wKTtcblxuICAgIHdoaWxlIChub25FbnVtSWR4LS0pIHtcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbm9uRW51bUlkeF07XG4gICAgICBpZiAocHJvcCBpbiBvYmogJiYgb2JqW3Byb3BdICE9PSBwcm90b1twcm9wXSAmJiAha2V5cy5jb250YWlucyhwcm9wKSkge1xuICAgICAgICBrZXlzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgLlxuICBmdW5jdGlvbiBrZXlzKG9iaikge1xuICAgIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKGhhcyQxKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIGFycmF5LCBzdHJpbmcsIG9yIG9iamVjdCBlbXB0eT9cbiAgLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cbiAgZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIC8vIFNraXAgdGhlIG1vcmUgZXhwZW5zaXZlIGB0b1N0cmluZ2AtYmFzZWQgdHlwZSBjaGVja3MgaWYgYG9iamAgaGFzIG5vXG4gICAgLy8gYC5sZW5ndGhgLlxuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgob2JqKTtcbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiAoXG4gICAgICBpc0FycmF5KG9iaikgfHwgaXNTdHJpbmcob2JqKSB8fCBpc0FyZ3VtZW50cyQxKG9iailcbiAgICApKSByZXR1cm4gbGVuZ3RoID09PSAwO1xuICAgIHJldHVybiBnZXRMZW5ndGgoa2V5cyhvYmopKSA9PT0gMDtcbiAgfVxuXG4gIC8vIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBmdW5jdGlvbiBpc01hdGNoKG9iamVjdCwgYXR0cnMpIHtcbiAgICB2YXIgX2tleXMgPSBrZXlzKGF0dHJzKSwgbGVuZ3RoID0gX2tleXMubGVuZ3RoO1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkgcmV0dXJuICFsZW5ndGg7XG4gICAgdmFyIG9iaiA9IE9iamVjdChvYmplY3QpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBfa2V5c1tpXTtcbiAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXQgY2FuXG4gIC8vIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCBmdW5jdGlvbnMgYWRkZWRcbiAgLy8gdGhyb3VnaCBgXy5taXhpbmAuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cbiAgZnVuY3Rpb24gXyQxKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfJDEpIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8kMSkpIHJldHVybiBuZXcgXyQxKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfVxuXG4gIF8kMS5WRVJTSU9OID0gVkVSU0lPTjtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXyQxLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIFByb3ZpZGUgdW53cmFwcGluZyBwcm94aWVzIGZvciBzb21lIG1ldGhvZHMgdXNlZCBpbiBlbmdpbmUgb3BlcmF0aW9uc1xuICAvLyBzdWNoIGFzIGFyaXRobWV0aWMgYW5kIEpTT04gc3RyaW5naWZpY2F0aW9uLlxuICBfJDEucHJvdG90eXBlLnZhbHVlT2YgPSBfJDEucHJvdG90eXBlLnRvSlNPTiA9IF8kMS5wcm90b3R5cGUudmFsdWU7XG5cbiAgXyQxLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5fd3JhcHBlZCk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdG8gd3JhcCBvciBzaGFsbG93LWNvcHkgYW4gQXJyYXlCdWZmZXIsXG4gIC8vIHR5cGVkIGFycmF5IG9yIERhdGFWaWV3IHRvIGEgbmV3IHZpZXcsIHJldXNpbmcgdGhlIGJ1ZmZlci5cbiAgZnVuY3Rpb24gdG9CdWZmZXJWaWV3KGJ1ZmZlclNvdXJjZSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShcbiAgICAgIGJ1ZmZlclNvdXJjZS5idWZmZXIgfHwgYnVmZmVyU291cmNlLFxuICAgICAgYnVmZmVyU291cmNlLmJ5dGVPZmZzZXQgfHwgMCxcbiAgICAgIGdldEJ5dGVMZW5ndGgoYnVmZmVyU291cmNlKVxuICAgICk7XG4gIH1cblxuICAvLyBXZSB1c2UgdGhpcyBzdHJpbmcgdHdpY2UsIHNvIGdpdmUgaXQgYSBuYW1lIGZvciBtaW5pZmljYXRpb24uXG4gIHZhciB0YWdEYXRhVmlldyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBfLmlzRXF1YWxgLlxuICBmdW5jdGlvbiBlcShhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cHM6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgb25seSBlcXVhbCB0byBpdHNlbGYgKHN0cmljdCBjb21wYXJpc29uKS5cbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgaWYgKGEgIT09IGEpIHJldHVybiBiICE9PSBiO1xuICAgIC8vIEV4aGF1c3QgcHJpbWl0aXZlIGNoZWNrc1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGE7XG4gICAgaWYgKHR5cGUgIT09ICdmdW5jdGlvbicgJiYgdHlwZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gZGVlcEVxKGEsIGIsIGFTdGFjaywgYlN0YWNrKTtcbiAgfVxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgXy5pc0VxdWFsYC5cbiAgZnVuY3Rpb24gZGVlcEVxKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG4gICAgaWYgKGEgaW5zdGFuY2VvZiBfJDEpIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXyQxKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICAvLyBXb3JrIGFyb3VuZCBhIGJ1ZyBpbiBJRSAxMCAtIEVkZ2UgMTMuXG4gICAgaWYgKGhhc1N0cmluZ1RhZ0J1ZyAmJiBjbGFzc05hbWUgPT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgaXNEYXRhVmlldyQxKGEpKSB7XG4gICAgICBpZiAoIWlzRGF0YVZpZXckMShiKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgY2xhc3NOYW1lID0gdGFnRGF0YVZpZXc7XG4gICAgfVxuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAvLyBUaGVzZSB0eXBlcyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgICAvLyBSZWdFeHBzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgZm9yIGNvbXBhcmlzb24gKE5vdGU6ICcnICsgL2EvaSA9PT0gJy9hL2knKVxuICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxuICAgICAgICByZXR1cm4gJycgKyBhID09PSAnJyArIGI7XG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgICAgICAvLyBPYmplY3QoTmFOKSBpcyBlcXVpdmFsZW50IHRvIE5hTi5cbiAgICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjtcbiAgICAgICAgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJldHVybiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IFN5bWJvbF0nOlxuICAgICAgICByZXR1cm4gU3ltYm9sUHJvdG8udmFsdWVPZi5jYWxsKGEpID09PSBTeW1ib2xQcm90by52YWx1ZU9mLmNhbGwoYik7XG4gICAgICBjYXNlICdbb2JqZWN0IEFycmF5QnVmZmVyXSc6XG4gICAgICBjYXNlIHRhZ0RhdGFWaWV3OlxuICAgICAgICAvLyBDb2VyY2UgdG8gdHlwZWQgYXJyYXkgc28gd2UgY2FuIGZhbGwgdGhyb3VnaC5cbiAgICAgICAgcmV0dXJuIGRlZXBFcSh0b0J1ZmZlclZpZXcoYSksIHRvQnVmZmVyVmlldyhiKSwgYVN0YWNrLCBiU3RhY2spO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMgJiYgaXNUeXBlZEFycmF5JDEoYSkpIHtcbiAgICAgICAgdmFyIGJ5dGVMZW5ndGggPSBnZXRCeXRlTGVuZ3RoKGEpO1xuICAgICAgICBpZiAoYnl0ZUxlbmd0aCAhPT0gZ2V0Qnl0ZUxlbmd0aChiKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoYS5idWZmZXIgPT09IGIuYnVmZmVyICYmIGEuYnl0ZU9mZnNldCA9PT0gYi5ieXRlT2Zmc2V0KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgYXJlQXJyYXlzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoaXNGdW5jdGlvbiQxKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbiQxKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIgX2tleXMgPSBrZXlzKGEpLCBrZXk7XG4gICAgICBsZW5ndGggPSBfa2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoa2V5cyhiKS5sZW5ndGggIT09IGxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxuICAgICAgICBrZXkgPSBfa2V5c1tsZW5ndGhdO1xuICAgICAgICBpZiAoIShoYXMkMShiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgZnVuY3Rpb24gYWxsS2V5cyhvYmopIHtcbiAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9XG5cbiAgLy8gU2luY2UgdGhlIHJlZ3VsYXIgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIHR5cGUgdGVzdHMgZG9uJ3Qgd29yayBmb3JcbiAgLy8gc29tZSB0eXBlcyBpbiBJRSAxMSwgd2UgdXNlIGEgZmluZ2VycHJpbnRpbmcgaGV1cmlzdGljIGluc3RlYWQsIGJhc2VkXG4gIC8vIG9uIHRoZSBtZXRob2RzLiBJdCdzIG5vdCBncmVhdCwgYnV0IGl0J3MgdGhlIGJlc3Qgd2UgZ290LlxuICAvLyBUaGUgZmluZ2VycHJpbnQgbWV0aG9kIGxpc3RzIGFyZSBkZWZpbmVkIGJlbG93LlxuICBmdW5jdGlvbiBpZTExZmluZ2VycHJpbnQobWV0aG9kcykge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgobWV0aG9kcyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBgTWFwYCwgYFdlYWtNYXBgIGFuZCBgU2V0YCBoYXZlIG5vIGVudW1lcmFibGUga2V5cy5cbiAgICAgIHZhciBrZXlzID0gYWxsS2V5cyhvYmopO1xuICAgICAgaWYgKGdldExlbmd0aChrZXlzKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWlzRnVuY3Rpb24kMShvYmpbbWV0aG9kc1tpXV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBhcmUgdGVzdGluZyBhZ2FpbnN0IGBXZWFrTWFwYCwgd2UgbmVlZCB0byBlbnN1cmUgdGhhdFxuICAgICAgLy8gYG9iamAgZG9lc24ndCBoYXZlIGEgYGZvckVhY2hgIG1ldGhvZCBpbiBvcmRlciB0byBkaXN0aW5ndWlzaFxuICAgICAgLy8gaXQgZnJvbSBhIHJlZ3VsYXIgYE1hcGAuXG4gICAgICByZXR1cm4gbWV0aG9kcyAhPT0gd2Vha01hcE1ldGhvZHMgfHwgIWlzRnVuY3Rpb24kMShvYmpbZm9yRWFjaE5hbWVdKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gSW4gdGhlIGludGVyZXN0IG9mIGNvbXBhY3QgbWluaWZpY2F0aW9uLCB3ZSB3cml0ZVxuICAvLyBlYWNoIHN0cmluZyBpbiB0aGUgZmluZ2VycHJpbnRzIG9ubHkgb25jZS5cbiAgdmFyIGZvckVhY2hOYW1lID0gJ2ZvckVhY2gnLFxuICAgICAgaGFzTmFtZSA9ICdoYXMnLFxuICAgICAgY29tbW9uSW5pdCA9IFsnY2xlYXInLCAnZGVsZXRlJ10sXG4gICAgICBtYXBUYWlsID0gWydnZXQnLCBoYXNOYW1lLCAnc2V0J107XG5cbiAgLy8gYE1hcGAsIGBXZWFrTWFwYCBhbmQgYFNldGAgZWFjaCBoYXZlIHNsaWdodGx5IGRpZmZlcmVudFxuICAvLyBjb21iaW5hdGlvbnMgb2YgdGhlIGFib3ZlIHN1Ymxpc3RzLlxuICB2YXIgbWFwTWV0aG9kcyA9IGNvbW1vbkluaXQuY29uY2F0KGZvckVhY2hOYW1lLCBtYXBUYWlsKSxcbiAgICAgIHdlYWtNYXBNZXRob2RzID0gY29tbW9uSW5pdC5jb25jYXQobWFwVGFpbCksXG4gICAgICBzZXRNZXRob2RzID0gWydhZGQnXS5jb25jYXQoY29tbW9uSW5pdCwgZm9yRWFjaE5hbWUsIGhhc05hbWUpO1xuXG4gIHZhciBpc01hcCA9IGlzSUUxMSA/IGllMTFmaW5nZXJwcmludChtYXBNZXRob2RzKSA6IHRhZ1Rlc3RlcignTWFwJyk7XG5cbiAgdmFyIGlzV2Vha01hcCA9IGlzSUUxMSA/IGllMTFmaW5nZXJwcmludCh3ZWFrTWFwTWV0aG9kcykgOiB0YWdUZXN0ZXIoJ1dlYWtNYXAnKTtcblxuICB2YXIgaXNTZXQgPSBpc0lFMTEgPyBpZTExZmluZ2VycHJpbnQoc2V0TWV0aG9kcykgOiB0YWdUZXN0ZXIoJ1NldCcpO1xuXG4gIHZhciBpc1dlYWtTZXQgPSB0YWdUZXN0ZXIoJ1dlYWtTZXQnKTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIGZ1bmN0aW9uIHZhbHVlcyhvYmopIHtcbiAgICB2YXIgX2tleXMgPSBrZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IF9rZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvYmpbX2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgLy8gQ29udmVydCBhbiBvYmplY3QgaW50byBhIGxpc3Qgb2YgYFtrZXksIHZhbHVlXWAgcGFpcnMuXG4gIC8vIFRoZSBvcHBvc2l0ZSBvZiBgXy5vYmplY3RgIHdpdGggb25lIGFyZ3VtZW50LlxuICBmdW5jdGlvbiBwYWlycyhvYmopIHtcbiAgICB2YXIgX2tleXMgPSBrZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IF9rZXlzLmxlbmd0aDtcbiAgICB2YXIgcGFpcnMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhaXJzW2ldID0gW19rZXlzW2ldLCBvYmpbX2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBmdW5jdGlvbiBpbnZlcnQob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBfa2V5cyA9IGtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gX2tleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtvYmpbX2tleXNbaV1dXSA9IF9rZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKGlzRnVuY3Rpb24kMShvYmpba2V5XSkpIG5hbWVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLnNvcnQoKTtcbiAgfVxuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhc3NpZ25lciBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGtleXNGdW5jLCBkZWZhdWx0cykge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKGRlZmF1bHRzKSBvYmogPSBPYmplY3Qob2JqKTtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghZGVmYXVsdHMgfHwgb2JqW2tleV0gPT09IHZvaWQgMCkgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIHZhciBleHRlbmQgPSBjcmVhdGVBc3NpZ25lcihhbGxLZXlzKTtcblxuICAvLyBBc3NpZ25zIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBvd24gcHJvcGVydGllcyBpbiB0aGUgcGFzc2VkLWluXG4gIC8vIG9iamVjdChzKS5cbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIHZhciBleHRlbmRPd24gPSBjcmVhdGVBc3NpZ25lcihrZXlzKTtcblxuICAvLyBGaWxsIGluIGEgZ2l2ZW4gb2JqZWN0IHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICB2YXIgZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihhbGxLZXlzLCB0cnVlKTtcblxuICAvLyBDcmVhdGUgYSBuYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIGZ1bmN0aW9uIGN0b3IoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCl7fTtcbiAgfVxuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIGFub3RoZXIuXG4gIGZ1bmN0aW9uIGJhc2VDcmVhdGUocHJvdG90eXBlKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4ge307XG4gICAgaWYgKG5hdGl2ZUNyZWF0ZSkgcmV0dXJuIG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIHZhciBDdG9yID0gY3RvcigpO1xuICAgIEN0b3IucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcjtcbiAgICBDdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BzKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICBpZiAocHJvcHMpIGV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBmdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIGlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogZXh0ZW5kKHt9LCBvYmopO1xuICB9XG5cbiAgLy8gSW52b2tlcyBgaW50ZXJjZXB0b3JgIHdpdGggdGhlIGBvYmpgIGFuZCB0aGVuIHJldHVybnMgYG9iamAuXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgZnVuY3Rpb24gdGFwKG9iaiwgaW50ZXJjZXB0b3IpIHtcbiAgICBpbnRlcmNlcHRvcihvYmopO1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgYSAoZGVlcCkgcHJvcGVydHkgYHBhdGhgIHRvIGFycmF5LlxuICAvLyBMaWtlIGBfLml0ZXJhdGVlYCwgdGhpcyBmdW5jdGlvbiBjYW4gYmUgY3VzdG9taXplZC5cbiAgZnVuY3Rpb24gdG9QYXRoJDEocGF0aCkge1xuICAgIHJldHVybiBpc0FycmF5KHBhdGgpID8gcGF0aCA6IFtwYXRoXTtcbiAgfVxuICBfJDEudG9QYXRoID0gdG9QYXRoJDE7XG5cbiAgLy8gSW50ZXJuYWwgd3JhcHBlciBmb3IgYF8udG9QYXRoYCB0byBlbmFibGUgbWluaWZpY2F0aW9uLlxuICAvLyBTaW1pbGFyIHRvIGBjYmAgZm9yIGBfLml0ZXJhdGVlYC5cbiAgZnVuY3Rpb24gdG9QYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gXyQxLnRvUGF0aChwYXRoKTtcbiAgfVxuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRvIG9idGFpbiBhIG5lc3RlZCBwcm9wZXJ0eSBpbiBgb2JqYCBhbG9uZyBgcGF0aGAuXG4gIGZ1bmN0aW9uIGRlZXBHZXQob2JqLCBwYXRoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgIG9iaiA9IG9ialtwYXRoW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aCA/IG9iaiA6IHZvaWQgMDtcbiAgfVxuXG4gIC8vIEdldCB0aGUgdmFsdWUgb2YgdGhlIChkZWVwKSBwcm9wZXJ0eSBvbiBgcGF0aGAgZnJvbSBgb2JqZWN0YC5cbiAgLy8gSWYgYW55IHByb3BlcnR5IGluIGBwYXRoYCBkb2VzIG5vdCBleGlzdCBvciBpZiB0aGUgdmFsdWUgaXNcbiAgLy8gYHVuZGVmaW5lZGAsIHJldHVybiBgZGVmYXVsdFZhbHVlYCBpbnN0ZWFkLlxuICAvLyBUaGUgYHBhdGhgIGlzIG5vcm1hbGl6ZWQgdGhyb3VnaCBgXy50b1BhdGhgLlxuICBmdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICB2YXIgdmFsdWUgPSBkZWVwR2V0KG9iamVjdCwgdG9QYXRoKHBhdGgpKTtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQodmFsdWUpID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG4gIH1cblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5IG9uXG4gIC8vIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuIFVubGlrZSB0aGUgaW50ZXJuYWwgYGhhc2BcbiAgLy8gZnVuY3Rpb24sIHRoaXMgcHVibGljIHZlcnNpb24gY2FuIGFsc28gdHJhdmVyc2UgbmVzdGVkIHByb3BlcnRpZXMuXG4gIGZ1bmN0aW9uIGhhcyhvYmosIHBhdGgpIHtcbiAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcGF0aFtpXTtcbiAgICAgIGlmICghaGFzJDEob2JqLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICBvYmogPSBvYmpba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuICEhbGVuZ3RoO1xuICB9XG5cbiAgLy8gS2VlcCB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYXJvdW5kIGZvciBkZWZhdWx0IGl0ZXJhdGVlcy5cbiAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIGZ1bmN0aW9uIG1hdGNoZXIoYXR0cnMpIHtcbiAgICBhdHRycyA9IGV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBpc01hdGNoKG9iaiwgYXR0cnMpO1xuICAgIH07XG4gIH1cblxuICAvLyBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBwYXNzZWQgYW4gb2JqZWN0LCB3aWxsIHRyYXZlcnNlIHRoYXQgb2JqZWN04oCZc1xuICAvLyBwcm9wZXJ0aWVzIGRvd24gdGhlIGdpdmVuIGBwYXRoYCwgc3BlY2lmaWVkIGFzIGFuIGFycmF5IG9mIGtleXMgb3IgaW5kaWNlcy5cbiAgZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICAgIHBhdGggPSB0b1BhdGgocGF0aCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIGRlZXBHZXQob2JqLCBwYXRoKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVmZmljaWVudCAoZm9yIGN1cnJlbnQgZW5naW5lcykgdmVyc2lvblxuICAvLyBvZiB0aGUgcGFzc2VkLWluIGNhbGxiYWNrLCB0byBiZSByZXBlYXRlZGx5IGFwcGxpZWQgaW4gb3RoZXIgVW5kZXJzY29yZVxuICAvLyBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIG9wdGltaXplQ2IoZnVuYywgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSByZXR1cm4gZnVuYztcbiAgICBzd2l0Y2ggKGFyZ0NvdW50ID09IG51bGwgPyAzIDogYXJnQ291bnQpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIC8vIFRoZSAyLWFyZ3VtZW50IGNhc2UgaXMgb21pdHRlZCBiZWNhdXNlIHdl4oCZcmUgbm90IHVzaW5nIGl0LlxuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjYWxsYmFja3MgdGhhdCBjYW4gYmUgYXBwbGllZCB0byBlYWNoXG4gIC8vIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGRlc2lyZWQgcmVzdWx0IOKAlCBlaXRoZXIgYF8uaWRlbnRpdHlgLFxuICAvLyBhbiBhcmJpdHJhcnkgY2FsbGJhY2ssIGEgcHJvcGVydHkgbWF0Y2hlciwgb3IgYSBwcm9wZXJ0eSBhY2Nlc3Nvci5cbiAgZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gaWRlbnRpdHk7XG4gICAgaWYgKGlzRnVuY3Rpb24kMSh2YWx1ZSkpIHJldHVybiBvcHRpbWl6ZUNiKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCk7XG4gICAgaWYgKGlzT2JqZWN0KHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkpIHJldHVybiBtYXRjaGVyKHZhbHVlKTtcbiAgICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xuICB9XG5cbiAgLy8gRXh0ZXJuYWwgd3JhcHBlciBmb3Igb3VyIGNhbGxiYWNrIGdlbmVyYXRvci4gVXNlcnMgbWF5IGN1c3RvbWl6ZVxuICAvLyBgXy5pdGVyYXRlZWAgaWYgdGhleSB3YW50IGFkZGl0aW9uYWwgcHJlZGljYXRlL2l0ZXJhdGVlIHNob3J0aGFuZCBzdHlsZXMuXG4gIC8vIFRoaXMgYWJzdHJhY3Rpb24gaGlkZXMgdGhlIGludGVybmFsLW9ubHkgYGFyZ0NvdW50YCBhcmd1bWVudC5cbiAgZnVuY3Rpb24gaXRlcmF0ZWUodmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gYmFzZUl0ZXJhdGVlKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH1cbiAgXyQxLml0ZXJhdGVlID0gaXRlcmF0ZWU7XG5cbiAgLy8gVGhlIGZ1bmN0aW9uIHdlIGNhbGwgaW50ZXJuYWxseSB0byBnZW5lcmF0ZSBhIGNhbGxiYWNrLiBJdCBpbnZva2VzXG4gIC8vIGBfLml0ZXJhdGVlYCBpZiBvdmVycmlkZGVuLCBvdGhlcndpc2UgYGJhc2VJdGVyYXRlZWAuXG4gIGZ1bmN0aW9uIGNiKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmIChfJDEuaXRlcmF0ZWUgIT09IGl0ZXJhdGVlKSByZXR1cm4gXyQxLml0ZXJhdGVlKHZhbHVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gYmFzZUl0ZXJhdGVlKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCk7XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBgaXRlcmF0ZWVgIHRvIGVhY2ggZWxlbWVudCBvZiBgb2JqYC5cbiAgLy8gSW4gY29udHJhc3QgdG8gYF8ubWFwYCBpdCByZXR1cm5zIGFuIG9iamVjdC5cbiAgZnVuY3Rpb24gbWFwT2JqZWN0KG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgX2tleXMgPSBrZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IF9rZXlzLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0gX2tleXNbaW5kZXhdO1xuICAgICAgcmVzdWx0c1tjdXJyZW50S2V5XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvLyBQcmVkaWNhdGUtZ2VuZXJhdGluZyBmdW5jdGlvbi4gT2Z0ZW4gdXNlZnVsIG91dHNpZGUgb2YgVW5kZXJzY29yZS5cbiAgZnVuY3Rpb24gbm9vcCgpe31cblxuICAvLyBHZW5lcmF0ZXMgYSBmdW5jdGlvbiBmb3IgYSBnaXZlbiBvYmplY3QgdGhhdCByZXR1cm5zIGEgZ2l2ZW4gcHJvcGVydHkuXG4gIGZ1bmN0aW9uIHByb3BlcnR5T2Yob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gbm9vcDtcbiAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgcmV0dXJuIGdldChvYmosIHBhdGgpO1xuICAgIH07XG4gIH1cblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgZnVuY3Rpb24gdGltZXMobiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgYWNjdW0gPSBBcnJheShNYXRoLm1heCgwLCBuKSk7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRlZShpKTtcbiAgICByZXR1cm4gYWNjdW07XG4gIH1cblxuICAvLyBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YCAoaW5jbHVzaXZlKS5cbiAgZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBtaW47XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgfVxuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgdmFyIG5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBoZWxwZXIgdG8gZ2VuZXJhdGUgZnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzXG4gIC8vIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICBmdW5jdGlvbiBjcmVhdGVFc2NhcGVyKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkLlxuICAgIHZhciBzb3VyY2UgPSAnKD86JyArIGtleXMobWFwKS5qb2luKCd8JykgKyAnKSc7XG4gICAgdmFyIHRlc3RSZWdleHAgPSBSZWdFeHAoc291cmNlKTtcbiAgICB2YXIgcmVwbGFjZVJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UsICdnJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyAnJyA6ICcnICsgc3RyaW5nO1xuICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEludGVybmFsIGxpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gZm9yIGVzY2FwaW5nIHN0cmluZ3MgdG8gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgX2VzY2FwZSA9IGNyZWF0ZUVzY2FwZXIoZXNjYXBlTWFwKTtcblxuICAvLyBJbnRlcm5hbCBsaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIHVuZXNjYXBpbmcuXG4gIHZhciB1bmVzY2FwZU1hcCA9IGludmVydChlc2NhcGVNYXApO1xuXG4gIC8vIEZ1bmN0aW9uIGZvciB1bmVzY2FwaW5nIHN0cmluZ3MgZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG4gIHZhciBfdW5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKHVuZXNjYXBlTWFwKTtcblxuICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMuIENoYW5nZSB0aGVcbiAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICB2YXIgdGVtcGxhdGVTZXR0aW5ncyA9IF8kMS50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgIGludGVycG9sYXRlOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGU6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgXy50ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgJ1xccic6ICdyJyxcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlUmVnRXhwID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gIGZ1bmN0aW9uIGVzY2FwZUNoYXIobWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XG4gIH1cblxuICAvLyBJbiBvcmRlciB0byBwcmV2ZW50IHRoaXJkLXBhcnR5IGNvZGUgaW5qZWN0aW9uIHRocm91Z2hcbiAgLy8gYF8udGVtcGxhdGVTZXR0aW5ncy52YXJpYWJsZWAsIHdlIHRlc3QgaXQgYWdhaW5zdCB0aGUgZm9sbG93aW5nIHJlZ3VsYXJcbiAgLy8gZXhwcmVzc2lvbi4gSXQgaXMgaW50ZW50aW9uYWxseSBhIGJpdCBtb3JlIGxpYmVyYWwgdGhhbiBqdXN0IG1hdGNoaW5nIHZhbGlkXG4gIC8vIGlkZW50aWZpZXJzLCBidXQgc3RpbGwgcHJldmVudHMgcG9zc2libGUgbG9vcGhvbGVzIHRocm91Z2ggZGVmYXVsdHMgb3JcbiAgLy8gZGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50LlxuICB2YXIgYmFyZUlkZW50aWZpZXIgPSAvXlxccyooXFx3fFxcJCkrXFxzKiQvO1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgZnVuY3Rpb24gdGVtcGxhdGUodGV4dCwgc2V0dGluZ3MsIG9sZFNldHRpbmdzKSB7XG4gICAgaWYgKCFzZXR0aW5ncyAmJiBvbGRTZXR0aW5ncykgc2V0dGluZ3MgPSBvbGRTZXR0aW5ncztcbiAgICBzZXR0aW5ncyA9IGRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXyQxLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXG4gICAgdmFyIG1hdGNoZXIgPSBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UoZXNjYXBlUmVnRXhwLCBlc2NhcGVDaGFyKTtcbiAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgaW50ZXJwb2xhdGUgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgICAgfVxuXG4gICAgICAvLyBBZG9iZSBWTXMgbmVlZCB0aGUgbWF0Y2ggcmV0dXJuZWQgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBvZmZzZXQuXG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgIHZhciBhcmd1bWVudCA9IHNldHRpbmdzLnZhcmlhYmxlO1xuICAgIGlmIChhcmd1bWVudCkge1xuICAgICAgLy8gSW5zdXJlIGFnYWluc3QgdGhpcmQtcGFydHkgY29kZSBpbmplY3Rpb24uIChDVkUtMjAyMS0yMzM1OClcbiAgICAgIGlmICghYmFyZUlkZW50aWZpZXIudGVzdChhcmd1bWVudCkpIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3ZhcmlhYmxlIGlzIG5vdCBhIGJhcmUgaWRlbnRpZmllcjogJyArIGFyZ3VtZW50XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgICAgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcbiAgICAgIGFyZ3VtZW50ID0gJ29iaic7XG4gICAgfVxuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB2YXIgcmVuZGVyO1xuICAgIHRyeSB7XG4gICAgICByZW5kZXIgPSBuZXcgRnVuY3Rpb24oYXJndW1lbnQsICdfJywgc291cmNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEsIF8kMSk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuXG4gIC8vIFRyYXZlcnNlcyB0aGUgY2hpbGRyZW4gb2YgYG9iamAgYWxvbmcgYHBhdGhgLiBJZiBhIGNoaWxkIGlzIGEgZnVuY3Rpb24sIGl0XG4gIC8vIGlzIGludm9rZWQgd2l0aCBpdHMgcGFyZW50IGFzIGNvbnRleHQuIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaW5hbFxuICAvLyBjaGlsZCwgb3IgYGZhbGxiYWNrYCBpZiBhbnkgY2hpbGQgaXMgdW5kZWZpbmVkLlxuICBmdW5jdGlvbiByZXN1bHQob2JqLCBwYXRoLCBmYWxsYmFjaykge1xuICAgIHBhdGggPSB0b1BhdGgocGF0aCk7XG4gICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbiQxKGZhbGxiYWNrKSA/IGZhbGxiYWNrLmNhbGwob2JqKSA6IGZhbGxiYWNrO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW3BhdGhbaV1dO1xuICAgICAgaWYgKHByb3AgPT09IHZvaWQgMCkge1xuICAgICAgICBwcm9wID0gZmFsbGJhY2s7XG4gICAgICAgIGkgPSBsZW5ndGg7IC8vIEVuc3VyZSB3ZSBkb24ndCBjb250aW51ZSBpdGVyYXRpbmcuXG4gICAgICB9XG4gICAgICBvYmogPSBpc0Z1bmN0aW9uJDEocHJvcCkgPyBwcm9wLmNhbGwob2JqKSA6IHByb3A7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgdmFyIGlkID0gKytpZENvdW50ZXIgKyAnJztcbiAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDtcbiAgfVxuXG4gIC8vIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgZnVuY3Rpb24gY2hhaW4ob2JqKSB7XG4gICAgdmFyIGluc3RhbmNlID0gXyQxKG9iaik7XG4gICAgaW5zdGFuY2UuX2NoYWluID0gdHJ1ZTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICAvLyBJbnRlcm5hbCBmdW5jdGlvbiB0byBleGVjdXRlIGBzb3VyY2VGdW5jYCBib3VuZCB0byBgY29udGV4dGAgd2l0aCBvcHRpb25hbFxuICAvLyBgYXJnc2AuIERldGVybWluZXMgd2hldGhlciB0byBleGVjdXRlIGEgZnVuY3Rpb24gYXMgYSBjb25zdHJ1Y3RvciBvciBhcyBhXG4gIC8vIG5vcm1hbCBmdW5jdGlvbi5cbiAgZnVuY3Rpb24gZXhlY3V0ZUJvdW5kKHNvdXJjZUZ1bmMsIGJvdW5kRnVuYywgY29udGV4dCwgY2FsbGluZ0NvbnRleHQsIGFyZ3MpIHtcbiAgICBpZiAoIShjYWxsaW5nQ29udGV4dCBpbnN0YW5jZW9mIGJvdW5kRnVuYykpIHJldHVybiBzb3VyY2VGdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIHZhciBzZWxmID0gYmFzZUNyZWF0ZShzb3VyY2VGdW5jLnByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IHNvdXJjZUZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgaWYgKGlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBgX2AgYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyIGJ5IGRlZmF1bHQsIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMgdG8gYmVcbiAgLy8gcHJlLWZpbGxlZC4gU2V0IGBfLnBhcnRpYWwucGxhY2Vob2xkZXJgIGZvciBhIGN1c3RvbSBwbGFjZWhvbGRlciBhcmd1bWVudC5cbiAgdmFyIHBhcnRpYWwgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGZ1bmMsIGJvdW5kQXJncykge1xuICAgIHZhciBwbGFjZWhvbGRlciA9IHBhcnRpYWwucGxhY2Vob2xkZXI7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwLCBsZW5ndGggPSBib3VuZEFyZ3MubGVuZ3RoO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYm91bmRBcmdzW2ldID09PSBwbGFjZWhvbGRlciA/IGFyZ3VtZW50c1twb3NpdGlvbisrXSA6IGJvdW5kQXJnc1tpXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgdGhpcywgdGhpcywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH0pO1xuXG4gIHBhcnRpYWwucGxhY2Vob2xkZXIgPSBfJDE7XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLlxuICB2YXIgYmluZCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oZnVuYywgY29udGV4dCwgYXJncykge1xuICAgIGlmICghaXNGdW5jdGlvbiQxKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdCaW5kIG11c3QgYmUgY2FsbGVkIG9uIGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgYm91bmQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGNhbGxBcmdzKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChjYWxsQXJncykpO1xuICAgIH0pO1xuICAgIHJldHVybiBib3VuZDtcbiAgfSk7XG5cbiAgLy8gSW50ZXJuYWwgaGVscGVyIGZvciBjb2xsZWN0aW9uIG1ldGhvZHMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBjb2xsZWN0aW9uXG4gIC8vIHNob3VsZCBiZSBpdGVyYXRlZCBhcyBhbiBhcnJheSBvciBhcyBhbiBvYmplY3QuXG4gIC8vIFJlbGF0ZWQ6IGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICAvLyBBdm9pZHMgYSB2ZXJ5IG5hc3R5IGlPUyA4IEpJVCBidWcgb24gQVJNLTY0LiAjMjA5NFxuICB2YXIgaXNBcnJheUxpa2UgPSBjcmVhdGVTaXplUHJvcGVydHlDaGVjayhnZXRMZW5ndGgpO1xuXG4gIC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIGEgcmVjdXJzaXZlIGBmbGF0dGVuYCBmdW5jdGlvbi5cbiAgZnVuY3Rpb24gZmxhdHRlbiQxKGlucHV0LCBkZXB0aCwgc3RyaWN0LCBvdXRwdXQpIHtcbiAgICBvdXRwdXQgPSBvdXRwdXQgfHwgW107XG4gICAgaWYgKCFkZXB0aCAmJiBkZXB0aCAhPT0gMCkge1xuICAgICAgZGVwdGggPSBJbmZpbml0eTtcbiAgICB9IGVsc2UgaWYgKGRlcHRoIDw9IDApIHtcbiAgICAgIHJldHVybiBvdXRwdXQuY29uY2F0KGlucHV0KTtcbiAgICB9XG4gICAgdmFyIGlkeCA9IG91dHB1dC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChpbnB1dCk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmIChpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyQxKHZhbHVlKSkpIHtcbiAgICAgICAgLy8gRmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3QuXG4gICAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgICBmbGF0dGVuJDEodmFsdWUsIGRlcHRoIC0gMSwgc3RyaWN0LCBvdXRwdXQpO1xuICAgICAgICAgIGlkeCA9IG91dHB1dC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGogPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGogPCBsZW4pIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIHZhciBiaW5kQWxsID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihvYmosIGtleXMpIHtcbiAgICBrZXlzID0gZmxhdHRlbiQxKGtleXMsIGZhbHNlLCBmYWxzZSk7XG4gICAgdmFyIGluZGV4ID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGluZGV4IDwgMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgIG9ialtrZXldID0gYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfSk7XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFoYXMkMShjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIHZhciBkZWxheSA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oZnVuYywgd2FpdCwgYXJncykge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSwgd2FpdCk7XG4gIH0pO1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICB2YXIgZGVmZXIgPSBwYXJ0aWFsKGRlbGF5LCBfJDEsIDEpO1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgIHZhciB0aW1lb3V0LCBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IG5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcblxuICAgIHZhciB0aHJvdHRsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfbm93ID0gbm93KCk7XG4gICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gX25vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKF9ub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IF9ub3c7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHRocm90dGxlZC5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHByZXZpb3VzID0gMDtcbiAgICAgIHRpbWVvdXQgPSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiB0aHJvdHRsZWQ7XG4gIH1cblxuICAvLyBXaGVuIGEgc2VxdWVuY2Ugb2YgY2FsbHMgb2YgdGhlIHJldHVybmVkIGZ1bmN0aW9uIGVuZHMsIHRoZSBhcmd1bWVudFxuICAvLyBmdW5jdGlvbiBpcyB0cmlnZ2VyZWQuIFRoZSBlbmQgb2YgYSBzZXF1ZW5jZSBpcyBkZWZpbmVkIGJ5IHRoZSBgd2FpdGBcbiAgLy8gcGFyYW1ldGVyLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRoZSBhcmd1bWVudCBmdW5jdGlvbiB3aWxsIGJlXG4gIC8vIHRyaWdnZXJlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZXF1ZW5jZSBpbnN0ZWFkIG9mIGF0IHRoZSBlbmQuXG4gIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBwcmV2aW91cywgYXJncywgcmVzdWx0LCBjb250ZXh0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFzc2VkID0gbm93KCkgLSBwcmV2aW91cztcbiAgICAgIGlmICh3YWl0ID4gcGFzc2VkKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gcGFzc2VkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgYmVjYXVzZSBgZnVuY2AgY2FuIHJlY3Vyc2l2ZWx5IGludm9rZSBgZGVib3VuY2VkYC5cbiAgICAgICAgaWYgKCF0aW1lb3V0KSBhcmdzID0gY29udGV4dCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkZWJvdW5jZWQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKF9hcmdzKSB7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBfYXJncztcbiAgICAgIHByZXZpb3VzID0gbm93KCk7XG4gICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgICBpZiAoaW1tZWRpYXRlKSByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIGRlYm91bmNlZC5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBhcmdzID0gY29udGV4dCA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICBmdW5jdGlvbiB3cmFwKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gcGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBuZWdhdGVkIHZlcnNpb24gb2YgdGhlIHBhc3NlZC1pbiBwcmVkaWNhdGUuXG4gIGZ1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBmdW5jdGlvbiBjb21wb3NlKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSA9IHN0YXJ0O1xuICAgICAgdmFyIHJlc3VsdCA9IGFyZ3Nbc3RhcnRdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB3aGlsZSAoaS0tKSByZXN1bHQgPSBhcmdzW2ldLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBmdW5jdGlvbiBhZnRlcih0aW1lcywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgdXAgdG8gKGJ1dCBub3QgaW5jbHVkaW5nKSB0aGVcbiAgLy8gTnRoIGNhbGwuXG4gIGZ1bmN0aW9uIGJlZm9yZSh0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICB2YXIgb25jZSA9IHBhcnRpYWwoYmVmb3JlLCAyKTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBrZXkgb24gYW4gb2JqZWN0IHRoYXQgcGFzc2VzIGEgdHJ1dGggdGVzdC5cbiAgZnVuY3Rpb24gZmluZEtleShvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIF9rZXlzID0ga2V5cyhvYmopLCBrZXk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IF9rZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBfa2V5c1tpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2tleV0sIGtleSwgb2JqKSkgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICAvLyBJbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YC5cbiAgZnVuY3Rpb24gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoZGlyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIHZhciBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb24gYW4gYXJyYXktbGlrZSB0aGF0IHBhc3NlcyBhIHRydXRoIHRlc3QuXG4gIHZhciBmaW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcblxuICAvLyBSZXR1cm5zIHRoZSBsYXN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSB0cnV0aCB0ZXN0LlxuICB2YXIgZmluZExhc3RJbmRleCA9IGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKC0xKTtcblxuICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXG4gIC8vIGFuIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cbiAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIGBfLmluZGV4T2ZgIGFuZCBgXy5sYXN0SW5kZXhPZmAgZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIsIHByZWRpY2F0ZUZpbmQsIHNvcnRlZEluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICAgIHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIGlmICh0eXBlb2YgaWR4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgaSA9IGlkeCA+PSAwID8gaWR4IDogTWF0aC5tYXgoaWR4ICsgbGVuZ3RoLCBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGggPSBpZHggPj0gMCA/IE1hdGgubWluKGlkeCArIDEsIGxlbmd0aCkgOiBpZHggKyBsZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNvcnRlZEluZGV4ICYmIGlkeCAmJiBsZW5ndGgpIHtcbiAgICAgICAgaWR4ID0gc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgICByZXR1cm4gYXJyYXlbaWR4XSA9PT0gaXRlbSA/IGlkeCA6IC0xO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgICAgaWR4ID0gcHJlZGljYXRlRmluZChzbGljZS5jYWxsKGFycmF5LCBpLCBsZW5ndGgpLCBpc05hTiQxKTtcbiAgICAgICAgcmV0dXJuIGlkeCA+PSAwID8gaWR4ICsgaSA6IC0xO1xuICAgICAgfVxuICAgICAgZm9yIChpZHggPSBkaXIgPiAwID8gaSA6IGxlbmd0aCAtIDE7IGlkeCA+PSAwICYmIGlkeCA8IGxlbmd0aDsgaWR4ICs9IGRpcikge1xuICAgICAgICBpZiAoYXJyYXlbaWR4XSA9PT0gaXRlbSkgcmV0dXJuIGlkeDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LFxuICAvLyBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgdmFyIGluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigxLCBmaW5kSW5kZXgsIHNvcnRlZEluZGV4KTtcblxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgdmFyIGxhc3RJbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoLTEsIGZpbmRMYXN0SW5kZXgpO1xuXG4gIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC5cbiAgZnVuY3Rpb24gZmluZChvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBrZXlGaW5kZXIgPSBpc0FycmF5TGlrZShvYmopID8gZmluZEluZGV4IDogZmluZEtleTtcbiAgICB2YXIga2V5ID0ga2V5RmluZGVyKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgXy5maW5kYDogZ2V0dGluZyB0aGUgZmlyc3RcbiAgLy8gb2JqZWN0IGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIGZ1bmN0aW9uIGZpbmRXaGVyZShvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIGZpbmQob2JqLCBtYXRjaGVyKGF0dHJzKSk7XG4gIH1cblxuICAvLyBUaGUgY29ybmVyc3RvbmUgZm9yIGNvbGxlY3Rpb24gZnVuY3Rpb25zLCBhbiBgZWFjaGBcbiAgLy8gaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgcmF3IG9iamVjdHMgaW4gYWRkaXRpb24gdG8gYXJyYXktbGlrZXMuIFRyZWF0cyBhbGxcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbiAgZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgaSwgbGVuZ3RoO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2tleXMgPSBrZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBfa2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbX2tleXNbaV1dLCBfa2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50LlxuICBmdW5jdGlvbiBtYXAob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBfa2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIGtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKF9rZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICByZXN1bHRzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IF9rZXlzID8gX2tleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvLyBJbnRlcm5hbCBoZWxwZXIgdG8gY3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24sIGl0ZXJhdGluZyBsZWZ0IG9yIHJpZ2h0LlxuICBmdW5jdGlvbiBjcmVhdGVSZWR1Y2UoZGlyKSB7XG4gICAgLy8gV3JhcCBjb2RlIHRoYXQgcmVhc3NpZ25zIGFyZ3VtZW50IHZhcmlhYmxlcyBpbiBhIHNlcGFyYXRlIGZ1bmN0aW9uIHRoYW5cbiAgICAvLyB0aGUgb25lIHRoYXQgYWNjZXNzZXMgYGFyZ3VtZW50cy5sZW5ndGhgIHRvIGF2b2lkIGEgcGVyZiBoaXQuICgjMTk5MSlcbiAgICB2YXIgcmVkdWNlciA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGluaXRpYWwpIHtcbiAgICAgIHZhciBfa2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIGtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSAoX2tleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgbWVtbyA9IG9ialtfa2V5cyA/IF9rZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICB2YXIgY3VycmVudEtleSA9IF9rZXlzID8gX2tleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+PSAzO1xuICAgICAgcmV0dXJuIHJlZHVjZXIob2JqLCBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KSwgbWVtbywgaW5pdGlhbCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcbiAgLy8gb3IgYGZvbGRsYC5cbiAgdmFyIHJlZHVjZSA9IGNyZWF0ZVJlZHVjZSgxKTtcblxuICAvLyBUaGUgcmlnaHQtYXNzb2NpYXRpdmUgdmVyc2lvbiBvZiByZWR1Y2UsIGFsc28ga25vd24gYXMgYGZvbGRyYC5cbiAgdmFyIHJlZHVjZVJpZ2h0ID0gY3JlYXRlUmVkdWNlKC0xKTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0LlxuICBmdW5jdGlvbiBmaWx0ZXIob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cbiAgZnVuY3Rpb24gcmVqZWN0KG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZpbHRlcihvYmosIG5lZ2F0ZShjYihwcmVkaWNhdGUpKSwgY29udGV4dCk7XG4gIH1cblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbGwgb2YgdGhlIGVsZW1lbnRzIHBhc3MgYSB0cnV0aCB0ZXN0LlxuICBmdW5jdGlvbiBldmVyeShvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIF9rZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYga2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoX2tleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBfa2V5cyA/IF9rZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKCFwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgcGFzc2VzIGEgdHJ1dGggdGVzdC5cbiAgZnVuY3Rpb24gc29tZShvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIF9rZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYga2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoX2tleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBfa2V5cyA/IF9rZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGFycmF5IG9yIG9iamVjdCBjb250YWlucyBhIGdpdmVuIGl0ZW0gKHVzaW5nIGA9PT1gKS5cbiAgZnVuY3Rpb24gY29udGFpbnMob2JqLCBpdGVtLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gICAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSB2YWx1ZXMob2JqKTtcbiAgICBpZiAodHlwZW9mIGZyb21JbmRleCAhPSAnbnVtYmVyJyB8fCBndWFyZCkgZnJvbUluZGV4ID0gMDtcbiAgICByZXR1cm4gaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfVxuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICB2YXIgaW52b2tlID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihvYmosIHBhdGgsIGFyZ3MpIHtcbiAgICB2YXIgY29udGV4dFBhdGgsIGZ1bmM7XG4gICAgaWYgKGlzRnVuY3Rpb24kMShwYXRoKSkge1xuICAgICAgZnVuYyA9IHBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSB0b1BhdGgocGF0aCk7XG4gICAgICBjb250ZXh0UGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICAgICAgcGF0aCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcChvYmosIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciBtZXRob2QgPSBmdW5jO1xuICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgaWYgKGNvbnRleHRQYXRoICYmIGNvbnRleHRQYXRoLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnRleHQgPSBkZWVwR2V0KGNvbnRleHQsIGNvbnRleHRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dCA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgICAgICBtZXRob2QgPSBjb250ZXh0W3BhdGhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldGhvZCA9PSBudWxsID8gbWV0aG9kIDogbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBfLm1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIGZ1bmN0aW9uIHBsdWNrKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG1hcChvYmosIHByb3BlcnR5KGtleSkpO1xuICB9XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgXy5maWx0ZXJgOiBzZWxlY3Rpbmcgb25seVxuICAvLyBvYmplY3RzIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIGZ1bmN0aW9uIHdoZXJlKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gZmlsdGVyKG9iaiwgbWF0Y2hlcihhdHRycykpO1xuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBmdW5jdGlvbiBtYXgob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsIHx8ICh0eXBlb2YgaXRlcmF0ZWUgPT0gJ251bWJlcicgJiYgdHlwZW9mIG9ialswXSAhPSAnb2JqZWN0JyAmJiBvYmogIT0gbnVsbCkpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiB2YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBlYWNoKG9iaiwgZnVuY3Rpb24odiwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2LCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCB8fCAoY29tcHV0ZWQgPT09IC1JbmZpbml0eSAmJiByZXN1bHQgPT09IC1JbmZpbml0eSkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2O1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgZnVuY3Rpb24gbWluKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgfHwgKHR5cGVvZiBpdGVyYXRlZSA9PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqWzBdICE9ICdvYmplY3QnICYmIG9iaiAhPSBudWxsKSkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IHZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIGVhY2gob2JqLCBmdW5jdGlvbih2LCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHYsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkIDwgbGFzdENvbXB1dGVkIHx8IChjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2O1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIHZhciByZVN0clN5bWJvbCA9IC9bXlxcdWQ4MDAtXFx1ZGZmZl18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXXxbXFx1ZDgwMC1cXHVkZmZmXS9nO1xuICBmdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKGlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNTdHJpbmcob2JqKSkge1xuICAgICAgLy8gS2VlcCBzdXJyb2dhdGUgcGFpciBjaGFyYWN0ZXJzIHRvZ2V0aGVyLlxuICAgICAgcmV0dXJuIG9iai5tYXRjaChyZVN0clN5bWJvbCk7XG4gICAgfVxuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSByZXR1cm4gbWFwKG9iaiwgaWRlbnRpdHkpO1xuICAgIHJldHVybiB2YWx1ZXMob2JqKTtcbiAgfVxuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXLigJNZYXRlc19zaHVmZmxlKS5cbiAgLy8gSWYgKipuKiogaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudC5cbiAgLy8gVGhlIGludGVybmFsIGBndWFyZGAgYXJndW1lbnQgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBmdW5jdGlvbiBzYW1wbGUob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gdmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW3JhbmRvbShvYmoubGVuZ3RoIC0gMSldO1xuICAgIH1cbiAgICB2YXIgc2FtcGxlID0gdG9BcnJheShvYmopO1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoc2FtcGxlKTtcbiAgICBuID0gTWF0aC5tYXgoTWF0aC5taW4obiwgbGVuZ3RoKSwgMCk7XG4gICAgdmFyIGxhc3QgPSBsZW5ndGggLSAxO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBuOyBpbmRleCsrKSB7XG4gICAgICB2YXIgcmFuZCA9IHJhbmRvbShpbmRleCwgbGFzdCk7XG4gICAgICB2YXIgdGVtcCA9IHNhbXBsZVtpbmRleF07XG4gICAgICBzYW1wbGVbaW5kZXhdID0gc2FtcGxlW3JhbmRdO1xuICAgICAgc2FtcGxlW3JhbmRdID0gdGVtcDtcbiAgICB9XG4gICAgcmV0dXJuIHNhbXBsZS5zbGljZSgwLCBuKTtcbiAgfVxuXG4gIC8vIFNodWZmbGUgYSBjb2xsZWN0aW9uLlxuICBmdW5jdGlvbiBzaHVmZmxlKG9iaikge1xuICAgIHJldHVybiBzYW1wbGUob2JqLCBJbmZpbml0eSk7XG4gIH1cblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0ZWUuXG4gIGZ1bmN0aW9uIHNvcnRCeShvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gcGx1Y2sobWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgrKyxcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH1cblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIGZ1bmN0aW9uIGdyb3VwKGJlaGF2aW9yLCBwYXJ0aXRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHBhcnRpdGlvbiA/IFtbXSwgW11dIDoge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGtleSA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgICAgYmVoYXZpb3IocmVzdWx0LCB2YWx1ZSwga2V5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgdmFyIGdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoaGFzJDEocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTsgZWxzZSByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gIH0pO1xuXG4gIC8vIEluZGV4ZXMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiwgc2ltaWxhciB0byBgXy5ncm91cEJ5YCwgYnV0IGZvclxuICAvLyB3aGVuIHlvdSBrbm93IHRoYXQgeW91ciBpbmRleCB2YWx1ZXMgd2lsbCBiZSB1bmlxdWUuXG4gIHZhciBpbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIHZhciBjb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKGhhcyQxKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0rKzsgZWxzZSByZXN1bHRba2V5XSA9IDE7XG4gIH0pO1xuXG4gIC8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgcGFzcyB0aGUgZ2l2ZW5cbiAgLy8gdHJ1dGggdGVzdCwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHBhc3MgdGhlIHRydXRoIHRlc3QuXG4gIHZhciBwYXJ0aXRpb24gPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBwYXNzKSB7XG4gICAgcmVzdWx0W3Bhc3MgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XG4gIH0sIHRydWUpO1xuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGEgY29sbGVjdGlvbi5cbiAgZnVuY3Rpb24gc2l6ZShvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IGtleXMob2JqKS5sZW5ndGg7XG4gIH1cblxuICAvLyBJbnRlcm5hbCBgXy5waWNrYCBoZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYGtleWAgaXMgYW4gZW51bWVyYWJsZVxuICAvLyBwcm9wZXJ0eSBuYW1lIG9mIGBvYmpgLlxuICBmdW5jdGlvbiBrZXlJbk9iaih2YWx1ZSwga2V5LCBvYmopIHtcbiAgICByZXR1cm4ga2V5IGluIG9iajtcbiAgfVxuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIGFsbG93ZWQgcHJvcGVydGllcy5cbiAgdmFyIHBpY2sgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKG9iaiwga2V5cykge1xuICAgIHZhciByZXN1bHQgPSB7fSwgaXRlcmF0ZWUgPSBrZXlzWzBdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoaXNGdW5jdGlvbiQxKGl0ZXJhdGVlKSkge1xuICAgICAgaWYgKGtleXMubGVuZ3RoID4gMSkgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBrZXlzWzFdKTtcbiAgICAgIGtleXMgPSBhbGxLZXlzKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0ga2V5SW5PYmo7XG4gICAgICBrZXlzID0gZmxhdHRlbiQxKGtleXMsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGRpc2FsbG93ZWQgcHJvcGVydGllcy5cbiAgdmFyIG9taXQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKG9iaiwga2V5cykge1xuICAgIHZhciBpdGVyYXRlZSA9IGtleXNbMF0sIGNvbnRleHQ7XG4gICAgaWYgKGlzRnVuY3Rpb24kMShpdGVyYXRlZSkpIHtcbiAgICAgIGl0ZXJhdGVlID0gbmVnYXRlKGl0ZXJhdGVlKTtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDEpIGNvbnRleHQgPSBrZXlzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gbWFwKGZsYXR0ZW4kMShrZXlzLCBmYWxzZSwgZmFsc2UpLCBTdHJpbmcpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAhY29udGFpbnMoa2V5cywga2V5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwaWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9KTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gKG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKSkpO1xuICB9XG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIFRoZSAqKmd1YXJkKiogY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBmdW5jdGlvbiBmaXJzdChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCB8fCBhcnJheS5sZW5ndGggPCAxKSByZXR1cm4gbiA9PSBudWxsIHx8IGd1YXJkID8gdm9pZCAwIDogW107XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5WzBdO1xuICAgIHJldHVybiBpbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBgYXJyYXlgLiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZVxuICAvLyBgYXJyYXlgLlxuICBmdW5jdGlvbiByZXN0KGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH1cblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIGZ1bmN0aW9uIGxhc3QoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwgfHwgYXJyYXkubGVuZ3RoIDwgMSkgcmV0dXJuIG4gPT0gbnVsbCB8fCBndWFyZCA/IHZvaWQgMCA6IFtdO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gcmVzdChhcnJheSwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gbikpO1xuICB9XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgcmV0dXJuIGZpbHRlcihhcnJheSwgQm9vbGVhbik7XG4gIH1cblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IgdXAgdG8gYGRlcHRoYC5cbiAgLy8gUGFzc2luZyBgdHJ1ZWAgb3IgYGZhbHNlYCBhcyBgZGVwdGhgIG1lYW5zIGAxYCBvciBgSW5maW5pdHlgLCByZXNwZWN0aXZlbHkuXG4gIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXksIGRlcHRoKSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4kMShhcnJheSwgZGVwdGgsIGZhbHNlKTtcbiAgfVxuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgdmFyIGRpZmZlcmVuY2UgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGFycmF5LCByZXN0KSB7XG4gICAgcmVzdCA9IGZsYXR0ZW4kMShyZXN0LCB0cnVlLCB0cnVlKTtcbiAgICByZXR1cm4gZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIWNvbnRhaW5zKHJlc3QsIHZhbHVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgdmFsdWUocykuXG4gIHZhciB3aXRob3V0ID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihhcnJheSwgb3RoZXJBcnJheXMpIHtcbiAgICByZXR1cm4gZGlmZmVyZW5jZShhcnJheSwgb3RoZXJBcnJheXMpO1xuICB9KTtcblxuICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeVxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIFRoZSBmYXN0ZXIgYWxnb3JpdGhtIHdpbGwgbm90IHdvcmsgd2l0aCBhbiBpdGVyYXRlZSBpZiB0aGUgaXRlcmF0ZWVcbiAgLy8gaXMgbm90IGEgb25lLXRvLW9uZSBmdW5jdGlvbiwgc28gcHJvdmlkaW5nIGFuIGl0ZXJhdGVlIHdpbGwgZGlzYWJsZVxuICAvLyB0aGUgZmFzdGVyIGFsZ29yaXRobS5cbiAgZnVuY3Rpb24gdW5pcShhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpc0Jvb2xlYW4oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XG4gICAgICBpdGVyYXRlZSA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhdGVlICE9IG51bGwpIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldLFxuICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaSwgYXJyYXkpIDogdmFsdWU7XG4gICAgICBpZiAoaXNTb3J0ZWQgJiYgIWl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSBjb21wdXRlZCkgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWNvbnRhaW5zKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgdmFyIHVuaW9uID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihhcnJheXMpIHtcbiAgICByZXR1cm4gdW5pcShmbGF0dGVuJDEoYXJyYXlzLCB0cnVlLCB0cnVlKSk7XG4gIH0pO1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgZnVuY3Rpb24gaW50ZXJzZWN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGFycmF5W2ldO1xuICAgICAgaWYgKGNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xuICAgICAgdmFyIGo7XG4gICAgICBmb3IgKGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBDb21wbGVtZW50IG9mIHppcC4gVW56aXAgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgYW5kIGdyb3Vwc1xuICAvLyBlYWNoIGFycmF5J3MgZWxlbWVudHMgb24gc2hhcmVkIGluZGljZXMuXG4gIGZ1bmN0aW9uIHVuemlwKGFycmF5KSB7XG4gICAgdmFyIGxlbmd0aCA9IChhcnJheSAmJiBtYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoKSB8fCAwO1xuICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IHBsdWNrKGFycmF5LCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICB2YXIgemlwID0gcmVzdEFyZ3VtZW50cyh1bnppcCk7XG5cbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLiBQYXNzaW5nIGJ5IHBhaXJzIGlzIHRoZSByZXZlcnNlIG9mIGBfLnBhaXJzYC5cbiAgZnVuY3Rpb24gb2JqZWN0KGxpc3QsIHZhbHVlcykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGxpc3QpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1bMF1dID0gbGlzdFtpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXG4gIGZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIGlmICghc3RlcCkge1xuICAgICAgc3RlcCA9IHN0b3AgPCBzdGFydCA/IC0xIDogMTtcbiAgICB9XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG5cbiAgLy8gQ2h1bmsgYSBzaW5nbGUgYXJyYXkgaW50byBtdWx0aXBsZSBhcnJheXMsIGVhY2ggY29udGFpbmluZyBgY291bnRgIG9yIGZld2VyXG4gIC8vIGl0ZW1zLlxuICBmdW5jdGlvbiBjaHVuayhhcnJheSwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPT0gbnVsbCB8fCBjb3VudCA8IDEpIHJldHVybiBbXTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHNsaWNlLmNhbGwoYXJyYXksIGksIGkgKz0gY291bnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgZnVuY3Rpb24gY2hhaW5SZXN1bHQoaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfJDEob2JqKS5jaGFpbigpIDogb2JqO1xuICB9XG5cbiAgLy8gQWRkIHlvdXIgb3duIGN1c3RvbSBmdW5jdGlvbnMgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBmdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgICBlYWNoKGZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IF8kMVtuYW1lXSA9IG9ialtuYW1lXTtcbiAgICAgIF8kMS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGNoYWluUmVzdWx0KHRoaXMsIGZ1bmMuYXBwbHkoXyQxLCBhcmdzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBfJDE7XG4gIH1cblxuICAvLyBBZGQgYWxsIG11dGF0b3IgYEFycmF5YCBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIGVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8kMS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICAgIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmpbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFpblJlc3VsdCh0aGlzLCBvYmopO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFkZCBhbGwgYWNjZXNzb3IgYEFycmF5YCBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIGVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXyQxLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICBpZiAob2JqICE9IG51bGwpIG9iaiA9IG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY2hhaW5SZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBOYW1lZCBFeHBvcnRzXG5cbiAgdmFyIGFsbEV4cG9ydHMgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIFZFUlNJT046IFZFUlNJT04sXG4gICAgcmVzdEFyZ3VtZW50czogcmVzdEFyZ3VtZW50cyxcbiAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgaXNOdWxsOiBpc051bGwsXG4gICAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICAgIGlzQm9vbGVhbjogaXNCb29sZWFuLFxuICAgIGlzRWxlbWVudDogaXNFbGVtZW50LFxuICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgICBpc051bWJlcjogaXNOdW1iZXIsXG4gICAgaXNEYXRlOiBpc0RhdGUsXG4gICAgaXNSZWdFeHA6IGlzUmVnRXhwLFxuICAgIGlzRXJyb3I6IGlzRXJyb3IsXG4gICAgaXNTeW1ib2w6IGlzU3ltYm9sLFxuICAgIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gICAgaXNEYXRhVmlldzogaXNEYXRhVmlldyQxLFxuICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbiQxLFxuICAgIGlzQXJndW1lbnRzOiBpc0FyZ3VtZW50cyQxLFxuICAgIGlzRmluaXRlOiBpc0Zpbml0ZSQxLFxuICAgIGlzTmFOOiBpc05hTiQxLFxuICAgIGlzVHlwZWRBcnJheTogaXNUeXBlZEFycmF5JDEsXG4gICAgaXNFbXB0eTogaXNFbXB0eSxcbiAgICBpc01hdGNoOiBpc01hdGNoLFxuICAgIGlzRXF1YWw6IGlzRXF1YWwsXG4gICAgaXNNYXA6IGlzTWFwLFxuICAgIGlzV2Vha01hcDogaXNXZWFrTWFwLFxuICAgIGlzU2V0OiBpc1NldCxcbiAgICBpc1dlYWtTZXQ6IGlzV2Vha1NldCxcbiAgICBrZXlzOiBrZXlzLFxuICAgIGFsbEtleXM6IGFsbEtleXMsXG4gICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgcGFpcnM6IHBhaXJzLFxuICAgIGludmVydDogaW52ZXJ0LFxuICAgIGZ1bmN0aW9uczogZnVuY3Rpb25zLFxuICAgIG1ldGhvZHM6IGZ1bmN0aW9ucyxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBleHRlbmRPd246IGV4dGVuZE93bixcbiAgICBhc3NpZ246IGV4dGVuZE93bixcbiAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgY3JlYXRlOiBjcmVhdGUsXG4gICAgY2xvbmU6IGNsb25lLFxuICAgIHRhcDogdGFwLFxuICAgIGdldDogZ2V0LFxuICAgIGhhczogaGFzLFxuICAgIG1hcE9iamVjdDogbWFwT2JqZWN0LFxuICAgIGlkZW50aXR5OiBpZGVudGl0eSxcbiAgICBjb25zdGFudDogY29uc3RhbnQsXG4gICAgbm9vcDogbm9vcCxcbiAgICB0b1BhdGg6IHRvUGF0aCQxLFxuICAgIHByb3BlcnR5OiBwcm9wZXJ0eSxcbiAgICBwcm9wZXJ0eU9mOiBwcm9wZXJ0eU9mLFxuICAgIG1hdGNoZXI6IG1hdGNoZXIsXG4gICAgbWF0Y2hlczogbWF0Y2hlcixcbiAgICB0aW1lczogdGltZXMsXG4gICAgcmFuZG9tOiByYW5kb20sXG4gICAgbm93OiBub3csXG4gICAgZXNjYXBlOiBfZXNjYXBlLFxuICAgIHVuZXNjYXBlOiBfdW5lc2NhcGUsXG4gICAgdGVtcGxhdGVTZXR0aW5nczogdGVtcGxhdGVTZXR0aW5ncyxcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgcmVzdWx0OiByZXN1bHQsXG4gICAgdW5pcXVlSWQ6IHVuaXF1ZUlkLFxuICAgIGNoYWluOiBjaGFpbixcbiAgICBpdGVyYXRlZTogaXRlcmF0ZWUsXG4gICAgcGFydGlhbDogcGFydGlhbCxcbiAgICBiaW5kOiBiaW5kLFxuICAgIGJpbmRBbGw6IGJpbmRBbGwsXG4gICAgbWVtb2l6ZTogbWVtb2l6ZSxcbiAgICBkZWxheTogZGVsYXksXG4gICAgZGVmZXI6IGRlZmVyLFxuICAgIHRocm90dGxlOiB0aHJvdHRsZSxcbiAgICBkZWJvdW5jZTogZGVib3VuY2UsXG4gICAgd3JhcDogd3JhcCxcbiAgICBuZWdhdGU6IG5lZ2F0ZSxcbiAgICBjb21wb3NlOiBjb21wb3NlLFxuICAgIGFmdGVyOiBhZnRlcixcbiAgICBiZWZvcmU6IGJlZm9yZSxcbiAgICBvbmNlOiBvbmNlLFxuICAgIGZpbmRLZXk6IGZpbmRLZXksXG4gICAgZmluZEluZGV4OiBmaW5kSW5kZXgsXG4gICAgZmluZExhc3RJbmRleDogZmluZExhc3RJbmRleCxcbiAgICBzb3J0ZWRJbmRleDogc29ydGVkSW5kZXgsXG4gICAgaW5kZXhPZjogaW5kZXhPZixcbiAgICBsYXN0SW5kZXhPZjogbGFzdEluZGV4T2YsXG4gICAgZmluZDogZmluZCxcbiAgICBkZXRlY3Q6IGZpbmQsXG4gICAgZmluZFdoZXJlOiBmaW5kV2hlcmUsXG4gICAgZWFjaDogZWFjaCxcbiAgICBmb3JFYWNoOiBlYWNoLFxuICAgIG1hcDogbWFwLFxuICAgIGNvbGxlY3Q6IG1hcCxcbiAgICByZWR1Y2U6IHJlZHVjZSxcbiAgICBmb2xkbDogcmVkdWNlLFxuICAgIGluamVjdDogcmVkdWNlLFxuICAgIHJlZHVjZVJpZ2h0OiByZWR1Y2VSaWdodCxcbiAgICBmb2xkcjogcmVkdWNlUmlnaHQsXG4gICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgc2VsZWN0OiBmaWx0ZXIsXG4gICAgcmVqZWN0OiByZWplY3QsXG4gICAgZXZlcnk6IGV2ZXJ5LFxuICAgIGFsbDogZXZlcnksXG4gICAgc29tZTogc29tZSxcbiAgICBhbnk6IHNvbWUsXG4gICAgY29udGFpbnM6IGNvbnRhaW5zLFxuICAgIGluY2x1ZGVzOiBjb250YWlucyxcbiAgICBpbmNsdWRlOiBjb250YWlucyxcbiAgICBpbnZva2U6IGludm9rZSxcbiAgICBwbHVjazogcGx1Y2ssXG4gICAgd2hlcmU6IHdoZXJlLFxuICAgIG1heDogbWF4LFxuICAgIG1pbjogbWluLFxuICAgIHNodWZmbGU6IHNodWZmbGUsXG4gICAgc2FtcGxlOiBzYW1wbGUsXG4gICAgc29ydEJ5OiBzb3J0QnksXG4gICAgZ3JvdXBCeTogZ3JvdXBCeSxcbiAgICBpbmRleEJ5OiBpbmRleEJ5LFxuICAgIGNvdW50Qnk6IGNvdW50QnksXG4gICAgcGFydGl0aW9uOiBwYXJ0aXRpb24sXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICBzaXplOiBzaXplLFxuICAgIHBpY2s6IHBpY2ssXG4gICAgb21pdDogb21pdCxcbiAgICBmaXJzdDogZmlyc3QsXG4gICAgaGVhZDogZmlyc3QsXG4gICAgdGFrZTogZmlyc3QsXG4gICAgaW5pdGlhbDogaW5pdGlhbCxcbiAgICBsYXN0OiBsYXN0LFxuICAgIHJlc3Q6IHJlc3QsXG4gICAgdGFpbDogcmVzdCxcbiAgICBkcm9wOiByZXN0LFxuICAgIGNvbXBhY3Q6IGNvbXBhY3QsXG4gICAgZmxhdHRlbjogZmxhdHRlbixcbiAgICB3aXRob3V0OiB3aXRob3V0LFxuICAgIHVuaXE6IHVuaXEsXG4gICAgdW5pcXVlOiB1bmlxLFxuICAgIHVuaW9uOiB1bmlvbixcbiAgICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvbixcbiAgICBkaWZmZXJlbmNlOiBkaWZmZXJlbmNlLFxuICAgIHVuemlwOiB1bnppcCxcbiAgICB0cmFuc3Bvc2U6IHVuemlwLFxuICAgIHppcDogemlwLFxuICAgIG9iamVjdDogb2JqZWN0LFxuICAgIHJhbmdlOiByYW5nZSxcbiAgICBjaHVuazogY2h1bmssXG4gICAgbWl4aW46IG1peGluLFxuICAgICdkZWZhdWx0JzogXyQxXG4gIH07XG5cbiAgLy8gRGVmYXVsdCBFeHBvcnRcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIHZhciBfID0gbWl4aW4oYWxsRXhwb3J0cyk7XG4gIC8vIExlZ2FjeSBOb2RlLmpzIEFQSS5cbiAgXy5fID0gXztcblxuICByZXR1cm4gXztcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuZGVyc2NvcmUtdW1kLmpzLm1hcFxuIl19"}