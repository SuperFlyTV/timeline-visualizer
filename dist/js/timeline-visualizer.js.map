{"version":3,"sources":["node_modules/browser-pack/_prelude.js","dist/index.js","dist/lib/timelineVisualizer.js","node_modules/events/events.js","node_modules/lodash.isequal/index.js","node_modules/superfly-timeline/dist/api/api.js","node_modules/superfly-timeline/dist/api/enums.js","node_modules/superfly-timeline/dist/index.js","node_modules/superfly-timeline/dist/lib.js","node_modules/superfly-timeline/dist/resolver/cache.js","node_modules/superfly-timeline/dist/resolver/common.js","node_modules/superfly-timeline/dist/resolver/expression.js","node_modules/superfly-timeline/dist/resolver/resolver.js","node_modules/superfly-timeline/dist/resolver/state.js","node_modules/superfly-timeline/dist/resolver/validate.js","node_modules/superfly-timeline/node_modules/tslib/tslib.js","node_modules/tslib/tslib.js","node_modules/underscore/underscore-umd.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7hCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxzDA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACllBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACp4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACnPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"timeline-visualizer.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\ntslib_1.__exportStar(require(\"./lib/timelineVisualizer\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst isEqual = require(\"lodash.isequal\");\nconst superfly_timeline_1 = require(\"superfly-timeline\");\nconst events_1 = require(\"events\");\n/** Step size/ time step. */\nconst DEFAULT_STEP_SIZE = 1;\n/** Width of label column. */\nconst LABEL_WIDTH_OF_TIMELINE = 0.25;\n/** Default zoom */\nconst DEFAULT_ZOOM_VALUE = 100;\n/** Factor to zoom by */\nconst ZOOM_FACTOR = 1.001;\n/** Factor to pan by (pan = PAN_FACTOR * STEP_SIZE) */\nconst PAN_FACTOR = 10;\n/** Maximum layer height */\nconst MAX_LAYER_HEIGHT = 60;\n/** Amount to move playhead per second. */\nconst DEFAULT_PLAYHEAD_SPEED = 1;\n/** BEGIN STYLING VALUES */\n/** Timeline background color. */\nconst COLOR_BACKGROUND = '#333333';\n/** Layer label background color. */\nconst COLOR_LABEL_BACKGROUND = '#666666';\n/** Color of the ruler lines */\nconst RULER_LINE_COLOR = '#999999';\n/** Width of the ruler lines */\nconst RULER_LINE_WIDTH = 1;\n/** Playhead color. */\nconst COLOR_PLAYHEAD = 'rgba(255, 0, 0, 0.5)';\n/** Playhead thickness. */\nconst THICKNESS_PLAYHEAD = 5;\n/** Color of line separating timeline rows. */\nconst COLOR_LINE = 'black';\n/** Height of line separating rows. */\nconst THICKNESS_LINE = 1;\n/** Text properties. */\nconst TEXT_FONT_FAMILY = 'Calibri';\nconst TEXT_FONT_SIZE = 16;\nconst TEXT_COLOR = 'white';\n/** Timeline object properties. */\nconst COLOR_TIMELINE_OBJECT_FILL = 'rgb(22, 102, 247, 0.75)';\nconst COLOR_TIMELINE_OBJECT_BORDER = 'rgba(232, 240, 255, 0.85)';\nconst THICKNESS_TIMELINE_OBJECT_BORDER = 1;\n/** Timeline object height as a proportion of the row height. */\nconst TIMELINE_OBJECT_HEIGHT = 1;\n/** END STYLING VALUES */\n/** BEGIN CONSTANTS FOR STATE MANAGEMENT */\nconst MOUSEIN = 0;\nconst MOUSEOUT = 1;\nclass TimelineVisualizer extends events_1.EventEmitter {\n    /**\n     * @param {string} canvasId The ID of the canvas object to draw within.\n     */\n    constructor(canvasId, options = {}) {\n        super();\n        // Step size.\n        this.stepSize = DEFAULT_STEP_SIZE;\n        /** @private @readonly Proportion of the canvas to be used for the layer labels column. */\n        this._layerLabelWidthProportionOfCanvas = LABEL_WIDTH_OF_TIMELINE;\n        /** Layers on timeline. */\n        this._layerLabels = {};\n        /** State of the timeline. */\n        this._timelineState = {};\n        /** Map of objects for determining hovered object */\n        this._hoveredObjectMap = {};\n        /** Start time of the current view. Defines the objects within view on the timeline [time] */\n        this._viewStartTime = 0;\n        /** Range of the current view [time] */\n        // private _viewTimeRange: number = 1\n        // private _drawTimeEnd: number\n        /** Store whether the mouse is held down, for scrolling. */\n        this._mouseDown = false;\n        /** Current zoom amount. */\n        this._timelineZoom = DEFAULT_ZOOM_VALUE;\n        /** Whether or not the playhead should move. */\n        this._playHeadPlaying = false;\n        /** Speed of the playhead [units / second] */\n        this._playSpeed = DEFAULT_PLAYHEAD_SPEED;\n        /** The current time position of the playhead. */\n        this._playHeadTime = 0;\n        /** The last time updateDraw() did a draw. */\n        this._updateDrawLastTime = 0;\n        /** Whether the mouse last moved over an object or out. */\n        this._lastHoverAction = MOUSEOUT;\n        /** Name of object that was last hovered over. */\n        this._lastHoveredHash = '';\n        /** If the visualizer automatically should re-resolve the timeline when navigating the viewport */\n        this._timelineResolveAuto = false;\n        /** At what time the timeline was resolved [time] */\n        this._timelineResolveStart = 0;\n        this._timelineResolveEnd = 0;\n        this._timelineResolveZoom = 1;\n        this._timelineResolveCount = 100;\n        this._timelineResolveCountAdjust = 1;\n        /** How much extra (outside the current viewport) the timeline should be resolved to [ratio] */\n        this._timelineResolveExpand = 3;\n        this.latestUpdateTime = 0;\n        this.reresolveTimeout = null;\n        this._mergeIterator = 0;\n        // Initialise other values.\n        this._canvasId = canvasId;\n        this.initCanvas();\n        this._drawPlayhead = !!options.drawPlayhead;\n        // Calculate width of label column.\n        this._layerLabelWidth = this._canvasWidth * this._layerLabelWidthProportionOfCanvas;\n        // Calculate timeline width and start point.\n        this._viewDrawX = this._layerLabelWidth;\n        this._viewDrawWidth = this._canvasWidth - this._layerLabelWidth;\n        // Draw background.\n        this.drawBackground();\n        // Draw playhead.\n        this.drawPlayhead();\n        this.updateDraw();\n    }\n    /**\n     * Initialises the canvas and registers canvas events.\n     */\n    initCanvas() {\n        // Create new canvas object.\n        this._canvasContainer = document.getElementById(this._canvasId);\n        if (!this._canvasContainer)\n            throw new Error(`Canvas \"${this._canvasId}\" not found`);\n        // Get rendering context.\n        this._canvas = this._canvasContainer.getContext('2d');\n        // Register canvas interaction event handlers.\n        this._canvasContainer.addEventListener('mousedown', (event) => this.canvasMouseDown(event));\n        this._canvasContainer.addEventListener('mouseup', (event) => this.canvasMouseUp(event));\n        this._canvasContainer.addEventListener('mousemove', (event) => this.canvasMouseMove(event));\n        this._canvasContainer.addEventListener('wheel', (event) => this.canvasScrollWheel(event));\n        // Get width and height of canvas.\n        this._canvasWidth = this._canvasContainer.width;\n        this._canvasHeight = this._canvasContainer.height;\n    }\n    /**\n     * Updates the timeline, should be called when actions are added/removed from a timeline\n     * but the same timeline is being drawn.\n     * @param {TimelineObject[]} timeline Timeline to draw.\n     * @param {ResolveOptions} options Resolve options.\n     */\n    updateTimeline(timeline, options) {\n        // If options have not been specified set time to 0.\n        if (options === undefined) {\n            options = {\n                time: 0,\n                limitCount: 10\n            };\n        }\n        this.latestTimeline = timeline;\n        this.latestOptions = options;\n        if (!options.limitTime) {\n            this._timelineResolveAuto = true;\n        }\n        else {\n            this._timelineResolveAuto = false;\n        }\n        const options2 = Object.assign({}, options);\n        if (this._timelineResolveAuto) {\n            this.updateTimelineResolveWindow();\n        }\n        if (this._resolvedStates === undefined) { // If first time this runs\n            // Set timeline start and end times.\n            if (options2.time !== undefined) {\n                this._viewStartTime = options2.time;\n            }\n            // Move playhead to start time.\n            this._playHeadTime = this._viewStartTime;\n        }\n        this._updateTimeline(true);\n    }\n    _updateTimeline(fromNewTimeline = false) {\n        const options2 = Object.assign({}, this.latestOptions);\n        if (this._timelineResolveAuto) {\n            options2.time = this._timelineResolveStart;\n            options2.limitTime = this._timelineResolveEnd;\n            options2.limitCount = Math.ceil(this._timelineResolveCount * this._timelineResolveCountAdjust);\n        }\n        // If the playhead is being drawn, the resolve time should be at the playhead time.\n        if (this._drawPlayhead && this._playHeadTime > options2.time) {\n            options2.time = this._playHeadTime;\n        }\n        // Resolve the timeline.\n        const startResolve = Date.now();\n        const resolvedTimeline = superfly_timeline_1.Resolver.resolveTimeline(this.latestTimeline, options2);\n        let newResolvedStates = superfly_timeline_1.Resolver.resolveAllStates(resolvedTimeline);\n        if (this._resolvedStates === undefined) { // If first time this runs\n            this._resolvedStates = newResolvedStates;\n        }\n        else {\n            if (this._drawPlayhead) {\n                // Trim the current timeline:\n                if (newResolvedStates) {\n                    // Merge the timelines.\n                    this._resolvedStates = this.mergeTimelineObjects(this._resolvedStates, newResolvedStates, fromNewTimeline);\n                }\n            }\n            else {\n                // Otherwise we only see one timeline at a time.\n                // Overwrite the previous timeline:\n                this._resolvedStates = newResolvedStates;\n            }\n        }\n        // Update layers.\n        this.updateLayerLabels();\n        this.latestUpdateTime = Date.now() - startResolve;\n        // Redraw the timeline.\n        this.redrawTimeline();\n        this.latestUpdateTime = Date.now() - startResolve;\n    }\n    /**\n     * Sets the viewport to a position, zoom, and playback speed.\n     * Playback speed currently not implemented.\n     * @param viewPort Object to update viewport with.\n     */\n    setViewPort(viewPort) {\n        // Whether the viewport has changed.\n        let changed = false;\n        // If zoom has been specified.\n        if (viewPort.zoom !== undefined) {\n            // Zoom to specified zoom.\n            this._timelineZoom = viewPort.zoom;\n            changed = true;\n        }\n        // If timestamp has been specified.\n        if (viewPort.timestamp !== undefined) {\n            // Set start time to specified time.\n            if (viewPort.timestamp > 0) {\n                this._viewStartTime = viewPort.timestamp;\n                changed = true;\n            }\n        }\n        if (viewPort.playViewPort !== undefined) {\n            this._playViewPort = viewPort.playViewPort;\n        }\n        // If the playback speed has been set, set the new playback speed.\n        if (viewPort.playSpeed !== undefined) {\n            if (!this._drawPlayhead)\n                throw new Error('setViewPort: viewPort.playSpeed was set, but drawPlayhead was not set in constructor');\n            this._playSpeed = viewPort.playSpeed;\n        }\n        // Set playhead playing/ not playing.\n        if (viewPort.playPlayhead !== undefined) {\n            if (!this._drawPlayhead)\n                throw new Error('setViewPort: viewPort.playPlayhead was set, but drawPlayhead was not set in constructor');\n            this._playHeadPlaying = viewPort.playPlayhead;\n        }\n        if (viewPort.playheadTime !== undefined) {\n            if (!this._drawPlayhead)\n                throw new Error('setViewPort: viewPort.playheadTime was set, but drawPlayhead was not set in constructor');\n            this._playHeadTime = Math.max(0, viewPort.playheadTime);\n            if (this._playHeadTime > 0)\n                this._updateDrawLastTime = this._playHeadTime;\n            changed = true;\n        }\n        // Redraw timeline if anything has changed.\n        if (changed === true) {\n            this.redrawTimeline();\n        }\n    }\n    /**\n     * Accessor for polling the currently hovered over object.\n     */\n    getHoveredObject() {\n        return this._hoveredOver;\n    }\n    /**\n     * Calculates the height to give to each row to fit all layers on screen.\n     * @param {String[]} layers Map of layers to use.\n     * @returns Height of rows.\n     */\n    calculateRowHeight(layers) {\n        return Math.min(MAX_LAYER_HEIGHT, this._canvasHeight / Object.keys(layers).length);\n    }\n    updateLayerLabels() {\n        // Store layers to draw.\n        const o = this.getLayersToDraw();\n        if (!isEqual(this._layerLabels, o.layers)) {\n            this._layerLabels = o.layers;\n            // Calculate row height.\n            this._rowHeight = this.calculateRowHeight(this._layerLabels);\n            // Set timeline object height.\n            this._timelineObjectHeight = this._rowHeight * TIMELINE_OBJECT_HEIGHT;\n            this._numberOfLayers = Object.keys(this._layerLabels).length;\n            this._rowsTotalHeight = this._rowHeight * this._numberOfLayers;\n        }\n    }\n    /**\n     * Draws the layer labels to the canvas.\n     */\n    drawLayerLabels() {\n        let row = 0;\n        // Iterate through layers.\n        for (let layerName of Object.keys(this._layerLabels)) {\n            this._canvas.fillStyle = COLOR_LABEL_BACKGROUND;\n            this._canvas.fillRect(0, row * this._rowHeight, this._layerLabelWidth, this._rowHeight);\n            this._canvas.fillStyle = TEXT_COLOR;\n            this._canvas.font = TEXT_FONT_SIZE.toString() + 'px ' + TEXT_FONT_FAMILY;\n            this._canvas.textBaseline = 'middle';\n            this._canvas.fillText(layerName, 0, (row * this._rowHeight) + (this._rowHeight / 2), this._layerLabelWidth);\n            if (this._layerLabels[layerName] !== 0) {\n                this._canvas.fillStyle = COLOR_LINE;\n                this._canvas.fillRect(this._layerLabelWidth, row * this._rowHeight, this._viewDrawWidth, THICKNESS_LINE);\n            }\n            row++;\n        }\n    }\n    /**\n     * Draws the timeline background.\n     */\n    drawBackground() {\n        this._canvas.fillStyle = COLOR_BACKGROUND;\n        this._canvas.fillRect(0, 0, this._canvasWidth, this._canvasHeight);\n        this.drawBackgroundRuler();\n    }\n    /**\n     * Draw a ruler on top of background\n     */\n    drawBackgroundRuler() {\n        const range = this.viewRange;\n        const endTime = this.viewEndTime;\n        const circaNumberOfLines = 5;\n        const rounder = Math.pow(10, Math.floor(Math.log10(range / circaNumberOfLines))); // What to round the ruler to\n        const rounderNext = rounder * 10;\n        const numberOfLines = Math.floor(range / rounder);\n        const rulerDiff = rounder;\n        const startTime = Math.floor(this._viewStartTime / rounder) * rounder;\n        const opacity = (Math.min(1, circaNumberOfLines / numberOfLines));\n        if (rulerDiff) {\n            this._canvas.strokeStyle = RULER_LINE_COLOR;\n            this._canvas.lineWidth = RULER_LINE_WIDTH;\n            for (let rulerTime = startTime; rulerTime < endTime; rulerTime += rulerDiff) {\n                this._canvas.beginPath();\n                let x = this.timeToXCoord(rulerTime);\n                let distanceToNext = (rulerTime / rounderNext) % 1;\n                if (distanceToNext > 0.5)\n                    distanceToNext -= 1;\n                distanceToNext = Math.abs(distanceToNext);\n                if (distanceToNext < 0.01) {\n                    // Is a significant line\n                    this._canvas.globalAlpha = 1;\n                }\n                else {\n                    this._canvas.globalAlpha = opacity;\n                }\n                if (x >= this._viewDrawX) {\n                    this._canvas.moveTo(x, 0);\n                    this._canvas.lineTo(x, this._canvasHeight);\n                }\n                this._canvas.stroke();\n            }\n            this._canvas.globalAlpha = 1;\n        }\n    }\n    /**\n     * Draws the playhead initially.\n     */\n    drawPlayhead() {\n        // If the playhead should be draw.\n        if (this._drawPlayhead) {\n            if (this.istimeInView(this._playHeadTime)) {\n                this._canvas.fillStyle = COLOR_PLAYHEAD;\n                this._canvas.fillRect(this.timeToXCoord(this._playHeadTime), 0, THICKNESS_PLAYHEAD, this._canvasHeight);\n            }\n        }\n    }\n    /**\n     * Gets the layers to draw from the timeline.\n     */\n    getLayersToDraw() {\n        this._hoveredObjectMap = {};\n        const layersArray = this._resolvedStates ? Object.keys(this._resolvedStates.layers) : [];\n        layersArray.sort((a, b) => {\n            if (a > b)\n                return 1;\n            if (a < b)\n                return 1;\n            return 0;\n        });\n        const layers = {};\n        layersArray.forEach((layerName, index) => {\n            layers[layerName] = index;\n            this._hoveredObjectMap[layerName] = [];\n        });\n        return {\n            layers: layers,\n            layersArray: layersArray\n        };\n    }\n    /**\n     * Redraws the timeline to the canvas.\n     */\n    redrawTimeline() {\n        this._canvas.clearRect(0, 0, this._canvasWidth, this._canvasHeight);\n        this.drawBackground();\n        this.drawLayerLabels();\n        // Recompute objects positions\n        this._timelineState = this.getTimelineDrawState(this._resolvedStates);\n        // Draw the current state.\n        this.drawTimelineState(this._timelineState);\n        this.drawPlayhead();\n        this.checkAutomaticReresolve();\n    }\n    /**\n     * Draws a timeline state to the canvas.\n     * @param {TimelineDrawState} currentDrawState State to draw.\n     */\n    drawTimelineState(currentDrawState) {\n        for (let element in currentDrawState) {\n            const drawState = currentDrawState[element];\n            if (drawState.visible) {\n                this._canvas.fillStyle = COLOR_TIMELINE_OBJECT_FILL;\n                this._canvas.fillRect(drawState.left, drawState.top, drawState.width, drawState.height);\n                this._canvas.strokeStyle = COLOR_TIMELINE_OBJECT_BORDER;\n                this._canvas.lineWidth = THICKNESS_TIMELINE_OBJECT_BORDER;\n                this._canvas.strokeRect(drawState.left, drawState.top, drawState.width, drawState.height);\n                this._canvas.fillStyle = TEXT_COLOR;\n                this._canvas.font = TEXT_FONT_SIZE.toString() + 'px ' + TEXT_FONT_FAMILY;\n                this._canvas.textBaseline = 'top';\n                this._canvas.fillText(drawState.title, drawState.left, drawState.top);\n            }\n        }\n    }\n    /**\n     * Returns the draw states for all timeline objects.\n     * @param {ResolvedStates} timeline Timeline to draw.\n     * @returns {TimelineDrawState} State of time-based objects.\n     */\n    getTimelineDrawState(timeline) {\n        let currentDrawState = {};\n        if (timeline) {\n            for (let objId in timeline.objects) {\n                let timelineObj = timeline.objects[objId];\n                for (let _i = 0; _i < timelineObj.resolved.instances.length; _i++) {\n                    let instanceObj = timelineObj.resolved.instances[_i];\n                    let name = 'timelineObject:' + objId + ':' + instanceObj.id;\n                    currentDrawState[name] = this.createStateForObject(timelineObj, instanceObj.start, instanceObj.end);\n                    if (currentDrawState[name].visible === true) {\n                        if (!this._hoveredObjectMap[timelineObj.layer + ''])\n                            this._hoveredObjectMap[timelineObj.layer + ''] = [];\n                        this._hoveredObjectMap[timelineObj.layer + ''].push({\n                            startX: currentDrawState[name].left,\n                            endX: currentDrawState[name].left + currentDrawState[name].width,\n                            objectRefId: objId,\n                            instanceId: instanceObj.id,\n                            type: 'timelineObject',\n                            name: name\n                        });\n                    }\n                }\n            }\n        }\n        return currentDrawState;\n    }\n    /**\n     * Creates a draw state for a timeline object.\n     * @param {string} layer Object's layer.\n     * @param {number} start Start time.\n     * @param {number} end End time.\n     * @returns {DrawState} State of the object to draw.\n     */\n    createStateForObject(obj, start, end) {\n        // Default state (hidden).\n        let state = {\n            height: 0,\n            left: 0,\n            top: 0,\n            width: 0,\n            visible: false,\n            title: 'N/A'\n        };\n        // State should be default if the object is not being shown.\n        if (this.showOnTimeline(start, end)) {\n            // Get object dimensions and position.\n            let objectWidth = this.getObjectWidth(start, end);\n            let xCoord = this.capXcoordToView(this.timeToXCoord(start));\n            let objectTop = this.getObjectOffsetFromTop(obj.layer + '');\n            // Set state properties.\n            state.height = this._timelineObjectHeight;\n            state.left = xCoord;\n            state.top = objectTop;\n            state.width = objectWidth;\n            state.visible = true;\n            state.title = obj.id;\n        }\n        return state;\n    }\n    /**\n     * Calculates the offset, in pixels from the start of the timeline for an object.\n     * @param {number} start start time of the object.\n     * @returns {number} Offset in pixels.\n     */\n    // private getObjectOffsetFromTimelineStart (start: number): number {\n    // \t// Calculate offset.\n    // \tlet offset = (start - this._viewStartTime) * this.pixelsWidthPerUnitTime\n    // \t// Offset cannot be to the left of the timeline start position.\n    // \tif (offset < 0) {\n    // \t\toffset = 0\n    // \t}\n    // \treturn offset\n    // }\n    /**\n     * Calculates the width, in pixels, of an object based on its duration.\n     * @param {number} start Start time of the object.\n     * @param {number} end End time of the object.\n     * @returns {number} Width in pixels.\n     */\n    getObjectWidth(startTime, endTime) {\n        if (!endTime)\n            return this._canvasWidth;\n        // If the start time is less than the timeline start, set to timeline start.\n        if (startTime < this._viewStartTime) {\n            startTime = this._viewStartTime;\n        }\n        // Calculate duration of the object remaining on the timeline.\n        let duration = endTime - startTime;\n        // Return end point position in pixels.\n        return duration * this.pixelsWidthPerUnitTime;\n    }\n    /**\n     * Determines whether to show an object on the timeline.\n     * @param {number} start Object start time.\n     * @param {number} end Object end time.\n     * @returns {true} if object should be shown on the timeline.\n     */\n    showOnTimeline(start, end) {\n        let isAfter = start >= this.viewEndTime;\n        let isBefore = (end || Infinity) <= this._viewStartTime;\n        return !isAfter && !isBefore;\n    }\n    /**\n     * Calculate position of object instance from top of timeline according to its layer.\n     * @param {string} layer Object's layer.\n     * @returns Position relative to top of canvas in pixels.\n     */\n    getObjectOffsetFromTop(layerName) {\n        let top = this._layerLabels[layerName];\n        return top * this._rowHeight;\n    }\n    /**\n     * Moves the playhead. Called periodically.\n     */\n    updateDraw() {\n        const now = Date.now();\n        // How long time since last update:\n        const dt = (this._updateDrawLastTime > 0 ?\n            now - this._updateDrawLastTime :\n            1) / 1000;\n        this._updateDrawLastTime = now;\n        const deltaTime = this._playSpeed * dt;\n        // Check playhead should be drawn.\n        let needRedraw = false;\n        if (this._playHeadPlaying && this._drawPlayhead) {\n            if (this._playViewPort &&\n                this.istimeInView(this._playHeadTime) // Only play if playhead is in view\n            ) {\n                this._viewStartTime += deltaTime;\n            }\n            // Move playhead forward\n            this._playHeadTime += deltaTime;\n            needRedraw = true;\n        }\n        if (needRedraw) {\n            this.redrawTimeline();\n        }\n        // call this function on next frame\n        window.requestAnimationFrame(() => this.updateDraw());\n    }\n    /**\n     * Handles mouse down event.\n     * @param event Mouse event.\n     */\n    canvasMouseDown(event) {\n        // Store mouse is down.\n        this._mouseDown = true;\n        // Store X position of mouse on click.\n        this._mouseLastX = event.clientX;\n        // Prevent event.\n        event.preventDefault();\n        event.stopPropagation();\n    }\n    /**\n     * Handles mouse up event.\n     * @param event Mouse event.\n     */\n    canvasMouseUp(event) {\n        // Mouse no longer down.\n        this._mouseDown = false;\n        // Reset scroll direction.\n        this._lastScrollDirection = 0;\n        // Prevent event.\n        event.preventDefault();\n        event.stopPropagation();\n    }\n    /**\n     * Handles mouse movement on canvas.\n     * @param event Mouse event.\n     */\n    canvasMouseMove(event) {\n        // If mouse is down.\n        if (this._mouseDown) {\n            // If we are beginning scrolling, we can move freely.\n            if (this._lastScrollDirection === undefined || this._lastScrollDirection === 0) {\n                // Store current mouse X.\n                this._mouseLastX = event.clientX;\n                // Calculate change in X.\n                let deltaX = event.clientX - this._mouseLastX;\n                // Store scrolling direction.\n                if (deltaX < 0) {\n                    this._lastScrollDirection = -1;\n                }\n                else {\n                    this._lastScrollDirection = 1;\n                }\n                // Scroll to new X position.\n                this.canvasScrollByDeltaX(-deltaX);\n            }\n            else {\n                // Calculate scroll direction.\n                let direction = this._mouseLastX - event.clientX;\n                // If changing direction, store new direction but don't scroll.\n                if (direction < 0 && this._lastScrollDirection === 1) {\n                    this._mouseLastX = event.clientX;\n                    this._lastScrollDirection = -1;\n                }\n                else if (direction > 0 && this._lastScrollDirection === -1) {\n                    this._mouseLastX = event.clientX;\n                    this._lastScrollDirection = 1;\n                }\n                else {\n                    // Calculate change in X.\n                    let deltaX = event.clientX - this._mouseLastX;\n                    // Store last X position.\n                    this._mouseLastX = event.clientX;\n                    // Move by change in X.\n                    this.canvasScrollByDeltaX(-deltaX);\n                }\n            }\n            // Redraw timeline.\n            this.redrawTimeline();\n        }\n        else {\n            // Whether an object is under the cursor.\n            let found = false;\n            // Find the object that is currently hovered over.\n            let mousePos = this.getMousePos(this._canvasContainer, event);\n            if (mousePos.x > this._viewDrawX) {\n                if (mousePos.y < this._rowsTotalHeight) {\n                    let selectedRow = Math.floor((mousePos.y / this._rowsTotalHeight) * this._numberOfLayers);\n                    let layer;\n                    Object.keys(this._layerLabels).forEach(layerName => {\n                        if (this._layerLabels[layerName] === selectedRow)\n                            layer = layerName;\n                    });\n                    let hoverMapData = (layer ? this._hoveredObjectMap[layer] : []) || [];\n                    hoverMapData.forEach(object => {\n                        if (object.startX <= mousePos.x && object.endX >= mousePos.x) {\n                            found = true;\n                            const hoverHash = object.type + object.objectRefId + object.instanceId; // hash-ish\n                            if (this._lastHoveredHash !== hoverHash) {\n                                // Get object metadata from the object name of the hovered object.\n                                // If we are hovering over a timeline object.\n                                if (object.type === 'timelineObject') {\n                                    // Get the timeline object and the instance being hovered over.\n                                    if (this._resolvedStates) {\n                                        let timelineObject = this._resolvedStates.objects[object.objectRefId];\n                                        let instance = timelineObject.resolved.instances.find(instance => instance.id === object.instanceId);\n                                        if (instance) {\n                                            // Construct hover info.\n                                            let hoverInfo = {\n                                                object: timelineObject,\n                                                instance: instance,\n                                                pointer: { xPostion: mousePos.x, yPosition: mousePos.y }\n                                            };\n                                            // Set currently hovered object.\n                                            this._hoveredOver = hoverInfo;\n                                            // Emit event.\n                                            this.emit('timeline:hover', { detail: this._hoveredOver });\n                                        }\n                                        // Store last items.\n                                        this._lastHoverAction = MOUSEIN;\n                                        this._lastHoveredHash = hoverHash;\n                                    }\n                                }\n                            }\n                        }\n                    });\n                }\n            }\n            // Emit undefined when mouse out.\n            if (!found && this._lastHoverAction === MOUSEIN) {\n                this.emit('timeline:hover', { detail: undefined });\n                this._lastHoverAction = MOUSEOUT;\n            }\n        }\n    }\n    /**\n     * Handles scroll wheel events on the canvas.\n     * @param event Scroll event.\n     */\n    canvasScrollWheel(event) {\n        // Get mouse pointer coordinates on canvas.\n        let canvasCoord = this.getMousePos(this._canvasContainer, event);\n        // Don't scroll if mouse is not over timeline.\n        if (canvasCoord.x <= this._viewDrawX) {\n            return;\n        }\n        let changed = false;\n        // CTRL + scroll to zoom.\n        if (event.ctrlKey === true) {\n            if (event.deltaY) {\n                changed = true;\n                const zoomFactor = Math.pow(ZOOM_FACTOR, -event.deltaY);\n                this.zoomUnderCursor(canvasCoord.x, zoomFactor);\n            }\n        }\n        else if (event.deltaX !== 0) { // Scroll on x-axis\n            changed = true;\n            // Pan.\n            this.canvasScrollByDeltaX((event.deltaX * (PAN_FACTOR * this.stepSize)));\n        }\n        else if (event.deltaY !== 0 && event.altKey === true) { // Also scroll on alt-key + scroll y-axis\n            changed = true;\n            // Pan.\n            this.canvasScrollByDeltaX((event.deltaY * (PAN_FACTOR * this.stepSize)));\n        }\n        // Prevent event.\n        event.preventDefault();\n        event.stopPropagation();\n        if (changed) {\n            // Redraw timeline.\n            this.redrawTimeline();\n        }\n    }\n    /**\n     * Scroll across the canvas by a specified X value.\n     * @param {number} deltaX Value to move by.\n     */\n    canvasScrollByDeltaX(deltaX) {\n        // Calculate new starting time.\n        let targetStart = this._viewStartTime + (deltaX / this.pixelsWidthPerUnitTime);\n        // Starting time cannot be < 0.\n        if (targetStart < 0) {\n            targetStart = 0;\n        }\n        // Optimisation, don't redraw if nothing has changed.\n        if (targetStart === this._viewStartTime) {\n            return;\n        }\n        this._viewStartTime = targetStart;\n    }\n    /**\n     * Zooms into/out of timeline, keeping the time under the cursor in the same position.\n     * @param cursorX Position of mouse cursor.\n     */\n    zoomUnderCursor(cursorX, zoomFactor) {\n        // Point in time of the cursor\n        let cursorTime = this.xCoordToTime(cursorX);\n        // Ratio (in view range) of the cursor\n        let cursorRatio = this.timeToRatio(cursorTime);\n        // Change zoom:\n        this._timelineZoom = this._timelineZoom * zoomFactor;\n        // Limit within current view\n        cursorRatio = Math.max(0, Math.min(1, cursorRatio));\n        // Calculate start\n        let targetStart = cursorTime - (cursorRatio * this.viewRange);\n        // Start cannot be less than 0\n        if (targetStart < 0) {\n            targetStart = 0;\n        }\n        // Set draw time\n        this._viewStartTime = targetStart;\n    }\n    /**\n     * Gets the mouse position relative to the top-left of the canvas [pixels]\n     * @param canvas\n     * @param evt\n     * @returns {x: number, y: number} Position.\n     */\n    getMousePos(canvas, evt) {\n        const rect = canvas.getBoundingClientRect();\n        return {\n            x: evt.clientX - rect.left,\n            y: evt.clientY - rect.top\n        };\n    }\n    /**\n     * Trims a timeline so that objects only exist within a specified time period.\n     * @param timeline Timeline to trim.\n     * @param trim Times to trim between.\n     */\n    trimTimeline(timeline, trim) {\n        // The new resolved objects.\n        let newObjects = {};\n        // Iterate through resolved objects.\n        Object.keys(timeline.objects).forEach((objId) => {\n            const obj = timeline.objects[objId];\n            const resultingInstances = [];\n            obj.resolved.instances.forEach(instance => {\n                // Whether to insert this object into the new timeline.\n                let useInstance = false;\n                let newInstance = Object.assign({}, instance); // clone\n                // If trimming the start time.\n                if (trim.start) {\n                    // If the object ends after the trim start time.\n                    if ((instance.end || Infinity) > trim.start) {\n                        useInstance = true;\n                        if (newInstance.start < trim.start) {\n                            newInstance.start = trim.start;\n                        }\n                    }\n                }\n                // If trimming the end time.\n                if (trim.end) {\n                    // If the object starts before the trim end time.\n                    if (instance.start < trim.end) {\n                        useInstance = true;\n                        if ((newInstance.end || Infinity) > trim.end) {\n                            newInstance.end = trim.end;\n                        }\n                    }\n                }\n                if (!trim.start && !trim.end) {\n                    useInstance = true;\n                }\n                if (useInstance &&\n                    newInstance.start < (newInstance.end || Infinity)) {\n                    resultingInstances.push(newInstance);\n                }\n            });\n            // If there isn't a resolved object for the new instance, create it.\n            if (!newObjects[objId]) {\n                let newObject = {\n                    content: obj.content,\n                    enable: obj.enable,\n                    id: obj.id,\n                    layer: obj.layer,\n                    resolved: {\n                        instances: [],\n                        levelDeep: obj.resolved.levelDeep,\n                        resolved: obj.resolved.resolved,\n                        resolving: obj.resolved.resolving,\n                        directReferences: obj.resolved.directReferences,\n                    }\n                };\n                newObjects[objId] = newObject;\n            }\n            newObjects[objId].resolved.instances = resultingInstances;\n        });\n        return {\n            classes: timeline.classes,\n            layers: timeline.layers,\n            objects: newObjects,\n            options: timeline.options,\n            statistics: timeline.statistics,\n            state: timeline.state,\n            nextEvents: timeline.nextEvents\n        };\n    }\n    /**\n     * Merges two timelines by merging instances of objects that intersect each other.\n     * @param past Older timeline.\n     * @param present Newer timeline.\n     * @returns {ResolvedTimeline} containing merged timelines.\n     */\n    mergeTimelineObjects(past, present, fromNewTimeline) {\n        const resultingObjects = {};\n        if (fromNewTimeline) {\n            past = this.trimTimeline(past, { end: this._playHeadTime });\n            present = this.trimTimeline(present, { start: this._playHeadTime });\n            // Because we want to keep old objects, this iterator is used to create unique old ids for them\n            this._mergeIterator++;\n            Object.keys(past.objects).forEach((objId) => {\n                const pastObj = past.objects[objId];\n                // @ts-ignore: hack to mark it as a \"past object\"\n                if (pastObj.__pastObj) {\n                    // Copy over it right away, it's old. Don't do anything else\n                    resultingObjects[objId] = pastObj;\n                    return;\n                }\n                // If an object exists in both timelines\n                const presentObj = present.objects[objId];\n                if (presentObj) {\n                    if (\n                    // Compare the objects, only look into merging them if they look identical\n                    isEqual(Object.assign({}, pastObj, { resolved: null }), Object.assign({}, presentObj, { resolved: null }))) {\n                        // This assumes that all past instances stop at a certain time at the very latest,\n                        // and that all new instances start at that time at the very earliest.\n                        // Iterate over all instances of those objects.\n                        const allInstances = {};\n                        pastObj.resolved.instances.forEach(pastInstance => {\n                            allInstances[pastInstance.end + ''] = pastInstance;\n                        });\n                        presentObj.resolved.instances.forEach(presentInstance => {\n                            if (allInstances[presentInstance.start + '']) {\n                                // The instances are next to each other, merge them into one:\n                                allInstances[presentInstance.start + ''].end = presentInstance.end;\n                            }\n                            else {\n                                allInstances[presentInstance.start + ''] = presentInstance;\n                            }\n                        });\n                        presentObj.resolved.instances = [];\n                        Object.keys(allInstances).forEach(key => {\n                            const instance = allInstances[key];\n                            presentObj.resolved.instances.push(instance);\n                        });\n                        // Copy over the new object\n                        resultingObjects[objId] = presentObj;\n                        return; // don't copy over old object\n                    }\n                    else {\n                        // The objects doesn't look identical\n                        // Copy over the new object\n                        resultingObjects[objId] = presentObj;\n                    }\n                }\n                else {\n                    // The old object doesn't exist in the new timeline\n                }\n                // @ts-ignore: hack to mark it as a \"past object\"\n                pastObj.__pastObj = true;\n                // Copy over the old object\n                resultingObjects[this._mergeIterator + '__' + objId] = pastObj;\n            });\n            // Iterate over the next objects\n            Object.keys(present.objects).forEach((objId) => {\n                const presentObj = present.objects[objId];\n                if (!past.objects[objId]) { // (if it did existed in the past, it has already been handled)\n                    // Just copy over the new object\n                    resultingObjects[objId] = presentObj;\n                }\n            });\n        }\n        else {\n            // No new timeline, objects and instances are only added\n            Object.keys(past.objects).forEach((objId) => {\n                const pastObj = past.objects[objId];\n                resultingObjects[objId] = pastObj;\n            });\n            Object.keys(present.objects).forEach((objId) => {\n                const presentObj = present.objects[objId];\n                const existingObj = resultingObjects[objId];\n                if (existingObj) {\n                    // merge with old instances\n                    const existingInstances = {};\n                    existingObj.resolved.instances.forEach(instance => {\n                        existingInstances[instance.start + '_' + instance.end] = true;\n                    });\n                    presentObj.resolved.instances.forEach(instance => {\n                        // Only push instances that aren't already present:\n                        if (!existingInstances[instance.start + '_' + instance.end]) {\n                            existingObj.resolved.instances.push(instance);\n                        }\n                    });\n                }\n                else {\n                    resultingObjects[objId] = presentObj;\n                }\n            });\n        }\n        const resultingLayers = {};\n        Object.keys(resultingObjects).forEach(key => {\n            const obj = resultingObjects[key];\n            const layer = obj.layer + '';\n            if (!resultingLayers[layer])\n                resultingLayers[layer] = [];\n            resultingLayers[layer].push(key);\n        });\n        return Object.assign({}, present, { objects: resultingObjects, layers: resultingLayers });\n    }\n    updateTimelineResolveWindow() {\n        const { start, end } = this.getExpandedStartEndTime(1);\n        this._timelineResolveStart = start;\n        this._timelineResolveEnd = end;\n        this._timelineResolveZoom = this._timelineZoom;\n        if (this.latestUpdateTime) {\n            // Calculate an optimal number of objects to create, so that the drawing still runs smoothly.\n            const targetResolveTime = 50; // ms\n            let ratio = targetResolveTime / this.latestUpdateTime;\n            this._timelineResolveCountAdjust = Math.max(0.1, Math.min(10, (1 + (this._timelineResolveCountAdjust * ratio)) / 2));\n        }\n    }\n    getExpandedStartEndTime(multiplier = 1) {\n        let start = this._viewStartTime;\n        let end = this.viewEndTime;\n        let duration = end - start;\n        let expand = duration * (this._timelineResolveExpand - 1) * multiplier;\n        start -= expand * 0.33;\n        end += expand * 0.66; // expand more into the future\n        start = Math.max(0, start);\n        end = Math.max(0, end);\n        const zoomDiff = Math.max(this._timelineResolveZoom, this._timelineZoom) /\n            Math.min(this._timelineResolveZoom, this._timelineZoom);\n        return { start, end, zoomDiff };\n    }\n    checkAutomaticReresolve() {\n        const { start, end, zoomDiff } = this.getExpandedStartEndTime(0.2);\n        if (this._timelineResolveAuto && (start < this._timelineResolveStart ||\n            end > this._timelineResolveEnd ||\n            zoomDiff > 3)) {\n            if (!this.reresolveTimeout) {\n                this.reresolveTimeout = setTimeout(() => {\n                    this.reresolveTimeout = null;\n                    this.updateTimelineResolveWindow();\n                    this._updateTimeline();\n                }, Math.max(100, this.latestUpdateTime * 5));\n            }\n        }\n    }\n    // --------------------- Conversions between position & time -------------\n    /**\n     * Calculate the X coordinate of a time value.\n     * @param {number} time The time to convert.\n     * @returns {number} The X coordinate of the time.\n     */\n    timeToXCoord(time) {\n        return this._viewDrawX + ((time - this._viewStartTime) * this.pixelsWidthPerUnitTime);\n    }\n    /**\n     * Calculate the time of a X coordinate.\n     * @param {number} time The X coordinate to convert.\n     * @returns {number} The time of the X coordinate.\n     */\n    xCoordToTime(position) {\n        return this._viewStartTime + ((position - this._viewDrawX) / this.pixelsWidthPerUnitTime);\n    }\n    /** Calculate the ratio of the time in current view (0 i beginning, 1 is end)  */\n    timeToRatio(time) {\n        return (time - this._viewStartTime) / this.viewRange;\n    }\n    /** Returns true if the position is within the current view  */\n    istimeInView(time) {\n        const ratio = this.timeToRatio(time);\n        return ratio >= 0 && ratio < 1;\n    }\n    capXcoordToView(position) {\n        return Math.max(this._viewDrawX, Math.min(this._viewDrawX + this._viewDrawWidth, position));\n    }\n    // -------------- Getters / Convenience functions ---------------------\n    /** Zoom factor [pixels / time] */\n    get pixelsWidthPerUnitTime() {\n        return (this._timelineZoom / 100);\n    }\n    /** The range of the view [time] */\n    get viewRange() {\n        return this._viewDrawWidth / this.pixelsWidthPerUnitTime;\n    }\n    /** The end time of the view [time] */\n    get viewEndTime() {\n        return this._viewStartTime + this.viewRange;\n    }\n}\nexports.TimelineVisualizer = TimelineVisualizer;\n//# sourceMappingURL=timelineVisualizer.js.map","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar objectCreate = Object.create || objectCreatePolyfill\nvar objectKeys = Object.keys || objectKeysPolyfill\nvar bind = Function.prototype.bind || functionBindPolyfill\n\nfunction EventEmitter() {\n  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {\n    this._events = objectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nvar hasDefineProperty;\ntry {\n  var o = {};\n  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });\n  hasDefineProperty = o.x === 0;\n} catch (err) { hasDefineProperty = false }\nif (hasDefineProperty) {\n  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n    enumerable: true,\n    get: function() {\n      return defaultMaxListeners;\n    },\n    set: function(arg) {\n      // check whether the input is a positive number (whose value is zero or\n      // greater and not a NaN).\n      if (typeof arg !== 'number' || arg < 0 || arg !== arg)\n        throw new TypeError('\"defaultMaxListeners\" must be a positive number');\n      defaultMaxListeners = arg;\n    }\n  });\n} else {\n  EventEmitter.defaultMaxListeners = defaultMaxListeners;\n}\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    if (arguments.length > 1)\n      er = arguments[1];\n    if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Unhandled \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n      // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n      // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = objectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n          listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n          prepend ? [listener, existing] : [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n            existing.length + ' \"' + String(type) + '\" listeners ' +\n            'added. Use emitter.setMaxListeners() to ' +\n            'increase limit.');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        if (typeof console === 'object' && console.warn) {\n          console.warn('%s: %s', w.name, w.message);\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    switch (arguments.length) {\n      case 0:\n        return this.listener.call(this.target);\n      case 1:\n        return this.listener.call(this.target, arguments[0]);\n      case 2:\n        return this.listener.call(this.target, arguments[0], arguments[1]);\n      case 3:\n        return this.listener.call(this.target, arguments[0], arguments[1],\n            arguments[2]);\n      default:\n        var args = new Array(arguments.length);\n        for (var i = 0; i < args.length; ++i)\n          args[i] = arguments[i];\n        this.listener.apply(this.target, args);\n    }\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = bind.call(onceWrapper, state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = objectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else\n          spliceOne(list, position);\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = objectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = objectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = objectKeys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = objectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (!events)\n    return [];\n\n  var evlistener = events[type];\n  if (!evlistener)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction objectCreatePolyfill(proto) {\n  var F = function() {};\n  F.prototype = proto;\n  return new F;\n}\nfunction objectKeysPolyfill(obj) {\n  var keys = [];\n  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {\n    keys.push(k);\n  }\n  return k;\n}\nfunction functionBindPolyfill(context) {\n  var fn = this;\n  return function () {\n    return fn.apply(context, arguments);\n  };\n}\n","/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = isEqual;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=api.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EventType = void 0;\nvar EventType;\n(function (EventType) {\n    EventType[EventType[\"START\"] = 0] = \"START\";\n    EventType[EventType[\"END\"] = 1] = \"END\";\n    EventType[EventType[\"KEYFRAME\"] = 2] = \"KEYFRAME\";\n})(EventType = exports.EventType || (exports.EventType = {}));\n//# sourceMappingURL=enums.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateKeyframe = exports.validateObject = exports.validateTimeline = exports.Resolver = void 0;\nconst tslib_1 = require(\"tslib\");\ntslib_1.__exportStar(require(\"./api/enums\"), exports);\ntslib_1.__exportStar(require(\"./api/api\"), exports);\nvar resolver_1 = require(\"./resolver/resolver\");\nObject.defineProperty(exports, \"Resolver\", { enumerable: true, get: function () { return resolver_1.Resolver; } });\nvar validate_1 = require(\"./resolver/validate\");\nObject.defineProperty(exports, \"validateTimeline\", { enumerable: true, get: function () { return validate_1.validateTimeline; } });\nObject.defineProperty(exports, \"validateObject\", { enumerable: true, get: function () { return validate_1.validateObject; } });\nObject.defineProperty(exports, \"validateKeyframe\", { enumerable: true, get: function () { return validate_1.validateKeyframe; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cacheResult = exports.applyParentInstances = exports.setInstanceStartTime = exports.setInstanceEndTime = exports.resetId = exports.getId = exports.joinCaps = exports.addCapsToResuming = exports.joinReferences = exports.isReference = exports.capInstances = exports.applyRepeatingInstances = exports.operateOnArrays = exports.invertInstances = exports.convertEventsToInstances = exports.cleanInstances = exports.sortEvents = exports.isNumeric = exports.isConstant = exports.extendMandadory = void 0;\nconst _ = require(\"underscore\");\n/**\n * Somewhat like _.extend, but with strong types & mandated additional properties\n * @param original Object to be extended\n * @param extendObj properties to add\n */\nfunction extendMandadory(original, extendObj) {\n    return _.extend(original, extendObj);\n}\nexports.extendMandadory = extendMandadory;\nfunction isConstant(str) {\n    return !!(isNumeric(str) || (_.isString(str) && (str.match(/^true$/) || str.match(/^false$/))));\n}\nexports.isConstant = isConstant;\nfunction isNumeric(str) {\n    if (str === null)\n        return false;\n    if (_.isNumber(str))\n        return true;\n    if (_.isString(str))\n        return !!(str.match(/^[-+]?[0-9.]+$/) && !_.isNaN(parseFloat(str)));\n    return false;\n}\nexports.isNumeric = isNumeric;\nfunction sortEvents(events) {\n    return events.sort((a, b) => {\n        if (a.time > b.time)\n            return 1;\n        if (a.time < b.time)\n            return -1;\n        const aId = a.data && (a.data.id || (a.data.instance && a.data.instance.id));\n        const bId = b.data && (b.data.id || (b.data.instance && b.data.instance.id));\n        if (aId && bId && aId === bId) {\n            // If the event refer to the same ID, let the ending event be first:\n            if (a.value && !b.value)\n                return -1;\n            if (!a.value && b.value)\n                return 1;\n        }\n        if (a.value && !b.value)\n            return 1;\n        if (!a.value && b.value)\n            return -1;\n        return 0;\n    });\n}\nexports.sortEvents = sortEvents;\n/**\n * Clean up instances, join overlapping etc..\n * @param instances\n */\nfunction cleanInstances(instances, allowMerge, allowZeroGaps = false) {\n    // First, optimize for certain common situations:\n    if (instances.length === 0)\n        return [];\n    if (instances.length <= 1) {\n        const instance = instances[0];\n        if (!instance.end)\n            instance.end = null;\n        return [instance];\n    }\n    const events = [];\n    for (let i = 0; i < instances.length; i++) {\n        const instance = instances[i];\n        events.push({\n            time: instance.start,\n            value: true,\n            data: { instance: instance },\n            references: instance.references,\n        });\n        if (instance.end !== null) {\n            events.push({\n                time: instance.end,\n                value: false,\n                data: { instance: instance },\n                references: instance.references,\n            });\n        }\n    }\n    return convertEventsToInstances(events, allowMerge, allowZeroGaps);\n}\nexports.cleanInstances = cleanInstances;\nfunction convertEventsToInstances(events, allowMerge, allowZeroGaps = false) {\n    sortEvents(events);\n    const activeInstances = {};\n    let activeInstanceId = null;\n    let previousActive = false;\n    const negativeInstances = {};\n    let previousNegative = false;\n    let negativeInstanceId = null;\n    const returnInstances = [];\n    for (let i = 0; i < events.length; i++) {\n        const event = events[i];\n        const eventId = event.data.id || event.data.instance.id;\n        const lastInstance = returnInstances[returnInstances.length - 1];\n        if (event.value) {\n            activeInstances[eventId] = event;\n            delete negativeInstances[eventId];\n        }\n        else {\n            delete activeInstances[eventId];\n            negativeInstances[eventId] = event;\n        }\n        if (Object.keys(activeInstances).length) {\n            // There is an active instance\n            if (!allowMerge && !allowZeroGaps && lastInstance && previousNegative) {\n                // There is previously an inActive (negative) instance\n                lastInstance.start = event.time;\n            }\n            else {\n                const o = handleActiveInstances(event, lastInstance, activeInstanceId, eventId, activeInstances, allowMerge, allowZeroGaps);\n                activeInstanceId = o.activeInstanceId;\n                if (o.returnInstance) {\n                    returnInstances.push(o.returnInstance);\n                }\n            }\n            previousActive = true;\n            previousNegative = false;\n        }\n        else {\n            // No instances are active\n            if (lastInstance && previousActive) {\n                lastInstance.end = event.time;\n            }\n            else {\n                if (Object.keys(negativeInstances).length) {\n                    // There is a negative instance running\n                    const o = handleActiveInstances(event, lastInstance, negativeInstanceId, eventId, negativeInstances, allowMerge, allowZeroGaps);\n                    negativeInstanceId = o.activeInstanceId;\n                    if (o.returnInstance) {\n                        returnInstances.push({\n                            ...o.returnInstance,\n                            start: o.returnInstance.end || 0,\n                            end: o.returnInstance.start,\n                        });\n                    }\n                    previousNegative = true;\n                }\n            }\n            previousActive = false;\n        }\n    }\n    return returnInstances;\n}\nexports.convertEventsToInstances = convertEventsToInstances;\nfunction handleActiveInstances(event, lastInstance, activeInstanceId, eventId, activeInstances, allowMerge, allowZeroGaps = false) {\n    let returnInstance = null;\n    if (!allowMerge &&\n        event.value &&\n        lastInstance &&\n        lastInstance.end === null &&\n        activeInstanceId !== null &&\n        activeInstanceId !== eventId) {\n        // Start a new instance:\n        lastInstance.end = event.time;\n        returnInstance = {\n            id: getId(),\n            start: event.time,\n            end: null,\n            references: event.references,\n            originalEnd: event.data.instance.originalEnd,\n            originalStart: event.data.instance.originalStart,\n        };\n        activeInstanceId = eventId;\n    }\n    else if (!allowMerge && !event.value && lastInstance && activeInstanceId === eventId) {\n        // The active instance stopped playing, but another is still playing\n        const latestInstance = _.reduce(activeInstances, (memo, instanceEvent, id) => {\n            if (memo === null || memo.event.time < instanceEvent.time) {\n                return {\n                    event: instanceEvent,\n                    id: id,\n                };\n            }\n            return memo;\n        }, null);\n        if (latestInstance) {\n            // Restart that instance now:\n            lastInstance.end = event.time;\n            returnInstance = {\n                id: eventId + '_' + getId(),\n                start: event.time,\n                end: null,\n                references: latestInstance.event.references,\n                originalEnd: event.data.instance.originalEnd,\n                originalStart: event.data.instance.originalStart,\n            };\n            activeInstanceId = latestInstance.id;\n        }\n    }\n    else if (allowMerge && !allowZeroGaps && lastInstance && lastInstance.end === event.time) {\n        // The previously running ended just now\n        // resume previous instance:\n        lastInstance.end = null;\n        lastInstance.references = joinReferences(lastInstance.references, event.references);\n        addCapsToResuming(lastInstance, event.data.instance.caps);\n    }\n    else if (!lastInstance || lastInstance.end !== null) {\n        // There is no previously running instance\n        // Start a new instance:\n        returnInstance = {\n            id: eventId,\n            start: event.time,\n            end: null,\n            references: event.references,\n            caps: event.data.instance.caps,\n            originalEnd: event.data.instance.originalEnd,\n            originalStart: event.data.instance.originalStart,\n        };\n        activeInstanceId = eventId;\n    }\n    else {\n        // There is already a running instance\n        lastInstance.references = joinReferences(lastInstance.references, event.references);\n        addCapsToResuming(lastInstance, event.data.instance.caps);\n    }\n    if (lastInstance && lastInstance.caps && !lastInstance.caps.length)\n        delete lastInstance.caps;\n    if (returnInstance &&\n        lastInstance &&\n        lastInstance.start === lastInstance.end &&\n        lastInstance.end === returnInstance.start) {\n        // replace the previous zero-length with this one instead\n        lastInstance.id = returnInstance.id;\n        lastInstance.start = returnInstance.start;\n        lastInstance.end = returnInstance.end;\n        lastInstance.references = returnInstance.references;\n        lastInstance.caps = returnInstance.caps;\n        lastInstance.originalStart = returnInstance.originalStart;\n        lastInstance.originalEnd = returnInstance.originalEnd;\n        returnInstance = null;\n    }\n    return {\n        activeInstanceId,\n        returnInstance,\n    };\n}\nfunction invertInstances(instances) {\n    if (instances.length) {\n        instances = cleanInstances(instances, true, true);\n        const invertedInstances = [];\n        if (instances[0].start !== 0) {\n            invertedInstances.push({\n                id: getId(),\n                isFirst: true,\n                start: 0,\n                end: null,\n                references: joinReferences(instances[0].references, instances[0].id),\n            });\n        }\n        for (let i = 0; i < instances.length; i++) {\n            const instance = instances[i];\n            const last = _.last(invertedInstances);\n            if (last) {\n                last.end = instance.start;\n            }\n            if (instance.end !== null) {\n                invertedInstances.push({\n                    id: getId(),\n                    start: instance.end,\n                    end: null,\n                    references: joinReferences(instance.references, instance.id),\n                    caps: instance.caps,\n                });\n            }\n        }\n        return invertedInstances;\n    }\n    else {\n        return [\n            {\n                id: getId(),\n                isFirst: true,\n                start: 0,\n                end: null,\n                references: [],\n            },\n        ];\n    }\n}\nexports.invertInstances = invertInstances;\n/**\n * Perform an action on 2 arrays. Behaves somewhat like the \".*\"-operator in Matlab\n * @param array0\n * @param array1\n * @param operate\n */\nfunction operateOnArrays(array0, array1, operate) {\n    if (array0 === null || array1 === null)\n        return null;\n    if (isReference(array0) && isReference(array1)) {\n        return operate(array0, array1);\n    }\n    const result = [];\n    const minLength = Math.min(_.isArray(array0) ? array0.length : Infinity, _.isArray(array1) ? array1.length : Infinity);\n    for (let i = 0; i < minLength; i++) {\n        const a = _.isArray(array0)\n            ? array0[i]\n            : { id: '', start: array0.value, end: array0.value, references: array0.references };\n        const b = _.isArray(array1)\n            ? array1[i]\n            : { id: '', start: array1.value, end: array1.value, references: array1.references };\n        const start = a.isFirst\n            ? { value: a.start, references: a.references }\n            : b.isFirst\n                ? { value: b.start, references: b.references }\n                : operate({ value: a.start, references: joinReferences(a.id, a.references) }, { value: b.start, references: joinReferences(b.id, b.references) });\n        const end = a.isFirst\n            ? a.end !== null\n                ? { value: a.end, references: a.references }\n                : null\n            : b.isFirst\n                ? b.end !== null\n                    ? { value: b.end, references: b.references }\n                    : null\n                : operate(a.end !== null ? { value: a.end, references: joinReferences(a.id, a.references) } : null, b.end !== null ? { value: b.end, references: joinReferences(b.id, b.references) } : null);\n        if (start !== null) {\n            result.push({\n                id: getId(),\n                start: start.value,\n                end: end === null ? null : end.value,\n                references: joinReferences(start.references, end !== null ? end.references : []),\n                caps: joinCaps(a.caps, b.caps),\n            });\n        }\n    }\n    return cleanInstances(result, false);\n}\nexports.operateOnArrays = operateOnArrays;\n/**\n * Like operateOnArrays, but will multiply the number of elements in array0, with the number of elements in array1\n * @param array0\n * @param array1\n * @param operate\n */\n/*export function operateOnArraysMulti (\n    array0: Array<TimelineObjectInstance> | Reference | null,\n    array1: Array<TimelineObjectInstance> | Reference | null,\n    operate: (a: Reference | null, b: Reference | null) => Reference | null\n) {\n    if (array0 === null) return null\n\n    if (_.isArray(array1)) {\n        let resultArray: Array<TimelineObjectInstance> = []\n        _.each(array1, (array1Val) => {\n            const result = operateOnArrays(array0, { value: array1Val.start, references: array1Val.references } , operate)\n            if (_.isArray(result)) {\n                resultArray = resultArray.concat(result)\n            } else if (result !== null) {\n                resultArray.push({\n                    id: getId(),\n                    start: result.value,\n                    end: (\n                        array1Val.end !== null ?\n                        result.value + (array1Val.end - array1Val.start) :\n                        null\n                    ),\n                    references: result.references\n                })\n            }\n        })\n        return resultArray\n    } else {\n        return operateOnArrays(array0, array1, operate)\n    }\n}\n*/\nfunction applyRepeatingInstances(instances, repeatTime0, options) {\n    if (repeatTime0 === null || !repeatTime0.value)\n        return instances;\n    const repeatTime = repeatTime0.value;\n    if (isReference(instances)) {\n        instances = [\n            {\n                id: '',\n                start: instances.value,\n                end: null,\n                references: instances.references,\n            },\n        ];\n    }\n    const repeatedInstances = [];\n    for (let i = 0; i < instances.length; i++) {\n        const instance = instances[i];\n        let startTime = Math.max(options.time - ((options.time - instance.start) % repeatTime), instance.start);\n        let endTime = instance.end === null ? null : instance.end + (startTime - instance.start);\n        const cap = (instance.caps ? _.find(instance.caps, (cap) => instance.references.indexOf(cap.id) !== -1) : null) || null;\n        const limit = options.limitCount || 2;\n        for (let i = 0; i < limit; i++) {\n            if (options.limitTime && startTime >= options.limitTime)\n                break;\n            const cappedStartTime = cap ? Math.max(cap.start, startTime) : startTime;\n            const cappedEndTime = cap && cap.end !== null && endTime !== null ? Math.min(cap.end, endTime) : endTime;\n            if ((cappedEndTime || Infinity) > cappedStartTime) {\n                repeatedInstances.push({\n                    id: getId(),\n                    start: cappedStartTime,\n                    end: cappedEndTime,\n                    references: joinReferences(instance.id, instance.references, repeatTime0.references),\n                });\n            }\n            startTime += repeatTime;\n            if (endTime !== null)\n                endTime += repeatTime;\n        }\n    }\n    return cleanInstances(repeatedInstances, false);\n}\nexports.applyRepeatingInstances = applyRepeatingInstances;\n/**\n * Cap instances so that they are within their parentInstances\n * @param instances\n * @param parentInstances\n */\nfunction capInstances(instances, parentInstances) {\n    if (isReference(parentInstances) || parentInstances === null)\n        return instances;\n    let returnInstances = [];\n    for (let i = 0; i < instances.length; i++) {\n        const instanceOrg = instances[i];\n        // let instanceParents: TimelineObjectInstance[] | null = null\n        for (let j = 0; j < parentInstances.length; j++) {\n            const parent = parentInstances[j];\n            // First, check if the instance crosses the parent at all:\n            if (instanceOrg.start <= (parent.end || Infinity) && (instanceOrg.end || Infinity) >= parent.start) {\n                const instance = _.clone(instanceOrg);\n                // Cap start\n                if (instance.start < parent.start) {\n                    setInstanceStartTime(instance, parent.start);\n                }\n                // Cap end\n                if (parent.end !== null && (instance.end || Infinity) > (parent.end || Infinity)) {\n                    setInstanceEndTime(instance, parent.end);\n                }\n                if (instance.start >= parent.start && (instance.end || Infinity) <= (parent.end || Infinity)) {\n                    // The instance is within the parent\n                    instance.references = joinReferences(instance.references, parent.references);\n                    returnInstances.push(instance);\n                }\n            }\n        }\n    }\n    returnInstances.sort((a, b) => a.start - b.start);\n    // Ensure unique ids:\n    const ids = {};\n    for (let i = 0; i < returnInstances.length; i++) {\n        const instance = returnInstances[i];\n        // tslint:disable-next-line\n        if (ids[instance.id] !== undefined) {\n            instance.id = instance.id + ++ids[instance.id];\n        }\n        else {\n            ids[instance.id] = 0;\n        }\n    }\n    // Clean up the instances, to remove duplicates\n    returnInstances = cleanInstances(returnInstances, true, true);\n    return returnInstances;\n}\nexports.capInstances = capInstances;\nfunction isReference(ref0) {\n    const ref = ref0;\n    return (typeof ref === 'object' &&\n        !_.isArray(ref) &&\n        ref.value !== undefined &&\n        _.isArray(ref.references) &&\n        ref !== null);\n}\nexports.isReference = isReference;\nfunction joinReferences(...references) {\n    const refMap = {};\n    const refs = [];\n    for (let i = 0; i < references.length; i++) {\n        const reference = references[i];\n        if (reference) {\n            if (typeof reference === 'string') {\n                if (!refMap[reference])\n                    refs.push(reference);\n                refMap[reference] = true;\n            }\n            else {\n                for (let j = 0; j < reference.length; j++) {\n                    const ref = reference[j];\n                    if (ref) {\n                        if (!refMap[ref])\n                            refs.push(ref);\n                        refMap[ref] = true;\n                    }\n                }\n            }\n        }\n    }\n    return refs.sort((a, b) => {\n        if (a > b)\n            return 1;\n        if (a < b)\n            return -1;\n        return 0;\n    });\n}\nexports.joinReferences = joinReferences;\nfunction addCapsToResuming(instance, ...caps) {\n    const capsToAdd = [];\n    const joinedCaps = joinCaps(...caps);\n    for (let i = 0; i < joinedCaps.length; i++) {\n        const cap = joinedCaps[i];\n        if (cap.end && instance.end && cap.end > instance.end) {\n            capsToAdd.push({\n                id: cap.id,\n                start: 0,\n                end: cap.end,\n            });\n        }\n    }\n    instance.caps = joinCaps(instance.caps, capsToAdd);\n}\nexports.addCapsToResuming = addCapsToResuming;\nfunction joinCaps(...caps) {\n    const capMap = {};\n    for (let i = 0; i < caps.length; i++) {\n        const caps2 = caps[i];\n        if (caps2) {\n            for (let j = 0; j < caps2.length; j++) {\n                const cap2 = caps2[j];\n                capMap[cap2.id] = cap2;\n            }\n        }\n    }\n    return Object.values(capMap);\n}\nexports.joinCaps = joinCaps;\nlet idCount = 0;\n/**\n * Returns a unique id\n */\nfunction getId() {\n    return '@' + (idCount++).toString(36);\n}\nexports.getId = getId;\nfunction resetId() {\n    idCount = 0;\n}\nexports.resetId = resetId;\nfunction setInstanceEndTime(instance, endTime) {\n    instance.originalEnd = instance.originalEnd !== undefined ? instance.originalEnd : instance.end;\n    instance.end = endTime;\n}\nexports.setInstanceEndTime = setInstanceEndTime;\nfunction setInstanceStartTime(instance, startTime) {\n    instance.originalStart = instance.originalStart !== undefined ? instance.originalStart : instance.start;\n    instance.start = startTime;\n}\nexports.setInstanceStartTime = setInstanceStartTime;\nfunction applyParentInstances(parentInstances, value) {\n    const operate = (a, b) => {\n        if (a === null || b === null)\n            return null;\n        return {\n            value: a.value + b.value,\n            references: joinReferences(a.references, b.references),\n        };\n    };\n    return operateOnArrays(parentInstances, value, operate);\n}\nexports.applyParentInstances = applyParentInstances;\nconst cacheResultCache = {};\n/** Cache the result of function for a limited time */\nfunction cacheResult(name, fcn, limitTime = 1000) {\n    if (Math.random() < 0.01) {\n        setTimeout(cleanCacheResult, 100);\n    }\n    const cache = cacheResultCache[name];\n    if (!cache || cache.ttl < Date.now()) {\n        const value = fcn();\n        cacheResultCache[name] = {\n            ttl: Date.now() + limitTime,\n            value: value,\n        };\n        return value;\n    }\n    else {\n        return cache.value;\n    }\n}\nexports.cacheResult = cacheResult;\nfunction cleanCacheResult() {\n    _.each(cacheResultCache, (cache, name) => {\n        if (cache.ttl < Date.now())\n            delete cacheResultCache[name];\n    });\n}\n//# sourceMappingURL=lib.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getObjectReferences = exports.hashTimelineObject = exports.initializeCache = void 0;\nfunction initializeCache(cacheOrg, resolvedTimeline) {\n    const cache = cacheOrg;\n    if (!cache.objHashes)\n        cache.objHashes = {};\n    if (!cache.resolvedTimeline)\n        cache.resolvedTimeline = resolvedTimeline;\n    // Todo: make statistics work when using cache\n    return cache;\n}\nexports.initializeCache = initializeCache;\n/** Return a \"hash-string\" which changes whenever anything that affects timing of a timeline-object has changed. */\nfunction hashTimelineObject(obj) {\n    const thingsThatMatter = [\n        JSON.stringify(obj.enable),\n        obj.disabled + '',\n        obj.priority + '',\n        obj.resolved.parentId || '',\n        obj.resolved.isKeyframe + '',\n        obj.classes ? obj.classes.join('.') : '',\n        obj.layer + '',\n        obj.seamless + '',\n    ];\n    return thingsThatMatter.join(',');\n}\nexports.hashTimelineObject = hashTimelineObject;\nfunction getObjectReferences(obj) {\n    return obj.resolved.directReferences;\n}\nexports.getObjectReferences = getObjectReferences;\n//# sourceMappingURL=cache.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addObjectToResolvedTimeline = void 0;\nfunction addObjectToResolvedTimeline(resolvedTimeline, obj) {\n    resolvedTimeline.objects[obj.id] = obj;\n    if (obj.classes) {\n        for (let i = 0; i < obj.classes.length; i++) {\n            const className = obj.classes[i];\n            if (className) {\n                if (!resolvedTimeline.classes[className])\n                    resolvedTimeline.classes[className] = [];\n                resolvedTimeline.classes[className].push(obj.id);\n            }\n        }\n    }\n    if (obj.layer) {\n        if (!resolvedTimeline.layers[obj.layer])\n            resolvedTimeline.layers[obj.layer] = [];\n        resolvedTimeline.layers[obj.layer].push(obj.id);\n    }\n}\nexports.addObjectToResolvedTimeline = addObjectToResolvedTimeline;\n//# sourceMappingURL=common.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateExpression = exports.wrapInnerExpressions = exports.simplifyExpression = exports.interpretExpression = exports.OPERATORS = void 0;\nconst _ = require(\"underscore\");\nconst lib_1 = require(\"../lib\");\nexports.OPERATORS = ['&', '|', '+', '-', '*', '/', '%', '!'];\nconst REGEXP_OPERATORS = _.map(exports.OPERATORS, (o) => '\\\\' + o).join('');\nfunction interpretExpression(expression) {\n    if (lib_1.isNumeric(expression)) {\n        return parseFloat(expression);\n    }\n    else if (_.isString(expression)) {\n        const expressionString = expression;\n        return lib_1.cacheResult(expressionString, () => {\n            const expr = expressionString.replace(new RegExp('([' + REGEXP_OPERATORS + '\\\\(\\\\)])', 'g'), ' $1 '); // Make sure there's a space between every operator & operand\n            const words = _.compact(expr.split(' '));\n            if (words.length === 0)\n                return null; // empty expression\n            // Fix special case: a + - b\n            for (let i = words.length - 2; i >= 1; i--) {\n                if ((words[i] === '-' || words[i] === '+') && wordIsOperator(exports.OPERATORS, words[i - 1])) {\n                    words[i] = words[i] + words[i + 1];\n                    words.splice(i + 1, 1);\n                }\n            }\n            const innerExpression = wrapInnerExpressions(words);\n            if (innerExpression.rest.length)\n                throw new Error('interpretExpression: syntax error: parentheses don\\'t add up in \"' + expr + '\".');\n            if (innerExpression.inner.length % 2 !== 1)\n                throw new Error('interpretExpression: operands & operators don\\'t add up: \"' +\n                    innerExpression.inner.join(' ') +\n                    '\".');\n            const expression = words2Expression(exports.OPERATORS, innerExpression.inner);\n            validateExpression(exports.OPERATORS, expression);\n            return expression;\n        }, 100 * 1000);\n    }\n    else {\n        return expression;\n    }\n}\nexports.interpretExpression = interpretExpression;\n/** Try to simplify an expression, this includes:\n * * Combine constant operands, using arithmetic operators\n * ...more to come?\n */\nfunction simplifyExpression(expr0) {\n    const expr = _.isString(expr0) ? interpretExpression(expr0) : expr0;\n    if (!expr)\n        return expr;\n    if (isExpressionObject(expr)) {\n        const l = simplifyExpression(expr.l);\n        const o = expr.o;\n        const r = simplifyExpression(expr.r);\n        if (lib_1.isConstant(l) && lib_1.isConstant(r) && _.isNumber(l) && _.isNumber(r)) {\n            // The operands can be combined:\n            return o === '+'\n                ? l + r\n                : o === '-'\n                    ? l - r\n                    : o === '*'\n                        ? l * r\n                        : o === '/'\n                            ? l / r\n                            : o === '%'\n                                ? l % r\n                                : { l, o, r };\n        }\n        return { l, o, r };\n    }\n    return expr;\n}\nexports.simplifyExpression = simplifyExpression;\nfunction isExpressionObject(expr) {\n    return typeof expr === 'object' && _.has(expr, 'l') && _.has(expr, 'o') && _.has(expr, 'r');\n}\nfunction wordIsOperator(operatorList, word) {\n    if (operatorList.indexOf(word) !== -1)\n        return true;\n    return false;\n}\n// Turns ['a', '(', 'b', 'c', ')'] into ['a', ['b', 'c']]\n// or ['a', '&', '!', 'b'] into ['a', '&', ['', '!', 'b']]\nfunction wrapInnerExpressions(words) {\n    for (let i = 0; i < words.length; i++) {\n        if (words[i] === '(') {\n            const tmp = wrapInnerExpressions(words.slice(i + 1));\n            // insert inner expression and remove tha\n            words[i] = tmp.inner;\n            words.splice(i + 1, 99999, ...tmp.rest);\n        }\n        else if (words[i] === ')') {\n            return {\n                inner: words.slice(0, i),\n                rest: words.slice(i + 1),\n            };\n        }\n        else if (words[i] === '!') {\n            const tmp = wrapInnerExpressions(words.slice(i + 1));\n            // insert inner expression after the '!'\n            words[i] = ['', '!'].concat(tmp.inner);\n            words.splice(i + 1, 99999, ...tmp.rest);\n        }\n    }\n    return {\n        inner: words,\n        rest: [],\n    };\n}\nexports.wrapInnerExpressions = wrapInnerExpressions;\nfunction words2Expression(operatorList, words) {\n    if (!words || !words.length)\n        throw new Error('words2Expression: syntax error: unbalanced expression');\n    while (words.length === 1 && _.isArray(words[0]))\n        words = words[0];\n    if (words.length === 1)\n        return words[0];\n    // Find the operator with the highest priority:\n    let operatorI = -1;\n    for (let i = 0; i < operatorList.length; i++) {\n        const operator = operatorList[i];\n        if (operatorI === -1) {\n            operatorI = words.lastIndexOf(operator);\n        }\n    }\n    if (operatorI !== -1) {\n        const l = words.slice(0, operatorI);\n        const r = words.slice(operatorI + 1);\n        const expr = {\n            l: words2Expression(operatorList, l),\n            o: words[operatorI],\n            r: words2Expression(operatorList, r),\n        };\n        return expr;\n    }\n    else\n        throw new Error('words2Expression: syntax error: operator not found: \"' + words.join(' ') + '\"');\n}\n/** Validates an expression. Returns true on success, throws error if not */\nfunction validateExpression(operatorList, expr0, breadcrumbs) {\n    if (!breadcrumbs)\n        breadcrumbs = 'ROOT';\n    if (_.isObject(expr0) && !_.isArray(expr0)) {\n        const expr = expr0;\n        if (!_.has(expr, 'l'))\n            throw new Error(`validateExpression: ${breadcrumbs}.l missing in ${JSON.stringify(expr)}`);\n        if (!_.has(expr, 'o'))\n            throw new Error(`validateExpression: ${breadcrumbs}.o missing in ${JSON.stringify(expr)}`);\n        if (!_.has(expr, 'r'))\n            throw new Error(`validateExpression: ${breadcrumbs}.r missing in ${JSON.stringify(expr)}`);\n        if (!_.isString(expr.o))\n            throw new Error(`validateExpression: ${breadcrumbs}.o not a string`);\n        if (!wordIsOperator(operatorList, expr.o))\n            throw new Error(breadcrumbs + '.o not valid: \"' + expr.o + '\"');\n        return (validateExpression(operatorList, expr.l, breadcrumbs + '.l') &&\n            validateExpression(operatorList, expr.r, breadcrumbs + '.r'));\n    }\n    else if (!_.isNull(expr0) && !_.isString(expr0) && !_.isNumber(expr0)) {\n        throw new Error(`validateExpression: ${breadcrumbs} is of invalid type`);\n    }\n    return true;\n}\nexports.validateExpression = validateExpression;\n//# sourceMappingURL=expression.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lookupExpression = exports.resolveTimelineObj = exports.Resolver = void 0;\nconst _ = require(\"underscore\");\nconst lib_1 = require(\"../lib\");\nconst validate_1 = require(\"./validate\");\nconst expression_1 = require(\"./expression\");\nconst state_1 = require(\"./state\");\nconst common_1 = require(\"./common\");\nconst cache_1 = require(\"./cache\");\nclass Resolver {\n    /**\n     * Go through all objects on the timeline and calculate all the timings.\n     * Returns a ResolvedTimeline which can be piped into Resolver.getState()\n     * @param timeline Array of timeline objects\n     * @param options Resolve options\n     */\n    static resolveTimeline(timeline, options) {\n        if (!_.isArray(timeline))\n            throw new Error('resolveTimeline: parameter timeline missing');\n        if (!options)\n            throw new Error('resolveTimeline: parameter options missing');\n        validate_1.validateTimeline(timeline, false);\n        lib_1.resetId();\n        const resolvedTimeline = {\n            options: { ...options },\n            objects: {},\n            classes: {},\n            layers: {},\n            statistics: {\n                unresolvedCount: 0,\n                resolvedCount: 0,\n                resolvedInstanceCount: 0,\n                resolvedObjectCount: 0,\n                resolvedGroupCount: 0,\n                resolvedKeyframeCount: 0,\n                resolvingCount: 0,\n            },\n        };\n        // Step 1: pre-populate resolvedTimeline with objects\n        const addToResolvedTimeline = (obj, levelDeep, parentId, isKeyframe) => {\n            if (resolvedTimeline.objects[obj.id])\n                throw Error(`All timelineObjects must be unique! (duplicate: \"${obj.id}\")`);\n            const o = lib_1.extendMandadory(_.clone(obj), {\n                resolved: {\n                    resolved: false,\n                    resolving: false,\n                    instances: [],\n                    levelDeep: levelDeep,\n                    isSelfReferencing: false,\n                    directReferences: [],\n                },\n            });\n            if (parentId) {\n                o.resolved.parentId = parentId;\n                o.resolved.directReferences.push(parentId);\n            }\n            if (isKeyframe)\n                o.resolved.isKeyframe = true;\n            common_1.addObjectToResolvedTimeline(resolvedTimeline, o);\n            // Add children:\n            if (obj.isGroup && obj.children) {\n                for (let i = 0; i < obj.children.length; i++) {\n                    const child = obj.children[i];\n                    addToResolvedTimeline(child, levelDeep + 1, obj.id);\n                }\n            }\n            // Add keyframes:\n            if (obj.keyframes) {\n                for (let i = 0; i < obj.keyframes.length; i++) {\n                    const keyframe = obj.keyframes[i];\n                    const kf2 = lib_1.extendMandadory(_.clone(keyframe), {\n                        layer: '',\n                    });\n                    addToResolvedTimeline(kf2, levelDeep + 1, obj.id, true);\n                }\n            }\n        };\n        for (let i = 0; i < timeline.length; i++) {\n            const obj = timeline[i];\n            addToResolvedTimeline(obj, 0);\n        }\n        // Step 2: go though and resolve the objects\n        if (options.cache) {\n            // Figure out which objects has changed since last time\n            const cache = cache_1.initializeCache(options.cache, resolvedTimeline);\n            // Go through all new objects, and determine whether they have changed:\n            const allNewObjects = {};\n            const changedReferences = {};\n            const getAllReferencesThisObjectAffects = (newObj) => {\n                const references = ['#' + newObj.id];\n                if (newObj.classes) {\n                    for (const className of newObj.classes) {\n                        references.push('.' + className);\n                    }\n                }\n                if (newObj.layer)\n                    references.push('$' + newObj.layer);\n                return references;\n            };\n            const addChangedObject = (obj) => {\n                const references = getAllReferencesThisObjectAffects(obj);\n                for (const ref of references) {\n                    changedReferences[ref] = true;\n                }\n            };\n            _.each(resolvedTimeline.objects, (obj) => {\n                const oldHash = cache.objHashes[obj.id];\n                const newHash = cache_1.hashTimelineObject(obj);\n                allNewObjects[obj.id] = true;\n                if (!oldHash || oldHash !== newHash) {\n                    cache.objHashes[obj.id] = newHash;\n                    addChangedObject(obj);\n                    const oldObj = cache.resolvedTimeline.objects[obj.id];\n                    if (oldObj)\n                        addChangedObject(oldObj);\n                }\n                else {\n                    // No timing-affecting changes detected\n                    // Even though the timeline-properties hasn't changed,\n                    // the content (and other properties) might have:\n                    const oldObj = cache.resolvedTimeline.objects[obj.id];\n                    cache.resolvedTimeline.objects[obj.id] = {\n                        ...obj,\n                        resolved: oldObj.resolved,\n                    };\n                }\n            });\n            if (cache.hasOldData) {\n                // Go through all old hashes, removing the ones that doesn't exist anymore\n                for (const objId in cache.resolvedTimeline.objects) {\n                    if (!allNewObjects[objId]) {\n                        const obj = cache.resolvedTimeline.objects[objId];\n                        delete cache.objHashes[objId];\n                        addChangedObject(obj);\n                    }\n                }\n                // Invalidate objects, by gradually removing the invalidated ones from validObjects\n                // Prepare validObjects:\n                const validObjects = {};\n                _.each(resolvedTimeline.objects, (obj) => {\n                    validObjects[obj.id] = obj;\n                });\n                /** All references that depend on another reference (ie objects, classs or layers): */\n                const affectReferenceMap = {};\n                _.each(resolvedTimeline.objects, (obj) => {\n                    // Add everything that this object affects:\n                    const cachedObj = cache.resolvedTimeline.objects[obj.id];\n                    let affectedReferences = getAllReferencesThisObjectAffects(obj);\n                    if (cachedObj) {\n                        affectedReferences = _.uniq(affectedReferences.concat(getAllReferencesThisObjectAffects(cachedObj)));\n                    }\n                    for (let i = 0; i < affectedReferences.length; i++) {\n                        const ref = affectedReferences[i];\n                        const objRef = '#' + obj.id;\n                        if (ref !== objRef) {\n                            if (!affectReferenceMap[objRef])\n                                affectReferenceMap[objRef] = [];\n                            affectReferenceMap[objRef].push(ref);\n                        }\n                    }\n                    // Add everything that this object is affected by:\n                    if (changedReferences['#' + obj.id]) {\n                        // The object is directly said to be invalid, no need to add it to referencingObjects,\n                        // since it'll be easily invalidated anyway later\n                    }\n                    else {\n                        // Note: we only have to check for the OLD object, since if the old and the new object differs,\n                        // that would mean it'll be directly invalidated anyway.\n                        if (cachedObj) {\n                            // Fetch all references for the object from the last time it was resolved.\n                            // Note: This can be done, since _if_ the object was changed in any way since last resolve\n                            // it'll be invalidated anyway\n                            const dependOnReferences = cache_1.getObjectReferences(cachedObj);\n                            for (let i = 0; i < dependOnReferences.length; i++) {\n                                const ref = dependOnReferences[i];\n                                if (!affectReferenceMap[ref])\n                                    affectReferenceMap[ref] = [];\n                                affectReferenceMap[ref].push('#' + obj.id);\n                            }\n                        }\n                    }\n                });\n                // Invalidate all changed objects, and recursively invalidate all objects that reference those objects:\n                const handledReferences = {};\n                for (const reference of Object.keys(changedReferences)) {\n                    invalidateObjectsWithReference(handledReferences, reference, affectReferenceMap, validObjects);\n                }\n                // The objects that are left in validObjects at this point are still valid.\n                // We can reuse the old resolving for those:\n                _.each(validObjects, (obj) => {\n                    if (!cache.resolvedTimeline.objects[obj.id])\n                        throw new Error(`Something went wrong: \"${obj.id}\" does not exist in cache.resolvedTimeline.objects`);\n                    resolvedTimeline.objects[obj.id] = cache.resolvedTimeline.objects[obj.id];\n                });\n            }\n            _.each(resolvedTimeline.objects, (obj) => {\n                resolveTimelineObj(resolvedTimeline, obj);\n            });\n            // Save for next time:\n            cache.resolvedTimeline = resolvedTimeline;\n            cache.hasOldData = true;\n            // Update statistics, since that's not accurate after having used the cache:\n            resolvedTimeline.statistics.unresolvedCount = 0;\n            resolvedTimeline.statistics.resolvedCount = 0;\n            resolvedTimeline.statistics.resolvedInstanceCount = 0;\n            resolvedTimeline.statistics.resolvedObjectCount = 0;\n            resolvedTimeline.statistics.resolvedGroupCount = 0;\n            resolvedTimeline.statistics.resolvedKeyframeCount = 0;\n            _.each(resolvedTimeline.objects, (obj) => {\n                updateStatistics(resolvedTimeline, obj);\n            });\n            return resolvedTimeline;\n        }\n        else {\n            // If there are no cache provided, just resolve all objects:\n            _.each(resolvedTimeline.objects, (obj) => {\n                resolveTimelineObj(resolvedTimeline, obj);\n            });\n            return resolvedTimeline;\n        }\n    }\n    /** Calculate the state for all points in time.  */\n    static resolveAllStates(resolvedTimeline, cache) {\n        return state_1.resolveStates(resolvedTimeline, undefined, cache);\n    }\n    /**\n     * Calculate the state at a given point in time.\n     * Using a ResolvedTimeline calculated by Resolver.resolveTimeline() or\n     * a ResolvedStates calculated by Resolver.resolveAllStates()\n     * @param resolved ResolvedTimeline calculated by Resolver.resolveTimeline.\n     * @param time The point in time where to calculate the state\n     * @param eventLimit (Optional) Limits the number of returned upcoming events.\n     */\n    static getState(resolved, time, eventLimit) {\n        return state_1.getState(resolved, time, eventLimit);\n    }\n}\nexports.Resolver = Resolver;\nfunction resolveTimelineObj(resolvedTimeline, obj) {\n    if (obj.resolved.resolved)\n        return;\n    if (obj.resolved.resolving)\n        throw new Error(`Circular dependency when trying to resolve \"${obj.id}\"`);\n    obj.resolved.resolving = true;\n    resolvedTimeline.statistics.resolvingCount++;\n    let instances = [];\n    let directReferences = [];\n    const enables = _.isArray(obj.enable) ? obj.enable : [obj.enable];\n    for (let i = 0; i < enables.length; i++) {\n        const enable = enables[i];\n        let newInstances = [];\n        const repeatingExpr = enable.repeating !== undefined ? expression_1.interpretExpression(enable.repeating) : null;\n        const lookedRepeating = lookupExpression(resolvedTimeline, obj, repeatingExpr, 'duration');\n        const lookedupRepeating = lookedRepeating.instances;\n        directReferences = directReferences.concat(lookedRepeating.allReferences);\n        if (_.isArray(lookedupRepeating)) {\n            throw new Error(`lookupExpression should never return an array for .duration lookup`); // perhaps tmp? maybe revisit this at some point\n        }\n        let start = enable.while !== undefined ? enable.while : enable.start !== undefined ? enable.start : '';\n        if (enable.while + '' === '1') {\n            start = 'true';\n        }\n        else if (enable.while + '' === '0') {\n            start = 'false';\n        }\n        const startExpr = expression_1.simplifyExpression(start);\n        let parentInstances = null;\n        let hasParent = false;\n        let startRefersToParent = false;\n        if (obj.resolved.parentId) {\n            hasParent = true;\n            const lookup = lookupExpression(resolvedTimeline, obj, expression_1.interpretExpression(`#${obj.resolved.parentId}`), 'start');\n            parentInstances = lookup.instances; // a start-reference will always return an array, or null\n            directReferences = directReferences.concat(lookup.allReferences);\n            if (lib_1.isConstant(startExpr)) {\n                // Only use parent if the expression resolves to a number (ie doesn't contain any references)\n                startRefersToParent = true;\n            }\n        }\n        const lookupStart = lookupExpression(resolvedTimeline, obj, startExpr, 'start');\n        let lookedupStarts = lookupStart.instances;\n        directReferences = directReferences.concat(lookupStart.allReferences);\n        if (startRefersToParent) {\n            lookedupStarts = lib_1.applyParentInstances(parentInstances, lookedupStarts);\n        }\n        if (enable.while) {\n            if (_.isArray(lookedupStarts)) {\n                newInstances = lookedupStarts;\n            }\n            else if (lookedupStarts !== null) {\n                newInstances = [\n                    {\n                        id: lib_1.getId(),\n                        start: lookedupStarts.value,\n                        end: null,\n                        references: lookedupStarts.references,\n                    },\n                ];\n            }\n        }\n        else {\n            const events = [];\n            let iStart = 0;\n            let iEnd = 0;\n            if (_.isArray(lookedupStarts)) {\n                for (let i = 0; i < lookedupStarts.length; i++) {\n                    const instance = lookedupStarts[i];\n                    events.push({\n                        time: instance.start,\n                        value: true,\n                        data: { instance: instance, id: obj.id + '_' + iStart++ },\n                        references: instance.references,\n                    });\n                }\n            }\n            else if (lookedupStarts !== null) {\n                events.push({\n                    time: lookedupStarts.value,\n                    value: true,\n                    data: {\n                        instance: {\n                            id: lib_1.getId(),\n                            start: lookedupStarts.value,\n                            end: null,\n                            references: lookedupStarts.references,\n                        },\n                        id: obj.id + '_' + iStart++,\n                    },\n                    references: lookedupStarts.references,\n                });\n            }\n            if (enable.end !== undefined) {\n                const endExpr = expression_1.interpretExpression(enable.end);\n                let endRefersToParent = false;\n                if (obj.resolved.parentId) {\n                    if (lib_1.isConstant(endExpr)) {\n                        // Only use parent if the expression resolves to a number (ie doesn't contain any references)\n                        endRefersToParent = true;\n                    }\n                }\n                // lookedupEnds will contain an inverted list of instances. Therefore .start means an end\n                const lookupEnd = endExpr ? lookupExpression(resolvedTimeline, obj, endExpr, 'end') : null;\n                let lookedupEnds = lookupEnd ? lookupEnd.instances : null;\n                if (lookupEnd)\n                    directReferences = directReferences.concat(lookupEnd.allReferences);\n                if (endRefersToParent) {\n                    lookedupEnds = lib_1.applyParentInstances(parentInstances, lookedupEnds);\n                }\n                if (_.isArray(lookedupEnds)) {\n                    for (let i = 0; i < lookedupEnds.length; i++) {\n                        const instance = lookedupEnds[i];\n                        events.push({\n                            time: instance.start,\n                            value: false,\n                            data: { instance: instance, id: obj.id + '_' + iEnd++ },\n                            references: instance.references,\n                        });\n                    }\n                }\n                else if (lookedupEnds !== null) {\n                    events.push({\n                        time: lookedupEnds.value,\n                        value: false,\n                        data: {\n                            instance: {\n                                id: lib_1.getId(),\n                                start: lookedupEnds.value,\n                                end: null,\n                                references: lookedupEnds.references,\n                            },\n                            id: obj.id + '_' + iEnd++,\n                        },\n                        references: lookedupEnds.references,\n                    });\n                }\n            }\n            else if (enable.duration !== undefined) {\n                const durationExpr = expression_1.interpretExpression(enable.duration);\n                const lookupDuration = lookupExpression(resolvedTimeline, obj, durationExpr, 'duration');\n                let lookedupDuration = lookupDuration.instances;\n                directReferences = directReferences.concat(lookupDuration.allReferences);\n                if (_.isArray(lookedupDuration) && lookedupDuration.length === 1) {\n                    lookedupDuration = {\n                        value: lookedupDuration[0].start,\n                        references: lookedupDuration[0].references,\n                    };\n                }\n                if (_.isArray(lookedupDuration) && !lookedupDuration.length)\n                    lookedupDuration = null;\n                if (_.isArray(lookedupDuration)) {\n                    throw new Error(`lookupExpression should never return an array for .duration lookup`); // perhaps tmp? maybe revisit this at some point\n                }\n                else if (lookedupDuration !== null) {\n                    if (lookedupRepeating !== null && lookedupDuration.value > lookedupRepeating.value)\n                        lookedupDuration.value = lookedupRepeating.value;\n                    const tmpLookedupDuration = lookedupDuration; // cast type\n                    for (let i = 0; i < events.length; i++) {\n                        const e = events[i];\n                        if (e.value) {\n                            const time = e.time + tmpLookedupDuration.value;\n                            const references = lib_1.joinReferences(e.references, tmpLookedupDuration.references);\n                            events.push({\n                                time: time,\n                                value: false,\n                                data: {\n                                    id: e.data.id,\n                                    instance: {\n                                        id: e.data.instance.id,\n                                        start: time,\n                                        end: null,\n                                        references: references,\n                                    },\n                                },\n                                references: references,\n                            });\n                        }\n                    }\n                }\n            }\n            newInstances = lib_1.convertEventsToInstances(events, false);\n        }\n        if (hasParent) {\n            // figure out what parent-instance the instances are tied to, and cap them\n            const cappedInstances = [];\n            for (let i = 0; i < newInstances.length; i++) {\n                const instance = newInstances[i];\n                if (parentInstances) {\n                    const referredParentInstance = _.find(parentInstances, (parentInstance) => {\n                        return instance.references.indexOf(parentInstance.id) !== -1;\n                    });\n                    if (referredParentInstance) {\n                        // If the child refers to its parent, there should be one specific instance to cap into\n                        const cappedInstance = lib_1.capInstances([instance], [referredParentInstance])[0];\n                        if (cappedInstance) {\n                            if (!cappedInstance.caps)\n                                cappedInstance.caps = [];\n                            cappedInstance.caps.push({\n                                id: referredParentInstance.id,\n                                start: referredParentInstance.start,\n                                end: referredParentInstance.end,\n                            });\n                            cappedInstances.push(cappedInstance);\n                        }\n                    }\n                    else {\n                        // If the child doesn't refer to its parent, it should be capped within all of its parent instances\n                        for (let i = 0; i < parentInstances.length; i++) {\n                            const parentInstance = parentInstances[i];\n                            const cappedInstance = lib_1.capInstances([instance], [parentInstance])[0];\n                            if (cappedInstance) {\n                                if (parentInstance) {\n                                    if (!cappedInstance.caps)\n                                        cappedInstance.caps = [];\n                                    cappedInstance.caps.push({\n                                        id: parentInstance.id,\n                                        start: parentInstance.start,\n                                        end: parentInstance.end,\n                                    });\n                                }\n                                cappedInstances.push(cappedInstance);\n                            }\n                        }\n                    }\n                }\n            }\n            newInstances = cappedInstances;\n        }\n        newInstances = lib_1.applyRepeatingInstances(newInstances, lookedupRepeating, resolvedTimeline.options);\n        instances = instances.concat(newInstances);\n    }\n    // Make sure the instance ids are unique:\n    const ids = {};\n    for (const instance of instances) {\n        if (ids[instance.id]) {\n            instance.id = `${instance.id}_${lib_1.getId()}`;\n        }\n        ids[instance.id] = true;\n    }\n    if (obj.seamless && instances.length > 1) {\n        instances = lib_1.cleanInstances(instances, true, false);\n    }\n    obj.resolved.resolved = true;\n    obj.resolved.resolving = false;\n    obj.resolved.instances = instances;\n    obj.resolved.directReferences = directReferences;\n    updateStatistics(resolvedTimeline, obj);\n}\nexports.resolveTimelineObj = resolveTimelineObj;\nfunction updateStatistics(resolvedTimeline, obj) {\n    if (obj.resolved.instances.length) {\n        resolvedTimeline.statistics.resolvedInstanceCount += obj.resolved.instances.length;\n        resolvedTimeline.statistics.resolvedCount += 1;\n        if (obj.isGroup) {\n            resolvedTimeline.statistics.resolvedGroupCount += 1;\n        }\n        if (obj.resolved.isKeyframe) {\n            resolvedTimeline.statistics.resolvedKeyframeCount += 1;\n        }\n        else {\n            resolvedTimeline.statistics.resolvedObjectCount += 1;\n        }\n    }\n    else {\n        resolvedTimeline.statistics.unresolvedCount += 1;\n    }\n}\n/** Invalidate all changed objects, and recursively invalidate all objects that reference those objects */\nfunction invalidateObjectsWithReference(handledReferences, reference, affectReferenceMap, validObjects) {\n    if (handledReferences[reference])\n        return; // to avoid infinite loops\n    handledReferences[reference] = true;\n    if (reference[0] === '#') {\n        // an id\n        const objId = reference.slice(1);\n        if (validObjects[objId]) {\n            delete validObjects[objId];\n        }\n    }\n    // Invalidate all objects that depend on any of the references that this reference affects:\n    const affectedReferences = affectReferenceMap[reference];\n    if (affectedReferences) {\n        for (let i = 0; i < affectedReferences.length; i++) {\n            const referencingReference = affectedReferences[i];\n            invalidateObjectsWithReference(handledReferences, referencingReference, affectReferenceMap, validObjects);\n        }\n    }\n}\n/**\n * Look up a reference on the timeline\n * Return values:\n * Array<TimelineObjectInstance>: Instances on the timeline where the reference expression is true\n * ValueWithReference: A singular value which can be combined arithmetically with Instances\n * null: Means \"something is invalid\", an null-value will always return null when combined with other values\n *\n * @param resolvedTimeline\n * @param obj\n * @param expr\n * @param context\n */\nfunction lookupExpression(resolvedTimeline, obj, expr, context) {\n    if (expr === null)\n        return { instances: null, allReferences: [] };\n    if (_.isString(expr) && lib_1.isNumeric(expr)) {\n        return {\n            instances: {\n                value: parseFloat(expr),\n                references: [],\n            },\n            allReferences: [],\n        };\n    }\n    else if (_.isNumber(expr)) {\n        return {\n            instances: {\n                value: expr,\n                references: [],\n            },\n            allReferences: [],\n        };\n    }\n    else if (_.isString(expr)) {\n        expr = expr.trim();\n        if (lib_1.isConstant(expr)) {\n            if (expr.match(/^true$/i)) {\n                return {\n                    instances: {\n                        value: 0,\n                        references: [],\n                    },\n                    allReferences: [],\n                };\n            }\n            else if (expr.match(/^false$/i)) {\n                return {\n                    instances: [],\n                    allReferences: [],\n                };\n            }\n        }\n        // Look up string\n        let invert = false;\n        let ignoreFirstIfZero = false;\n        let referencedObjs = [];\n        let ref = context;\n        let rest = '';\n        let objIdsToReference = [];\n        const allReferences = [];\n        let referenceIsOk = false;\n        // Match id, example: \"#objectId.start\"\n        const m = expr.match(/^\\W*#([^.]+)(.*)/);\n        if (m) {\n            const id = m[1];\n            rest = m[2];\n            referenceIsOk = true;\n            objIdsToReference = [id];\n            allReferences.push('#' + id);\n        }\n        else {\n            // Match class, example: \".className.start\"\n            const m = expr.match(/^\\W*\\.([^.]+)(.*)/);\n            if (m) {\n                const className = m[1];\n                rest = m[2];\n                referenceIsOk = true;\n                objIdsToReference = resolvedTimeline.classes[className] || [];\n                allReferences.push('.' + className);\n            }\n            else {\n                // Match layer, example: \"$layer\"\n                const m = expr.match(/^\\W*\\$([^.]+)(.*)/);\n                if (m) {\n                    const layer = m[1];\n                    rest = m[2];\n                    referenceIsOk = true;\n                    objIdsToReference = resolvedTimeline.layers[layer] || [];\n                    allReferences.push('$' + layer);\n                }\n            }\n        }\n        for (let i = 0; i < objIdsToReference.length; i++) {\n            const refObjId = objIdsToReference[i];\n            if (refObjId !== obj.id) {\n                const refObj = resolvedTimeline.objects[refObjId];\n                if (refObj) {\n                    referencedObjs.push(refObj);\n                }\n            }\n            else {\n                // Looks like the object is referencing itself!\n                if (obj.resolved.resolving) {\n                    obj.resolved.isSelfReferencing = true;\n                }\n            }\n        }\n        if (!referenceIsOk) {\n            return { instances: null, allReferences: [] };\n        }\n        if (obj.resolved.isSelfReferencing) {\n            // Exclude any self-referencing objects:\n            referencedObjs = _.filter(referencedObjs, (refObj) => {\n                return !refObj.resolved.isSelfReferencing;\n            });\n        }\n        if (referencedObjs.length) {\n            if (rest.match(/start/))\n                ref = 'start';\n            if (rest.match(/end/))\n                ref = 'end';\n            if (rest.match(/duration/))\n                ref = 'duration';\n            if (ref === 'duration') {\n                // Duration refers to the first object on the resolved timeline\n                const instanceDurations = [];\n                for (let i = 0; i < referencedObjs.length; i++) {\n                    const referencedObj = referencedObjs[i];\n                    resolveTimelineObj(resolvedTimeline, referencedObj);\n                    if (referencedObj.resolved.resolved) {\n                        if (obj.resolved.isSelfReferencing && referencedObj.resolved.isSelfReferencing) {\n                            // If the querying object is self-referencing, exclude any other self-referencing objects,\n                            // ignore the object\n                        }\n                        else {\n                            const firstInstance = _.first(referencedObj.resolved.instances);\n                            if (firstInstance) {\n                                const duration = firstInstance.end !== null ? firstInstance.end - firstInstance.start : null;\n                                if (duration !== null) {\n                                    instanceDurations.push({\n                                        value: duration,\n                                        references: lib_1.joinReferences(referencedObj.id, firstInstance.references),\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n                let firstDuration = null;\n                for (let i = 0; i < instanceDurations.length; i++) {\n                    const d = instanceDurations[i];\n                    if (firstDuration === null || d.value < firstDuration.value)\n                        firstDuration = d;\n                }\n                return { instances: firstDuration, allReferences: allReferences };\n            }\n            else {\n                let returnInstances = [];\n                if (ref === 'start') {\n                    // nothing\n                }\n                else if (ref === 'end') {\n                    invert = !invert;\n                    ignoreFirstIfZero = true;\n                }\n                else\n                    throw Error(`Unknown ref: \"${ref}\"`);\n                for (let i = 0; i < referencedObjs.length; i++) {\n                    const referencedObj = referencedObjs[i];\n                    resolveTimelineObj(resolvedTimeline, referencedObj);\n                    if (referencedObj.resolved.resolved) {\n                        if (obj.resolved.isSelfReferencing && referencedObj.resolved.isSelfReferencing) {\n                            // If the querying object is self-referencing, exclude any other self-referencing objects,\n                            // ignore the object\n                        }\n                        else {\n                            returnInstances = returnInstances.concat(referencedObj.resolved.instances);\n                        }\n                    }\n                }\n                if (returnInstances.length) {\n                    if (invert) {\n                        returnInstances = lib_1.invertInstances(returnInstances);\n                    }\n                    else {\n                        returnInstances = lib_1.cleanInstances(returnInstances, true, true);\n                    }\n                    if (ignoreFirstIfZero) {\n                        const first = _.first(returnInstances);\n                        if (first && first.start === 0) {\n                            returnInstances.splice(0, 1);\n                        }\n                    }\n                    return { instances: returnInstances, allReferences: allReferences };\n                }\n                else {\n                    return { instances: [], allReferences: allReferences };\n                }\n            }\n        }\n        else {\n            return { instances: [], allReferences: allReferences };\n        }\n    }\n    else {\n        if (expr) {\n            const l = lookupExpression(resolvedTimeline, obj, expr.l, context);\n            const r = lookupExpression(resolvedTimeline, obj, expr.r, context);\n            const lookupExpr = {\n                l: l.instances,\n                o: expr.o,\n                r: r.instances,\n            };\n            const allReferences = l.allReferences.concat(r.allReferences);\n            if (lookupExpr.o === '!') {\n                // Discard l, invert and return r:\n                if (lookupExpr.r && _.isArray(lookupExpr.r)) {\n                    return {\n                        instances: lib_1.invertInstances(lookupExpr.r),\n                        allReferences: allReferences,\n                    };\n                }\n                else {\n                    // We can't invert a value\n                    return {\n                        instances: lookupExpr.r,\n                        allReferences: allReferences,\n                    };\n                }\n            }\n            else {\n                if (_.isNull(lookupExpr.l) || _.isNull(lookupExpr.r)) {\n                    return { instances: null, allReferences: allReferences };\n                }\n                if (lookupExpr.o === '&' || lookupExpr.o === '|') {\n                    let events = [];\n                    const addEvents = (instances, left) => {\n                        for (let i = 0; i < instances.length; i++) {\n                            const instance = instances[i];\n                            if (instance.start !== instance.end) {\n                                // event doesn't actually exist...\n                                events.push({\n                                    left: left,\n                                    time: instance.start,\n                                    value: true,\n                                    references: [],\n                                    data: true,\n                                    instance: instance,\n                                });\n                                if (instance.end !== null) {\n                                    events.push({\n                                        left: left,\n                                        time: instance.end,\n                                        value: false,\n                                        references: [],\n                                        data: false,\n                                        instance: instance,\n                                    });\n                                }\n                            }\n                        }\n                    };\n                    if (_.isArray(lookupExpr.l))\n                        addEvents(lookupExpr.l, true);\n                    if (_.isArray(lookupExpr.r))\n                        addEvents(lookupExpr.r, false);\n                    events = lib_1.sortEvents(events);\n                    const calcResult = lookupExpr.o === '&'\n                        ? (left, right) => !!(left && right)\n                        : lookupExpr.o === '|'\n                            ? (left, right) => !!(left || right)\n                            : () => {\n                                return false;\n                            };\n                    let leftValue = lib_1.isReference(lookupExpr.l) ? !!lookupExpr.l.value : false;\n                    let rightValue = lib_1.isReference(lookupExpr.r) ? !!lookupExpr.r.value : false;\n                    let leftInstance = null;\n                    let rightInstance = null;\n                    let resultValue = calcResult(leftValue, rightValue);\n                    const instances = [];\n                    const updateInstance = (time, value, references, caps) => {\n                        if (value) {\n                            instances.push({\n                                id: lib_1.getId(),\n                                start: time,\n                                end: null,\n                                references: references,\n                                caps: caps,\n                            });\n                        }\n                        else {\n                            const last = _.last(instances);\n                            if (last) {\n                                last.end = time;\n                                // don't update reference on end\n                            }\n                        }\n                    };\n                    updateInstance(0, resultValue, lib_1.joinReferences(lib_1.isReference(lookupExpr.l) ? lookupExpr.l.references : [], lib_1.isReference(lookupExpr.r) ? lookupExpr.r.references : []), []);\n                    for (let i = 0; i < events.length; i++) {\n                        const e = events[i];\n                        const next = events[i + 1];\n                        if (e.left) {\n                            leftValue = e.value;\n                            leftInstance = e.instance;\n                        }\n                        else {\n                            rightValue = e.value;\n                            rightInstance = e.instance;\n                        }\n                        if (!next || next.time !== e.time) {\n                            const newResultValue = calcResult(leftValue, rightValue);\n                            const resultCaps = (leftInstance ? leftInstance.caps || [] : []).concat(rightInstance ? rightInstance.caps || [] : []);\n                            if (newResultValue !== resultValue) {\n                                updateInstance(e.time, newResultValue, lib_1.joinReferences(leftInstance ? leftInstance.references : [], rightInstance ? rightInstance.references : []), resultCaps);\n                                resultValue = newResultValue;\n                            }\n                        }\n                    }\n                    return { instances: instances, allReferences: allReferences };\n                }\n                else {\n                    const operateInner = lookupExpr.o === '+'\n                        ? (a, b) => {\n                            return {\n                                value: a.value + b.value,\n                                references: lib_1.joinReferences(a.references, b.references),\n                            };\n                        }\n                        : lookupExpr.o === '-'\n                            ? (a, b) => {\n                                return {\n                                    value: a.value - b.value,\n                                    references: lib_1.joinReferences(a.references, b.references),\n                                };\n                            }\n                            : lookupExpr.o === '*'\n                                ? (a, b) => {\n                                    return {\n                                        value: a.value * b.value,\n                                        references: lib_1.joinReferences(a.references, b.references),\n                                    };\n                                }\n                                : lookupExpr.o === '/'\n                                    ? (a, b) => {\n                                        return {\n                                            value: a.value / b.value,\n                                            references: lib_1.joinReferences(a.references, b.references),\n                                        };\n                                    }\n                                    : lookupExpr.o === '%'\n                                        ? (a, b) => {\n                                            return {\n                                                value: a.value % b.value,\n                                                references: lib_1.joinReferences(a.references, b.references),\n                                            };\n                                        }\n                                        : () => null;\n                    const operate = (a, b) => {\n                        if (a === null || b === null)\n                            return null;\n                        return operateInner(a, b);\n                    };\n                    const result = lib_1.operateOnArrays(lookupExpr.l, lookupExpr.r, operate);\n                    return { instances: result, allReferences: allReferences };\n                }\n            }\n        }\n    }\n    return { instances: null, allReferences: [] };\n}\nexports.lookupExpression = lookupExpression;\n//# sourceMappingURL=resolver.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyKeyframeContent = exports.resolveStates = exports.getState = void 0;\nconst _ = require(\"underscore\");\nconst common_1 = require(\"./common\");\nconst enums_1 = require(\"../api/enums\");\nconst lib_1 = require(\"../lib\");\nfunction getState(resolved, time, eventLimit = 0) {\n    const resolvedStates = isResolvedStates(resolved) ? resolved : resolveStates(resolved, time);\n    const state = {\n        time: time,\n        layers: {},\n        nextEvents: _.filter(resolvedStates.nextEvents, (e) => e.time > time),\n    };\n    if (eventLimit)\n        state.nextEvents = state.nextEvents.slice(0, eventLimit);\n    const layerKeys = Object.keys(resolvedStates.layers);\n    for (let i = 0; i < layerKeys.length; i++) {\n        const layer = layerKeys[i];\n        const o = getStateAtTime(resolvedStates.state, layer, time);\n        if (o)\n            state.layers[layer] = o;\n    }\n    return state;\n}\nexports.getState = getState;\nfunction resolveStates(resolved, onlyForTime, cache) {\n    const resolvedStates = {\n        options: resolved.options,\n        statistics: resolved.statistics,\n        // These will be re-created during the state-resolving:\n        objects: {},\n        classes: {},\n        layers: {},\n        state: {},\n        nextEvents: [],\n    };\n    if (cache && !onlyForTime && resolved.statistics.resolvingCount === 0 && cache.resolvedStates) {\n        // Nothing has changed since last time, just return the states right away:\n        return cache.resolvedStates;\n    }\n    const resolvedObjects = _.values(resolved.objects);\n    // Sort to make sure parent groups are evaluated before their children:\n    resolvedObjects.sort((a, b) => {\n        if ((a.resolved.levelDeep || 0) > (b.resolved.levelDeep || 0))\n            return 1;\n        if ((a.resolved.levelDeep || 0) < (b.resolved.levelDeep || 0))\n            return -1;\n        if (a.id > b.id)\n            return 1;\n        if (a.id < b.id)\n            return -1;\n        return 0;\n    });\n    // Step 1: Collect all points-of-interest (which points in time we want to evaluate)\n    // and which instances that are interesting\n    const pointsInTime = {};\n    const addPointInTime = (time, enable, obj, instance) => {\n        if (!pointsInTime[time + ''])\n            pointsInTime[time + ''] = [];\n        pointsInTime[time + ''].push({ obj, instance, enable: enable });\n    };\n    for (const obj of resolvedObjects) {\n        if (!obj.disabled && obj.resolved.resolved) {\n            if (!obj.resolved.isKeyframe) {\n                const parentTimes = getTimesFromParents(resolved, obj);\n                if (obj.layer) {\n                    // if layer is empty, don't put in state\n                    for (const instance of obj.resolved.instances) {\n                        let useInstance = true;\n                        if (onlyForTime) {\n                            useInstance =\n                                (instance.start || 0) <= onlyForTime && (instance.end || Infinity) > onlyForTime;\n                        }\n                        if (useInstance) {\n                            const timeEvents = [];\n                            timeEvents.push({ time: instance.start, enable: true });\n                            if (instance.end)\n                                timeEvents.push({ time: instance.end, enable: false });\n                            // Also include times from parents, as they could affect the state of this instance:\n                            for (let i = 0; i < parentTimes.length; i++) {\n                                const parentTime = parentTimes[i];\n                                if (parentTime &&\n                                    parentTime.time > (instance.start || 0) &&\n                                    parentTime.time < (instance.end || Infinity)) {\n                                    timeEvents.push(parentTime);\n                                }\n                            }\n                            // Save a reference to this instance on all points in time that could affect it:\n                            for (let i = 0; i < timeEvents.length; i++) {\n                                const timeEvent = timeEvents[i];\n                                addPointInTime(timeEvent.time, timeEvent.enable, obj, instance);\n                            }\n                        }\n                    }\n                }\n            }\n            else if (obj.resolved.isKeyframe && obj.resolved.parentId) {\n                const keyframe = obj;\n                // Also add keyframes to pointsInTime:\n                for (const instance of keyframe.resolved.instances) {\n                    // Keyframe start time\n                    addPointInTime(instance.start, true, keyframe, instance);\n                    // Keyframe end time\n                    if (instance.end !== null) {\n                        addPointInTime(instance.end, false, keyframe, instance);\n                    }\n                }\n            }\n        }\n    }\n    // Step 2: Resolve the state for the points-of-interest\n    // This is done by sweeping the points-of-interest chronologically,\n    // determining the state for every point in time by adding & removing objects from aspiringInstances\n    // Then sorting it to determine who takes precedence\n    const eventObjectTimes = {};\n    const currentState = {};\n    const activeObjIds = {};\n    const activeKeyframes = {};\n    const activeKeyframesChecked = {};\n    /** The objects in aspiringInstances  */\n    const aspiringInstances = {};\n    const keyframeEvents = [];\n    const times = Object.keys(pointsInTime)\n        .map((time) => parseFloat(time))\n        // Sort chronologically:\n        .sort((a, b) => a - b);\n    // Iterate through all points-of-interest times:\n    for (let i = 0; i < times.length; i++) {\n        const time = times[i];\n        const instancesToCheck = pointsInTime[time];\n        const checkedObjectsThisTime = {};\n        instancesToCheck.sort((a, b) => {\n            if (a.obj.resolved && b.obj.resolved) {\n                // Keyframes comes first:\n                if (a.obj.resolved.isKeyframe && !b.obj.resolved.isKeyframe)\n                    return -1;\n                if (!a.obj.resolved.isKeyframe && b.obj.resolved.isKeyframe)\n                    return 1;\n                // Ending events come before starting events:\n                if (a.enable && !b.enable)\n                    return 1;\n                if (!a.enable && b.enable)\n                    return -1;\n                // Deeper objects (children in groups) comes later, we want to check the parent groups first:\n                if ((a.obj.resolved.levelDeep || 0) > (b.obj.resolved.levelDeep || 0))\n                    return 1;\n                if ((a.obj.resolved.levelDeep || 0) < (b.obj.resolved.levelDeep || 0))\n                    return -1;\n            }\n            return 0;\n        });\n        for (let j = 0; j < instancesToCheck.length; j++) {\n            const o = instancesToCheck[j];\n            const obj = o.obj;\n            const instance = o.instance;\n            let toBeEnabled = (instance.start || 0) <= time && (instance.end || Infinity) > time;\n            const layer = obj.layer + '';\n            const identifier = obj.id + '_' + instance.id + '_' + o.enable;\n            if (!checkedObjectsThisTime[identifier]) {\n                // Only check each object and event-type once for every point in time\n                checkedObjectsThisTime[identifier] = true;\n                if (!obj.resolved.isKeyframe) {\n                    // If object has a parent, only set if parent is on a layer (if layer is set for parent)\n                    if (toBeEnabled && obj.resolved.parentId) {\n                        const parentObj = obj.resolved.parentId ? resolved.objects[obj.resolved.parentId] : null;\n                        toBeEnabled = !!(parentObj && (!parentObj.layer || activeObjIds[parentObj.id]));\n                    }\n                    if (!aspiringInstances[obj.layer])\n                        aspiringInstances[obj.layer] = [];\n                    if (toBeEnabled) {\n                        // The instance wants to be enabled (is starting)\n                        // Add to aspiringInstances:\n                        aspiringInstances[obj.layer].push({ obj, instance });\n                    }\n                    else {\n                        // The instance doesn't want to be enabled (is ending)\n                        // Remove from aspiringInstances:\n                        aspiringInstances[layer] = _.reject(aspiringInstances[layer] || [], (o) => o.obj.id === obj.id);\n                    }\n                    // Evaluate the layer to determine who has the throne:\n                    aspiringInstances[layer].sort((a, b) => {\n                        // Determine who takes precedence:\n                        // First, sort using priority\n                        if ((a.obj.priority || 0) < (b.obj.priority || 0))\n                            return 1;\n                        if ((a.obj.priority || 0) > (b.obj.priority || 0))\n                            return -1;\n                        // Then, sort using the start time\n                        if ((a.instance.start || 0) < (b.instance.start || 0))\n                            return 1;\n                        if ((a.instance.start || 0) > (b.instance.start || 0))\n                            return -1;\n                        // Last resort: sort using id:\n                        if (a.obj.id > b.obj.id)\n                            return 1;\n                        if (a.obj.id < b.obj.id)\n                            return -1;\n                        return 0;\n                    });\n                    // Now, the one on top has the throne\n                    // Update current state:\n                    const currentOnTopOfLayer = aspiringInstances[layer][0];\n                    const prevObj = currentState[layer];\n                    const replaceOldObj = currentOnTopOfLayer &&\n                        (!prevObj ||\n                            prevObj.id !== currentOnTopOfLayer.obj.id ||\n                            prevObj.instance.id !== currentOnTopOfLayer.instance.id);\n                    const removeOldObj = !currentOnTopOfLayer && prevObj;\n                    if (replaceOldObj || removeOldObj) {\n                        if (prevObj) {\n                            // Cap the old instance, so it'll end at this point in time:\n                            lib_1.setInstanceEndTime(prevObj.instance, time);\n                            // Update activeObjIds:\n                            delete activeObjIds[prevObj.id];\n                            // Add to nextEvents:\n                            if (!onlyForTime || time > onlyForTime) {\n                                resolvedStates.nextEvents.push({\n                                    type: enums_1.EventType.END,\n                                    time: time,\n                                    objId: prevObj.id,\n                                });\n                                eventObjectTimes[instance.end + ''] = enums_1.EventType.END;\n                            }\n                        }\n                    }\n                    if (replaceOldObj) {\n                        // Set the new object to State\n                        // Construct a new object clone:\n                        let newObj;\n                        if (resolvedStates.objects[currentOnTopOfLayer.obj.id]) {\n                            // Use the already existing one\n                            newObj = resolvedStates.objects[currentOnTopOfLayer.obj.id];\n                        }\n                        else {\n                            newObj = _.clone(currentOnTopOfLayer.obj);\n                            newObj.content = JSON.parse(JSON.stringify(newObj.content));\n                            newObj.resolved = {\n                                ...(newObj.resolved || {}),\n                                instances: [],\n                            };\n                            common_1.addObjectToResolvedTimeline(resolvedStates, newObj);\n                        }\n                        const newInstance = {\n                            ...currentOnTopOfLayer.instance,\n                            // We're setting new start & end times so they match up with the state:\n                            start: time,\n                            end: null,\n                            fromInstanceId: currentOnTopOfLayer.instance.id,\n                            originalEnd: currentOnTopOfLayer.instance.originalEnd !== undefined\n                                ? currentOnTopOfLayer.instance.originalEnd\n                                : currentOnTopOfLayer.instance.end,\n                            originalStart: currentOnTopOfLayer.instance.originalStart !== undefined\n                                ? currentOnTopOfLayer.instance.originalStart\n                                : currentOnTopOfLayer.instance.start,\n                        };\n                        // Make the instance id unique:\n                        for (let i = 0; i < newObj.resolved.instances.length; i++) {\n                            if (newObj.resolved.instances[i].id === newInstance.id) {\n                                newInstance.id = newInstance.id + '_$' + newObj.resolved.instances.length;\n                            }\n                        }\n                        newObj.resolved.instances.push(newInstance);\n                        const newObjInstance = {\n                            ...newObj,\n                            instance: newInstance,\n                        };\n                        // Save to current state:\n                        currentState[layer] = newObjInstance;\n                        // Update activeObjIds:\n                        activeObjIds[newObjInstance.id] = newObjInstance;\n                        // Update the tracking state as well:\n                        setStateAtTime(resolvedStates.state, layer, time, newObjInstance);\n                        // Add to nextEvents:\n                        if (newInstance.start > (onlyForTime || 0)) {\n                            resolvedStates.nextEvents.push({\n                                type: enums_1.EventType.START,\n                                time: newInstance.start,\n                                objId: obj.id,\n                            });\n                            eventObjectTimes[newInstance.start + ''] = enums_1.EventType.START;\n                        }\n                    }\n                    else if (removeOldObj) {\n                        // Remove from current state:\n                        delete currentState[layer];\n                        // Update the tracking state as well:\n                        setStateAtTime(resolvedStates.state, layer, time, null);\n                    }\n                }\n                else {\n                    // Is a keyframe\n                    const keyframe = obj;\n                    // Add keyframe to resolvedStates.objects:\n                    resolvedStates.objects[keyframe.id] = keyframe;\n                    const toBeEnabled = (instance.start || 0) <= time && (instance.end || Infinity) > time;\n                    if (toBeEnabled) {\n                        const newObjInstance = {\n                            ...keyframe,\n                            instance: instance,\n                        };\n                        activeKeyframes[keyframe.id] = newObjInstance;\n                    }\n                    else {\n                        delete activeKeyframes[keyframe.id];\n                        delete activeKeyframesChecked[keyframe.id];\n                    }\n                }\n            }\n        }\n        // Go through keyframes:\n        const activeKeyframesObjIds = Object.keys(activeKeyframes);\n        for (let i = 0; i < activeKeyframesObjIds.length; i++) {\n            const objId = activeKeyframesObjIds[i];\n            const objInstance = activeKeyframes[objId];\n            const keyframe = objInstance;\n            const instance = objInstance.instance;\n            // Check if the keyframe's parent is currently active?\n            if (keyframe.resolved.parentId) {\n                const parentObj = activeObjIds[keyframe.resolved.parentId];\n                if (parentObj && parentObj.layer) {\n                    // keyframe is on an active object\n                    const parentObjInstance = currentState[parentObj.layer];\n                    if (parentObjInstance) {\n                        if (!activeKeyframesChecked[objId]) {\n                            // hasn't started before\n                            activeKeyframesChecked[objId] = true;\n                            // Note: The keyframes are a little bit special, since their contents are applied to their parents.\n                            // That application is done in the getStateAtTime function.\n                            // Add keyframe to nextEvents:\n                            keyframeEvents.push({\n                                type: enums_1.EventType.KEYFRAME,\n                                time: instance.start,\n                                objId: keyframe.id,\n                            });\n                            // Cap end within parent\n                            let instanceEnd = Math.min(instance.end || Infinity, parentObjInstance.instance.end || Infinity);\n                            if (instanceEnd === Infinity)\n                                instanceEnd = null;\n                            if (instanceEnd !== null) {\n                                keyframeEvents.push({\n                                    type: enums_1.EventType.KEYFRAME,\n                                    time: instanceEnd,\n                                    objId: keyframe.id,\n                                });\n                            }\n                        }\n                        continue;\n                    }\n                }\n            }\n            // else: the keyframe:s parent isn't active, remove/stop the keyframe then:\n            delete activeKeyframesChecked[objId];\n        }\n    }\n    // At this point, the instances of all objects (excluding keyframes) are properly calculated,\n    // taking into account priorities, clashes etc.\n    for (const id of Object.keys(resolvedStates.objects)) {\n        const keyframe = resolvedStates.objects[id];\n        if (keyframe.resolved.isKeyframe && keyframe.resolved.parentId) {\n            const parent = resolvedStates.objects[keyframe.resolved.parentId];\n            if (parent) {\n                // Cap the keyframe instances within its parents instances:\n                keyframe.resolved.instances = lib_1.capInstances(keyframe.resolved.instances, parent.resolved.instances);\n                // Ensure sure the instances are in the state\n                for (let i = 0; i < keyframe.resolved.instances.length; i++) {\n                    const instance = keyframe.resolved.instances[i];\n                    const keyframeInstance = {\n                        ...keyframe,\n                        instance: instance,\n                        isKeyframe: true,\n                        keyframeEndTime: instance.end,\n                    };\n                    // Add keyframe to the tracking state:\n                    addKeyframeAtTime(resolvedStates.state, parent.layer + '', instance.start, keyframeInstance);\n                }\n            }\n        }\n        const obj = resolvedStates.objects[id];\n        if (obj.seamless && obj.resolved.instances.length > 1) {\n            obj.resolved.instances = lib_1.cleanInstances(obj.resolved.instances, true, false);\n        }\n    }\n    // At this point, ALL instances are properly calculated.\n    // Go through the keyframe events and add them to nextEvents:\n    for (let i = 0; i < keyframeEvents.length; i++) {\n        const keyframeEvent = keyframeEvents[i];\n        // tslint:disable-next-line\n        if (eventObjectTimes[keyframeEvent.time + ''] === undefined) {\n            // no need to put a keyframe event if there's already another event there\n            resolvedStates.nextEvents.push(keyframeEvent);\n            eventObjectTimes[keyframeEvent.time + ''] = enums_1.EventType.KEYFRAME;\n        }\n    }\n    if (onlyForTime) {\n        resolvedStates.nextEvents = _.filter(resolvedStates.nextEvents, (e) => e.time > onlyForTime);\n    }\n    resolvedStates.nextEvents.sort((a, b) => {\n        if (a.time > b.time)\n            return 1;\n        if (a.time < b.time)\n            return -1;\n        if (a.type > b.type)\n            return -1;\n        if (a.type < b.type)\n            return 1;\n        if (a.objId < b.objId)\n            return -1;\n        if (a.objId > b.objId)\n            return 1;\n        return 0;\n    });\n    if (cache && !onlyForTime) {\n        cache.resolvedStates = resolvedStates;\n    }\n    return resolvedStates;\n}\nexports.resolveStates = resolveStates;\nfunction applyKeyframeContent(parentContent, keyframeContent) {\n    _.each(keyframeContent, (value, attr) => {\n        if (_.isArray(value)) {\n            if (!_.isArray(parentContent[attr]))\n                parentContent[attr] = [];\n            applyKeyframeContent(parentContent[attr], value);\n            parentContent[attr].splice(value.length, 99999);\n        }\n        else if (_.isObject(value)) {\n            if (!_.isObject(parentContent[attr]) || _.isArray(parentContent[attr]))\n                parentContent[attr] = {};\n            applyKeyframeContent(parentContent[attr], value);\n        }\n        else {\n            parentContent[attr] = value;\n        }\n    });\n}\nexports.applyKeyframeContent = applyKeyframeContent;\nfunction getTimesFromParents(resolved, obj) {\n    let times = [];\n    const parentObj = obj.resolved.parentId ? resolved.objects[obj.resolved.parentId] : null;\n    if (parentObj && parentObj.resolved.resolved) {\n        for (const instance of parentObj.resolved.instances) {\n            times.push({ time: instance.start, enable: true });\n            if (instance.end)\n                times.push({ time: instance.end, enable: false });\n        }\n        times = times.concat(getTimesFromParents(resolved, parentObj));\n    }\n    return times;\n}\nfunction setStateAtTime(states, layer, time, objInstance) {\n    if (!states[layer])\n        states[layer] = {};\n    states[layer][time + ''] = objInstance ? [objInstance] : objInstance;\n}\nfunction addKeyframeAtTime(states, layer, time, objInstanceKf) {\n    if (!states[layer])\n        states[layer] = {};\n    const inner = states[layer][time + ''];\n    if (!inner) {\n        states[layer][time + ''] = [objInstanceKf];\n    }\n    else {\n        inner.push(objInstanceKf);\n    }\n}\nfunction getStateAtTime(states, layer, requestTime) {\n    const layerStates = states[layer] || {};\n    const times = _.map(_.keys(layerStates), (time) => parseFloat(time));\n    times.sort((a, b) => {\n        return a - b;\n    });\n    let state = null;\n    let isCloned = false;\n    for (let i = 0; i < times.length; i++) {\n        const time = times[i];\n        if (time <= requestTime) {\n            const currentStateInstances = layerStates[time + ''];\n            if (currentStateInstances && currentStateInstances.length) {\n                const keyframes = [];\n                for (let i = 0; i < currentStateInstances.length; i++) {\n                    const currentState = currentStateInstances[i];\n                    if (currentState && currentState.isKeyframe) {\n                        keyframes.push(currentState);\n                    }\n                    else {\n                        state = currentState;\n                        isCloned = false;\n                    }\n                }\n                for (let i = 0; i < keyframes.length; i++) {\n                    const keyframe = keyframes[i];\n                    if (state && keyframe.resolved.parentId === state.id) {\n                        if ((keyframe.keyframeEndTime || Infinity) > requestTime) {\n                            if (!isCloned) {\n                                isCloned = true;\n                                state = {\n                                    ...state,\n                                    content: JSON.parse(JSON.stringify(state.content)),\n                                };\n                            }\n                            // Apply the keyframe on the state:\n                            applyKeyframeContent(state.content, keyframe.content);\n                        }\n                    }\n                }\n            }\n            else {\n                state = null;\n                isCloned = false;\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return state;\n}\nfunction isResolvedStates(resolved) {\n    return !!(resolved && typeof resolved === 'object' && resolved.objects && resolved.state && resolved.nextEvents);\n}\n//# sourceMappingURL=state.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateKeyframe = exports.validateObject = exports.validateTimeline = void 0;\nconst _ = require(\"underscore\");\nfunction validateObject0(obj, strict, uniqueIds) {\n    if (!uniqueIds)\n        uniqueIds = {};\n    if (!obj)\n        throw new Error(`Object is undefined`);\n    if (typeof obj !== 'object')\n        throw new Error(`Object is not an object`);\n    if (!obj.id)\n        throw new Error(`Object missing \"id\" attribute`);\n    if (typeof obj.id !== 'string')\n        throw new Error(`Object \"id\" attribute is not a string: \"${obj.id}\"`);\n    if (uniqueIds[obj.id])\n        throw new Error(`Object id \"${obj.id}\" is not unique`);\n    uniqueIds[obj.id] = true;\n    if (obj.layer === undefined)\n        throw new Error(`Object \"${obj.id}\": \"layer\" attribute is undefined`);\n    if (!obj.content)\n        throw new Error(`Object \"${obj.id}\": \"content\" attribute must be set`);\n    if (!obj.enable)\n        throw new Error(`Object \"${obj.id}\": \"enable\" attribute must be set`);\n    const enables = _.isArray(obj.enable) ? obj.enable : [obj.enable];\n    for (let i = 0; i < enables.length; i++) {\n        const enable = enables[i];\n        if (enable.start !== undefined) {\n            if (strict && enable.while !== undefined)\n                throw new Error(`Object \"${obj.id}\": \"enable.start\" and \"enable.while\" cannot be combined`);\n            if (strict && enable.end !== undefined && enable.duration !== undefined)\n                throw new Error(`Object \"${obj.id}\": \"enable.end\" and \"enable.duration\" cannot be combined`);\n        }\n        else if (enable.while !== undefined) {\n            if (strict && enable.end !== undefined)\n                throw new Error(`Object \"${obj.id}\": \"enable.while\" and \"enable.end\" cannot be combined`);\n            if (strict && enable.duration !== undefined)\n                throw new Error(`Object \"${obj.id}\": \"enable.while\" and \"enable.duration\" cannot be combined`);\n        }\n        else\n            throw new Error(`Object \"${obj.id}\": \"enable.start\" or \"enable.while\" must be set`);\n    }\n    if (obj.keyframes) {\n        for (let i = 0; i < obj.keyframes.length; i++) {\n            const keyframe = obj.keyframes[i];\n            try {\n                validateKeyframe0(keyframe, strict, uniqueIds);\n            }\n            catch (e) {\n                throw new Error(`Object \"${obj.id}\" keyframe[${i}]: ${e}`);\n            }\n        }\n    }\n    if (obj.classes) {\n        for (let i = 0; i < obj.classes.length; i++) {\n            const className = obj.classes[i];\n            if (className && typeof className !== 'string')\n                throw new Error(`Object \"${obj.id}\": \"classes[${i}]\" is not a string`);\n        }\n    }\n    if (obj.children && !obj.isGroup)\n        throw new Error(`Object \"${obj.id}\": attribute \"children\" is set but \"isGroup\" is not`);\n    if (obj.isGroup && !obj.children)\n        throw new Error(`Object \"${obj.id}\": attribute \"isGroup\" is set but \"children\" missing`);\n    if (obj.children) {\n        for (let i = 0; i < obj.children.length; i++) {\n            const child = obj.children[i];\n            try {\n                validateObject0(child, strict, uniqueIds);\n            }\n            catch (e) {\n                throw new Error(`Object \"${obj.id}\" child[${i}]: ${e}`);\n            }\n        }\n    }\n    if (obj.priority !== undefined && !_.isNumber(obj.priority))\n        throw new Error(`Object \"${obj.id}\": attribute \"priority\" is not a number`);\n}\nfunction validateKeyframe0(keyframe, strict, uniqueIds) {\n    if (!uniqueIds)\n        uniqueIds = {};\n    if (!keyframe)\n        throw new Error(`Keyframe is undefined`);\n    if (typeof keyframe !== 'object')\n        throw new Error(`Keyframe is not an object`);\n    if (!keyframe.id)\n        throw new Error(`Keyframe missing id attribute`);\n    if (typeof keyframe.id !== 'string')\n        throw new Error(`Keyframe id attribute is not a string: \"${keyframe.id}\"`);\n    if (uniqueIds[keyframe.id])\n        throw new Error(`Keyframe id \"${keyframe.id}\" is not unique`);\n    uniqueIds[keyframe.id] = true;\n    if (!keyframe.content)\n        throw new Error(`Keyframe \"${keyframe.id}\": \"content\" attribute must be set`);\n    if (!keyframe.enable)\n        throw new Error(`Keyframe \"${keyframe.id}\": \"enable\" attribute must be set`);\n    const enables = _.isArray(keyframe.enable) ? keyframe.enable : [keyframe.enable];\n    for (let i = 0; i < enables.length; i++) {\n        const enable = enables[i];\n        if (enable.start !== undefined) {\n            if (strict && enable.while !== undefined)\n                throw new Error(`Keyframe \"${keyframe.id}\": \"enable.start\" and \"enable.while\" cannot be combined`);\n            if (strict && enable.end !== undefined && enable.duration !== undefined)\n                throw new Error(`Keyframe \"${keyframe.id}\": \"enable.end\" and \"enable.duration\" cannot be combined`);\n        }\n        else if (enable.while !== undefined) {\n            if (strict && enable.end !== undefined)\n                throw new Error(`Keyframe \"${keyframe.id}\": \"enable.while\" and \"enable.end\" cannot be combined`);\n            if (strict && enable.duration !== undefined)\n                throw new Error(`Keyframe \"${keyframe.id}\": \"enable.while\" and \"enable.duration\" cannot be combined`);\n        }\n        else\n            throw new Error(`Keyframe \"${keyframe.id}\": \"enable.start\" or \"enable.while\" must be set`);\n    }\n    if (keyframe.classes) {\n        for (let i = 0; i < keyframe.classes.length; i++) {\n            const className = keyframe.classes[i];\n            if (className && !_.isString(className))\n                throw new Error(`Keyframe \"${keyframe.id}\": \"classes[${i}]\" is not a string`);\n        }\n    }\n}\n/**\n * Validates all objects in the timeline. Throws an error if something's wrong\n * @param timeline The timeline to validate\n * @param strict Set to true to enable some strict rules (rules that can possibly be ignored)\n */\nfunction validateTimeline(timeline, strict) {\n    const uniqueIds = {};\n    for (let i = 0; i < timeline.length; i++) {\n        const obj = timeline[i];\n        validateObject0(obj, strict, uniqueIds);\n    }\n}\nexports.validateTimeline = validateTimeline;\n/**\n * Validates a Timeline-object. Throws an error if something's wrong\n * @param timeline The timeline to validate\n * @param strict Set to true to enable some strict rules (rules that can possibly be ignored)\n */\nfunction validateObject(obj, strict) {\n    validateObject0(obj, strict);\n}\nexports.validateObject = validateObject;\n/**\n * Validates a Timeline-keyframe. Throws an error if something's wrong\n * @param timeline The timeline to validate\n * @param strict Set to true to enable some strict rules (rules that can possibly be ignored)\n */\nfunction validateKeyframe(keyframe, strict) {\n    validateKeyframe0(keyframe, strict);\n}\nexports.validateKeyframe = validateKeyframe;\n//# sourceMappingURL=validate.js.map","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global global, define, System, Reflect, Promise */\r\nvar __extends;\r\nvar __assign;\r\nvar __rest;\r\nvar __decorate;\r\nvar __param;\r\nvar __metadata;\r\nvar __awaiter;\r\nvar __generator;\r\nvar __exportStar;\r\nvar __values;\r\nvar __read;\r\nvar __spread;\r\nvar __spreadArrays;\r\nvar __spreadArray;\r\nvar __await;\r\nvar __asyncGenerator;\r\nvar __asyncDelegator;\r\nvar __asyncValues;\r\nvar __makeTemplateObject;\r\nvar __importStar;\r\nvar __importDefault;\r\nvar __classPrivateFieldGet;\r\nvar __classPrivateFieldSet;\r\nvar __createBinding;\r\n(function (factory) {\r\n    var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"tslib\", [\"exports\"], function (exports) { factory(createExporter(root, createExporter(exports))); });\r\n    }\r\n    else if (typeof module === \"object\" && typeof module.exports === \"object\") {\r\n        factory(createExporter(root, createExporter(module.exports)));\r\n    }\r\n    else {\r\n        factory(createExporter(root));\r\n    }\r\n    function createExporter(exports, previous) {\r\n        if (exports !== root) {\r\n            if (typeof Object.create === \"function\") {\r\n                Object.defineProperty(exports, \"__esModule\", { value: true });\r\n            }\r\n            else {\r\n                exports.__esModule = true;\r\n            }\r\n        }\r\n        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };\r\n    }\r\n})\r\n(function (exporter) {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\r\n    __extends = function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n\r\n    __assign = Object.assign || function (t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n\r\n    __rest = function (s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                    t[p[i]] = s[p[i]];\r\n            }\r\n        return t;\r\n    };\r\n\r\n    __decorate = function (decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    };\r\n\r\n    __param = function (paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    };\r\n\r\n    __metadata = function (metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    };\r\n\r\n    __awaiter = function (thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    };\r\n\r\n    __generator = function (thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    };\r\n\r\n    __exportStar = function(m, o) {\r\n        for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n    };\r\n\r\n    __createBinding = Object.create ? (function(o, m, k, k2) {\r\n        if (k2 === undefined) k2 = k;\r\n        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n    }) : (function(o, m, k, k2) {\r\n        if (k2 === undefined) k2 = k;\r\n        o[k2] = m[k];\r\n    });\r\n\r\n    __values = function (o) {\r\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n        if (m) return m.call(o);\r\n        if (o && typeof o.length === \"number\") return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n    };\r\n\r\n    __read = function (o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    };\r\n\r\n    /** @deprecated */\r\n    __spread = function () {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    };\r\n\r\n    /** @deprecated */\r\n    __spreadArrays = function () {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    };\r\n\r\n    __spreadArray = function (to, from, pack) {\r\n        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n            if (ar || !(i in from)) {\r\n                if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n                ar[i] = from[i];\r\n            }\r\n        }\r\n        return to.concat(ar || from);\r\n    };\r\n\r\n    __await = function (v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    };\r\n\r\n    __asyncGenerator = function (thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    };\r\n\r\n    __asyncDelegator = function (o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n    };\r\n\r\n    __asyncValues = function (o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n    };\r\n\r\n    __makeTemplateObject = function (cooked, raw) {\r\n        if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n        return cooked;\r\n    };\r\n\r\n    var __setModuleDefault = Object.create ? (function(o, v) {\r\n        Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n    }) : function(o, v) {\r\n        o[\"default\"] = v;\r\n    };\r\n\r\n    __importStar = function (mod) {\r\n        if (mod && mod.__esModule) return mod;\r\n        var result = {};\r\n        if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n        __setModuleDefault(result, mod);\r\n        return result;\r\n    };\r\n\r\n    __importDefault = function (mod) {\r\n        return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n    };\r\n\r\n    __classPrivateFieldGet = function (receiver, state, kind, f) {\r\n        if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n        if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n        return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n    };\r\n\r\n    __classPrivateFieldSet = function (receiver, state, value, kind, f) {\r\n        if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n        if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n        if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n        return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n    };\r\n\r\n    exporter(\"__extends\", __extends);\r\n    exporter(\"__assign\", __assign);\r\n    exporter(\"__rest\", __rest);\r\n    exporter(\"__decorate\", __decorate);\r\n    exporter(\"__param\", __param);\r\n    exporter(\"__metadata\", __metadata);\r\n    exporter(\"__awaiter\", __awaiter);\r\n    exporter(\"__generator\", __generator);\r\n    exporter(\"__exportStar\", __exportStar);\r\n    exporter(\"__createBinding\", __createBinding);\r\n    exporter(\"__values\", __values);\r\n    exporter(\"__read\", __read);\r\n    exporter(\"__spread\", __spread);\r\n    exporter(\"__spreadArrays\", __spreadArrays);\r\n    exporter(\"__spreadArray\", __spreadArray);\r\n    exporter(\"__await\", __await);\r\n    exporter(\"__asyncGenerator\", __asyncGenerator);\r\n    exporter(\"__asyncDelegator\", __asyncDelegator);\r\n    exporter(\"__asyncValues\", __asyncValues);\r\n    exporter(\"__makeTemplateObject\", __makeTemplateObject);\r\n    exporter(\"__importStar\", __importStar);\r\n    exporter(\"__importDefault\", __importDefault);\r\n    exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet);\r\n    exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet);\r\n});\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global global, define, System, Reflect, Promise */\r\nvar __extends;\r\nvar __assign;\r\nvar __rest;\r\nvar __decorate;\r\nvar __param;\r\nvar __metadata;\r\nvar __awaiter;\r\nvar __generator;\r\nvar __exportStar;\r\nvar __values;\r\nvar __read;\r\nvar __spread;\r\nvar __await;\r\nvar __asyncGenerator;\r\nvar __asyncDelegator;\r\nvar __asyncValues;\r\nvar __makeTemplateObject;\r\nvar __importStar;\r\nvar __importDefault;\r\n(function (factory) {\r\n    var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"tslib\", [\"exports\"], function (exports) { factory(createExporter(root, createExporter(exports))); });\r\n    }\r\n    else if (typeof module === \"object\" && typeof module.exports === \"object\") {\r\n        factory(createExporter(root, createExporter(module.exports)));\r\n    }\r\n    else {\r\n        factory(createExporter(root));\r\n    }\r\n    function createExporter(exports, previous) {\r\n        if (exports !== root) {\r\n            if (typeof Object.create === \"function\") {\r\n                Object.defineProperty(exports, \"__esModule\", { value: true });\r\n            }\r\n            else {\r\n                exports.__esModule = true;\r\n            }\r\n        }\r\n        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };\r\n    }\r\n})\r\n(function (exporter) {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\n    __extends = function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n\r\n    __assign = Object.assign || function (t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n\r\n    __rest = function (s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n                t[p[i]] = s[p[i]];\r\n        return t;\r\n    };\r\n\r\n    __decorate = function (decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    };\r\n\r\n    __param = function (paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    };\r\n\r\n    __metadata = function (metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    };\r\n\r\n    __awaiter = function (thisArg, _arguments, P, generator) {\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    };\r\n\r\n    __generator = function (thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    };\r\n\r\n    __exportStar = function (m, exports) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    };\r\n\r\n    __values = function (o) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n        if (m) return m.call(o);\r\n        return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n    };\r\n\r\n    __read = function (o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    };\r\n\r\n    __spread = function () {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    };\r\n\r\n    __await = function (v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    };\r\n\r\n    __asyncGenerator = function (thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    };\r\n\r\n    __asyncDelegator = function (o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n    };\r\n\r\n    __asyncValues = function (o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n    };\r\n\r\n    __makeTemplateObject = function (cooked, raw) {\r\n        if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n        return cooked;\r\n    };\r\n\r\n    __importStar = function (mod) {\r\n        if (mod && mod.__esModule) return mod;\r\n        var result = {};\r\n        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n        result[\"default\"] = mod;\r\n        return result;\r\n    };\r\n\r\n    __importDefault = function (mod) {\r\n        return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n    };\r\n\r\n    exporter(\"__extends\", __extends);\r\n    exporter(\"__assign\", __assign);\r\n    exporter(\"__rest\", __rest);\r\n    exporter(\"__decorate\", __decorate);\r\n    exporter(\"__param\", __param);\r\n    exporter(\"__metadata\", __metadata);\r\n    exporter(\"__awaiter\", __awaiter);\r\n    exporter(\"__generator\", __generator);\r\n    exporter(\"__exportStar\", __exportStar);\r\n    exporter(\"__values\", __values);\r\n    exporter(\"__read\", __read);\r\n    exporter(\"__spread\", __spread);\r\n    exporter(\"__await\", __await);\r\n    exporter(\"__asyncGenerator\", __asyncGenerator);\r\n    exporter(\"__asyncDelegator\", __asyncDelegator);\r\n    exporter(\"__asyncValues\", __asyncValues);\r\n    exporter(\"__makeTemplateObject\", __makeTemplateObject);\r\n    exporter(\"__importStar\", __importStar);\r\n    exporter(\"__importDefault\", __importDefault);\r\n});\r\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define('underscore', factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (function () {\n    var current = global._;\n    var exports = global._ = factory();\n    exports.noConflict = function () { global._ = current; return exports; };\n  }()));\n}(this, (function () {\n  //     Underscore.js 1.13.1\n  //     https://underscorejs.org\n  //     (c) 2009-2021 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters & Editors\n  //     Underscore may be freely distributed under the MIT license.\n\n  // Current version.\n  var VERSION = '1.13.1';\n\n  // Establish the root object, `window` (`self`) in the browser, `global`\n  // on the server, or `this` in some virtual machines. We use `self`\n  // instead of `window` for `WebWorker` support.\n  var root = typeof self == 'object' && self.self === self && self ||\n            typeof global == 'object' && global.global === global && global ||\n            Function('return this')() ||\n            {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype;\n  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n\n  // Modern feature detection.\n  var supportsArrayBuffer = typeof ArrayBuffer !== 'undefined',\n      supportsDataView = typeof DataView !== 'undefined';\n\n  // All **ECMAScript 5+** native function implementations that we hope to use\n  // are declared here.\n  var nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeCreate = Object.create,\n      nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;\n\n  // Create references to these builtin functions because we override them.\n  var _isNaN = isNaN,\n      _isFinite = isFinite;\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  // The largest integer that can be represented exactly.\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\n  // Some functions take a variable number of arguments, or a few expected\n  // arguments at the beginning and then a variable number of values to operate\n  // on. This helper accumulates all remaining arguments past the function’s\n  // argument length (or an explicit `startIndex`), into an array that becomes\n  // the last argument. Similar to ES6’s \"rest parameter\".\n  function restArguments(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n      var length = Math.max(arguments.length - startIndex, 0),\n          rest = Array(length),\n          index = 0;\n      for (; index < length; index++) {\n        rest[index] = arguments[index + startIndex];\n      }\n      switch (startIndex) {\n        case 0: return func.call(this, rest);\n        case 1: return func.call(this, arguments[0], rest);\n        case 2: return func.call(this, arguments[0], arguments[1], rest);\n      }\n      var args = Array(startIndex + 1);\n      for (index = 0; index < startIndex; index++) {\n        args[index] = arguments[index];\n      }\n      args[startIndex] = rest;\n      return func.apply(this, args);\n    };\n  }\n\n  // Is a given variable an object?\n  function isObject(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  }\n\n  // Is a given value equal to null?\n  function isNull(obj) {\n    return obj === null;\n  }\n\n  // Is a given variable undefined?\n  function isUndefined(obj) {\n    return obj === void 0;\n  }\n\n  // Is a given value a boolean?\n  function isBoolean(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  }\n\n  // Is a given value a DOM element?\n  function isElement(obj) {\n    return !!(obj && obj.nodeType === 1);\n  }\n\n  // Internal function for creating a `toString`-based type tester.\n  function tagTester(name) {\n    var tag = '[object ' + name + ']';\n    return function(obj) {\n      return toString.call(obj) === tag;\n    };\n  }\n\n  var isString = tagTester('String');\n\n  var isNumber = tagTester('Number');\n\n  var isDate = tagTester('Date');\n\n  var isRegExp = tagTester('RegExp');\n\n  var isError = tagTester('Error');\n\n  var isSymbol = tagTester('Symbol');\n\n  var isArrayBuffer = tagTester('ArrayBuffer');\n\n  var isFunction = tagTester('Function');\n\n  // Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old\n  // v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).\n  var nodelist = root.document && root.document.childNodes;\n  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {\n    isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  var isFunction$1 = isFunction;\n\n  var hasObjectTag = tagTester('Object');\n\n  // In IE 10 - Edge 13, `DataView` has string tag `'[object Object]'`.\n  // In IE 11, the most common among them, this problem also applies to\n  // `Map`, `WeakMap` and `Set`.\n  var hasStringTagBug = (\n        supportsDataView && hasObjectTag(new DataView(new ArrayBuffer(8)))\n      ),\n      isIE11 = (typeof Map !== 'undefined' && hasObjectTag(new Map));\n\n  var isDataView = tagTester('DataView');\n\n  // In IE 10 - Edge 13, we need a different heuristic\n  // to determine whether an object is a `DataView`.\n  function ie10IsDataView(obj) {\n    return obj != null && isFunction$1(obj.getInt8) && isArrayBuffer(obj.buffer);\n  }\n\n  var isDataView$1 = (hasStringTagBug ? ie10IsDataView : isDataView);\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native `Array.isArray`.\n  var isArray = nativeIsArray || tagTester('Array');\n\n  // Internal function to check whether `key` is an own property name of `obj`.\n  function has$1(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  }\n\n  var isArguments = tagTester('Arguments');\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  (function() {\n    if (!isArguments(arguments)) {\n      isArguments = function(obj) {\n        return has$1(obj, 'callee');\n      };\n    }\n  }());\n\n  var isArguments$1 = isArguments;\n\n  // Is a given object a finite number?\n  function isFinite$1(obj) {\n    return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));\n  }\n\n  // Is the given value `NaN`?\n  function isNaN$1(obj) {\n    return isNumber(obj) && _isNaN(obj);\n  }\n\n  // Predicate-generating function. Often useful outside of Underscore.\n  function constant(value) {\n    return function() {\n      return value;\n    };\n  }\n\n  // Common internal logic for `isArrayLike` and `isBufferLike`.\n  function createSizePropertyCheck(getSizeProperty) {\n    return function(collection) {\n      var sizeProperty = getSizeProperty(collection);\n      return typeof sizeProperty == 'number' && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;\n    }\n  }\n\n  // Internal helper to generate a function to obtain property `key` from `obj`.\n  function shallowProperty(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  }\n\n  // Internal helper to obtain the `byteLength` property of an object.\n  var getByteLength = shallowProperty('byteLength');\n\n  // Internal helper to determine whether we should spend extensive checks against\n  // `ArrayBuffer` et al.\n  var isBufferLike = createSizePropertyCheck(getByteLength);\n\n  // Is a given value a typed array?\n  var typedArrayPattern = /\\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\\]/;\n  function isTypedArray(obj) {\n    // `ArrayBuffer.isView` is the most future-proof, so use it when available.\n    // Otherwise, fall back on the above regular expression.\n    return nativeIsView ? (nativeIsView(obj) && !isDataView$1(obj)) :\n                  isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));\n  }\n\n  var isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);\n\n  // Internal helper to obtain the `length` property of an object.\n  var getLength = shallowProperty('length');\n\n  // Internal helper to create a simple lookup structure.\n  // `collectNonEnumProps` used to depend on `_.contains`, but this led to\n  // circular imports. `emulatedSet` is a one-off solution that only works for\n  // arrays of strings.\n  function emulatedSet(keys) {\n    var hash = {};\n    for (var l = keys.length, i = 0; i < l; ++i) hash[keys[i]] = true;\n    return {\n      contains: function(key) { return hash[key]; },\n      push: function(key) {\n        hash[key] = true;\n        return keys.push(key);\n      }\n    };\n  }\n\n  // Internal helper. Checks `keys` for the presence of keys in IE < 9 that won't\n  // be iterated by `for key in ...` and thus missed. Extends `keys` in place if\n  // needed.\n  function collectNonEnumProps(obj, keys) {\n    keys = emulatedSet(keys);\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = isFunction$1(constructor) && constructor.prototype || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (has$1(obj, prop) && !keys.contains(prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) {\n        keys.push(prop);\n      }\n    }\n  }\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`.\n  function keys(obj) {\n    if (!isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (has$1(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  }\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  function isEmpty(obj) {\n    if (obj == null) return true;\n    // Skip the more expensive `toString`-based type checks if `obj` has no\n    // `.length`.\n    var length = getLength(obj);\n    if (typeof length == 'number' && (\n      isArray(obj) || isString(obj) || isArguments$1(obj)\n    )) return length === 0;\n    return getLength(keys(obj)) === 0;\n  }\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  function isMatch(object, attrs) {\n    var _keys = keys(attrs), length = _keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = _keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  }\n\n  // If Underscore is called as a function, it returns a wrapped object that can\n  // be used OO-style. This wrapper holds altered versions of all functions added\n  // through `_.mixin`. Wrapped objects may be chained.\n  function _$1(obj) {\n    if (obj instanceof _$1) return obj;\n    if (!(this instanceof _$1)) return new _$1(obj);\n    this._wrapped = obj;\n  }\n\n  _$1.VERSION = VERSION;\n\n  // Extracts the result from a wrapped and chained object.\n  _$1.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxies for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;\n\n  _$1.prototype.toString = function() {\n    return String(this._wrapped);\n  };\n\n  // Internal function to wrap or shallow-copy an ArrayBuffer,\n  // typed array or DataView to a new view, reusing the buffer.\n  function toBufferView(bufferSource) {\n    return new Uint8Array(\n      bufferSource.buffer || bufferSource,\n      bufferSource.byteOffset || 0,\n      getByteLength(bufferSource)\n    );\n  }\n\n  // We use this string twice, so give it a name for minification.\n  var tagDataView = '[object DataView]';\n\n  // Internal recursive comparison function for `_.isEqual`.\n  function eq(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // `null` or `undefined` only equal to itself (strict comparison).\n    if (a == null || b == null) return false;\n    // `NaN`s are equivalent, but non-reflexive.\n    if (a !== a) return b !== b;\n    // Exhaust primitive checks\n    var type = typeof a;\n    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\n    return deepEq(a, b, aStack, bStack);\n  }\n\n  // Internal recursive comparison function for `_.isEqual`.\n  function deepEq(a, b, aStack, bStack) {\n    // Unwrap any wrapped objects.\n    if (a instanceof _$1) a = a._wrapped;\n    if (b instanceof _$1) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    // Work around a bug in IE 10 - Edge 13.\n    if (hasStringTagBug && className == '[object Object]' && isDataView$1(a)) {\n      if (!isDataView$1(b)) return false;\n      className = tagDataView;\n    }\n    switch (className) {\n      // These types are compared by value.\n      case '[object RegExp]':\n        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN.\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n      case '[object Symbol]':\n        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\n      case '[object ArrayBuffer]':\n      case tagDataView:\n        // Coerce to typed array so we can fall through.\n        return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays && isTypedArray$1(a)) {\n        var byteLength = getByteLength(a);\n        if (byteLength !== getByteLength(b)) return false;\n        if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;\n        areArrays = true;\n    }\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor &&\n                               isFunction$1(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var _keys = keys(a), key;\n      length = _keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = _keys[length];\n        if (!(has$1(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  }\n\n  // Perform a deep comparison to check if two objects are equal.\n  function isEqual(a, b) {\n    return eq(a, b);\n  }\n\n  // Retrieve all the enumerable property names of an object.\n  function allKeys(obj) {\n    if (!isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  }\n\n  // Since the regular `Object.prototype.toString` type tests don't work for\n  // some types in IE 11, we use a fingerprinting heuristic instead, based\n  // on the methods. It's not great, but it's the best we got.\n  // The fingerprint method lists are defined below.\n  function ie11fingerprint(methods) {\n    var length = getLength(methods);\n    return function(obj) {\n      if (obj == null) return false;\n      // `Map`, `WeakMap` and `Set` have no enumerable keys.\n      var keys = allKeys(obj);\n      if (getLength(keys)) return false;\n      for (var i = 0; i < length; i++) {\n        if (!isFunction$1(obj[methods[i]])) return false;\n      }\n      // If we are testing against `WeakMap`, we need to ensure that\n      // `obj` doesn't have a `forEach` method in order to distinguish\n      // it from a regular `Map`.\n      return methods !== weakMapMethods || !isFunction$1(obj[forEachName]);\n    };\n  }\n\n  // In the interest of compact minification, we write\n  // each string in the fingerprints only once.\n  var forEachName = 'forEach',\n      hasName = 'has',\n      commonInit = ['clear', 'delete'],\n      mapTail = ['get', hasName, 'set'];\n\n  // `Map`, `WeakMap` and `Set` each have slightly different\n  // combinations of the above sublists.\n  var mapMethods = commonInit.concat(forEachName, mapTail),\n      weakMapMethods = commonInit.concat(mapTail),\n      setMethods = ['add'].concat(commonInit, forEachName, hasName);\n\n  var isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester('Map');\n\n  var isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester('WeakMap');\n\n  var isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester('Set');\n\n  var isWeakSet = tagTester('WeakSet');\n\n  // Retrieve the values of an object's properties.\n  function values(obj) {\n    var _keys = keys(obj);\n    var length = _keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[_keys[i]];\n    }\n    return values;\n  }\n\n  // Convert an object into a list of `[key, value]` pairs.\n  // The opposite of `_.object` with one argument.\n  function pairs(obj) {\n    var _keys = keys(obj);\n    var length = _keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [_keys[i], obj[_keys[i]]];\n    }\n    return pairs;\n  }\n\n  // Invert the keys and values of an object. The values must be serializable.\n  function invert(obj) {\n    var result = {};\n    var _keys = keys(obj);\n    for (var i = 0, length = _keys.length; i < length; i++) {\n      result[obj[_keys[i]]] = _keys[i];\n    }\n    return result;\n  }\n\n  // Return a sorted list of the function names available on the object.\n  function functions(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (isFunction$1(obj[key])) names.push(key);\n    }\n    return names.sort();\n  }\n\n  // An internal function for creating assigner functions.\n  function createAssigner(keysFunc, defaults) {\n    return function(obj) {\n      var length = arguments.length;\n      if (defaults) obj = Object(obj);\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!defaults || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  }\n\n  // Extend a given object with all the properties in passed-in object(s).\n  var extend = createAssigner(allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in\n  // object(s).\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  var extendOwn = createAssigner(keys);\n\n  // Fill in a given object with default properties.\n  var defaults = createAssigner(allKeys, true);\n\n  // Create a naked function reference for surrogate-prototype-swapping.\n  function ctor() {\n    return function(){};\n  }\n\n  // An internal function for creating a new object that inherits from another.\n  function baseCreate(prototype) {\n    if (!isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    var Ctor = ctor();\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  }\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  function create(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) extendOwn(result, props);\n    return result;\n  }\n\n  // Create a (shallow-cloned) duplicate of an object.\n  function clone(obj) {\n    if (!isObject(obj)) return obj;\n    return isArray(obj) ? obj.slice() : extend({}, obj);\n  }\n\n  // Invokes `interceptor` with the `obj` and then returns `obj`.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  function tap(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  }\n\n  // Normalize a (deep) property `path` to array.\n  // Like `_.iteratee`, this function can be customized.\n  function toPath$1(path) {\n    return isArray(path) ? path : [path];\n  }\n  _$1.toPath = toPath$1;\n\n  // Internal wrapper for `_.toPath` to enable minification.\n  // Similar to `cb` for `_.iteratee`.\n  function toPath(path) {\n    return _$1.toPath(path);\n  }\n\n  // Internal function to obtain a nested property in `obj` along `path`.\n  function deepGet(obj, path) {\n    var length = path.length;\n    for (var i = 0; i < length; i++) {\n      if (obj == null) return void 0;\n      obj = obj[path[i]];\n    }\n    return length ? obj : void 0;\n  }\n\n  // Get the value of the (deep) property on `path` from `object`.\n  // If any property in `path` does not exist or if the value is\n  // `undefined`, return `defaultValue` instead.\n  // The `path` is normalized through `_.toPath`.\n  function get(object, path, defaultValue) {\n    var value = deepGet(object, toPath(path));\n    return isUndefined(value) ? defaultValue : value;\n  }\n\n  // Shortcut function for checking if an object has a given property directly on\n  // itself (in other words, not on a prototype). Unlike the internal `has`\n  // function, this public version can also traverse nested properties.\n  function has(obj, path) {\n    path = toPath(path);\n    var length = path.length;\n    for (var i = 0; i < length; i++) {\n      var key = path[i];\n      if (!has$1(obj, key)) return false;\n      obj = obj[key];\n    }\n    return !!length;\n  }\n\n  // Keep the identity function around for default iteratees.\n  function identity(value) {\n    return value;\n  }\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  function matcher(attrs) {\n    attrs = extendOwn({}, attrs);\n    return function(obj) {\n      return isMatch(obj, attrs);\n    };\n  }\n\n  // Creates a function that, when passed an object, will traverse that object’s\n  // properties down the given `path`, specified as an array of keys or indices.\n  function property(path) {\n    path = toPath(path);\n    return function(obj) {\n      return deepGet(obj, path);\n    };\n  }\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  function optimizeCb(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      // The 2-argument case is omitted because we’re not using it.\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  }\n\n  // An internal function to generate callbacks that can be applied to each\n  // element in a collection, returning the desired result — either `_.identity`,\n  // an arbitrary callback, a property matcher, or a property accessor.\n  function baseIteratee(value, context, argCount) {\n    if (value == null) return identity;\n    if (isFunction$1(value)) return optimizeCb(value, context, argCount);\n    if (isObject(value) && !isArray(value)) return matcher(value);\n    return property(value);\n  }\n\n  // External wrapper for our callback generator. Users may customize\n  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.\n  // This abstraction hides the internal-only `argCount` argument.\n  function iteratee(value, context) {\n    return baseIteratee(value, context, Infinity);\n  }\n  _$1.iteratee = iteratee;\n\n  // The function we call internally to generate a callback. It invokes\n  // `_.iteratee` if overridden, otherwise `baseIteratee`.\n  function cb(value, context, argCount) {\n    if (_$1.iteratee !== iteratee) return _$1.iteratee(value, context);\n    return baseIteratee(value, context, argCount);\n  }\n\n  // Returns the results of applying the `iteratee` to each element of `obj`.\n  // In contrast to `_.map` it returns an object.\n  function mapObject(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var _keys = keys(obj),\n        length = _keys.length,\n        results = {};\n    for (var index = 0; index < length; index++) {\n      var currentKey = _keys[index];\n      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  }\n\n  // Predicate-generating function. Often useful outside of Underscore.\n  function noop(){}\n\n  // Generates a function for a given object that returns a given property.\n  function propertyOf(obj) {\n    if (obj == null) return noop;\n    return function(path) {\n      return get(obj, path);\n    };\n  }\n\n  // Run a function **n** times.\n  function times(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  }\n\n  // Return a random integer between `min` and `max` (inclusive).\n  function random(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  }\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  var now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n  // Internal helper to generate functions for escaping and unescaping strings\n  // to/from HTML interpolation.\n  function createEscaper(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped.\n    var source = '(?:' + keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  }\n\n  // Internal list of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n\n  // Function for escaping strings to HTML interpolation.\n  var _escape = createEscaper(escapeMap);\n\n  // Internal list of HTML entities for unescaping.\n  var unescapeMap = invert(escapeMap);\n\n  // Function for unescaping strings from HTML interpolation.\n  var _unescape = createEscaper(unescapeMap);\n\n  // By default, Underscore uses ERB-style template delimiters. Change the\n  // following template settings to use alternative delimiters.\n  var templateSettings = _$1.templateSettings = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape: /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `_.templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\": \"'\",\n    '\\\\': '\\\\',\n    '\\r': 'r',\n    '\\n': 'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escapeRegExp = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  function escapeChar(match) {\n    return '\\\\' + escapes[match];\n  }\n\n  // In order to prevent third-party code injection through\n  // `_.templateSettings.variable`, we test it against the following regular\n  // expression. It is intentionally a bit more liberal than just matching valid\n  // identifiers, but still prevents possible loopholes through defaults or\n  // destructuring assignment.\n  var bareIdentifier = /^\\s*(\\w|\\$)+\\s*$/;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  function template(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = defaults({}, settings, _$1.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offset.\n      return match;\n    });\n    source += \"';\\n\";\n\n    var argument = settings.variable;\n    if (argument) {\n      // Insure against third-party code injection. (CVE-2021-23358)\n      if (!bareIdentifier.test(argument)) throw new Error(\n        'variable is not a bare identifier: ' + argument\n      );\n    } else {\n      // If a variable is not specified, place data values in local scope.\n      source = 'with(obj||{}){\\n' + source + '}\\n';\n      argument = 'obj';\n    }\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    var render;\n    try {\n      render = new Function(argument, '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _$1);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  }\n\n  // Traverses the children of `obj` along `path`. If a child is a function, it\n  // is invoked with its parent as context. Returns the value of the final\n  // child, or `fallback` if any child is undefined.\n  function result(obj, path, fallback) {\n    path = toPath(path);\n    var length = path.length;\n    if (!length) {\n      return isFunction$1(fallback) ? fallback.call(obj) : fallback;\n    }\n    for (var i = 0; i < length; i++) {\n      var prop = obj == null ? void 0 : obj[path[i]];\n      if (prop === void 0) {\n        prop = fallback;\n        i = length; // Ensure we don't continue iterating.\n      }\n      obj = isFunction$1(prop) ? prop.call(obj) : prop;\n    }\n    return obj;\n  }\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  function uniqueId(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  }\n\n  // Start chaining a wrapped Underscore object.\n  function chain(obj) {\n    var instance = _$1(obj);\n    instance._chain = true;\n    return instance;\n  }\n\n  // Internal function to execute `sourceFunc` bound to `context` with optional\n  // `args`. Determines whether to execute a function as a constructor or as a\n  // normal function.\n  function executeBound(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (isObject(result)) return result;\n    return self;\n  }\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. `_` acts\n  // as a placeholder by default, allowing any combination of arguments to be\n  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.\n  var partial = restArguments(function(func, boundArgs) {\n    var placeholder = partial.placeholder;\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  });\n\n  partial.placeholder = _$1;\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally).\n  var bind = restArguments(function(func, context, args) {\n    if (!isFunction$1(func)) throw new TypeError('Bind must be called on a function');\n    var bound = restArguments(function(callArgs) {\n      return executeBound(func, bound, context, this, args.concat(callArgs));\n    });\n    return bound;\n  });\n\n  // Internal helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object.\n  // Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var isArrayLike = createSizePropertyCheck(getLength);\n\n  // Internal implementation of a recursive `flatten` function.\n  function flatten$1(input, depth, strict, output) {\n    output = output || [];\n    if (!depth && depth !== 0) {\n      depth = Infinity;\n    } else if (depth <= 0) {\n      return output.concat(input);\n    }\n    var idx = output.length;\n    for (var i = 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {\n        // Flatten current level of array or arguments object.\n        if (depth > 1) {\n          flatten$1(value, depth - 1, strict, output);\n          idx = output.length;\n        } else {\n          var j = 0, len = value.length;\n          while (j < len) output[idx++] = value[j++];\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  }\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  var bindAll = restArguments(function(obj, keys) {\n    keys = flatten$1(keys, false, false);\n    var index = keys.length;\n    if (index < 1) throw new Error('bindAll must be passed function names');\n    while (index--) {\n      var key = keys[index];\n      obj[key] = bind(obj[key], obj);\n    }\n    return obj;\n  });\n\n  // Memoize an expensive function by storing its results.\n  function memoize(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!has$1(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  }\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  var delay = restArguments(function(func, wait, args) {\n    return setTimeout(function() {\n      return func.apply(null, args);\n    }, wait);\n  });\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  var defer = partial(delay, _$1, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  function throttle(func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function() {\n      previous = options.leading === false ? 0 : now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function() {\n      var _now = now();\n      if (!previous && options.leading === false) previous = _now;\n      var remaining = wait - (_now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = _now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n\n    throttled.cancel = function() {\n      clearTimeout(timeout);\n      previous = 0;\n      timeout = context = args = null;\n    };\n\n    return throttled;\n  }\n\n  // When a sequence of calls of the returned function ends, the argument\n  // function is triggered. The end of a sequence is defined by the `wait`\n  // parameter. If `immediate` is passed, the argument function will be\n  // triggered at the beginning of the sequence instead of at the end.\n  function debounce(func, wait, immediate) {\n    var timeout, previous, args, result, context;\n\n    var later = function() {\n      var passed = now() - previous;\n      if (wait > passed) {\n        timeout = setTimeout(later, wait - passed);\n      } else {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n        // This check is needed because `func` can recursively invoke `debounced`.\n        if (!timeout) args = context = null;\n      }\n    };\n\n    var debounced = restArguments(function(_args) {\n      context = this;\n      args = _args;\n      previous = now();\n      if (!timeout) {\n        timeout = setTimeout(later, wait);\n        if (immediate) result = func.apply(context, args);\n      }\n      return result;\n    });\n\n    debounced.cancel = function() {\n      clearTimeout(timeout);\n      timeout = args = context = null;\n    };\n\n    return debounced;\n  }\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  function wrap(func, wrapper) {\n    return partial(wrapper, func);\n  }\n\n  // Returns a negated version of the passed-in predicate.\n  function negate(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  }\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  function compose() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  }\n\n  // Returns a function that will only be executed on and after the Nth call.\n  function after(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  }\n\n  // Returns a function that will only be executed up to (but not including) the\n  // Nth call.\n  function before(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  }\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  var once = partial(before, 2);\n\n  // Returns the first key on an object that passes a truth test.\n  function findKey(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var _keys = keys(obj), key;\n    for (var i = 0, length = _keys.length; i < length; i++) {\n      key = _keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  }\n\n  // Internal function to generate `_.findIndex` and `_.findLastIndex`.\n  function createPredicateIndexFinder(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  }\n\n  // Returns the first index on an array-like that passes a truth test.\n  var findIndex = createPredicateIndexFinder(1);\n\n  // Returns the last index on an array-like that passes a truth test.\n  var findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  function sortedIndex(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  }\n\n  // Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.\n  function createIndexFinder(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n          i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), isNaN$1);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  }\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  var indexOf = createIndexFinder(1, findIndex, sortedIndex);\n\n  // Return the position of the last occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  var lastIndexOf = createIndexFinder(-1, findLastIndex);\n\n  // Return the first value which passes a truth test.\n  function find(obj, predicate, context) {\n    var keyFinder = isArrayLike(obj) ? findIndex : findKey;\n    var key = keyFinder(obj, predicate, context);\n    if (key !== void 0 && key !== -1) return obj[key];\n  }\n\n  // Convenience version of a common use case of `_.find`: getting the first\n  // object containing specific `key:value` pairs.\n  function findWhere(obj, attrs) {\n    return find(obj, matcher(attrs));\n  }\n\n  // The cornerstone for collection functions, an `each`\n  // implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  function each(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var _keys = keys(obj);\n      for (i = 0, length = _keys.length; i < length; i++) {\n        iteratee(obj[_keys[i]], _keys[i], obj);\n      }\n    }\n    return obj;\n  }\n\n  // Return the results of applying the iteratee to each element.\n  function map(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var _keys = !isArrayLike(obj) && keys(obj),\n        length = (_keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = _keys ? _keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  }\n\n  // Internal helper to create a reducing function, iterating left or right.\n  function createReduce(dir) {\n    // Wrap code that reassigns argument variables in a separate function than\n    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)\n    var reducer = function(obj, iteratee, memo, initial) {\n      var _keys = !isArrayLike(obj) && keys(obj),\n          length = (_keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      if (!initial) {\n        memo = obj[_keys ? _keys[index] : index];\n        index += dir;\n      }\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = _keys ? _keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    };\n\n    return function(obj, iteratee, memo, context) {\n      var initial = arguments.length >= 3;\n      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);\n    };\n  }\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  var reduce = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  var reduceRight = createReduce(-1);\n\n  // Return all the elements that pass a truth test.\n  function filter(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  }\n\n  // Return all the elements for which a truth test fails.\n  function reject(obj, predicate, context) {\n    return filter(obj, negate(cb(predicate)), context);\n  }\n\n  // Determine whether all of the elements pass a truth test.\n  function every(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var _keys = !isArrayLike(obj) && keys(obj),\n        length = (_keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = _keys ? _keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  }\n\n  // Determine if at least one element in the object passes a truth test.\n  function some(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var _keys = !isArrayLike(obj) && keys(obj),\n        length = (_keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = _keys ? _keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  }\n\n  // Determine if the array or object contains a given item (using `===`).\n  function contains(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return indexOf(obj, item, fromIndex) >= 0;\n  }\n\n  // Invoke a method (with arguments) on every item in a collection.\n  var invoke = restArguments(function(obj, path, args) {\n    var contextPath, func;\n    if (isFunction$1(path)) {\n      func = path;\n    } else {\n      path = toPath(path);\n      contextPath = path.slice(0, -1);\n      path = path[path.length - 1];\n    }\n    return map(obj, function(context) {\n      var method = func;\n      if (!method) {\n        if (contextPath && contextPath.length) {\n          context = deepGet(context, contextPath);\n        }\n        if (context == null) return void 0;\n        method = context[path];\n      }\n      return method == null ? method : method.apply(context, args);\n    });\n  });\n\n  // Convenience version of a common use case of `_.map`: fetching a property.\n  function pluck(obj, key) {\n    return map(obj, property(key));\n  }\n\n  // Convenience version of a common use case of `_.filter`: selecting only\n  // objects containing specific `key:value` pairs.\n  function where(obj, attrs) {\n    return filter(obj, matcher(attrs));\n  }\n\n  // Return the maximum element (or element-based computation).\n  function max(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {\n      obj = isArrayLike(obj) ? obj : values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      each(obj, function(v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  }\n\n  // Return the minimum element (or element-based computation).\n  function min(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {\n      obj = isArrayLike(obj) ? obj : values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      each(obj, function(v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  }\n\n  // Sample **n** random values from a collection using the modern version of the\n  // [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `_.map`.\n  function sample(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = values(obj);\n      return obj[random(obj.length - 1)];\n    }\n    var sample = isArrayLike(obj) ? clone(obj) : values(obj);\n    var length = getLength(sample);\n    n = Math.max(Math.min(n, length), 0);\n    var last = length - 1;\n    for (var index = 0; index < n; index++) {\n      var rand = random(index, last);\n      var temp = sample[index];\n      sample[index] = sample[rand];\n      sample[rand] = temp;\n    }\n    return sample.slice(0, n);\n  }\n\n  // Shuffle a collection.\n  function shuffle(obj) {\n    return sample(obj, Infinity);\n  }\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  function sortBy(obj, iteratee, context) {\n    var index = 0;\n    iteratee = cb(iteratee, context);\n    return pluck(map(obj, function(value, key, list) {\n      return {\n        value: value,\n        index: index++,\n        criteria: iteratee(value, key, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  }\n\n  // An internal function used for aggregate \"group by\" operations.\n  function group(behavior, partition) {\n    return function(obj, iteratee, context) {\n      var result = partition ? [[], []] : {};\n      iteratee = cb(iteratee, context);\n      each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  }\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  var groupBy = group(function(result, value, key) {\n    if (has$1(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `_.groupBy`, but for\n  // when you know that your index values will be unique.\n  var indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  var countBy = group(function(result, value, key) {\n    if (has$1(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Split a collection into two arrays: one whose elements all pass the given\n  // truth test, and one whose elements all do not pass the truth test.\n  var partition = group(function(result, value, pass) {\n    result[pass ? 0 : 1].push(value);\n  }, true);\n\n  // Safely create a real, live array from anything iterable.\n  var reStrSymbol = /[^\\ud800-\\udfff]|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff]/g;\n  function toArray(obj) {\n    if (!obj) return [];\n    if (isArray(obj)) return slice.call(obj);\n    if (isString(obj)) {\n      // Keep surrogate pair characters together.\n      return obj.match(reStrSymbol);\n    }\n    if (isArrayLike(obj)) return map(obj, identity);\n    return values(obj);\n  }\n\n  // Return the number of elements in a collection.\n  function size(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : keys(obj).length;\n  }\n\n  // Internal `_.pick` helper function to determine whether `key` is an enumerable\n  // property name of `obj`.\n  function keyInObj(value, key, obj) {\n    return key in obj;\n  }\n\n  // Return a copy of the object only containing the allowed properties.\n  var pick = restArguments(function(obj, keys) {\n    var result = {}, iteratee = keys[0];\n    if (obj == null) return result;\n    if (isFunction$1(iteratee)) {\n      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);\n      keys = allKeys(obj);\n    } else {\n      iteratee = keyInObj;\n      keys = flatten$1(keys, false, false);\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  });\n\n  // Return a copy of the object without the disallowed properties.\n  var omit = restArguments(function(obj, keys) {\n    var iteratee = keys[0], context;\n    if (isFunction$1(iteratee)) {\n      iteratee = negate(iteratee);\n      if (keys.length > 1) context = keys[1];\n    } else {\n      keys = map(flatten$1(keys, false, false), String);\n      iteratee = function(value, key) {\n        return !contains(keys, key);\n      };\n    }\n    return pick(obj, iteratee, context);\n  });\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  function initial(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  }\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  function first(array, n, guard) {\n    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];\n    if (n == null || guard) return array[0];\n    return initial(array, array.length - n);\n  }\n\n  // Returns everything but the first entry of the `array`. Especially useful on\n  // the `arguments` object. Passing an **n** will return the rest N values in the\n  // `array`.\n  function rest(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  }\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  function last(array, n, guard) {\n    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];\n    if (n == null || guard) return array[array.length - 1];\n    return rest(array, Math.max(0, array.length - n));\n  }\n\n  // Trim out all falsy values from an array.\n  function compact(array) {\n    return filter(array, Boolean);\n  }\n\n  // Flatten out an array, either recursively (by default), or up to `depth`.\n  // Passing `true` or `false` as `depth` means `1` or `Infinity`, respectively.\n  function flatten(array, depth) {\n    return flatten$1(array, depth, false);\n  }\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  var difference = restArguments(function(array, rest) {\n    rest = flatten$1(rest, true, true);\n    return filter(array, function(value){\n      return !contains(rest, value);\n    });\n  });\n\n  // Return a version of the array that does not contain the specified value(s).\n  var without = restArguments(function(array, otherArrays) {\n    return difference(array, otherArrays);\n  });\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // The faster algorithm will not work with an iteratee if the iteratee\n  // is not a one-to-one function, so providing an iteratee will disable\n  // the faster algorithm.\n  function uniq(array, isSorted, iteratee, context) {\n    if (!isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted && !iteratee) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  }\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  var union = restArguments(function(arrays) {\n    return uniq(flatten$1(arrays, true, true));\n  });\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  function intersection(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (contains(result, item)) continue;\n      var j;\n      for (j = 1; j < argsLength; j++) {\n        if (!contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  }\n\n  // Complement of zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices.\n  function unzip(array) {\n    var length = array && max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = pluck(array, index);\n    }\n    return result;\n  }\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  var zip = restArguments(unzip);\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values. Passing by pairs is the reverse of `_.pairs`.\n  function object(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  }\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](https://docs.python.org/library/functions.html#range).\n  function range(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    if (!step) {\n      step = stop < start ? -1 : 1;\n    }\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  }\n\n  // Chunk a single array into multiple arrays, each containing `count` or fewer\n  // items.\n  function chunk(array, count) {\n    if (count == null || count < 1) return [];\n    var result = [];\n    var i = 0, length = array.length;\n    while (i < length) {\n      result.push(slice.call(array, i, i += count));\n    }\n    return result;\n  }\n\n  // Helper function to continue chaining intermediate results.\n  function chainResult(instance, obj) {\n    return instance._chain ? _$1(obj).chain() : obj;\n  }\n\n  // Add your own custom functions to the Underscore object.\n  function mixin(obj) {\n    each(functions(obj), function(name) {\n      var func = _$1[name] = obj[name];\n      _$1.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return chainResult(this, func.apply(_$1, args));\n      };\n    });\n    return _$1;\n  }\n\n  // Add all mutator `Array` functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _$1.prototype[name] = function() {\n      var obj = this._wrapped;\n      if (obj != null) {\n        method.apply(obj, arguments);\n        if ((name === 'shift' || name === 'splice') && obj.length === 0) {\n          delete obj[0];\n        }\n      }\n      return chainResult(this, obj);\n    };\n  });\n\n  // Add all accessor `Array` functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _$1.prototype[name] = function() {\n      var obj = this._wrapped;\n      if (obj != null) obj = method.apply(obj, arguments);\n      return chainResult(this, obj);\n    };\n  });\n\n  // Named Exports\n\n  var allExports = {\n    __proto__: null,\n    VERSION: VERSION,\n    restArguments: restArguments,\n    isObject: isObject,\n    isNull: isNull,\n    isUndefined: isUndefined,\n    isBoolean: isBoolean,\n    isElement: isElement,\n    isString: isString,\n    isNumber: isNumber,\n    isDate: isDate,\n    isRegExp: isRegExp,\n    isError: isError,\n    isSymbol: isSymbol,\n    isArrayBuffer: isArrayBuffer,\n    isDataView: isDataView$1,\n    isArray: isArray,\n    isFunction: isFunction$1,\n    isArguments: isArguments$1,\n    isFinite: isFinite$1,\n    isNaN: isNaN$1,\n    isTypedArray: isTypedArray$1,\n    isEmpty: isEmpty,\n    isMatch: isMatch,\n    isEqual: isEqual,\n    isMap: isMap,\n    isWeakMap: isWeakMap,\n    isSet: isSet,\n    isWeakSet: isWeakSet,\n    keys: keys,\n    allKeys: allKeys,\n    values: values,\n    pairs: pairs,\n    invert: invert,\n    functions: functions,\n    methods: functions,\n    extend: extend,\n    extendOwn: extendOwn,\n    assign: extendOwn,\n    defaults: defaults,\n    create: create,\n    clone: clone,\n    tap: tap,\n    get: get,\n    has: has,\n    mapObject: mapObject,\n    identity: identity,\n    constant: constant,\n    noop: noop,\n    toPath: toPath$1,\n    property: property,\n    propertyOf: propertyOf,\n    matcher: matcher,\n    matches: matcher,\n    times: times,\n    random: random,\n    now: now,\n    escape: _escape,\n    unescape: _unescape,\n    templateSettings: templateSettings,\n    template: template,\n    result: result,\n    uniqueId: uniqueId,\n    chain: chain,\n    iteratee: iteratee,\n    partial: partial,\n    bind: bind,\n    bindAll: bindAll,\n    memoize: memoize,\n    delay: delay,\n    defer: defer,\n    throttle: throttle,\n    debounce: debounce,\n    wrap: wrap,\n    negate: negate,\n    compose: compose,\n    after: after,\n    before: before,\n    once: once,\n    findKey: findKey,\n    findIndex: findIndex,\n    findLastIndex: findLastIndex,\n    sortedIndex: sortedIndex,\n    indexOf: indexOf,\n    lastIndexOf: lastIndexOf,\n    find: find,\n    detect: find,\n    findWhere: findWhere,\n    each: each,\n    forEach: each,\n    map: map,\n    collect: map,\n    reduce: reduce,\n    foldl: reduce,\n    inject: reduce,\n    reduceRight: reduceRight,\n    foldr: reduceRight,\n    filter: filter,\n    select: filter,\n    reject: reject,\n    every: every,\n    all: every,\n    some: some,\n    any: some,\n    contains: contains,\n    includes: contains,\n    include: contains,\n    invoke: invoke,\n    pluck: pluck,\n    where: where,\n    max: max,\n    min: min,\n    shuffle: shuffle,\n    sample: sample,\n    sortBy: sortBy,\n    groupBy: groupBy,\n    indexBy: indexBy,\n    countBy: countBy,\n    partition: partition,\n    toArray: toArray,\n    size: size,\n    pick: pick,\n    omit: omit,\n    first: first,\n    head: first,\n    take: first,\n    initial: initial,\n    last: last,\n    rest: rest,\n    tail: rest,\n    drop: rest,\n    compact: compact,\n    flatten: flatten,\n    without: without,\n    uniq: uniq,\n    unique: uniq,\n    union: union,\n    intersection: intersection,\n    difference: difference,\n    unzip: unzip,\n    transpose: unzip,\n    zip: zip,\n    object: object,\n    range: range,\n    chunk: chunk,\n    mixin: mixin,\n    'default': _$1\n  };\n\n  // Default Export\n\n  // Add all of the Underscore functions to the wrapper object.\n  var _ = mixin(allExports);\n  // Legacy Node.js API.\n  _._ = _;\n\n  return _;\n\n})));\n//# sourceMappingURL=underscore-umd.js.map\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2luZGV4LmpzIiwiZGlzdC9saWIvdGltZWxpbmVWaXN1YWxpemVyLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmlzZXF1YWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvZGlzdC9hcGkvYXBpLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyZmx5LXRpbWVsaW5lL2Rpc3QvYXBpL2VudW1zLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyZmx5LXRpbWVsaW5lL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvZGlzdC9saWIuanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvZGlzdC9yZXNvbHZlci9jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L3Jlc29sdmVyL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L3Jlc29sdmVyL2V4cHJlc3Npb24uanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvZGlzdC9yZXNvbHZlci9yZXNvbHZlci5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L3Jlc29sdmVyL3N0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyZmx5LXRpbWVsaW5lL2Rpc3QvcmVzb2x2ZXIvdmFsaWRhdGUuanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzIiwibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS11bWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3h6REE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ25QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvdGltZWxpbmVWaXN1YWxpemVyXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaXNFcXVhbCA9IHJlcXVpcmUoXCJsb2Rhc2guaXNlcXVhbFwiKTtcbmNvbnN0IHN1cGVyZmx5X3RpbWVsaW5lXzEgPSByZXF1aXJlKFwic3VwZXJmbHktdGltZWxpbmVcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG4vKiogU3RlcCBzaXplLyB0aW1lIHN0ZXAuICovXG5jb25zdCBERUZBVUxUX1NURVBfU0laRSA9IDE7XG4vKiogV2lkdGggb2YgbGFiZWwgY29sdW1uLiAqL1xuY29uc3QgTEFCRUxfV0lEVEhfT0ZfVElNRUxJTkUgPSAwLjI1O1xuLyoqIERlZmF1bHQgem9vbSAqL1xuY29uc3QgREVGQVVMVF9aT09NX1ZBTFVFID0gMTAwO1xuLyoqIEZhY3RvciB0byB6b29tIGJ5ICovXG5jb25zdCBaT09NX0ZBQ1RPUiA9IDEuMDAxO1xuLyoqIEZhY3RvciB0byBwYW4gYnkgKHBhbiA9IFBBTl9GQUNUT1IgKiBTVEVQX1NJWkUpICovXG5jb25zdCBQQU5fRkFDVE9SID0gMTA7XG4vKiogTWF4aW11bSBsYXllciBoZWlnaHQgKi9cbmNvbnN0IE1BWF9MQVlFUl9IRUlHSFQgPSA2MDtcbi8qKiBBbW91bnQgdG8gbW92ZSBwbGF5aGVhZCBwZXIgc2Vjb25kLiAqL1xuY29uc3QgREVGQVVMVF9QTEFZSEVBRF9TUEVFRCA9IDE7XG4vKiogQkVHSU4gU1RZTElORyBWQUxVRVMgKi9cbi8qKiBUaW1lbGluZSBiYWNrZ3JvdW5kIGNvbG9yLiAqL1xuY29uc3QgQ09MT1JfQkFDS0dST1VORCA9ICcjMzMzMzMzJztcbi8qKiBMYXllciBsYWJlbCBiYWNrZ3JvdW5kIGNvbG9yLiAqL1xuY29uc3QgQ09MT1JfTEFCRUxfQkFDS0dST1VORCA9ICcjNjY2NjY2Jztcbi8qKiBDb2xvciBvZiB0aGUgcnVsZXIgbGluZXMgKi9cbmNvbnN0IFJVTEVSX0xJTkVfQ09MT1IgPSAnIzk5OTk5OSc7XG4vKiogV2lkdGggb2YgdGhlIHJ1bGVyIGxpbmVzICovXG5jb25zdCBSVUxFUl9MSU5FX1dJRFRIID0gMTtcbi8qKiBQbGF5aGVhZCBjb2xvci4gKi9cbmNvbnN0IENPTE9SX1BMQVlIRUFEID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjUpJztcbi8qKiBQbGF5aGVhZCB0aGlja25lc3MuICovXG5jb25zdCBUSElDS05FU1NfUExBWUhFQUQgPSA1O1xuLyoqIENvbG9yIG9mIGxpbmUgc2VwYXJhdGluZyB0aW1lbGluZSByb3dzLiAqL1xuY29uc3QgQ09MT1JfTElORSA9ICdibGFjayc7XG4vKiogSGVpZ2h0IG9mIGxpbmUgc2VwYXJhdGluZyByb3dzLiAqL1xuY29uc3QgVEhJQ0tORVNTX0xJTkUgPSAxO1xuLyoqIFRleHQgcHJvcGVydGllcy4gKi9cbmNvbnN0IFRFWFRfRk9OVF9GQU1JTFkgPSAnQ2FsaWJyaSc7XG5jb25zdCBURVhUX0ZPTlRfU0laRSA9IDE2O1xuY29uc3QgVEVYVF9DT0xPUiA9ICd3aGl0ZSc7XG4vKiogVGltZWxpbmUgb2JqZWN0IHByb3BlcnRpZXMuICovXG5jb25zdCBDT0xPUl9USU1FTElORV9PQkpFQ1RfRklMTCA9ICdyZ2IoMjIsIDEwMiwgMjQ3LCAwLjc1KSc7XG5jb25zdCBDT0xPUl9USU1FTElORV9PQkpFQ1RfQk9SREVSID0gJ3JnYmEoMjMyLCAyNDAsIDI1NSwgMC44NSknO1xuY29uc3QgVEhJQ0tORVNTX1RJTUVMSU5FX09CSkVDVF9CT1JERVIgPSAxO1xuLyoqIFRpbWVsaW5lIG9iamVjdCBoZWlnaHQgYXMgYSBwcm9wb3J0aW9uIG9mIHRoZSByb3cgaGVpZ2h0LiAqL1xuY29uc3QgVElNRUxJTkVfT0JKRUNUX0hFSUdIVCA9IDE7XG4vKiogRU5EIFNUWUxJTkcgVkFMVUVTICovXG4vKiogQkVHSU4gQ09OU1RBTlRTIEZPUiBTVEFURSBNQU5BR0VNRU5UICovXG5jb25zdCBNT1VTRUlOID0gMDtcbmNvbnN0IE1PVVNFT1VUID0gMTtcbmNsYXNzIFRpbWVsaW5lVmlzdWFsaXplciBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhbnZhc0lkIFRoZSBJRCBvZiB0aGUgY2FudmFzIG9iamVjdCB0byBkcmF3IHdpdGhpbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjYW52YXNJZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIFN0ZXAgc2l6ZS5cbiAgICAgICAgdGhpcy5zdGVwU2l6ZSA9IERFRkFVTFRfU1RFUF9TSVpFO1xuICAgICAgICAvKiogQHByaXZhdGUgQHJlYWRvbmx5IFByb3BvcnRpb24gb2YgdGhlIGNhbnZhcyB0byBiZSB1c2VkIGZvciB0aGUgbGF5ZXIgbGFiZWxzIGNvbHVtbi4gKi9cbiAgICAgICAgdGhpcy5fbGF5ZXJMYWJlbFdpZHRoUHJvcG9ydGlvbk9mQ2FudmFzID0gTEFCRUxfV0lEVEhfT0ZfVElNRUxJTkU7XG4gICAgICAgIC8qKiBMYXllcnMgb24gdGltZWxpbmUuICovXG4gICAgICAgIHRoaXMuX2xheWVyTGFiZWxzID0ge307XG4gICAgICAgIC8qKiBTdGF0ZSBvZiB0aGUgdGltZWxpbmUuICovXG4gICAgICAgIHRoaXMuX3RpbWVsaW5lU3RhdGUgPSB7fTtcbiAgICAgICAgLyoqIE1hcCBvZiBvYmplY3RzIGZvciBkZXRlcm1pbmluZyBob3ZlcmVkIG9iamVjdCAqL1xuICAgICAgICB0aGlzLl9ob3ZlcmVkT2JqZWN0TWFwID0ge307XG4gICAgICAgIC8qKiBTdGFydCB0aW1lIG9mIHRoZSBjdXJyZW50IHZpZXcuIERlZmluZXMgdGhlIG9iamVjdHMgd2l0aGluIHZpZXcgb24gdGhlIHRpbWVsaW5lIFt0aW1lXSAqL1xuICAgICAgICB0aGlzLl92aWV3U3RhcnRUaW1lID0gMDtcbiAgICAgICAgLyoqIFJhbmdlIG9mIHRoZSBjdXJyZW50IHZpZXcgW3RpbWVdICovXG4gICAgICAgIC8vIHByaXZhdGUgX3ZpZXdUaW1lUmFuZ2U6IG51bWJlciA9IDFcbiAgICAgICAgLy8gcHJpdmF0ZSBfZHJhd1RpbWVFbmQ6IG51bWJlclxuICAgICAgICAvKiogU3RvcmUgd2hldGhlciB0aGUgbW91c2UgaXMgaGVsZCBkb3duLCBmb3Igc2Nyb2xsaW5nLiAqL1xuICAgICAgICB0aGlzLl9tb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgLyoqIEN1cnJlbnQgem9vbSBhbW91bnQuICovXG4gICAgICAgIHRoaXMuX3RpbWVsaW5lWm9vbSA9IERFRkFVTFRfWk9PTV9WQUxVRTtcbiAgICAgICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBwbGF5aGVhZCBzaG91bGQgbW92ZS4gKi9cbiAgICAgICAgdGhpcy5fcGxheUhlYWRQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIC8qKiBTcGVlZCBvZiB0aGUgcGxheWhlYWQgW3VuaXRzIC8gc2Vjb25kXSAqL1xuICAgICAgICB0aGlzLl9wbGF5U3BlZWQgPSBERUZBVUxUX1BMQVlIRUFEX1NQRUVEO1xuICAgICAgICAvKiogVGhlIGN1cnJlbnQgdGltZSBwb3NpdGlvbiBvZiB0aGUgcGxheWhlYWQuICovXG4gICAgICAgIHRoaXMuX3BsYXlIZWFkVGltZSA9IDA7XG4gICAgICAgIC8qKiBUaGUgbGFzdCB0aW1lIHVwZGF0ZURyYXcoKSBkaWQgYSBkcmF3LiAqL1xuICAgICAgICB0aGlzLl91cGRhdGVEcmF3TGFzdFRpbWUgPSAwO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgbW91c2UgbGFzdCBtb3ZlZCBvdmVyIGFuIG9iamVjdCBvciBvdXQuICovXG4gICAgICAgIHRoaXMuX2xhc3RIb3ZlckFjdGlvbiA9IE1PVVNFT1VUO1xuICAgICAgICAvKiogTmFtZSBvZiBvYmplY3QgdGhhdCB3YXMgbGFzdCBob3ZlcmVkIG92ZXIuICovXG4gICAgICAgIHRoaXMuX2xhc3RIb3ZlcmVkSGFzaCA9ICcnO1xuICAgICAgICAvKiogSWYgdGhlIHZpc3VhbGl6ZXIgYXV0b21hdGljYWxseSBzaG91bGQgcmUtcmVzb2x2ZSB0aGUgdGltZWxpbmUgd2hlbiBuYXZpZ2F0aW5nIHRoZSB2aWV3cG9ydCAqL1xuICAgICAgICB0aGlzLl90aW1lbGluZVJlc29sdmVBdXRvID0gZmFsc2U7XG4gICAgICAgIC8qKiBBdCB3aGF0IHRpbWUgdGhlIHRpbWVsaW5lIHdhcyByZXNvbHZlZCBbdGltZV0gKi9cbiAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlU3RhcnQgPSAwO1xuICAgICAgICB0aGlzLl90aW1lbGluZVJlc29sdmVFbmQgPSAwO1xuICAgICAgICB0aGlzLl90aW1lbGluZVJlc29sdmVab29tID0gMTtcbiAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlQ291bnQgPSAxMDA7XG4gICAgICAgIHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUNvdW50QWRqdXN0ID0gMTtcbiAgICAgICAgLyoqIEhvdyBtdWNoIGV4dHJhIChvdXRzaWRlIHRoZSBjdXJyZW50IHZpZXdwb3J0KSB0aGUgdGltZWxpbmUgc2hvdWxkIGJlIHJlc29sdmVkIHRvIFtyYXRpb10gKi9cbiAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlRXhwYW5kID0gMztcbiAgICAgICAgdGhpcy5sYXRlc3RVcGRhdGVUaW1lID0gMDtcbiAgICAgICAgdGhpcy5yZXJlc29sdmVUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWVyZ2VJdGVyYXRvciA9IDA7XG4gICAgICAgIC8vIEluaXRpYWxpc2Ugb3RoZXIgdmFsdWVzLlxuICAgICAgICB0aGlzLl9jYW52YXNJZCA9IGNhbnZhc0lkO1xuICAgICAgICB0aGlzLmluaXRDYW52YXMoKTtcbiAgICAgICAgdGhpcy5fZHJhd1BsYXloZWFkID0gISFvcHRpb25zLmRyYXdQbGF5aGVhZDtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHdpZHRoIG9mIGxhYmVsIGNvbHVtbi5cbiAgICAgICAgdGhpcy5fbGF5ZXJMYWJlbFdpZHRoID0gdGhpcy5fY2FudmFzV2lkdGggKiB0aGlzLl9sYXllckxhYmVsV2lkdGhQcm9wb3J0aW9uT2ZDYW52YXM7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aW1lbGluZSB3aWR0aCBhbmQgc3RhcnQgcG9pbnQuXG4gICAgICAgIHRoaXMuX3ZpZXdEcmF3WCA9IHRoaXMuX2xheWVyTGFiZWxXaWR0aDtcbiAgICAgICAgdGhpcy5fdmlld0RyYXdXaWR0aCA9IHRoaXMuX2NhbnZhc1dpZHRoIC0gdGhpcy5fbGF5ZXJMYWJlbFdpZHRoO1xuICAgICAgICAvLyBEcmF3IGJhY2tncm91bmQuXG4gICAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICAgICAgLy8gRHJhdyBwbGF5aGVhZC5cbiAgICAgICAgdGhpcy5kcmF3UGxheWhlYWQoKTtcbiAgICAgICAgdGhpcy51cGRhdGVEcmF3KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpc2VzIHRoZSBjYW52YXMgYW5kIHJlZ2lzdGVycyBjYW52YXMgZXZlbnRzLlxuICAgICAqL1xuICAgIGluaXRDYW52YXMoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgY2FudmFzIG9iamVjdC5cbiAgICAgICAgdGhpcy5fY2FudmFzQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fY2FudmFzSWQpO1xuICAgICAgICBpZiAoIXRoaXMuX2NhbnZhc0NvbnRhaW5lcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FudmFzIFwiJHt0aGlzLl9jYW52YXNJZH1cIiBub3QgZm91bmRgKTtcbiAgICAgICAgLy8gR2V0IHJlbmRlcmluZyBjb250ZXh0LlxuICAgICAgICB0aGlzLl9jYW52YXMgPSB0aGlzLl9jYW52YXNDb250YWluZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgLy8gUmVnaXN0ZXIgY2FudmFzIGludGVyYWN0aW9uIGV2ZW50IGhhbmRsZXJzLlxuICAgICAgICB0aGlzLl9jYW52YXNDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGV2ZW50KSA9PiB0aGlzLmNhbnZhc01vdXNlRG93bihldmVudCkpO1xuICAgICAgICB0aGlzLl9jYW52YXNDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIChldmVudCkgPT4gdGhpcy5jYW52YXNNb3VzZVVwKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuX2NhbnZhc0NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZXZlbnQpID0+IHRoaXMuY2FudmFzTW91c2VNb3ZlKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuX2NhbnZhc0NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIChldmVudCkgPT4gdGhpcy5jYW52YXNTY3JvbGxXaGVlbChldmVudCkpO1xuICAgICAgICAvLyBHZXQgd2lkdGggYW5kIGhlaWdodCBvZiBjYW52YXMuXG4gICAgICAgIHRoaXMuX2NhbnZhc1dpZHRoID0gdGhpcy5fY2FudmFzQ29udGFpbmVyLndpZHRoO1xuICAgICAgICB0aGlzLl9jYW52YXNIZWlnaHQgPSB0aGlzLl9jYW52YXNDb250YWluZXIuaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0aW1lbGluZSwgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIGFjdGlvbnMgYXJlIGFkZGVkL3JlbW92ZWQgZnJvbSBhIHRpbWVsaW5lXG4gICAgICogYnV0IHRoZSBzYW1lIHRpbWVsaW5lIGlzIGJlaW5nIGRyYXduLlxuICAgICAqIEBwYXJhbSB7VGltZWxpbmVPYmplY3RbXX0gdGltZWxpbmUgVGltZWxpbmUgdG8gZHJhdy5cbiAgICAgKiBAcGFyYW0ge1Jlc29sdmVPcHRpb25zfSBvcHRpb25zIFJlc29sdmUgb3B0aW9ucy5cbiAgICAgKi9cbiAgICB1cGRhdGVUaW1lbGluZSh0aW1lbGluZSwgb3B0aW9ucykge1xuICAgICAgICAvLyBJZiBvcHRpb25zIGhhdmUgbm90IGJlZW4gc3BlY2lmaWVkIHNldCB0aW1lIHRvIDAuXG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICAgICAgICBsaW1pdENvdW50OiAxMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhdGVzdFRpbWVsaW5lID0gdGltZWxpbmU7XG4gICAgICAgIHRoaXMubGF0ZXN0T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIGlmICghb3B0aW9ucy5saW1pdFRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUF1dG8gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlQXV0byA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMyID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLl90aW1lbGluZVJlc29sdmVBdXRvKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRpbWVsaW5lUmVzb2x2ZVdpbmRvdygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZXNvbHZlZFN0YXRlcyA9PT0gdW5kZWZpbmVkKSB7IC8vIElmIGZpcnN0IHRpbWUgdGhpcyBydW5zXG4gICAgICAgICAgICAvLyBTZXQgdGltZWxpbmUgc3RhcnQgYW5kIGVuZCB0aW1lcy5cbiAgICAgICAgICAgIGlmIChvcHRpb25zMi50aW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3U3RhcnRUaW1lID0gb3B0aW9uczIudGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1vdmUgcGxheWhlYWQgdG8gc3RhcnQgdGltZS5cbiAgICAgICAgICAgIHRoaXMuX3BsYXlIZWFkVGltZSA9IHRoaXMuX3ZpZXdTdGFydFRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlVGltZWxpbmUodHJ1ZSk7XG4gICAgfVxuICAgIF91cGRhdGVUaW1lbGluZShmcm9tTmV3VGltZWxpbmUgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBvcHRpb25zMiA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMubGF0ZXN0T3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLl90aW1lbGluZVJlc29sdmVBdXRvKSB7XG4gICAgICAgICAgICBvcHRpb25zMi50aW1lID0gdGhpcy5fdGltZWxpbmVSZXNvbHZlU3RhcnQ7XG4gICAgICAgICAgICBvcHRpb25zMi5saW1pdFRpbWUgPSB0aGlzLl90aW1lbGluZVJlc29sdmVFbmQ7XG4gICAgICAgICAgICBvcHRpb25zMi5saW1pdENvdW50ID0gTWF0aC5jZWlsKHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUNvdW50ICogdGhpcy5fdGltZWxpbmVSZXNvbHZlQ291bnRBZGp1c3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBwbGF5aGVhZCBpcyBiZWluZyBkcmF3biwgdGhlIHJlc29sdmUgdGltZSBzaG91bGQgYmUgYXQgdGhlIHBsYXloZWFkIHRpbWUuXG4gICAgICAgIGlmICh0aGlzLl9kcmF3UGxheWhlYWQgJiYgdGhpcy5fcGxheUhlYWRUaW1lID4gb3B0aW9uczIudGltZSkge1xuICAgICAgICAgICAgb3B0aW9uczIudGltZSA9IHRoaXMuX3BsYXlIZWFkVGltZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNvbHZlIHRoZSB0aW1lbGluZS5cbiAgICAgICAgY29uc3Qgc3RhcnRSZXNvbHZlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRUaW1lbGluZSA9IHN1cGVyZmx5X3RpbWVsaW5lXzEuUmVzb2x2ZXIucmVzb2x2ZVRpbWVsaW5lKHRoaXMubGF0ZXN0VGltZWxpbmUsIG9wdGlvbnMyKTtcbiAgICAgICAgbGV0IG5ld1Jlc29sdmVkU3RhdGVzID0gc3VwZXJmbHlfdGltZWxpbmVfMS5SZXNvbHZlci5yZXNvbHZlQWxsU3RhdGVzKHJlc29sdmVkVGltZWxpbmUpO1xuICAgICAgICBpZiAodGhpcy5fcmVzb2x2ZWRTdGF0ZXMgPT09IHVuZGVmaW5lZCkgeyAvLyBJZiBmaXJzdCB0aW1lIHRoaXMgcnVuc1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWRTdGF0ZXMgPSBuZXdSZXNvbHZlZFN0YXRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3UGxheWhlYWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmltIHRoZSBjdXJyZW50IHRpbWVsaW5lOlxuICAgICAgICAgICAgICAgIGlmIChuZXdSZXNvbHZlZFN0YXRlcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBNZXJnZSB0aGUgdGltZWxpbmVzLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlZFN0YXRlcyA9IHRoaXMubWVyZ2VUaW1lbGluZU9iamVjdHModGhpcy5fcmVzb2x2ZWRTdGF0ZXMsIG5ld1Jlc29sdmVkU3RhdGVzLCBmcm9tTmV3VGltZWxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBvbmx5IHNlZSBvbmUgdGltZWxpbmUgYXQgYSB0aW1lLlxuICAgICAgICAgICAgICAgIC8vIE92ZXJ3cml0ZSB0aGUgcHJldmlvdXMgdGltZWxpbmU6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWRTdGF0ZXMgPSBuZXdSZXNvbHZlZFN0YXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgbGF5ZXJzLlxuICAgICAgICB0aGlzLnVwZGF0ZUxheWVyTGFiZWxzKCk7XG4gICAgICAgIHRoaXMubGF0ZXN0VXBkYXRlVGltZSA9IERhdGUubm93KCkgLSBzdGFydFJlc29sdmU7XG4gICAgICAgIC8vIFJlZHJhdyB0aGUgdGltZWxpbmUuXG4gICAgICAgIHRoaXMucmVkcmF3VGltZWxpbmUoKTtcbiAgICAgICAgdGhpcy5sYXRlc3RVcGRhdGVUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0UmVzb2x2ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmlld3BvcnQgdG8gYSBwb3NpdGlvbiwgem9vbSwgYW5kIHBsYXliYWNrIHNwZWVkLlxuICAgICAqIFBsYXliYWNrIHNwZWVkIGN1cnJlbnRseSBub3QgaW1wbGVtZW50ZWQuXG4gICAgICogQHBhcmFtIHZpZXdQb3J0IE9iamVjdCB0byB1cGRhdGUgdmlld3BvcnQgd2l0aC5cbiAgICAgKi9cbiAgICBzZXRWaWV3UG9ydCh2aWV3UG9ydCkge1xuICAgICAgICAvLyBXaGV0aGVyIHRoZSB2aWV3cG9ydCBoYXMgY2hhbmdlZC5cbiAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gSWYgem9vbSBoYXMgYmVlbiBzcGVjaWZpZWQuXG4gICAgICAgIGlmICh2aWV3UG9ydC56b29tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFpvb20gdG8gc3BlY2lmaWVkIHpvb20uXG4gICAgICAgICAgICB0aGlzLl90aW1lbGluZVpvb20gPSB2aWV3UG9ydC56b29tO1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGltZXN0YW1wIGhhcyBiZWVuIHNwZWNpZmllZC5cbiAgICAgICAgaWYgKHZpZXdQb3J0LnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBTZXQgc3RhcnQgdGltZSB0byBzcGVjaWZpZWQgdGltZS5cbiAgICAgICAgICAgIGlmICh2aWV3UG9ydC50aW1lc3RhbXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld1N0YXJ0VGltZSA9IHZpZXdQb3J0LnRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmlld1BvcnQucGxheVZpZXdQb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXlWaWV3UG9ydCA9IHZpZXdQb3J0LnBsYXlWaWV3UG9ydDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgcGxheWJhY2sgc3BlZWQgaGFzIGJlZW4gc2V0LCBzZXQgdGhlIG5ldyBwbGF5YmFjayBzcGVlZC5cbiAgICAgICAgaWYgKHZpZXdQb3J0LnBsYXlTcGVlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RyYXdQbGF5aGVhZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFZpZXdQb3J0OiB2aWV3UG9ydC5wbGF5U3BlZWQgd2FzIHNldCwgYnV0IGRyYXdQbGF5aGVhZCB3YXMgbm90IHNldCBpbiBjb25zdHJ1Y3RvcicpO1xuICAgICAgICAgICAgdGhpcy5fcGxheVNwZWVkID0gdmlld1BvcnQucGxheVNwZWVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBwbGF5aGVhZCBwbGF5aW5nLyBub3QgcGxheWluZy5cbiAgICAgICAgaWYgKHZpZXdQb3J0LnBsYXlQbGF5aGVhZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RyYXdQbGF5aGVhZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFZpZXdQb3J0OiB2aWV3UG9ydC5wbGF5UGxheWhlYWQgd2FzIHNldCwgYnV0IGRyYXdQbGF5aGVhZCB3YXMgbm90IHNldCBpbiBjb25zdHJ1Y3RvcicpO1xuICAgICAgICAgICAgdGhpcy5fcGxheUhlYWRQbGF5aW5nID0gdmlld1BvcnQucGxheVBsYXloZWFkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aWV3UG9ydC5wbGF5aGVhZFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kcmF3UGxheWhlYWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRWaWV3UG9ydDogdmlld1BvcnQucGxheWhlYWRUaW1lIHdhcyBzZXQsIGJ1dCBkcmF3UGxheWhlYWQgd2FzIG5vdCBzZXQgaW4gY29uc3RydWN0b3InKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXlIZWFkVGltZSA9IE1hdGgubWF4KDAsIHZpZXdQb3J0LnBsYXloZWFkVGltZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGxheUhlYWRUaW1lID4gMClcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVEcmF3TGFzdFRpbWUgPSB0aGlzLl9wbGF5SGVhZFRpbWU7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWRyYXcgdGltZWxpbmUgaWYgYW55dGhpbmcgaGFzIGNoYW5nZWQuXG4gICAgICAgIGlmIChjaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnJlZHJhd1RpbWVsaW5lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNjZXNzb3IgZm9yIHBvbGxpbmcgdGhlIGN1cnJlbnRseSBob3ZlcmVkIG92ZXIgb2JqZWN0LlxuICAgICAqL1xuICAgIGdldEhvdmVyZWRPYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ob3ZlcmVkT3ZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgaGVpZ2h0IHRvIGdpdmUgdG8gZWFjaCByb3cgdG8gZml0IGFsbCBsYXllcnMgb24gc2NyZWVuLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGxheWVycyBNYXAgb2YgbGF5ZXJzIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyBIZWlnaHQgb2Ygcm93cy5cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVSb3dIZWlnaHQobGF5ZXJzKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihNQVhfTEFZRVJfSEVJR0hULCB0aGlzLl9jYW52YXNIZWlnaHQgLyBPYmplY3Qua2V5cyhsYXllcnMpLmxlbmd0aCk7XG4gICAgfVxuICAgIHVwZGF0ZUxheWVyTGFiZWxzKCkge1xuICAgICAgICAvLyBTdG9yZSBsYXllcnMgdG8gZHJhdy5cbiAgICAgICAgY29uc3QgbyA9IHRoaXMuZ2V0TGF5ZXJzVG9EcmF3KCk7XG4gICAgICAgIGlmICghaXNFcXVhbCh0aGlzLl9sYXllckxhYmVscywgby5sYXllcnMpKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllckxhYmVscyA9IG8ubGF5ZXJzO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHJvdyBoZWlnaHQuXG4gICAgICAgICAgICB0aGlzLl9yb3dIZWlnaHQgPSB0aGlzLmNhbGN1bGF0ZVJvd0hlaWdodCh0aGlzLl9sYXllckxhYmVscyk7XG4gICAgICAgICAgICAvLyBTZXQgdGltZWxpbmUgb2JqZWN0IGhlaWdodC5cbiAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lT2JqZWN0SGVpZ2h0ID0gdGhpcy5fcm93SGVpZ2h0ICogVElNRUxJTkVfT0JKRUNUX0hFSUdIVDtcbiAgICAgICAgICAgIHRoaXMuX251bWJlck9mTGF5ZXJzID0gT2JqZWN0LmtleXModGhpcy5fbGF5ZXJMYWJlbHMpLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX3Jvd3NUb3RhbEhlaWdodCA9IHRoaXMuX3Jvd0hlaWdodCAqIHRoaXMuX251bWJlck9mTGF5ZXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBsYXllciBsYWJlbHMgdG8gdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBkcmF3TGF5ZXJMYWJlbHMoKSB7XG4gICAgICAgIGxldCByb3cgPSAwO1xuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggbGF5ZXJzLlxuICAgICAgICBmb3IgKGxldCBsYXllck5hbWUgb2YgT2JqZWN0LmtleXModGhpcy5fbGF5ZXJMYWJlbHMpKSB7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuZmlsbFN0eWxlID0gQ09MT1JfTEFCRUxfQkFDS0dST1VORDtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsUmVjdCgwLCByb3cgKiB0aGlzLl9yb3dIZWlnaHQsIHRoaXMuX2xheWVyTGFiZWxXaWR0aCwgdGhpcy5fcm93SGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsU3R5bGUgPSBURVhUX0NPTE9SO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLmZvbnQgPSBURVhUX0ZPTlRfU0laRS50b1N0cmluZygpICsgJ3B4ICcgKyBURVhUX0ZPTlRfRkFNSUxZO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxUZXh0KGxheWVyTmFtZSwgMCwgKHJvdyAqIHRoaXMuX3Jvd0hlaWdodCkgKyAodGhpcy5fcm93SGVpZ2h0IC8gMiksIHRoaXMuX2xheWVyTGFiZWxXaWR0aCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGF5ZXJMYWJlbHNbbGF5ZXJOYW1lXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsU3R5bGUgPSBDT0xPUl9MSU5FO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsUmVjdCh0aGlzLl9sYXllckxhYmVsV2lkdGgsIHJvdyAqIHRoaXMuX3Jvd0hlaWdodCwgdGhpcy5fdmlld0RyYXdXaWR0aCwgVEhJQ0tORVNTX0xJTkUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIHRpbWVsaW5lIGJhY2tncm91bmQuXG4gICAgICovXG4gICAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5maWxsU3R5bGUgPSBDT0xPUl9CQUNLR1JPVU5EO1xuICAgICAgICB0aGlzLl9jYW52YXMuZmlsbFJlY3QoMCwgMCwgdGhpcy5fY2FudmFzV2lkdGgsIHRoaXMuX2NhbnZhc0hlaWdodCk7XG4gICAgICAgIHRoaXMuZHJhd0JhY2tncm91bmRSdWxlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgcnVsZXIgb24gdG9wIG9mIGJhY2tncm91bmRcbiAgICAgKi9cbiAgICBkcmF3QmFja2dyb3VuZFJ1bGVyKCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMudmlld1JhbmdlO1xuICAgICAgICBjb25zdCBlbmRUaW1lID0gdGhpcy52aWV3RW5kVGltZTtcbiAgICAgICAgY29uc3QgY2lyY2FOdW1iZXJPZkxpbmVzID0gNTtcbiAgICAgICAgY29uc3Qgcm91bmRlciA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nMTAocmFuZ2UgLyBjaXJjYU51bWJlck9mTGluZXMpKSk7IC8vIFdoYXQgdG8gcm91bmQgdGhlIHJ1bGVyIHRvXG4gICAgICAgIGNvbnN0IHJvdW5kZXJOZXh0ID0gcm91bmRlciAqIDEwO1xuICAgICAgICBjb25zdCBudW1iZXJPZkxpbmVzID0gTWF0aC5mbG9vcihyYW5nZSAvIHJvdW5kZXIpO1xuICAgICAgICBjb25zdCBydWxlckRpZmYgPSByb3VuZGVyO1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBNYXRoLmZsb29yKHRoaXMuX3ZpZXdTdGFydFRpbWUgLyByb3VuZGVyKSAqIHJvdW5kZXI7XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSAoTWF0aC5taW4oMSwgY2lyY2FOdW1iZXJPZkxpbmVzIC8gbnVtYmVyT2ZMaW5lcykpO1xuICAgICAgICBpZiAocnVsZXJEaWZmKSB7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3Ryb2tlU3R5bGUgPSBSVUxFUl9MSU5FX0NPTE9SO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLmxpbmVXaWR0aCA9IFJVTEVSX0xJTkVfV0lEVEg7XG4gICAgICAgICAgICBmb3IgKGxldCBydWxlclRpbWUgPSBzdGFydFRpbWU7IHJ1bGVyVGltZSA8IGVuZFRpbWU7IHJ1bGVyVGltZSArPSBydWxlckRpZmYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgbGV0IHggPSB0aGlzLnRpbWVUb1hDb29yZChydWxlclRpbWUpO1xuICAgICAgICAgICAgICAgIGxldCBkaXN0YW5jZVRvTmV4dCA9IChydWxlclRpbWUgLyByb3VuZGVyTmV4dCkgJSAxO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZVRvTmV4dCA+IDAuNSlcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VUb05leHQgLT0gMTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZVRvTmV4dCA9IE1hdGguYWJzKGRpc3RhbmNlVG9OZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VUb05leHQgPCAwLjAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElzIGEgc2lnbmlmaWNhbnQgbGluZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHggPj0gdGhpcy5fdmlld0RyYXdYKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5tb3ZlVG8oeCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5saW5lVG8oeCwgdGhpcy5fY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgcGxheWhlYWQgaW5pdGlhbGx5LlxuICAgICAqL1xuICAgIGRyYXdQbGF5aGVhZCgpIHtcbiAgICAgICAgLy8gSWYgdGhlIHBsYXloZWFkIHNob3VsZCBiZSBkcmF3LlxuICAgICAgICBpZiAodGhpcy5fZHJhd1BsYXloZWFkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc3RpbWVJblZpZXcodGhpcy5fcGxheUhlYWRUaW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsU3R5bGUgPSBDT0xPUl9QTEFZSEVBRDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuZmlsbFJlY3QodGhpcy50aW1lVG9YQ29vcmQodGhpcy5fcGxheUhlYWRUaW1lKSwgMCwgVEhJQ0tORVNTX1BMQVlIRUFELCB0aGlzLl9jYW52YXNIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxheWVycyB0byBkcmF3IGZyb20gdGhlIHRpbWVsaW5lLlxuICAgICAqL1xuICAgIGdldExheWVyc1RvRHJhdygpIHtcbiAgICAgICAgdGhpcy5faG92ZXJlZE9iamVjdE1hcCA9IHt9O1xuICAgICAgICBjb25zdCBsYXllcnNBcnJheSA9IHRoaXMuX3Jlc29sdmVkU3RhdGVzID8gT2JqZWN0LmtleXModGhpcy5fcmVzb2x2ZWRTdGF0ZXMubGF5ZXJzKSA6IFtdO1xuICAgICAgICBsYXllcnNBcnJheS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBpZiAoYSA+IGIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAoYSA8IGIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGxheWVycyA9IHt9O1xuICAgICAgICBsYXllcnNBcnJheS5mb3JFYWNoKChsYXllck5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsYXllcnNbbGF5ZXJOYW1lXSA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5faG92ZXJlZE9iamVjdE1hcFtsYXllck5hbWVdID0gW107XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGF5ZXJzOiBsYXllcnMsXG4gICAgICAgICAgICBsYXllcnNBcnJheTogbGF5ZXJzQXJyYXlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkcmF3cyB0aGUgdGltZWxpbmUgdG8gdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICByZWRyYXdUaW1lbGluZSgpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzLmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jYW52YXNXaWR0aCwgdGhpcy5fY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgICAgICB0aGlzLmRyYXdMYXllckxhYmVscygpO1xuICAgICAgICAvLyBSZWNvbXB1dGUgb2JqZWN0cyBwb3NpdGlvbnNcbiAgICAgICAgdGhpcy5fdGltZWxpbmVTdGF0ZSA9IHRoaXMuZ2V0VGltZWxpbmVEcmF3U3RhdGUodGhpcy5fcmVzb2x2ZWRTdGF0ZXMpO1xuICAgICAgICAvLyBEcmF3IHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAgICB0aGlzLmRyYXdUaW1lbGluZVN0YXRlKHRoaXMuX3RpbWVsaW5lU3RhdGUpO1xuICAgICAgICB0aGlzLmRyYXdQbGF5aGVhZCgpO1xuICAgICAgICB0aGlzLmNoZWNrQXV0b21hdGljUmVyZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgdGltZWxpbmUgc3RhdGUgdG8gdGhlIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0ge1RpbWVsaW5lRHJhd1N0YXRlfSBjdXJyZW50RHJhd1N0YXRlIFN0YXRlIHRvIGRyYXcuXG4gICAgICovXG4gICAgZHJhd1RpbWVsaW5lU3RhdGUoY3VycmVudERyYXdTdGF0ZSkge1xuICAgICAgICBmb3IgKGxldCBlbGVtZW50IGluIGN1cnJlbnREcmF3U3RhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRyYXdTdGF0ZSA9IGN1cnJlbnREcmF3U3RhdGVbZWxlbWVudF07XG4gICAgICAgICAgICBpZiAoZHJhd1N0YXRlLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuZmlsbFN0eWxlID0gQ09MT1JfVElNRUxJTkVfT0JKRUNUX0ZJTEw7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxSZWN0KGRyYXdTdGF0ZS5sZWZ0LCBkcmF3U3RhdGUudG9wLCBkcmF3U3RhdGUud2lkdGgsIGRyYXdTdGF0ZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHJva2VTdHlsZSA9IENPTE9SX1RJTUVMSU5FX09CSkVDVF9CT1JERVI7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLmxpbmVXaWR0aCA9IFRISUNLTkVTU19USU1FTElORV9PQkpFQ1RfQk9SREVSO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHJva2VSZWN0KGRyYXdTdGF0ZS5sZWZ0LCBkcmF3U3RhdGUudG9wLCBkcmF3U3RhdGUud2lkdGgsIGRyYXdTdGF0ZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsU3R5bGUgPSBURVhUX0NPTE9SO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5mb250ID0gVEVYVF9GT05UX1NJWkUudG9TdHJpbmcoKSArICdweCAnICsgVEVYVF9GT05UX0ZBTUlMWTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxUZXh0KGRyYXdTdGF0ZS50aXRsZSwgZHJhd1N0YXRlLmxlZnQsIGRyYXdTdGF0ZS50b3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRyYXcgc3RhdGVzIGZvciBhbGwgdGltZWxpbmUgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge1Jlc29sdmVkU3RhdGVzfSB0aW1lbGluZSBUaW1lbGluZSB0byBkcmF3LlxuICAgICAqIEByZXR1cm5zIHtUaW1lbGluZURyYXdTdGF0ZX0gU3RhdGUgb2YgdGltZS1iYXNlZCBvYmplY3RzLlxuICAgICAqL1xuICAgIGdldFRpbWVsaW5lRHJhd1N0YXRlKHRpbWVsaW5lKSB7XG4gICAgICAgIGxldCBjdXJyZW50RHJhd1N0YXRlID0ge307XG4gICAgICAgIGlmICh0aW1lbGluZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgb2JqSWQgaW4gdGltZWxpbmUub2JqZWN0cykge1xuICAgICAgICAgICAgICAgIGxldCB0aW1lbGluZU9iaiA9IHRpbWVsaW5lLm9iamVjdHNbb2JqSWRdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IF9pID0gMDsgX2kgPCB0aW1lbGluZU9iai5yZXNvbHZlZC5pbnN0YW5jZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZU9iaiA9IHRpbWVsaW5lT2JqLnJlc29sdmVkLmluc3RhbmNlc1tfaV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBuYW1lID0gJ3RpbWVsaW5lT2JqZWN0OicgKyBvYmpJZCArICc6JyArIGluc3RhbmNlT2JqLmlkO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHJhd1N0YXRlW25hbWVdID0gdGhpcy5jcmVhdGVTdGF0ZUZvck9iamVjdCh0aW1lbGluZU9iaiwgaW5zdGFuY2VPYmouc3RhcnQsIGluc3RhbmNlT2JqLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RHJhd1N0YXRlW25hbWVdLnZpc2libGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faG92ZXJlZE9iamVjdE1hcFt0aW1lbGluZU9iai5sYXllciArICcnXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ob3ZlcmVkT2JqZWN0TWFwW3RpbWVsaW5lT2JqLmxheWVyICsgJyddID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ob3ZlcmVkT2JqZWN0TWFwW3RpbWVsaW5lT2JqLmxheWVyICsgJyddLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0WDogY3VycmVudERyYXdTdGF0ZVtuYW1lXS5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFg6IGN1cnJlbnREcmF3U3RhdGVbbmFtZV0ubGVmdCArIGN1cnJlbnREcmF3U3RhdGVbbmFtZV0ud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0UmVmSWQ6IG9iaklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWQ6IGluc3RhbmNlT2JqLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0aW1lbGluZU9iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnREcmF3U3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkcmF3IHN0YXRlIGZvciBhIHRpbWVsaW5lIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgT2JqZWN0J3MgbGF5ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IHRpbWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgdGltZS5cbiAgICAgKiBAcmV0dXJucyB7RHJhd1N0YXRlfSBTdGF0ZSBvZiB0aGUgb2JqZWN0IHRvIGRyYXcuXG4gICAgICovXG4gICAgY3JlYXRlU3RhdGVGb3JPYmplY3Qob2JqLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIC8vIERlZmF1bHQgc3RhdGUgKGhpZGRlbikuXG4gICAgICAgIGxldCBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgdGl0bGU6ICdOL0EnXG4gICAgICAgIH07XG4gICAgICAgIC8vIFN0YXRlIHNob3VsZCBiZSBkZWZhdWx0IGlmIHRoZSBvYmplY3QgaXMgbm90IGJlaW5nIHNob3duLlxuICAgICAgICBpZiAodGhpcy5zaG93T25UaW1lbGluZShzdGFydCwgZW5kKSkge1xuICAgICAgICAgICAgLy8gR2V0IG9iamVjdCBkaW1lbnNpb25zIGFuZCBwb3NpdGlvbi5cbiAgICAgICAgICAgIGxldCBvYmplY3RXaWR0aCA9IHRoaXMuZ2V0T2JqZWN0V2lkdGgoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICBsZXQgeENvb3JkID0gdGhpcy5jYXBYY29vcmRUb1ZpZXcodGhpcy50aW1lVG9YQ29vcmQoc3RhcnQpKTtcbiAgICAgICAgICAgIGxldCBvYmplY3RUb3AgPSB0aGlzLmdldE9iamVjdE9mZnNldEZyb21Ub3Aob2JqLmxheWVyICsgJycpO1xuICAgICAgICAgICAgLy8gU2V0IHN0YXRlIHByb3BlcnRpZXMuXG4gICAgICAgICAgICBzdGF0ZS5oZWlnaHQgPSB0aGlzLl90aW1lbGluZU9iamVjdEhlaWdodDtcbiAgICAgICAgICAgIHN0YXRlLmxlZnQgPSB4Q29vcmQ7XG4gICAgICAgICAgICBzdGF0ZS50b3AgPSBvYmplY3RUb3A7XG4gICAgICAgICAgICBzdGF0ZS53aWR0aCA9IG9iamVjdFdpZHRoO1xuICAgICAgICAgICAgc3RhdGUudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICBzdGF0ZS50aXRsZSA9IG9iai5pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG9mZnNldCwgaW4gcGl4ZWxzIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSB0aW1lbGluZSBmb3IgYW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBzdGFydCB0aW1lIG9mIHRoZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge251bWJlcn0gT2Zmc2V0IGluIHBpeGVscy5cbiAgICAgKi9cbiAgICAvLyBwcml2YXRlIGdldE9iamVjdE9mZnNldEZyb21UaW1lbGluZVN0YXJ0IChzdGFydDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAvLyBcdC8vIENhbGN1bGF0ZSBvZmZzZXQuXG4gICAgLy8gXHRsZXQgb2Zmc2V0ID0gKHN0YXJ0IC0gdGhpcy5fdmlld1N0YXJ0VGltZSkgKiB0aGlzLnBpeGVsc1dpZHRoUGVyVW5pdFRpbWVcbiAgICAvLyBcdC8vIE9mZnNldCBjYW5ub3QgYmUgdG8gdGhlIGxlZnQgb2YgdGhlIHRpbWVsaW5lIHN0YXJ0IHBvc2l0aW9uLlxuICAgIC8vIFx0aWYgKG9mZnNldCA8IDApIHtcbiAgICAvLyBcdFx0b2Zmc2V0ID0gMFxuICAgIC8vIFx0fVxuICAgIC8vIFx0cmV0dXJuIG9mZnNldFxuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB3aWR0aCwgaW4gcGl4ZWxzLCBvZiBhbiBvYmplY3QgYmFzZWQgb24gaXRzIGR1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCB0aW1lIG9mIHRoZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgdGltZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFdpZHRoIGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBnZXRPYmplY3RXaWR0aChzdGFydFRpbWUsIGVuZFRpbWUpIHtcbiAgICAgICAgaWYgKCFlbmRUaW1lKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhc1dpZHRoO1xuICAgICAgICAvLyBJZiB0aGUgc3RhcnQgdGltZSBpcyBsZXNzIHRoYW4gdGhlIHRpbWVsaW5lIHN0YXJ0LCBzZXQgdG8gdGltZWxpbmUgc3RhcnQuXG4gICAgICAgIGlmIChzdGFydFRpbWUgPCB0aGlzLl92aWV3U3RhcnRUaW1lKSB7XG4gICAgICAgICAgICBzdGFydFRpbWUgPSB0aGlzLl92aWV3U3RhcnRUaW1lO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbGN1bGF0ZSBkdXJhdGlvbiBvZiB0aGUgb2JqZWN0IHJlbWFpbmluZyBvbiB0aGUgdGltZWxpbmUuXG4gICAgICAgIGxldCBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgIC8vIFJldHVybiBlbmQgcG9pbnQgcG9zaXRpb24gaW4gcGl4ZWxzLlxuICAgICAgICByZXR1cm4gZHVyYXRpb24gKiB0aGlzLnBpeGVsc1dpZHRoUGVyVW5pdFRpbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0byBzaG93IGFuIG9iamVjdCBvbiB0aGUgdGltZWxpbmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IE9iamVjdCBzdGFydCB0aW1lLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgT2JqZWN0IGVuZCB0aW1lLlxuICAgICAqIEByZXR1cm5zIHt0cnVlfSBpZiBvYmplY3Qgc2hvdWxkIGJlIHNob3duIG9uIHRoZSB0aW1lbGluZS5cbiAgICAgKi9cbiAgICBzaG93T25UaW1lbGluZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGxldCBpc0FmdGVyID0gc3RhcnQgPj0gdGhpcy52aWV3RW5kVGltZTtcbiAgICAgICAgbGV0IGlzQmVmb3JlID0gKGVuZCB8fCBJbmZpbml0eSkgPD0gdGhpcy5fdmlld1N0YXJ0VGltZTtcbiAgICAgICAgcmV0dXJuICFpc0FmdGVyICYmICFpc0JlZm9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHBvc2l0aW9uIG9mIG9iamVjdCBpbnN0YW5jZSBmcm9tIHRvcCBvZiB0aW1lbGluZSBhY2NvcmRpbmcgdG8gaXRzIGxheWVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciBPYmplY3QncyBsYXllci5cbiAgICAgKiBAcmV0dXJucyBQb3NpdGlvbiByZWxhdGl2ZSB0byB0b3Agb2YgY2FudmFzIGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBnZXRPYmplY3RPZmZzZXRGcm9tVG9wKGxheWVyTmFtZSkge1xuICAgICAgICBsZXQgdG9wID0gdGhpcy5fbGF5ZXJMYWJlbHNbbGF5ZXJOYW1lXTtcbiAgICAgICAgcmV0dXJuIHRvcCAqIHRoaXMuX3Jvd0hlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIHBsYXloZWFkLiBDYWxsZWQgcGVyaW9kaWNhbGx5LlxuICAgICAqL1xuICAgIHVwZGF0ZURyYXcoKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIC8vIEhvdyBsb25nIHRpbWUgc2luY2UgbGFzdCB1cGRhdGU6XG4gICAgICAgIGNvbnN0IGR0ID0gKHRoaXMuX3VwZGF0ZURyYXdMYXN0VGltZSA+IDAgP1xuICAgICAgICAgICAgbm93IC0gdGhpcy5fdXBkYXRlRHJhd0xhc3RUaW1lIDpcbiAgICAgICAgICAgIDEpIC8gMTAwMDtcbiAgICAgICAgdGhpcy5fdXBkYXRlRHJhd0xhc3RUaW1lID0gbm93O1xuICAgICAgICBjb25zdCBkZWx0YVRpbWUgPSB0aGlzLl9wbGF5U3BlZWQgKiBkdDtcbiAgICAgICAgLy8gQ2hlY2sgcGxheWhlYWQgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgICBsZXQgbmVlZFJlZHJhdyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fcGxheUhlYWRQbGF5aW5nICYmIHRoaXMuX2RyYXdQbGF5aGVhZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BsYXlWaWV3UG9ydCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaXN0aW1lSW5WaWV3KHRoaXMuX3BsYXlIZWFkVGltZSkgLy8gT25seSBwbGF5IGlmIHBsYXloZWFkIGlzIGluIHZpZXdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdTdGFydFRpbWUgKz0gZGVsdGFUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTW92ZSBwbGF5aGVhZCBmb3J3YXJkXG4gICAgICAgICAgICB0aGlzLl9wbGF5SGVhZFRpbWUgKz0gZGVsdGFUaW1lO1xuICAgICAgICAgICAgbmVlZFJlZHJhdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRSZWRyYXcpIHtcbiAgICAgICAgICAgIHRoaXMucmVkcmF3VGltZWxpbmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYWxsIHRoaXMgZnVuY3Rpb24gb24gbmV4dCBmcmFtZVxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMudXBkYXRlRHJhdygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBtb3VzZSBkb3duIGV2ZW50LlxuICAgICAqIEBwYXJhbSBldmVudCBNb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBjYW52YXNNb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgLy8gU3RvcmUgbW91c2UgaXMgZG93bi5cbiAgICAgICAgdGhpcy5fbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgLy8gU3RvcmUgWCBwb3NpdGlvbiBvZiBtb3VzZSBvbiBjbGljay5cbiAgICAgICAgdGhpcy5fbW91c2VMYXN0WCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIC8vIFByZXZlbnQgZXZlbnQuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG1vdXNlIHVwIGV2ZW50LlxuICAgICAqIEBwYXJhbSBldmVudCBNb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBjYW52YXNNb3VzZVVwKGV2ZW50KSB7XG4gICAgICAgIC8vIE1vdXNlIG5vIGxvbmdlciBkb3duLlxuICAgICAgICB0aGlzLl9tb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgLy8gUmVzZXQgc2Nyb2xsIGRpcmVjdGlvbi5cbiAgICAgICAgdGhpcy5fbGFzdFNjcm9sbERpcmVjdGlvbiA9IDA7XG4gICAgICAgIC8vIFByZXZlbnQgZXZlbnQuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG1vdXNlIG1vdmVtZW50IG9uIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgTW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgY2FudmFzTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIC8vIElmIG1vdXNlIGlzIGRvd24uXG4gICAgICAgIGlmICh0aGlzLl9tb3VzZURvd24pIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBiZWdpbm5pbmcgc2Nyb2xsaW5nLCB3ZSBjYW4gbW92ZSBmcmVlbHkuXG4gICAgICAgICAgICBpZiAodGhpcy5fbGFzdFNjcm9sbERpcmVjdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX2xhc3RTY3JvbGxEaXJlY3Rpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBjdXJyZW50IG1vdXNlIFguXG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VMYXN0WCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNoYW5nZSBpbiBYLlxuICAgICAgICAgICAgICAgIGxldCBkZWx0YVggPSBldmVudC5jbGllbnRYIC0gdGhpcy5fbW91c2VMYXN0WDtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBzY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChkZWx0YVggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RTY3JvbGxEaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RTY3JvbGxEaXJlY3Rpb24gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTY3JvbGwgdG8gbmV3IFggcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTY3JvbGxCeURlbHRhWCgtZGVsdGFYKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBzY3JvbGwgZGlyZWN0aW9uLlxuICAgICAgICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSB0aGlzLl9tb3VzZUxhc3RYIC0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgICAgICAgICAvLyBJZiBjaGFuZ2luZyBkaXJlY3Rpb24sIHN0b3JlIG5ldyBkaXJlY3Rpb24gYnV0IGRvbid0IHNjcm9sbC5cbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uIDwgMCAmJiB0aGlzLl9sYXN0U2Nyb2xsRGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlTGFzdFggPSBldmVudC5jbGllbnRYO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0U2Nyb2xsRGlyZWN0aW9uID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA+IDAgJiYgdGhpcy5fbGFzdFNjcm9sbERpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW91c2VMYXN0WCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RTY3JvbGxEaXJlY3Rpb24gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNoYW5nZSBpbiBYLlxuICAgICAgICAgICAgICAgICAgICBsZXQgZGVsdGFYID0gZXZlbnQuY2xpZW50WCAtIHRoaXMuX21vdXNlTGFzdFg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIGxhc3QgWCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW91c2VMYXN0WCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgYnkgY2hhbmdlIGluIFguXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2Nyb2xsQnlEZWx0YVgoLWRlbHRhWCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVkcmF3IHRpbWVsaW5lLlxuICAgICAgICAgICAgdGhpcy5yZWRyYXdUaW1lbGluZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2hldGhlciBhbiBvYmplY3QgaXMgdW5kZXIgdGhlIGN1cnNvci5cbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgb2JqZWN0IHRoYXQgaXMgY3VycmVudGx5IGhvdmVyZWQgb3Zlci5cbiAgICAgICAgICAgIGxldCBtb3VzZVBvcyA9IHRoaXMuZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzQ29udGFpbmVyLCBldmVudCk7XG4gICAgICAgICAgICBpZiAobW91c2VQb3MueCA+IHRoaXMuX3ZpZXdEcmF3WCkge1xuICAgICAgICAgICAgICAgIGlmIChtb3VzZVBvcy55IDwgdGhpcy5fcm93c1RvdGFsSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3RlZFJvdyA9IE1hdGguZmxvb3IoKG1vdXNlUG9zLnkgLyB0aGlzLl9yb3dzVG90YWxIZWlnaHQpICogdGhpcy5fbnVtYmVyT2ZMYXllcnMpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGF5ZXI7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2xheWVyTGFiZWxzKS5mb3JFYWNoKGxheWVyTmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGF5ZXJMYWJlbHNbbGF5ZXJOYW1lXSA9PT0gc2VsZWN0ZWRSb3cpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIgPSBsYXllck5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaG92ZXJNYXBEYXRhID0gKGxheWVyID8gdGhpcy5faG92ZXJlZE9iamVjdE1hcFtsYXllcl0gOiBbXSkgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGhvdmVyTWFwRGF0YS5mb3JFYWNoKG9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0LnN0YXJ0WCA8PSBtb3VzZVBvcy54ICYmIG9iamVjdC5lbmRYID49IG1vdXNlUG9zLngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaG92ZXJIYXNoID0gb2JqZWN0LnR5cGUgKyBvYmplY3Qub2JqZWN0UmVmSWQgKyBvYmplY3QuaW5zdGFuY2VJZDsgLy8gaGFzaC1pc2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGFzdEhvdmVyZWRIYXNoICE9PSBob3Zlckhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IG9iamVjdCBtZXRhZGF0YSBmcm9tIHRoZSBvYmplY3QgbmFtZSBvZiB0aGUgaG92ZXJlZCBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBob3ZlcmluZyBvdmVyIGEgdGltZWxpbmUgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0LnR5cGUgPT09ICd0aW1lbGluZU9iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdGltZWxpbmUgb2JqZWN0IGFuZCB0aGUgaW5zdGFuY2UgYmVpbmcgaG92ZXJlZCBvdmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkU3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRpbWVsaW5lT2JqZWN0ID0gdGhpcy5fcmVzb2x2ZWRTdGF0ZXMub2JqZWN0c1tvYmplY3Qub2JqZWN0UmVmSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IHRpbWVsaW5lT2JqZWN0LnJlc29sdmVkLmluc3RhbmNlcy5maW5kKGluc3RhbmNlID0+IGluc3RhbmNlLmlkID09PSBvYmplY3QuaW5zdGFuY2VJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCBob3ZlciBpbmZvLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaG92ZXJJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aW1lbGluZU9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXI6IHsgeFBvc3Rpb246IG1vdXNlUG9zLngsIHlQb3NpdGlvbjogbW91c2VQb3MueSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBjdXJyZW50bHkgaG92ZXJlZCBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hvdmVyZWRPdmVyID0gaG92ZXJJbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbWl0IGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3RpbWVsaW5lOmhvdmVyJywgeyBkZXRhaWw6IHRoaXMuX2hvdmVyZWRPdmVyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSBsYXN0IGl0ZW1zLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RIb3ZlckFjdGlvbiA9IE1PVVNFSU47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdEhvdmVyZWRIYXNoID0gaG92ZXJIYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbWl0IHVuZGVmaW5lZCB3aGVuIG1vdXNlIG91dC5cbiAgICAgICAgICAgIGlmICghZm91bmQgJiYgdGhpcy5fbGFzdEhvdmVyQWN0aW9uID09PSBNT1VTRUlOKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd0aW1lbGluZTpob3ZlcicsIHsgZGV0YWlsOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdEhvdmVyQWN0aW9uID0gTU9VU0VPVVQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBzY3JvbGwgd2hlZWwgZXZlbnRzIG9uIHRoZSBjYW52YXMuXG4gICAgICogQHBhcmFtIGV2ZW50IFNjcm9sbCBldmVudC5cbiAgICAgKi9cbiAgICBjYW52YXNTY3JvbGxXaGVlbChldmVudCkge1xuICAgICAgICAvLyBHZXQgbW91c2UgcG9pbnRlciBjb29yZGluYXRlcyBvbiBjYW52YXMuXG4gICAgICAgIGxldCBjYW52YXNDb29yZCA9IHRoaXMuZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzQ29udGFpbmVyLCBldmVudCk7XG4gICAgICAgIC8vIERvbid0IHNjcm9sbCBpZiBtb3VzZSBpcyBub3Qgb3ZlciB0aW1lbGluZS5cbiAgICAgICAgaWYgKGNhbnZhc0Nvb3JkLnggPD0gdGhpcy5fdmlld0RyYXdYKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQ1RSTCArIHNjcm9sbCB0byB6b29tLlxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmRlbHRhWSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHpvb21GYWN0b3IgPSBNYXRoLnBvdyhaT09NX0ZBQ1RPUiwgLWV2ZW50LmRlbHRhWSk7XG4gICAgICAgICAgICAgICAgdGhpcy56b29tVW5kZXJDdXJzb3IoY2FudmFzQ29vcmQueCwgem9vbUZhY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuZGVsdGFYICE9PSAwKSB7IC8vIFNjcm9sbCBvbiB4LWF4aXNcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gUGFuLlxuICAgICAgICAgICAgdGhpcy5jYW52YXNTY3JvbGxCeURlbHRhWCgoZXZlbnQuZGVsdGFYICogKFBBTl9GQUNUT1IgKiB0aGlzLnN0ZXBTaXplKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmRlbHRhWSAhPT0gMCAmJiBldmVudC5hbHRLZXkgPT09IHRydWUpIHsgLy8gQWxzbyBzY3JvbGwgb24gYWx0LWtleSArIHNjcm9sbCB5LWF4aXNcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gUGFuLlxuICAgICAgICAgICAgdGhpcy5jYW52YXNTY3JvbGxCeURlbHRhWCgoZXZlbnQuZGVsdGFZICogKFBBTl9GQUNUT1IgKiB0aGlzLnN0ZXBTaXplKSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgZXZlbnQuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgLy8gUmVkcmF3IHRpbWVsaW5lLlxuICAgICAgICAgICAgdGhpcy5yZWRyYXdUaW1lbGluZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjcm9sbCBhY3Jvc3MgdGhlIGNhbnZhcyBieSBhIHNwZWNpZmllZCBYIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVggVmFsdWUgdG8gbW92ZSBieS5cbiAgICAgKi9cbiAgICBjYW52YXNTY3JvbGxCeURlbHRhWChkZWx0YVgpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBzdGFydGluZyB0aW1lLlxuICAgICAgICBsZXQgdGFyZ2V0U3RhcnQgPSB0aGlzLl92aWV3U3RhcnRUaW1lICsgKGRlbHRhWCAvIHRoaXMucGl4ZWxzV2lkdGhQZXJVbml0VGltZSk7XG4gICAgICAgIC8vIFN0YXJ0aW5nIHRpbWUgY2Fubm90IGJlIDwgMC5cbiAgICAgICAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgdGFyZ2V0U3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9wdGltaXNhdGlvbiwgZG9uJ3QgcmVkcmF3IGlmIG5vdGhpbmcgaGFzIGNoYW5nZWQuXG4gICAgICAgIGlmICh0YXJnZXRTdGFydCA9PT0gdGhpcy5fdmlld1N0YXJ0VGltZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZpZXdTdGFydFRpbWUgPSB0YXJnZXRTdGFydDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogWm9vbXMgaW50by9vdXQgb2YgdGltZWxpbmUsIGtlZXBpbmcgdGhlIHRpbWUgdW5kZXIgdGhlIGN1cnNvciBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gY3Vyc29yWCBQb3NpdGlvbiBvZiBtb3VzZSBjdXJzb3IuXG4gICAgICovXG4gICAgem9vbVVuZGVyQ3Vyc29yKGN1cnNvclgsIHpvb21GYWN0b3IpIHtcbiAgICAgICAgLy8gUG9pbnQgaW4gdGltZSBvZiB0aGUgY3Vyc29yXG4gICAgICAgIGxldCBjdXJzb3JUaW1lID0gdGhpcy54Q29vcmRUb1RpbWUoY3Vyc29yWCk7XG4gICAgICAgIC8vIFJhdGlvIChpbiB2aWV3IHJhbmdlKSBvZiB0aGUgY3Vyc29yXG4gICAgICAgIGxldCBjdXJzb3JSYXRpbyA9IHRoaXMudGltZVRvUmF0aW8oY3Vyc29yVGltZSk7XG4gICAgICAgIC8vIENoYW5nZSB6b29tOlxuICAgICAgICB0aGlzLl90aW1lbGluZVpvb20gPSB0aGlzLl90aW1lbGluZVpvb20gKiB6b29tRmFjdG9yO1xuICAgICAgICAvLyBMaW1pdCB3aXRoaW4gY3VycmVudCB2aWV3XG4gICAgICAgIGN1cnNvclJhdGlvID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgY3Vyc29yUmF0aW8pKTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHN0YXJ0XG4gICAgICAgIGxldCB0YXJnZXRTdGFydCA9IGN1cnNvclRpbWUgLSAoY3Vyc29yUmF0aW8gKiB0aGlzLnZpZXdSYW5nZSk7XG4gICAgICAgIC8vIFN0YXJ0IGNhbm5vdCBiZSBsZXNzIHRoYW4gMFxuICAgICAgICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgICAgICAgICB0YXJnZXRTdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IGRyYXcgdGltZVxuICAgICAgICB0aGlzLl92aWV3U3RhcnRUaW1lID0gdGFyZ2V0U3RhcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1vdXNlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB0b3AtbGVmdCBvZiB0aGUgY2FudmFzIFtwaXhlbHNdXG4gICAgICogQHBhcmFtIGNhbnZhc1xuICAgICAqIEBwYXJhbSBldnRcbiAgICAgKiBAcmV0dXJucyB7eDogbnVtYmVyLCB5OiBudW1iZXJ9IFBvc2l0aW9uLlxuICAgICAqL1xuICAgIGdldE1vdXNlUG9zKGNhbnZhcywgZXZ0KSB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBldnQuY2xpZW50WCAtIHJlY3QubGVmdCxcbiAgICAgICAgICAgIHk6IGV2dC5jbGllbnRZIC0gcmVjdC50b3BcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpbXMgYSB0aW1lbGluZSBzbyB0aGF0IG9iamVjdHMgb25seSBleGlzdCB3aXRoaW4gYSBzcGVjaWZpZWQgdGltZSBwZXJpb2QuXG4gICAgICogQHBhcmFtIHRpbWVsaW5lIFRpbWVsaW5lIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHRyaW0gVGltZXMgdG8gdHJpbSBiZXR3ZWVuLlxuICAgICAqL1xuICAgIHRyaW1UaW1lbGluZSh0aW1lbGluZSwgdHJpbSkge1xuICAgICAgICAvLyBUaGUgbmV3IHJlc29sdmVkIG9iamVjdHMuXG4gICAgICAgIGxldCBuZXdPYmplY3RzID0ge307XG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCByZXNvbHZlZCBvYmplY3RzLlxuICAgICAgICBPYmplY3Qua2V5cyh0aW1lbGluZS5vYmplY3RzKS5mb3JFYWNoKChvYmpJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0gdGltZWxpbmUub2JqZWN0c1tvYmpJZF07XG4gICAgICAgICAgICBjb25zdCByZXN1bHRpbmdJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgICAgIG9iai5yZXNvbHZlZC5pbnN0YW5jZXMuZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2hldGhlciB0byBpbnNlcnQgdGhpcyBvYmplY3QgaW50byB0aGUgbmV3IHRpbWVsaW5lLlxuICAgICAgICAgICAgICAgIGxldCB1c2VJbnN0YW5jZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBuZXdJbnN0YW5jZSA9IE9iamVjdC5hc3NpZ24oe30sIGluc3RhbmNlKTsgLy8gY2xvbmVcbiAgICAgICAgICAgICAgICAvLyBJZiB0cmltbWluZyB0aGUgc3RhcnQgdGltZS5cbiAgICAgICAgICAgICAgICBpZiAodHJpbS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGVuZHMgYWZ0ZXIgdGhlIHRyaW0gc3RhcnQgdGltZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKChpbnN0YW5jZS5lbmQgfHwgSW5maW5pdHkpID4gdHJpbS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlSW5zdGFuY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luc3RhbmNlLnN0YXJ0IDwgdHJpbS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luc3RhbmNlLnN0YXJ0ID0gdHJpbS5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0cmltbWluZyB0aGUgZW5kIHRpbWUuXG4gICAgICAgICAgICAgICAgaWYgKHRyaW0uZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3Qgc3RhcnRzIGJlZm9yZSB0aGUgdHJpbSBlbmQgdGltZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXJ0IDwgdHJpbS5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUluc3RhbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobmV3SW5zdGFuY2UuZW5kIHx8IEluZmluaXR5KSA+IHRyaW0uZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5zdGFuY2UuZW5kID0gdHJpbS5lbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0cmltLnN0YXJ0ICYmICF0cmltLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICB1c2VJbnN0YW5jZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1c2VJbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgICAgICBuZXdJbnN0YW5jZS5zdGFydCA8IChuZXdJbnN0YW5jZS5lbmQgfHwgSW5maW5pdHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0luc3RhbmNlcy5wdXNoKG5ld0luc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzbid0IGEgcmVzb2x2ZWQgb2JqZWN0IGZvciB0aGUgbmV3IGluc3RhbmNlLCBjcmVhdGUgaXQuXG4gICAgICAgICAgICBpZiAoIW5ld09iamVjdHNbb2JqSWRdKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld09iamVjdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogb2JqLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZTogb2JqLmVuYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG9iai5pZCxcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IG9iai5sYXllcixcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbERlZXA6IG9iai5yZXNvbHZlZC5sZXZlbERlZXAsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZDogb2JqLnJlc29sdmVkLnJlc29sdmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2aW5nOiBvYmoucmVzb2x2ZWQucmVzb2x2aW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0UmVmZXJlbmNlczogb2JqLnJlc29sdmVkLmRpcmVjdFJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG5ld09iamVjdHNbb2JqSWRdID0gbmV3T2JqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3T2JqZWN0c1tvYmpJZF0ucmVzb2x2ZWQuaW5zdGFuY2VzID0gcmVzdWx0aW5nSW5zdGFuY2VzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsYXNzZXM6IHRpbWVsaW5lLmNsYXNzZXMsXG4gICAgICAgICAgICBsYXllcnM6IHRpbWVsaW5lLmxheWVycyxcbiAgICAgICAgICAgIG9iamVjdHM6IG5ld09iamVjdHMsXG4gICAgICAgICAgICBvcHRpb25zOiB0aW1lbGluZS5vcHRpb25zLFxuICAgICAgICAgICAgc3RhdGlzdGljczogdGltZWxpbmUuc3RhdGlzdGljcyxcbiAgICAgICAgICAgIHN0YXRlOiB0aW1lbGluZS5zdGF0ZSxcbiAgICAgICAgICAgIG5leHRFdmVudHM6IHRpbWVsaW5lLm5leHRFdmVudHNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHR3byB0aW1lbGluZXMgYnkgbWVyZ2luZyBpbnN0YW5jZXMgb2Ygb2JqZWN0cyB0aGF0IGludGVyc2VjdCBlYWNoIG90aGVyLlxuICAgICAqIEBwYXJhbSBwYXN0IE9sZGVyIHRpbWVsaW5lLlxuICAgICAqIEBwYXJhbSBwcmVzZW50IE5ld2VyIHRpbWVsaW5lLlxuICAgICAqIEByZXR1cm5zIHtSZXNvbHZlZFRpbWVsaW5lfSBjb250YWluaW5nIG1lcmdlZCB0aW1lbGluZXMuXG4gICAgICovXG4gICAgbWVyZ2VUaW1lbGluZU9iamVjdHMocGFzdCwgcHJlc2VudCwgZnJvbU5ld1RpbWVsaW5lKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdGluZ09iamVjdHMgPSB7fTtcbiAgICAgICAgaWYgKGZyb21OZXdUaW1lbGluZSkge1xuICAgICAgICAgICAgcGFzdCA9IHRoaXMudHJpbVRpbWVsaW5lKHBhc3QsIHsgZW5kOiB0aGlzLl9wbGF5SGVhZFRpbWUgfSk7XG4gICAgICAgICAgICBwcmVzZW50ID0gdGhpcy50cmltVGltZWxpbmUocHJlc2VudCwgeyBzdGFydDogdGhpcy5fcGxheUhlYWRUaW1lIH0pO1xuICAgICAgICAgICAgLy8gQmVjYXVzZSB3ZSB3YW50IHRvIGtlZXAgb2xkIG9iamVjdHMsIHRoaXMgaXRlcmF0b3IgaXMgdXNlZCB0byBjcmVhdGUgdW5pcXVlIG9sZCBpZHMgZm9yIHRoZW1cbiAgICAgICAgICAgIHRoaXMuX21lcmdlSXRlcmF0b3IrKztcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhc3Qub2JqZWN0cykuZm9yRWFjaCgob2JqSWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXN0T2JqID0gcGFzdC5vYmplY3RzW29iaklkXTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlOiBoYWNrIHRvIG1hcmsgaXQgYXMgYSBcInBhc3Qgb2JqZWN0XCJcbiAgICAgICAgICAgICAgICBpZiAocGFzdE9iai5fX3Bhc3RPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBvdmVyIGl0IHJpZ2h0IGF3YXksIGl0J3Mgb2xkLiBEb24ndCBkbyBhbnl0aGluZyBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ09iamVjdHNbb2JqSWRdID0gcGFzdE9iajtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBhbiBvYmplY3QgZXhpc3RzIGluIGJvdGggdGltZWxpbmVzXG4gICAgICAgICAgICAgICAgY29uc3QgcHJlc2VudE9iaiA9IHByZXNlbnQub2JqZWN0c1tvYmpJZF07XG4gICAgICAgICAgICAgICAgaWYgKHByZXNlbnRPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wYXJlIHRoZSBvYmplY3RzLCBvbmx5IGxvb2sgaW50byBtZXJnaW5nIHRoZW0gaWYgdGhleSBsb29rIGlkZW50aWNhbFxuICAgICAgICAgICAgICAgICAgICBpc0VxdWFsKE9iamVjdC5hc3NpZ24oe30sIHBhc3RPYmosIHsgcmVzb2x2ZWQ6IG51bGwgfSksIE9iamVjdC5hc3NpZ24oe30sIHByZXNlbnRPYmosIHsgcmVzb2x2ZWQ6IG51bGwgfSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCBhbGwgcGFzdCBpbnN0YW5jZXMgc3RvcCBhdCBhIGNlcnRhaW4gdGltZSBhdCB0aGUgdmVyeSBsYXRlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhhdCBhbGwgbmV3IGluc3RhbmNlcyBzdGFydCBhdCB0aGF0IHRpbWUgYXQgdGhlIHZlcnkgZWFybGllc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIGluc3RhbmNlcyBvZiB0aG9zZSBvYmplY3RzLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsSW5zdGFuY2VzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXN0T2JqLnJlc29sdmVkLmluc3RhbmNlcy5mb3JFYWNoKHBhc3RJbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsSW5zdGFuY2VzW3Bhc3RJbnN0YW5jZS5lbmQgKyAnJ10gPSBwYXN0SW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnRPYmoucmVzb2x2ZWQuaW5zdGFuY2VzLmZvckVhY2gocHJlc2VudEluc3RhbmNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsSW5zdGFuY2VzW3ByZXNlbnRJbnN0YW5jZS5zdGFydCArICcnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgaW5zdGFuY2VzIGFyZSBuZXh0IHRvIGVhY2ggb3RoZXIsIG1lcmdlIHRoZW0gaW50byBvbmU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEluc3RhbmNlc1twcmVzZW50SW5zdGFuY2Uuc3RhcnQgKyAnJ10uZW5kID0gcHJlc2VudEluc3RhbmNlLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEluc3RhbmNlc1twcmVzZW50SW5zdGFuY2Uuc3RhcnQgKyAnJ10gPSBwcmVzZW50SW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW50T2JqLnJlc29sdmVkLmluc3RhbmNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYWxsSW5zdGFuY2VzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBhbGxJbnN0YW5jZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW50T2JqLnJlc29sdmVkLmluc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBvdmVyIHRoZSBuZXcgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdPYmplY3RzW29iaklkXSA9IHByZXNlbnRPYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGRvbid0IGNvcHkgb3ZlciBvbGQgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb2JqZWN0cyBkb2Vzbid0IGxvb2sgaWRlbnRpY2FsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IG92ZXIgdGhlIG5ldyBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ09iamVjdHNbb2JqSWRdID0gcHJlc2VudE9iajtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9sZCBvYmplY3QgZG9lc24ndCBleGlzdCBpbiB0aGUgbmV3IHRpbWVsaW5lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IGhhY2sgdG8gbWFyayBpdCBhcyBhIFwicGFzdCBvYmplY3RcIlxuICAgICAgICAgICAgICAgIHBhc3RPYmouX19wYXN0T2JqID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBDb3B5IG92ZXIgdGhlIG9sZCBvYmplY3RcbiAgICAgICAgICAgICAgICByZXN1bHRpbmdPYmplY3RzW3RoaXMuX21lcmdlSXRlcmF0b3IgKyAnX18nICsgb2JqSWRdID0gcGFzdE9iajtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBuZXh0IG9iamVjdHNcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByZXNlbnQub2JqZWN0cykuZm9yRWFjaCgob2JqSWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVzZW50T2JqID0gcHJlc2VudC5vYmplY3RzW29iaklkXTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhc3Qub2JqZWN0c1tvYmpJZF0pIHsgLy8gKGlmIGl0IGRpZCBleGlzdGVkIGluIHRoZSBwYXN0LCBpdCBoYXMgYWxyZWFkeSBiZWVuIGhhbmRsZWQpXG4gICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgY29weSBvdmVyIHRoZSBuZXcgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ09iamVjdHNbb2JqSWRdID0gcHJlc2VudE9iajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIG5ldyB0aW1lbGluZSwgb2JqZWN0cyBhbmQgaW5zdGFuY2VzIGFyZSBvbmx5IGFkZGVkXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwYXN0Lm9iamVjdHMpLmZvckVhY2goKG9iaklkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFzdE9iaiA9IHBhc3Qub2JqZWN0c1tvYmpJZF07XG4gICAgICAgICAgICAgICAgcmVzdWx0aW5nT2JqZWN0c1tvYmpJZF0gPSBwYXN0T2JqO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwcmVzZW50Lm9iamVjdHMpLmZvckVhY2goKG9iaklkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlc2VudE9iaiA9IHByZXNlbnQub2JqZWN0c1tvYmpJZF07XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdPYmogPSByZXN1bHRpbmdPYmplY3RzW29iaklkXTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2Ugd2l0aCBvbGQgaW5zdGFuY2VzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSW5zdGFuY2VzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nT2JqLnJlc29sdmVkLmluc3RhbmNlcy5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5zdGFuY2VzW2luc3RhbmNlLnN0YXJ0ICsgJ18nICsgaW5zdGFuY2UuZW5kXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBwcmVzZW50T2JqLnJlc29sdmVkLmluc3RhbmNlcy5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgcHVzaCBpbnN0YW5jZXMgdGhhdCBhcmVuJ3QgYWxyZWFkeSBwcmVzZW50OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZ0luc3RhbmNlc1tpbnN0YW5jZS5zdGFydCArICdfJyArIGluc3RhbmNlLmVuZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ09iai5yZXNvbHZlZC5pbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nT2JqZWN0c1tvYmpJZF0gPSBwcmVzZW50T2JqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdGluZ0xheWVycyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhyZXN1bHRpbmdPYmplY3RzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvYmogPSByZXN1bHRpbmdPYmplY3RzW2tleV07XG4gICAgICAgICAgICBjb25zdCBsYXllciA9IG9iai5sYXllciArICcnO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHRpbmdMYXllcnNbbGF5ZXJdKVxuICAgICAgICAgICAgICAgIHJlc3VsdGluZ0xheWVyc1tsYXllcl0gPSBbXTtcbiAgICAgICAgICAgIHJlc3VsdGluZ0xheWVyc1tsYXllcl0ucHVzaChrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHByZXNlbnQsIHsgb2JqZWN0czogcmVzdWx0aW5nT2JqZWN0cywgbGF5ZXJzOiByZXN1bHRpbmdMYXllcnMgfSk7XG4gICAgfVxuICAgIHVwZGF0ZVRpbWVsaW5lUmVzb2x2ZVdpbmRvdygpIHtcbiAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSB0aGlzLmdldEV4cGFuZGVkU3RhcnRFbmRUaW1lKDEpO1xuICAgICAgICB0aGlzLl90aW1lbGluZVJlc29sdmVTdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLl90aW1lbGluZVJlc29sdmVFbmQgPSBlbmQ7XG4gICAgICAgIHRoaXMuX3RpbWVsaW5lUmVzb2x2ZVpvb20gPSB0aGlzLl90aW1lbGluZVpvb207XG4gICAgICAgIGlmICh0aGlzLmxhdGVzdFVwZGF0ZVRpbWUpIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBhbiBvcHRpbWFsIG51bWJlciBvZiBvYmplY3RzIHRvIGNyZWF0ZSwgc28gdGhhdCB0aGUgZHJhd2luZyBzdGlsbCBydW5zIHNtb290aGx5LlxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UmVzb2x2ZVRpbWUgPSA1MDsgLy8gbXNcbiAgICAgICAgICAgIGxldCByYXRpbyA9IHRhcmdldFJlc29sdmVUaW1lIC8gdGhpcy5sYXRlc3RVcGRhdGVUaW1lO1xuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlQ291bnRBZGp1c3QgPSBNYXRoLm1heCgwLjEsIE1hdGgubWluKDEwLCAoMSArICh0aGlzLl90aW1lbGluZVJlc29sdmVDb3VudEFkanVzdCAqIHJhdGlvKSkgLyAyKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RXhwYW5kZWRTdGFydEVuZFRpbWUobXVsdGlwbGllciA9IDEpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5fdmlld1N0YXJ0VGltZTtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMudmlld0VuZFRpbWU7XG4gICAgICAgIGxldCBkdXJhdGlvbiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICBsZXQgZXhwYW5kID0gZHVyYXRpb24gKiAodGhpcy5fdGltZWxpbmVSZXNvbHZlRXhwYW5kIC0gMSkgKiBtdWx0aXBsaWVyO1xuICAgICAgICBzdGFydCAtPSBleHBhbmQgKiAwLjMzO1xuICAgICAgICBlbmQgKz0gZXhwYW5kICogMC42NjsgLy8gZXhwYW5kIG1vcmUgaW50byB0aGUgZnV0dXJlXG4gICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnQpO1xuICAgICAgICBlbmQgPSBNYXRoLm1heCgwLCBlbmQpO1xuICAgICAgICBjb25zdCB6b29tRGlmZiA9IE1hdGgubWF4KHRoaXMuX3RpbWVsaW5lUmVzb2x2ZVpvb20sIHRoaXMuX3RpbWVsaW5lWm9vbSkgL1xuICAgICAgICAgICAgTWF0aC5taW4odGhpcy5fdGltZWxpbmVSZXNvbHZlWm9vbSwgdGhpcy5fdGltZWxpbmVab29tKTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCwgem9vbURpZmYgfTtcbiAgICB9XG4gICAgY2hlY2tBdXRvbWF0aWNSZXJlc29sdmUoKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgem9vbURpZmYgfSA9IHRoaXMuZ2V0RXhwYW5kZWRTdGFydEVuZFRpbWUoMC4yKTtcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUF1dG8gJiYgKHN0YXJ0IDwgdGhpcy5fdGltZWxpbmVSZXNvbHZlU3RhcnQgfHxcbiAgICAgICAgICAgIGVuZCA+IHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUVuZCB8fFxuICAgICAgICAgICAgem9vbURpZmYgPiAzKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlcmVzb2x2ZVRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcmVzb2x2ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXJlc29sdmVUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUaW1lbGluZVJlc29sdmVXaW5kb3coKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGltZWxpbmUoKTtcbiAgICAgICAgICAgICAgICB9LCBNYXRoLm1heCgxMDAsIHRoaXMubGF0ZXN0VXBkYXRlVGltZSAqIDUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gQ29udmVyc2lvbnMgYmV0d2VlbiBwb3NpdGlvbiAmIHRpbWUgLS0tLS0tLS0tLS0tLVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgWCBjb29yZGluYXRlIG9mIGEgdGltZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaGUgdGltZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHRpbWUuXG4gICAgICovXG4gICAgdGltZVRvWENvb3JkKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdEcmF3WCArICgodGltZSAtIHRoaXMuX3ZpZXdTdGFydFRpbWUpICogdGhpcy5waXhlbHNXaWR0aFBlclVuaXRUaW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSB0aW1lIG9mIGEgWCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFRoZSBYIGNvb3JkaW5hdGUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgdGltZSBvZiB0aGUgWCBjb29yZGluYXRlLlxuICAgICAqL1xuICAgIHhDb29yZFRvVGltZShwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlld1N0YXJ0VGltZSArICgocG9zaXRpb24gLSB0aGlzLl92aWV3RHJhd1gpIC8gdGhpcy5waXhlbHNXaWR0aFBlclVuaXRUaW1lKTtcbiAgICB9XG4gICAgLyoqIENhbGN1bGF0ZSB0aGUgcmF0aW8gb2YgdGhlIHRpbWUgaW4gY3VycmVudCB2aWV3ICgwIGkgYmVnaW5uaW5nLCAxIGlzIGVuZCkgICovXG4gICAgdGltZVRvUmF0aW8odGltZSkge1xuICAgICAgICByZXR1cm4gKHRpbWUgLSB0aGlzLl92aWV3U3RhcnRUaW1lKSAvIHRoaXMudmlld1JhbmdlO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBwb3NpdGlvbiBpcyB3aXRoaW4gdGhlIGN1cnJlbnQgdmlldyAgKi9cbiAgICBpc3RpbWVJblZpZXcodGltZSkge1xuICAgICAgICBjb25zdCByYXRpbyA9IHRoaXMudGltZVRvUmF0aW8odGltZSk7XG4gICAgICAgIHJldHVybiByYXRpbyA+PSAwICYmIHJhdGlvIDwgMTtcbiAgICB9XG4gICAgY2FwWGNvb3JkVG9WaWV3KHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLl92aWV3RHJhd1gsIE1hdGgubWluKHRoaXMuX3ZpZXdEcmF3WCArIHRoaXMuX3ZpZXdEcmF3V2lkdGgsIHBvc2l0aW9uKSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tIEdldHRlcnMgLyBDb252ZW5pZW5jZSBmdW5jdGlvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLyoqIFpvb20gZmFjdG9yIFtwaXhlbHMgLyB0aW1lXSAqL1xuICAgIGdldCBwaXhlbHNXaWR0aFBlclVuaXRUaW1lKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3RpbWVsaW5lWm9vbSAvIDEwMCk7XG4gICAgfVxuICAgIC8qKiBUaGUgcmFuZ2Ugb2YgdGhlIHZpZXcgW3RpbWVdICovXG4gICAgZ2V0IHZpZXdSYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdEcmF3V2lkdGggLyB0aGlzLnBpeGVsc1dpZHRoUGVyVW5pdFRpbWU7XG4gICAgfVxuICAgIC8qKiBUaGUgZW5kIHRpbWUgb2YgdGhlIHZpZXcgW3RpbWVdICovXG4gICAgZ2V0IHZpZXdFbmRUaW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlld1N0YXJ0VGltZSArIHRoaXMudmlld1JhbmdlO1xuICAgIH1cbn1cbmV4cG9ydHMuVGltZWxpbmVWaXN1YWxpemVyID0gVGltZWxpbmVWaXN1YWxpemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZWxpbmVWaXN1YWxpemVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBvYmplY3RDcmVhdGVQb2x5ZmlsbFxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBvYmplY3RLZXlzUG9seWZpbGxcbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgZnVuY3Rpb25CaW5kUG9seWZpbGxcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfZXZlbnRzJykpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxudmFyIGhhc0RlZmluZVByb3BlcnR5O1xudHJ5IHtcbiAgdmFyIG8gPSB7fTtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sICd4JywgeyB2YWx1ZTogMCB9KTtcbiAgaGFzRGVmaW5lUHJvcGVydHkgPSBvLnggPT09IDA7XG59IGNhdGNoIChlcnIpIHsgaGFzRGVmaW5lUHJvcGVydHkgPSBmYWxzZSB9XG5pZiAoaGFzRGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgaW5wdXQgaXMgYSBwb3NpdGl2ZSBudW1iZXIgKHdob3NlIHZhbHVlIGlzIHplcm8gb3JcbiAgICAgIC8vIGdyZWF0ZXIgYW5kIG5vdCBhIE5hTikuXG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBhcmcgIT09IGFyZylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xufVxuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiblwiIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuLy8gVGhlc2Ugc3RhbmRhbG9uZSBlbWl0KiBmdW5jdGlvbnMgYXJlIHVzZWQgdG8gb3B0aW1pemUgY2FsbGluZyBvZiBldmVudFxuLy8gaGFuZGxlcnMgZm9yIGZhc3QgY2FzZXMgYmVjYXVzZSBlbWl0KCkgaXRzZWxmIG9mdGVuIGhhcyBhIHZhcmlhYmxlIG51bWJlciBvZlxuLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmVcbi8vIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHRodXMgZG8gbm90IGdldCBkZW9wdGltaXplZCwgc28gdGhlIGNvZGVcbi8vIGluc2lkZSB0aGVtIGNhbiBleGVjdXRlIGZhc3Rlci5cbmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSkge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmdzKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBldmVudHM7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cylcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09IG51bGwpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmICghaGFuZGxlcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGlzRm4gPSB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJztcbiAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgc3dpdGNoIChsZW4pIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICBjYXNlIDE6XG4gICAgICBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICBkZWZhdWx0OlxuICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKCFldmVudHMpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmICghZXhpc3RpbmcpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSkge1xuICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgXCInICsgU3RyaW5nKHR5cGUpICsgJ1wiIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQuJyk7XG4gICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCclczogJXMnLCB3Lm5hbWUsIHcubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMl0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gYmluZC5jYWxsKG9uY2VXcmFwcGVyLCBzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKCFsaXN0KVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoIWV2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoIWV2ZW50cylcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmICghZXZsaXN0ZW5lcilcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0Lm93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpLlxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSlcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvYmplY3RDcmVhdGVQb2x5ZmlsbChwcm90bykge1xuICB2YXIgRiA9IGZ1bmN0aW9uKCkge307XG4gIEYucHJvdG90eXBlID0gcHJvdG87XG4gIHJldHVybiBuZXcgRjtcbn1cbmZ1bmN0aW9uIG9iamVjdEtleXNQb2x5ZmlsbChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIgayBpbiBvYmopIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrKSkge1xuICAgIGtleXMucHVzaChrKTtcbiAgfVxuICByZXR1cm4gaztcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQmluZFBvbHlmaWxsKGNvbnRleHQpIHtcbiAgdmFyIGZuID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiIsIi8qKlxuICogTG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pzLmZvdW5kYXRpb24vPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXG4gICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyksXG4gICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcbiAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAqIGVxdWl2YWxlbnQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIG9iamVjdCA9PT0gb3RoZXI7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VxdWFsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV2ZW50VHlwZSA9IHZvaWQgMDtcbnZhciBFdmVudFR5cGU7XG4oZnVuY3Rpb24gKEV2ZW50VHlwZSkge1xuICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJTVEFSVFwiXSA9IDBdID0gXCJTVEFSVFwiO1xuICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJFTkRcIl0gPSAxXSA9IFwiRU5EXCI7XG4gICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIktFWUZSQU1FXCJdID0gMl0gPSBcIktFWUZSQU1FXCI7XG59KShFdmVudFR5cGUgPSBleHBvcnRzLkV2ZW50VHlwZSB8fCAoZXhwb3J0cy5FdmVudFR5cGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlS2V5ZnJhbWUgPSBleHBvcnRzLnZhbGlkYXRlT2JqZWN0ID0gZXhwb3J0cy52YWxpZGF0ZVRpbWVsaW5lID0gZXhwb3J0cy5SZXNvbHZlciA9IHZvaWQgMDtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hcGkvZW51bXNcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXBpL2FwaVwiKSwgZXhwb3J0cyk7XG52YXIgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyL3Jlc29sdmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVzb2x2ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVyXzEuUmVzb2x2ZXI7IH0gfSk7XG52YXIgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyL3ZhbGlkYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmFsaWRhdGVUaW1lbGluZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfMS52YWxpZGF0ZVRpbWVsaW5lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmFsaWRhdGVPYmplY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlXzEudmFsaWRhdGVPYmplY3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YWxpZGF0ZUtleWZyYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWxpZGF0ZV8xLnZhbGlkYXRlS2V5ZnJhbWU7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FjaGVSZXN1bHQgPSBleHBvcnRzLmFwcGx5UGFyZW50SW5zdGFuY2VzID0gZXhwb3J0cy5zZXRJbnN0YW5jZVN0YXJ0VGltZSA9IGV4cG9ydHMuc2V0SW5zdGFuY2VFbmRUaW1lID0gZXhwb3J0cy5yZXNldElkID0gZXhwb3J0cy5nZXRJZCA9IGV4cG9ydHMuam9pbkNhcHMgPSBleHBvcnRzLmFkZENhcHNUb1Jlc3VtaW5nID0gZXhwb3J0cy5qb2luUmVmZXJlbmNlcyA9IGV4cG9ydHMuaXNSZWZlcmVuY2UgPSBleHBvcnRzLmNhcEluc3RhbmNlcyA9IGV4cG9ydHMuYXBwbHlSZXBlYXRpbmdJbnN0YW5jZXMgPSBleHBvcnRzLm9wZXJhdGVPbkFycmF5cyA9IGV4cG9ydHMuaW52ZXJ0SW5zdGFuY2VzID0gZXhwb3J0cy5jb252ZXJ0RXZlbnRzVG9JbnN0YW5jZXMgPSBleHBvcnRzLmNsZWFuSW5zdGFuY2VzID0gZXhwb3J0cy5zb3J0RXZlbnRzID0gZXhwb3J0cy5pc051bWVyaWMgPSBleHBvcnRzLmlzQ29uc3RhbnQgPSBleHBvcnRzLmV4dGVuZE1hbmRhZG9yeSA9IHZvaWQgMDtcbmNvbnN0IF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcbi8qKlxuICogU29tZXdoYXQgbGlrZSBfLmV4dGVuZCwgYnV0IHdpdGggc3Ryb25nIHR5cGVzICYgbWFuZGF0ZWQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gb3JpZ2luYWwgT2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0gZXh0ZW5kT2JqIHByb3BlcnRpZXMgdG8gYWRkXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZE1hbmRhZG9yeShvcmlnaW5hbCwgZXh0ZW5kT2JqKSB7XG4gICAgcmV0dXJuIF8uZXh0ZW5kKG9yaWdpbmFsLCBleHRlbmRPYmopO1xufVxuZXhwb3J0cy5leHRlbmRNYW5kYWRvcnkgPSBleHRlbmRNYW5kYWRvcnk7XG5mdW5jdGlvbiBpc0NvbnN0YW50KHN0cikge1xuICAgIHJldHVybiAhIShpc051bWVyaWMoc3RyKSB8fCAoXy5pc1N0cmluZyhzdHIpICYmIChzdHIubWF0Y2goL150cnVlJC8pIHx8IHN0ci5tYXRjaCgvXmZhbHNlJC8pKSkpO1xufVxuZXhwb3J0cy5pc0NvbnN0YW50ID0gaXNDb25zdGFudDtcbmZ1bmN0aW9uIGlzTnVtZXJpYyhzdHIpIHtcbiAgICBpZiAoc3RyID09PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKF8uaXNOdW1iZXIoc3RyKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKF8uaXNTdHJpbmcoc3RyKSlcbiAgICAgICAgcmV0dXJuICEhKHN0ci5tYXRjaCgvXlstK10/WzAtOS5dKyQvKSAmJiAhXy5pc05hTihwYXJzZUZsb2F0KHN0cikpKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzTnVtZXJpYyA9IGlzTnVtZXJpYztcbmZ1bmN0aW9uIHNvcnRFdmVudHMoZXZlbnRzKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGlmIChhLnRpbWUgPiBiLnRpbWUpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEudGltZSA8IGIudGltZSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgY29uc3QgYUlkID0gYS5kYXRhICYmIChhLmRhdGEuaWQgfHwgKGEuZGF0YS5pbnN0YW5jZSAmJiBhLmRhdGEuaW5zdGFuY2UuaWQpKTtcbiAgICAgICAgY29uc3QgYklkID0gYi5kYXRhICYmIChiLmRhdGEuaWQgfHwgKGIuZGF0YS5pbnN0YW5jZSAmJiBiLmRhdGEuaW5zdGFuY2UuaWQpKTtcbiAgICAgICAgaWYgKGFJZCAmJiBiSWQgJiYgYUlkID09PSBiSWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBldmVudCByZWZlciB0byB0aGUgc2FtZSBJRCwgbGV0IHRoZSBlbmRpbmcgZXZlbnQgYmUgZmlyc3Q6XG4gICAgICAgICAgICBpZiAoYS52YWx1ZSAmJiAhYi52YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBpZiAoIWEudmFsdWUgJiYgYi52YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS52YWx1ZSAmJiAhYi52YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoIWEudmFsdWUgJiYgYi52YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG59XG5leHBvcnRzLnNvcnRFdmVudHMgPSBzb3J0RXZlbnRzO1xuLyoqXG4gKiBDbGVhbiB1cCBpbnN0YW5jZXMsIGpvaW4gb3ZlcmxhcHBpbmcgZXRjLi5cbiAqIEBwYXJhbSBpbnN0YW5jZXNcbiAqL1xuZnVuY3Rpb24gY2xlYW5JbnN0YW5jZXMoaW5zdGFuY2VzLCBhbGxvd01lcmdlLCBhbGxvd1plcm9HYXBzID0gZmFsc2UpIHtcbiAgICAvLyBGaXJzdCwgb3B0aW1pemUgZm9yIGNlcnRhaW4gY29tbW9uIHNpdHVhdGlvbnM6XG4gICAgaWYgKGluc3RhbmNlcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBpZiAoaW5zdGFuY2VzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzWzBdO1xuICAgICAgICBpZiAoIWluc3RhbmNlLmVuZClcbiAgICAgICAgICAgIGluc3RhbmNlLmVuZCA9IG51bGw7XG4gICAgICAgIHJldHVybiBbaW5zdGFuY2VdO1xuICAgIH1cbiAgICBjb25zdCBldmVudHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlc1tpXTtcbiAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgdGltZTogaW5zdGFuY2Uuc3RhcnQsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHsgaW5zdGFuY2U6IGluc3RhbmNlIH0sXG4gICAgICAgICAgICByZWZlcmVuY2VzOiBpbnN0YW5jZS5yZWZlcmVuY2VzLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluc3RhbmNlLmVuZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRpbWU6IGluc3RhbmNlLmVuZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGF0YTogeyBpbnN0YW5jZTogaW5zdGFuY2UgfSxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBpbnN0YW5jZS5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRFdmVudHNUb0luc3RhbmNlcyhldmVudHMsIGFsbG93TWVyZ2UsIGFsbG93WmVyb0dhcHMpO1xufVxuZXhwb3J0cy5jbGVhbkluc3RhbmNlcyA9IGNsZWFuSW5zdGFuY2VzO1xuZnVuY3Rpb24gY29udmVydEV2ZW50c1RvSW5zdGFuY2VzKGV2ZW50cywgYWxsb3dNZXJnZSwgYWxsb3daZXJvR2FwcyA9IGZhbHNlKSB7XG4gICAgc29ydEV2ZW50cyhldmVudHMpO1xuICAgIGNvbnN0IGFjdGl2ZUluc3RhbmNlcyA9IHt9O1xuICAgIGxldCBhY3RpdmVJbnN0YW5jZUlkID0gbnVsbDtcbiAgICBsZXQgcHJldmlvdXNBY3RpdmUgPSBmYWxzZTtcbiAgICBjb25zdCBuZWdhdGl2ZUluc3RhbmNlcyA9IHt9O1xuICAgIGxldCBwcmV2aW91c05lZ2F0aXZlID0gZmFsc2U7XG4gICAgbGV0IG5lZ2F0aXZlSW5zdGFuY2VJZCA9IG51bGw7XG4gICAgY29uc3QgcmV0dXJuSW5zdGFuY2VzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbaV07XG4gICAgICAgIGNvbnN0IGV2ZW50SWQgPSBldmVudC5kYXRhLmlkIHx8IGV2ZW50LmRhdGEuaW5zdGFuY2UuaWQ7XG4gICAgICAgIGNvbnN0IGxhc3RJbnN0YW5jZSA9IHJldHVybkluc3RhbmNlc1tyZXR1cm5JbnN0YW5jZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChldmVudC52YWx1ZSkge1xuICAgICAgICAgICAgYWN0aXZlSW5zdGFuY2VzW2V2ZW50SWRdID0gZXZlbnQ7XG4gICAgICAgICAgICBkZWxldGUgbmVnYXRpdmVJbnN0YW5jZXNbZXZlbnRJZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgYWN0aXZlSW5zdGFuY2VzW2V2ZW50SWRdO1xuICAgICAgICAgICAgbmVnYXRpdmVJbnN0YW5jZXNbZXZlbnRJZF0gPSBldmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoYWN0aXZlSW5zdGFuY2VzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIGFuIGFjdGl2ZSBpbnN0YW5jZVxuICAgICAgICAgICAgaWYgKCFhbGxvd01lcmdlICYmICFhbGxvd1plcm9HYXBzICYmIGxhc3RJbnN0YW5jZSAmJiBwcmV2aW91c05lZ2F0aXZlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgcHJldmlvdXNseSBhbiBpbkFjdGl2ZSAobmVnYXRpdmUpIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgbGFzdEluc3RhbmNlLnN0YXJ0ID0gZXZlbnQudGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG8gPSBoYW5kbGVBY3RpdmVJbnN0YW5jZXMoZXZlbnQsIGxhc3RJbnN0YW5jZSwgYWN0aXZlSW5zdGFuY2VJZCwgZXZlbnRJZCwgYWN0aXZlSW5zdGFuY2VzLCBhbGxvd01lcmdlLCBhbGxvd1plcm9HYXBzKTtcbiAgICAgICAgICAgICAgICBhY3RpdmVJbnN0YW5jZUlkID0gby5hY3RpdmVJbnN0YW5jZUlkO1xuICAgICAgICAgICAgICAgIGlmIChvLnJldHVybkluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybkluc3RhbmNlcy5wdXNoKG8ucmV0dXJuSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHByZXZpb3VzTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIGluc3RhbmNlcyBhcmUgYWN0aXZlXG4gICAgICAgICAgICBpZiAobGFzdEluc3RhbmNlICYmIHByZXZpb3VzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgbGFzdEluc3RhbmNlLmVuZCA9IGV2ZW50LnRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobmVnYXRpdmVJbnN0YW5jZXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBhIG5lZ2F0aXZlIGluc3RhbmNlIHJ1bm5pbmdcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbyA9IGhhbmRsZUFjdGl2ZUluc3RhbmNlcyhldmVudCwgbGFzdEluc3RhbmNlLCBuZWdhdGl2ZUluc3RhbmNlSWQsIGV2ZW50SWQsIG5lZ2F0aXZlSW5zdGFuY2VzLCBhbGxvd01lcmdlLCBhbGxvd1plcm9HYXBzKTtcbiAgICAgICAgICAgICAgICAgICAgbmVnYXRpdmVJbnN0YW5jZUlkID0gby5hY3RpdmVJbnN0YW5jZUlkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoby5yZXR1cm5JbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuSW5zdGFuY2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm8ucmV0dXJuSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG8ucmV0dXJuSW5zdGFuY2UuZW5kIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBvLnJldHVybkluc3RhbmNlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNOZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuSW5zdGFuY2VzO1xufVxuZXhwb3J0cy5jb252ZXJ0RXZlbnRzVG9JbnN0YW5jZXMgPSBjb252ZXJ0RXZlbnRzVG9JbnN0YW5jZXM7XG5mdW5jdGlvbiBoYW5kbGVBY3RpdmVJbnN0YW5jZXMoZXZlbnQsIGxhc3RJbnN0YW5jZSwgYWN0aXZlSW5zdGFuY2VJZCwgZXZlbnRJZCwgYWN0aXZlSW5zdGFuY2VzLCBhbGxvd01lcmdlLCBhbGxvd1plcm9HYXBzID0gZmFsc2UpIHtcbiAgICBsZXQgcmV0dXJuSW5zdGFuY2UgPSBudWxsO1xuICAgIGlmICghYWxsb3dNZXJnZSAmJlxuICAgICAgICBldmVudC52YWx1ZSAmJlxuICAgICAgICBsYXN0SW5zdGFuY2UgJiZcbiAgICAgICAgbGFzdEluc3RhbmNlLmVuZCA9PT0gbnVsbCAmJlxuICAgICAgICBhY3RpdmVJbnN0YW5jZUlkICE9PSBudWxsICYmXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlSWQgIT09IGV2ZW50SWQpIHtcbiAgICAgICAgLy8gU3RhcnQgYSBuZXcgaW5zdGFuY2U6XG4gICAgICAgIGxhc3RJbnN0YW5jZS5lbmQgPSBldmVudC50aW1lO1xuICAgICAgICByZXR1cm5JbnN0YW5jZSA9IHtcbiAgICAgICAgICAgIGlkOiBnZXRJZCgpLFxuICAgICAgICAgICAgc3RhcnQ6IGV2ZW50LnRpbWUsXG4gICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICByZWZlcmVuY2VzOiBldmVudC5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgb3JpZ2luYWxFbmQ6IGV2ZW50LmRhdGEuaW5zdGFuY2Uub3JpZ2luYWxFbmQsXG4gICAgICAgICAgICBvcmlnaW5hbFN0YXJ0OiBldmVudC5kYXRhLmluc3RhbmNlLm9yaWdpbmFsU3RhcnQsXG4gICAgICAgIH07XG4gICAgICAgIGFjdGl2ZUluc3RhbmNlSWQgPSBldmVudElkO1xuICAgIH1cbiAgICBlbHNlIGlmICghYWxsb3dNZXJnZSAmJiAhZXZlbnQudmFsdWUgJiYgbGFzdEluc3RhbmNlICYmIGFjdGl2ZUluc3RhbmNlSWQgPT09IGV2ZW50SWQpIHtcbiAgICAgICAgLy8gVGhlIGFjdGl2ZSBpbnN0YW5jZSBzdG9wcGVkIHBsYXlpbmcsIGJ1dCBhbm90aGVyIGlzIHN0aWxsIHBsYXlpbmdcbiAgICAgICAgY29uc3QgbGF0ZXN0SW5zdGFuY2UgPSBfLnJlZHVjZShhY3RpdmVJbnN0YW5jZXMsIChtZW1vLCBpbnN0YW5jZUV2ZW50LCBpZCkgPT4ge1xuICAgICAgICAgICAgaWYgKG1lbW8gPT09IG51bGwgfHwgbWVtby5ldmVudC50aW1lIDwgaW5zdGFuY2VFdmVudC50aW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGluc3RhbmNlRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH0sIG51bGwpO1xuICAgICAgICBpZiAobGF0ZXN0SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIC8vIFJlc3RhcnQgdGhhdCBpbnN0YW5jZSBub3c6XG4gICAgICAgICAgICBsYXN0SW5zdGFuY2UuZW5kID0gZXZlbnQudGltZTtcbiAgICAgICAgICAgIHJldHVybkluc3RhbmNlID0ge1xuICAgICAgICAgICAgICAgIGlkOiBldmVudElkICsgJ18nICsgZ2V0SWQoKSxcbiAgICAgICAgICAgICAgICBzdGFydDogZXZlbnQudGltZSxcbiAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogbGF0ZXN0SW5zdGFuY2UuZXZlbnQucmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZDogZXZlbnQuZGF0YS5pbnN0YW5jZS5vcmlnaW5hbEVuZCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0OiBldmVudC5kYXRhLmluc3RhbmNlLm9yaWdpbmFsU3RhcnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWN0aXZlSW5zdGFuY2VJZCA9IGxhdGVzdEluc3RhbmNlLmlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsbG93TWVyZ2UgJiYgIWFsbG93WmVyb0dhcHMgJiYgbGFzdEluc3RhbmNlICYmIGxhc3RJbnN0YW5jZS5lbmQgPT09IGV2ZW50LnRpbWUpIHtcbiAgICAgICAgLy8gVGhlIHByZXZpb3VzbHkgcnVubmluZyBlbmRlZCBqdXN0IG5vd1xuICAgICAgICAvLyByZXN1bWUgcHJldmlvdXMgaW5zdGFuY2U6XG4gICAgICAgIGxhc3RJbnN0YW5jZS5lbmQgPSBudWxsO1xuICAgICAgICBsYXN0SW5zdGFuY2UucmVmZXJlbmNlcyA9IGpvaW5SZWZlcmVuY2VzKGxhc3RJbnN0YW5jZS5yZWZlcmVuY2VzLCBldmVudC5yZWZlcmVuY2VzKTtcbiAgICAgICAgYWRkQ2Fwc1RvUmVzdW1pbmcobGFzdEluc3RhbmNlLCBldmVudC5kYXRhLmluc3RhbmNlLmNhcHMpO1xuICAgIH1cbiAgICBlbHNlIGlmICghbGFzdEluc3RhbmNlIHx8IGxhc3RJbnN0YW5jZS5lbmQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gcHJldmlvdXNseSBydW5uaW5nIGluc3RhbmNlXG4gICAgICAgIC8vIFN0YXJ0IGEgbmV3IGluc3RhbmNlOlxuICAgICAgICByZXR1cm5JbnN0YW5jZSA9IHtcbiAgICAgICAgICAgIGlkOiBldmVudElkLFxuICAgICAgICAgICAgc3RhcnQ6IGV2ZW50LnRpbWUsXG4gICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICByZWZlcmVuY2VzOiBldmVudC5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgY2FwczogZXZlbnQuZGF0YS5pbnN0YW5jZS5jYXBzLFxuICAgICAgICAgICAgb3JpZ2luYWxFbmQ6IGV2ZW50LmRhdGEuaW5zdGFuY2Uub3JpZ2luYWxFbmQsXG4gICAgICAgICAgICBvcmlnaW5hbFN0YXJ0OiBldmVudC5kYXRhLmluc3RhbmNlLm9yaWdpbmFsU3RhcnQsXG4gICAgICAgIH07XG4gICAgICAgIGFjdGl2ZUluc3RhbmNlSWQgPSBldmVudElkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgYWxyZWFkeSBhIHJ1bm5pbmcgaW5zdGFuY2VcbiAgICAgICAgbGFzdEluc3RhbmNlLnJlZmVyZW5jZXMgPSBqb2luUmVmZXJlbmNlcyhsYXN0SW5zdGFuY2UucmVmZXJlbmNlcywgZXZlbnQucmVmZXJlbmNlcyk7XG4gICAgICAgIGFkZENhcHNUb1Jlc3VtaW5nKGxhc3RJbnN0YW5jZSwgZXZlbnQuZGF0YS5pbnN0YW5jZS5jYXBzKTtcbiAgICB9XG4gICAgaWYgKGxhc3RJbnN0YW5jZSAmJiBsYXN0SW5zdGFuY2UuY2FwcyAmJiAhbGFzdEluc3RhbmNlLmNhcHMubGVuZ3RoKVxuICAgICAgICBkZWxldGUgbGFzdEluc3RhbmNlLmNhcHM7XG4gICAgaWYgKHJldHVybkluc3RhbmNlICYmXG4gICAgICAgIGxhc3RJbnN0YW5jZSAmJlxuICAgICAgICBsYXN0SW5zdGFuY2Uuc3RhcnQgPT09IGxhc3RJbnN0YW5jZS5lbmQgJiZcbiAgICAgICAgbGFzdEluc3RhbmNlLmVuZCA9PT0gcmV0dXJuSW5zdGFuY2Uuc3RhcnQpIHtcbiAgICAgICAgLy8gcmVwbGFjZSB0aGUgcHJldmlvdXMgemVyby1sZW5ndGggd2l0aCB0aGlzIG9uZSBpbnN0ZWFkXG4gICAgICAgIGxhc3RJbnN0YW5jZS5pZCA9IHJldHVybkluc3RhbmNlLmlkO1xuICAgICAgICBsYXN0SW5zdGFuY2Uuc3RhcnQgPSByZXR1cm5JbnN0YW5jZS5zdGFydDtcbiAgICAgICAgbGFzdEluc3RhbmNlLmVuZCA9IHJldHVybkluc3RhbmNlLmVuZDtcbiAgICAgICAgbGFzdEluc3RhbmNlLnJlZmVyZW5jZXMgPSByZXR1cm5JbnN0YW5jZS5yZWZlcmVuY2VzO1xuICAgICAgICBsYXN0SW5zdGFuY2UuY2FwcyA9IHJldHVybkluc3RhbmNlLmNhcHM7XG4gICAgICAgIGxhc3RJbnN0YW5jZS5vcmlnaW5hbFN0YXJ0ID0gcmV0dXJuSW5zdGFuY2Uub3JpZ2luYWxTdGFydDtcbiAgICAgICAgbGFzdEluc3RhbmNlLm9yaWdpbmFsRW5kID0gcmV0dXJuSW5zdGFuY2Uub3JpZ2luYWxFbmQ7XG4gICAgICAgIHJldHVybkluc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VJZCxcbiAgICAgICAgcmV0dXJuSW5zdGFuY2UsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludmVydEluc3RhbmNlcyhpbnN0YW5jZXMpIHtcbiAgICBpZiAoaW5zdGFuY2VzLmxlbmd0aCkge1xuICAgICAgICBpbnN0YW5jZXMgPSBjbGVhbkluc3RhbmNlcyhpbnN0YW5jZXMsIHRydWUsIHRydWUpO1xuICAgICAgICBjb25zdCBpbnZlcnRlZEluc3RhbmNlcyA9IFtdO1xuICAgICAgICBpZiAoaW5zdGFuY2VzWzBdLnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICBpbnZlcnRlZEluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogZ2V0SWQoKSxcbiAgICAgICAgICAgICAgICBpc0ZpcnN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBqb2luUmVmZXJlbmNlcyhpbnN0YW5jZXNbMF0ucmVmZXJlbmNlcywgaW5zdGFuY2VzWzBdLmlkKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBfLmxhc3QoaW52ZXJ0ZWRJbnN0YW5jZXMpO1xuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICBsYXN0LmVuZCA9IGluc3RhbmNlLnN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluc3RhbmNlLmVuZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGludmVydGVkSW5zdGFuY2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogZ2V0SWQoKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGluc3RhbmNlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBqb2luUmVmZXJlbmNlcyhpbnN0YW5jZS5yZWZlcmVuY2VzLCBpbnN0YW5jZS5pZCksXG4gICAgICAgICAgICAgICAgICAgIGNhcHM6IGluc3RhbmNlLmNhcHMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludmVydGVkSW5zdGFuY2VzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogZ2V0SWQoKSxcbiAgICAgICAgICAgICAgICBpc0ZpcnN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfVxufVxuZXhwb3J0cy5pbnZlcnRJbnN0YW5jZXMgPSBpbnZlcnRJbnN0YW5jZXM7XG4vKipcbiAqIFBlcmZvcm0gYW4gYWN0aW9uIG9uIDIgYXJyYXlzLiBCZWhhdmVzIHNvbWV3aGF0IGxpa2UgdGhlIFwiLipcIi1vcGVyYXRvciBpbiBNYXRsYWJcbiAqIEBwYXJhbSBhcnJheTBcbiAqIEBwYXJhbSBhcnJheTFcbiAqIEBwYXJhbSBvcGVyYXRlXG4gKi9cbmZ1bmN0aW9uIG9wZXJhdGVPbkFycmF5cyhhcnJheTAsIGFycmF5MSwgb3BlcmF0ZSkge1xuICAgIGlmIChhcnJheTAgPT09IG51bGwgfHwgYXJyYXkxID09PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaXNSZWZlcmVuY2UoYXJyYXkwKSAmJiBpc1JlZmVyZW5jZShhcnJheTEpKSB7XG4gICAgICAgIHJldHVybiBvcGVyYXRlKGFycmF5MCwgYXJyYXkxKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgbWluTGVuZ3RoID0gTWF0aC5taW4oXy5pc0FycmF5KGFycmF5MCkgPyBhcnJheTAubGVuZ3RoIDogSW5maW5pdHksIF8uaXNBcnJheShhcnJheTEpID8gYXJyYXkxLmxlbmd0aCA6IEluZmluaXR5KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBfLmlzQXJyYXkoYXJyYXkwKVxuICAgICAgICAgICAgPyBhcnJheTBbaV1cbiAgICAgICAgICAgIDogeyBpZDogJycsIHN0YXJ0OiBhcnJheTAudmFsdWUsIGVuZDogYXJyYXkwLnZhbHVlLCByZWZlcmVuY2VzOiBhcnJheTAucmVmZXJlbmNlcyB9O1xuICAgICAgICBjb25zdCBiID0gXy5pc0FycmF5KGFycmF5MSlcbiAgICAgICAgICAgID8gYXJyYXkxW2ldXG4gICAgICAgICAgICA6IHsgaWQ6ICcnLCBzdGFydDogYXJyYXkxLnZhbHVlLCBlbmQ6IGFycmF5MS52YWx1ZSwgcmVmZXJlbmNlczogYXJyYXkxLnJlZmVyZW5jZXMgfTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBhLmlzRmlyc3RcbiAgICAgICAgICAgID8geyB2YWx1ZTogYS5zdGFydCwgcmVmZXJlbmNlczogYS5yZWZlcmVuY2VzIH1cbiAgICAgICAgICAgIDogYi5pc0ZpcnN0XG4gICAgICAgICAgICAgICAgPyB7IHZhbHVlOiBiLnN0YXJ0LCByZWZlcmVuY2VzOiBiLnJlZmVyZW5jZXMgfVxuICAgICAgICAgICAgICAgIDogb3BlcmF0ZSh7IHZhbHVlOiBhLnN0YXJ0LCByZWZlcmVuY2VzOiBqb2luUmVmZXJlbmNlcyhhLmlkLCBhLnJlZmVyZW5jZXMpIH0sIHsgdmFsdWU6IGIuc3RhcnQsIHJlZmVyZW5jZXM6IGpvaW5SZWZlcmVuY2VzKGIuaWQsIGIucmVmZXJlbmNlcykgfSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGEuaXNGaXJzdFxuICAgICAgICAgICAgPyBhLmVuZCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8geyB2YWx1ZTogYS5lbmQsIHJlZmVyZW5jZXM6IGEucmVmZXJlbmNlcyB9XG4gICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICA6IGIuaXNGaXJzdFxuICAgICAgICAgICAgICAgID8gYi5lbmQgIT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyB7IHZhbHVlOiBiLmVuZCwgcmVmZXJlbmNlczogYi5yZWZlcmVuY2VzIH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICAgOiBvcGVyYXRlKGEuZW5kICE9PSBudWxsID8geyB2YWx1ZTogYS5lbmQsIHJlZmVyZW5jZXM6IGpvaW5SZWZlcmVuY2VzKGEuaWQsIGEucmVmZXJlbmNlcykgfSA6IG51bGwsIGIuZW5kICE9PSBudWxsID8geyB2YWx1ZTogYi5lbmQsIHJlZmVyZW5jZXM6IGpvaW5SZWZlcmVuY2VzKGIuaWQsIGIucmVmZXJlbmNlcykgfSA6IG51bGwpO1xuICAgICAgICBpZiAoc3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogZ2V0SWQoKSxcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQudmFsdWUsXG4gICAgICAgICAgICAgICAgZW5kOiBlbmQgPT09IG51bGwgPyBudWxsIDogZW5kLnZhbHVlLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGpvaW5SZWZlcmVuY2VzKHN0YXJ0LnJlZmVyZW5jZXMsIGVuZCAhPT0gbnVsbCA/IGVuZC5yZWZlcmVuY2VzIDogW10pLFxuICAgICAgICAgICAgICAgIGNhcHM6IGpvaW5DYXBzKGEuY2FwcywgYi5jYXBzKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbGVhbkluc3RhbmNlcyhyZXN1bHQsIGZhbHNlKTtcbn1cbmV4cG9ydHMub3BlcmF0ZU9uQXJyYXlzID0gb3BlcmF0ZU9uQXJyYXlzO1xuLyoqXG4gKiBMaWtlIG9wZXJhdGVPbkFycmF5cywgYnV0IHdpbGwgbXVsdGlwbHkgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhcnJheTAsIHdpdGggdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhcnJheTFcbiAqIEBwYXJhbSBhcnJheTBcbiAqIEBwYXJhbSBhcnJheTFcbiAqIEBwYXJhbSBvcGVyYXRlXG4gKi9cbi8qZXhwb3J0IGZ1bmN0aW9uIG9wZXJhdGVPbkFycmF5c011bHRpIChcbiAgICBhcnJheTA6IEFycmF5PFRpbWVsaW5lT2JqZWN0SW5zdGFuY2U+IHwgUmVmZXJlbmNlIHwgbnVsbCxcbiAgICBhcnJheTE6IEFycmF5PFRpbWVsaW5lT2JqZWN0SW5zdGFuY2U+IHwgUmVmZXJlbmNlIHwgbnVsbCxcbiAgICBvcGVyYXRlOiAoYTogUmVmZXJlbmNlIHwgbnVsbCwgYjogUmVmZXJlbmNlIHwgbnVsbCkgPT4gUmVmZXJlbmNlIHwgbnVsbFxuKSB7XG4gICAgaWYgKGFycmF5MCA9PT0gbnVsbCkgcmV0dXJuIG51bGxcblxuICAgIGlmIChfLmlzQXJyYXkoYXJyYXkxKSkge1xuICAgICAgICBsZXQgcmVzdWx0QXJyYXk6IEFycmF5PFRpbWVsaW5lT2JqZWN0SW5zdGFuY2U+ID0gW11cbiAgICAgICAgXy5lYWNoKGFycmF5MSwgKGFycmF5MVZhbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3BlcmF0ZU9uQXJyYXlzKGFycmF5MCwgeyB2YWx1ZTogYXJyYXkxVmFsLnN0YXJ0LCByZWZlcmVuY2VzOiBhcnJheTFWYWwucmVmZXJlbmNlcyB9ICwgb3BlcmF0ZSlcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdEFycmF5ID0gcmVzdWx0QXJyYXkuY29uY2F0KHJlc3VsdClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0QXJyYXkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBnZXRJZCgpLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogcmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5MVZhbC5lbmQgIT09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlICsgKGFycmF5MVZhbC5lbmQgLSBhcnJheTFWYWwuc3RhcnQpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogcmVzdWx0LnJlZmVyZW5jZXNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gcmVzdWx0QXJyYXlcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb3BlcmF0ZU9uQXJyYXlzKGFycmF5MCwgYXJyYXkxLCBvcGVyYXRlKVxuICAgIH1cbn1cbiovXG5mdW5jdGlvbiBhcHBseVJlcGVhdGluZ0luc3RhbmNlcyhpbnN0YW5jZXMsIHJlcGVhdFRpbWUwLCBvcHRpb25zKSB7XG4gICAgaWYgKHJlcGVhdFRpbWUwID09PSBudWxsIHx8ICFyZXBlYXRUaW1lMC52YWx1ZSlcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlcztcbiAgICBjb25zdCByZXBlYXRUaW1lID0gcmVwZWF0VGltZTAudmFsdWU7XG4gICAgaWYgKGlzUmVmZXJlbmNlKGluc3RhbmNlcykpIHtcbiAgICAgICAgaW5zdGFuY2VzID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiAnJyxcbiAgICAgICAgICAgICAgICBzdGFydDogaW5zdGFuY2VzLnZhbHVlLFxuICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBpbnN0YW5jZXMucmVmZXJlbmNlcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0IHJlcGVhdGVkSW5zdGFuY2VzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaV07XG4gICAgICAgIGxldCBzdGFydFRpbWUgPSBNYXRoLm1heChvcHRpb25zLnRpbWUgLSAoKG9wdGlvbnMudGltZSAtIGluc3RhbmNlLnN0YXJ0KSAlIHJlcGVhdFRpbWUpLCBpbnN0YW5jZS5zdGFydCk7XG4gICAgICAgIGxldCBlbmRUaW1lID0gaW5zdGFuY2UuZW5kID09PSBudWxsID8gbnVsbCA6IGluc3RhbmNlLmVuZCArIChzdGFydFRpbWUgLSBpbnN0YW5jZS5zdGFydCk7XG4gICAgICAgIGNvbnN0IGNhcCA9IChpbnN0YW5jZS5jYXBzID8gXy5maW5kKGluc3RhbmNlLmNhcHMsIChjYXApID0+IGluc3RhbmNlLnJlZmVyZW5jZXMuaW5kZXhPZihjYXAuaWQpICE9PSAtMSkgOiBudWxsKSB8fCBudWxsO1xuICAgICAgICBjb25zdCBsaW1pdCA9IG9wdGlvbnMubGltaXRDb3VudCB8fCAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxpbWl0VGltZSAmJiBzdGFydFRpbWUgPj0gb3B0aW9ucy5saW1pdFRpbWUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjb25zdCBjYXBwZWRTdGFydFRpbWUgPSBjYXAgPyBNYXRoLm1heChjYXAuc3RhcnQsIHN0YXJ0VGltZSkgOiBzdGFydFRpbWU7XG4gICAgICAgICAgICBjb25zdCBjYXBwZWRFbmRUaW1lID0gY2FwICYmIGNhcC5lbmQgIT09IG51bGwgJiYgZW5kVGltZSAhPT0gbnVsbCA/IE1hdGgubWluKGNhcC5lbmQsIGVuZFRpbWUpIDogZW5kVGltZTtcbiAgICAgICAgICAgIGlmICgoY2FwcGVkRW5kVGltZSB8fCBJbmZpbml0eSkgPiBjYXBwZWRTdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXBlYXRlZEluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGdldElkKCksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBjYXBwZWRTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogY2FwcGVkRW5kVGltZSxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogam9pblJlZmVyZW5jZXMoaW5zdGFuY2UuaWQsIGluc3RhbmNlLnJlZmVyZW5jZXMsIHJlcGVhdFRpbWUwLnJlZmVyZW5jZXMpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRUaW1lICs9IHJlcGVhdFRpbWU7XG4gICAgICAgICAgICBpZiAoZW5kVGltZSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICBlbmRUaW1lICs9IHJlcGVhdFRpbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsZWFuSW5zdGFuY2VzKHJlcGVhdGVkSW5zdGFuY2VzLCBmYWxzZSk7XG59XG5leHBvcnRzLmFwcGx5UmVwZWF0aW5nSW5zdGFuY2VzID0gYXBwbHlSZXBlYXRpbmdJbnN0YW5jZXM7XG4vKipcbiAqIENhcCBpbnN0YW5jZXMgc28gdGhhdCB0aGV5IGFyZSB3aXRoaW4gdGhlaXIgcGFyZW50SW5zdGFuY2VzXG4gKiBAcGFyYW0gaW5zdGFuY2VzXG4gKiBAcGFyYW0gcGFyZW50SW5zdGFuY2VzXG4gKi9cbmZ1bmN0aW9uIGNhcEluc3RhbmNlcyhpbnN0YW5jZXMsIHBhcmVudEluc3RhbmNlcykge1xuICAgIGlmIChpc1JlZmVyZW5jZShwYXJlbnRJbnN0YW5jZXMpIHx8IHBhcmVudEluc3RhbmNlcyA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlcztcbiAgICBsZXQgcmV0dXJuSW5zdGFuY2VzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2VPcmcgPSBpbnN0YW5jZXNbaV07XG4gICAgICAgIC8vIGxldCBpbnN0YW5jZVBhcmVudHM6IFRpbWVsaW5lT2JqZWN0SW5zdGFuY2VbXSB8IG51bGwgPSBudWxsXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGFyZW50SW5zdGFuY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBwYXJlbnRJbnN0YW5jZXNbal07XG4gICAgICAgICAgICAvLyBGaXJzdCwgY2hlY2sgaWYgdGhlIGluc3RhbmNlIGNyb3NzZXMgdGhlIHBhcmVudCBhdCBhbGw6XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VPcmcuc3RhcnQgPD0gKHBhcmVudC5lbmQgfHwgSW5maW5pdHkpICYmIChpbnN0YW5jZU9yZy5lbmQgfHwgSW5maW5pdHkpID49IHBhcmVudC5zdGFydCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gXy5jbG9uZShpbnN0YW5jZU9yZyk7XG4gICAgICAgICAgICAgICAgLy8gQ2FwIHN0YXJ0XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXJ0IDwgcGFyZW50LnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEluc3RhbmNlU3RhcnRUaW1lKGluc3RhbmNlLCBwYXJlbnQuc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDYXAgZW5kXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5lbmQgIT09IG51bGwgJiYgKGluc3RhbmNlLmVuZCB8fCBJbmZpbml0eSkgPiAocGFyZW50LmVuZCB8fCBJbmZpbml0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5zdGFuY2VFbmRUaW1lKGluc3RhbmNlLCBwYXJlbnQuZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXJ0ID49IHBhcmVudC5zdGFydCAmJiAoaW5zdGFuY2UuZW5kIHx8IEluZmluaXR5KSA8PSAocGFyZW50LmVuZCB8fCBJbmZpbml0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGluc3RhbmNlIGlzIHdpdGhpbiB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnJlZmVyZW5jZXMgPSBqb2luUmVmZXJlbmNlcyhpbnN0YW5jZS5yZWZlcmVuY2VzLCBwYXJlbnQucmVmZXJlbmNlcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybkluc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuSW5zdGFuY2VzLnNvcnQoKGEsIGIpID0+IGEuc3RhcnQgLSBiLnN0YXJ0KTtcbiAgICAvLyBFbnN1cmUgdW5pcXVlIGlkczpcbiAgICBjb25zdCBpZHMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldHVybkluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHJldHVybkluc3RhbmNlc1tpXTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGlmIChpZHNbaW5zdGFuY2UuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmlkID0gaW5zdGFuY2UuaWQgKyArK2lkc1tpbnN0YW5jZS5pZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZHNbaW5zdGFuY2UuaWRdID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDbGVhbiB1cCB0aGUgaW5zdGFuY2VzLCB0byByZW1vdmUgZHVwbGljYXRlc1xuICAgIHJldHVybkluc3RhbmNlcyA9IGNsZWFuSW5zdGFuY2VzKHJldHVybkluc3RhbmNlcywgdHJ1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHJldHVybkluc3RhbmNlcztcbn1cbmV4cG9ydHMuY2FwSW5zdGFuY2VzID0gY2FwSW5zdGFuY2VzO1xuZnVuY3Rpb24gaXNSZWZlcmVuY2UocmVmMCkge1xuICAgIGNvbnN0IHJlZiA9IHJlZjA7XG4gICAgcmV0dXJuICh0eXBlb2YgcmVmID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAhXy5pc0FycmF5KHJlZikgJiZcbiAgICAgICAgcmVmLnZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgXy5pc0FycmF5KHJlZi5yZWZlcmVuY2VzKSAmJlxuICAgICAgICByZWYgIT09IG51bGwpO1xufVxuZXhwb3J0cy5pc1JlZmVyZW5jZSA9IGlzUmVmZXJlbmNlO1xuZnVuY3Rpb24gam9pblJlZmVyZW5jZXMoLi4ucmVmZXJlbmNlcykge1xuICAgIGNvbnN0IHJlZk1hcCA9IHt9O1xuICAgIGNvbnN0IHJlZnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZmVyZW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gcmVmZXJlbmNlc1tpXTtcbiAgICAgICAgaWYgKHJlZmVyZW5jZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZWZlcmVuY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZNYXBbcmVmZXJlbmNlXSlcbiAgICAgICAgICAgICAgICAgICAgcmVmcy5wdXNoKHJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgcmVmTWFwW3JlZmVyZW5jZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZWZlcmVuY2UubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gcmVmZXJlbmNlW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZk1hcFtyZWZdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnMucHVzaChyZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmTWFwW3JlZl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWZzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgaWYgKGEgPiBiKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhIDwgYilcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG59XG5leHBvcnRzLmpvaW5SZWZlcmVuY2VzID0gam9pblJlZmVyZW5jZXM7XG5mdW5jdGlvbiBhZGRDYXBzVG9SZXN1bWluZyhpbnN0YW5jZSwgLi4uY2Fwcykge1xuICAgIGNvbnN0IGNhcHNUb0FkZCA9IFtdO1xuICAgIGNvbnN0IGpvaW5lZENhcHMgPSBqb2luQ2FwcyguLi5jYXBzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGpvaW5lZENhcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2FwID0gam9pbmVkQ2Fwc1tpXTtcbiAgICAgICAgaWYgKGNhcC5lbmQgJiYgaW5zdGFuY2UuZW5kICYmIGNhcC5lbmQgPiBpbnN0YW5jZS5lbmQpIHtcbiAgICAgICAgICAgIGNhcHNUb0FkZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogY2FwLmlkLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgICAgIGVuZDogY2FwLmVuZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLmNhcHMgPSBqb2luQ2FwcyhpbnN0YW5jZS5jYXBzLCBjYXBzVG9BZGQpO1xufVxuZXhwb3J0cy5hZGRDYXBzVG9SZXN1bWluZyA9IGFkZENhcHNUb1Jlc3VtaW5nO1xuZnVuY3Rpb24gam9pbkNhcHMoLi4uY2Fwcykge1xuICAgIGNvbnN0IGNhcE1hcCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2Fwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjYXBzMiA9IGNhcHNbaV07XG4gICAgICAgIGlmIChjYXBzMikge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjYXBzMi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhcDIgPSBjYXBzMltqXTtcbiAgICAgICAgICAgICAgICBjYXBNYXBbY2FwMi5pZF0gPSBjYXAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKGNhcE1hcCk7XG59XG5leHBvcnRzLmpvaW5DYXBzID0gam9pbkNhcHM7XG5sZXQgaWRDb3VudCA9IDA7XG4vKipcbiAqIFJldHVybnMgYSB1bmlxdWUgaWRcbiAqL1xuZnVuY3Rpb24gZ2V0SWQoKSB7XG4gICAgcmV0dXJuICdAJyArIChpZENvdW50KyspLnRvU3RyaW5nKDM2KTtcbn1cbmV4cG9ydHMuZ2V0SWQgPSBnZXRJZDtcbmZ1bmN0aW9uIHJlc2V0SWQoKSB7XG4gICAgaWRDb3VudCA9IDA7XG59XG5leHBvcnRzLnJlc2V0SWQgPSByZXNldElkO1xuZnVuY3Rpb24gc2V0SW5zdGFuY2VFbmRUaW1lKGluc3RhbmNlLCBlbmRUaW1lKSB7XG4gICAgaW5zdGFuY2Uub3JpZ2luYWxFbmQgPSBpbnN0YW5jZS5vcmlnaW5hbEVuZCAhPT0gdW5kZWZpbmVkID8gaW5zdGFuY2Uub3JpZ2luYWxFbmQgOiBpbnN0YW5jZS5lbmQ7XG4gICAgaW5zdGFuY2UuZW5kID0gZW5kVGltZTtcbn1cbmV4cG9ydHMuc2V0SW5zdGFuY2VFbmRUaW1lID0gc2V0SW5zdGFuY2VFbmRUaW1lO1xuZnVuY3Rpb24gc2V0SW5zdGFuY2VTdGFydFRpbWUoaW5zdGFuY2UsIHN0YXJ0VGltZSkge1xuICAgIGluc3RhbmNlLm9yaWdpbmFsU3RhcnQgPSBpbnN0YW5jZS5vcmlnaW5hbFN0YXJ0ICE9PSB1bmRlZmluZWQgPyBpbnN0YW5jZS5vcmlnaW5hbFN0YXJ0IDogaW5zdGFuY2Uuc3RhcnQ7XG4gICAgaW5zdGFuY2Uuc3RhcnQgPSBzdGFydFRpbWU7XG59XG5leHBvcnRzLnNldEluc3RhbmNlU3RhcnRUaW1lID0gc2V0SW5zdGFuY2VTdGFydFRpbWU7XG5mdW5jdGlvbiBhcHBseVBhcmVudEluc3RhbmNlcyhwYXJlbnRJbnN0YW5jZXMsIHZhbHVlKSB7XG4gICAgY29uc3Qgb3BlcmF0ZSA9IChhLCBiKSA9PiB7XG4gICAgICAgIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBhLnZhbHVlICsgYi52YWx1ZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZXM6IGpvaW5SZWZlcmVuY2VzKGEucmVmZXJlbmNlcywgYi5yZWZlcmVuY2VzKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBvcGVyYXRlT25BcnJheXMocGFyZW50SW5zdGFuY2VzLCB2YWx1ZSwgb3BlcmF0ZSk7XG59XG5leHBvcnRzLmFwcGx5UGFyZW50SW5zdGFuY2VzID0gYXBwbHlQYXJlbnRJbnN0YW5jZXM7XG5jb25zdCBjYWNoZVJlc3VsdENhY2hlID0ge307XG4vKiogQ2FjaGUgdGhlIHJlc3VsdCBvZiBmdW5jdGlvbiBmb3IgYSBsaW1pdGVkIHRpbWUgKi9cbmZ1bmN0aW9uIGNhY2hlUmVzdWx0KG5hbWUsIGZjbiwgbGltaXRUaW1lID0gMTAwMCkge1xuICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMSkge1xuICAgICAgICBzZXRUaW1lb3V0KGNsZWFuQ2FjaGVSZXN1bHQsIDEwMCk7XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlID0gY2FjaGVSZXN1bHRDYWNoZVtuYW1lXTtcbiAgICBpZiAoIWNhY2hlIHx8IGNhY2hlLnR0bCA8IERhdGUubm93KCkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBmY24oKTtcbiAgICAgICAgY2FjaGVSZXN1bHRDYWNoZVtuYW1lXSA9IHtcbiAgICAgICAgICAgIHR0bDogRGF0ZS5ub3coKSArIGxpbWl0VGltZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLnZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuY2FjaGVSZXN1bHQgPSBjYWNoZVJlc3VsdDtcbmZ1bmN0aW9uIGNsZWFuQ2FjaGVSZXN1bHQoKSB7XG4gICAgXy5lYWNoKGNhY2hlUmVzdWx0Q2FjaGUsIChjYWNoZSwgbmFtZSkgPT4ge1xuICAgICAgICBpZiAoY2FjaGUudHRsIDwgRGF0ZS5ub3coKSlcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVJlc3VsdENhY2hlW25hbWVdO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGliLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRPYmplY3RSZWZlcmVuY2VzID0gZXhwb3J0cy5oYXNoVGltZWxpbmVPYmplY3QgPSBleHBvcnRzLmluaXRpYWxpemVDYWNoZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIGluaXRpYWxpemVDYWNoZShjYWNoZU9yZywgcmVzb2x2ZWRUaW1lbGluZSkge1xuICAgIGNvbnN0IGNhY2hlID0gY2FjaGVPcmc7XG4gICAgaWYgKCFjYWNoZS5vYmpIYXNoZXMpXG4gICAgICAgIGNhY2hlLm9iakhhc2hlcyA9IHt9O1xuICAgIGlmICghY2FjaGUucmVzb2x2ZWRUaW1lbGluZSlcbiAgICAgICAgY2FjaGUucmVzb2x2ZWRUaW1lbGluZSA9IHJlc29sdmVkVGltZWxpbmU7XG4gICAgLy8gVG9kbzogbWFrZSBzdGF0aXN0aWNzIHdvcmsgd2hlbiB1c2luZyBjYWNoZVxuICAgIHJldHVybiBjYWNoZTtcbn1cbmV4cG9ydHMuaW5pdGlhbGl6ZUNhY2hlID0gaW5pdGlhbGl6ZUNhY2hlO1xuLyoqIFJldHVybiBhIFwiaGFzaC1zdHJpbmdcIiB3aGljaCBjaGFuZ2VzIHdoZW5ldmVyIGFueXRoaW5nIHRoYXQgYWZmZWN0cyB0aW1pbmcgb2YgYSB0aW1lbGluZS1vYmplY3QgaGFzIGNoYW5nZWQuICovXG5mdW5jdGlvbiBoYXNoVGltZWxpbmVPYmplY3Qob2JqKSB7XG4gICAgY29uc3QgdGhpbmdzVGhhdE1hdHRlciA9IFtcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkob2JqLmVuYWJsZSksXG4gICAgICAgIG9iai5kaXNhYmxlZCArICcnLFxuICAgICAgICBvYmoucHJpb3JpdHkgKyAnJyxcbiAgICAgICAgb2JqLnJlc29sdmVkLnBhcmVudElkIHx8ICcnLFxuICAgICAgICBvYmoucmVzb2x2ZWQuaXNLZXlmcmFtZSArICcnLFxuICAgICAgICBvYmouY2xhc3NlcyA/IG9iai5jbGFzc2VzLmpvaW4oJy4nKSA6ICcnLFxuICAgICAgICBvYmoubGF5ZXIgKyAnJyxcbiAgICAgICAgb2JqLnNlYW1sZXNzICsgJycsXG4gICAgXTtcbiAgICByZXR1cm4gdGhpbmdzVGhhdE1hdHRlci5qb2luKCcsJyk7XG59XG5leHBvcnRzLmhhc2hUaW1lbGluZU9iamVjdCA9IGhhc2hUaW1lbGluZU9iamVjdDtcbmZ1bmN0aW9uIGdldE9iamVjdFJlZmVyZW5jZXMob2JqKSB7XG4gICAgcmV0dXJuIG9iai5yZXNvbHZlZC5kaXJlY3RSZWZlcmVuY2VzO1xufVxuZXhwb3J0cy5nZXRPYmplY3RSZWZlcmVuY2VzID0gZ2V0T2JqZWN0UmVmZXJlbmNlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhY2hlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRPYmplY3RUb1Jlc29sdmVkVGltZWxpbmUgPSB2b2lkIDA7XG5mdW5jdGlvbiBhZGRPYmplY3RUb1Jlc29sdmVkVGltZWxpbmUocmVzb2x2ZWRUaW1lbGluZSwgb2JqKSB7XG4gICAgcmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzW29iai5pZF0gPSBvYmo7XG4gICAgaWYgKG9iai5jbGFzc2VzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IG9iai5jbGFzc2VzW2ldO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZWRUaW1lbGluZS5jbGFzc2VzW2NsYXNzTmFtZV0pXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkVGltZWxpbmUuY2xhc3Nlc1tjbGFzc05hbWVdID0gW107XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRUaW1lbGluZS5jbGFzc2VzW2NsYXNzTmFtZV0ucHVzaChvYmouaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvYmoubGF5ZXIpIHtcbiAgICAgICAgaWYgKCFyZXNvbHZlZFRpbWVsaW5lLmxheWVyc1tvYmoubGF5ZXJdKVxuICAgICAgICAgICAgcmVzb2x2ZWRUaW1lbGluZS5sYXllcnNbb2JqLmxheWVyXSA9IFtdO1xuICAgICAgICByZXNvbHZlZFRpbWVsaW5lLmxheWVyc1tvYmoubGF5ZXJdLnB1c2gob2JqLmlkKTtcbiAgICB9XG59XG5leHBvcnRzLmFkZE9iamVjdFRvUmVzb2x2ZWRUaW1lbGluZSA9IGFkZE9iamVjdFRvUmVzb2x2ZWRUaW1lbGluZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVFeHByZXNzaW9uID0gZXhwb3J0cy53cmFwSW5uZXJFeHByZXNzaW9ucyA9IGV4cG9ydHMuc2ltcGxpZnlFeHByZXNzaW9uID0gZXhwb3J0cy5pbnRlcnByZXRFeHByZXNzaW9uID0gZXhwb3J0cy5PUEVSQVRPUlMgPSB2b2lkIDA7XG5jb25zdCBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuLi9saWJcIik7XG5leHBvcnRzLk9QRVJBVE9SUyA9IFsnJicsICd8JywgJysnLCAnLScsICcqJywgJy8nLCAnJScsICchJ107XG5jb25zdCBSRUdFWFBfT1BFUkFUT1JTID0gXy5tYXAoZXhwb3J0cy5PUEVSQVRPUlMsIChvKSA9PiAnXFxcXCcgKyBvKS5qb2luKCcnKTtcbmZ1bmN0aW9uIGludGVycHJldEV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICAgIGlmIChsaWJfMS5pc051bWVyaWMoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoZXhwcmVzc2lvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKF8uaXNTdHJpbmcoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvblN0cmluZyA9IGV4cHJlc3Npb247XG4gICAgICAgIHJldHVybiBsaWJfMS5jYWNoZVJlc3VsdChleHByZXNzaW9uU3RyaW5nLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleHByID0gZXhwcmVzc2lvblN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAoJyhbJyArIFJFR0VYUF9PUEVSQVRPUlMgKyAnXFxcXChcXFxcKV0pJywgJ2cnKSwgJyAkMSAnKTsgLy8gTWFrZSBzdXJlIHRoZXJlJ3MgYSBzcGFjZSBiZXR3ZWVuIGV2ZXJ5IG9wZXJhdG9yICYgb3BlcmFuZFxuICAgICAgICAgICAgY29uc3Qgd29yZHMgPSBfLmNvbXBhY3QoZXhwci5zcGxpdCgnICcpKTtcbiAgICAgICAgICAgIGlmICh3b3Jkcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGVtcHR5IGV4cHJlc3Npb25cbiAgICAgICAgICAgIC8vIEZpeCBzcGVjaWFsIGNhc2U6IGEgKyAtIGJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB3b3Jkcy5sZW5ndGggLSAyOyBpID49IDE7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmICgod29yZHNbaV0gPT09ICctJyB8fCB3b3Jkc1tpXSA9PT0gJysnKSAmJiB3b3JkSXNPcGVyYXRvcihleHBvcnRzLk9QRVJBVE9SUywgd29yZHNbaSAtIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICB3b3Jkc1tpXSA9IHdvcmRzW2ldICsgd29yZHNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICB3b3Jkcy5zcGxpY2UoaSArIDEsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlubmVyRXhwcmVzc2lvbiA9IHdyYXBJbm5lckV4cHJlc3Npb25zKHdvcmRzKTtcbiAgICAgICAgICAgIGlmIChpbm5lckV4cHJlc3Npb24ucmVzdC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnRlcnByZXRFeHByZXNzaW9uOiBzeW50YXggZXJyb3I6IHBhcmVudGhlc2VzIGRvblxcJ3QgYWRkIHVwIGluIFwiJyArIGV4cHIgKyAnXCIuJyk7XG4gICAgICAgICAgICBpZiAoaW5uZXJFeHByZXNzaW9uLmlubmVyLmxlbmd0aCAlIDIgIT09IDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnRlcnByZXRFeHByZXNzaW9uOiBvcGVyYW5kcyAmIG9wZXJhdG9ycyBkb25cXCd0IGFkZCB1cDogXCInICtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJFeHByZXNzaW9uLmlubmVyLmpvaW4oJyAnKSArXG4gICAgICAgICAgICAgICAgICAgICdcIi4nKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSB3b3JkczJFeHByZXNzaW9uKGV4cG9ydHMuT1BFUkFUT1JTLCBpbm5lckV4cHJlc3Npb24uaW5uZXIpO1xuICAgICAgICAgICAgdmFsaWRhdGVFeHByZXNzaW9uKGV4cG9ydHMuT1BFUkFUT1JTLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgICB9LCAxMDAgKiAxMDAwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgIH1cbn1cbmV4cG9ydHMuaW50ZXJwcmV0RXhwcmVzc2lvbiA9IGludGVycHJldEV4cHJlc3Npb247XG4vKiogVHJ5IHRvIHNpbXBsaWZ5IGFuIGV4cHJlc3Npb24sIHRoaXMgaW5jbHVkZXM6XG4gKiAqIENvbWJpbmUgY29uc3RhbnQgb3BlcmFuZHMsIHVzaW5nIGFyaXRobWV0aWMgb3BlcmF0b3JzXG4gKiAuLi5tb3JlIHRvIGNvbWU/XG4gKi9cbmZ1bmN0aW9uIHNpbXBsaWZ5RXhwcmVzc2lvbihleHByMCkge1xuICAgIGNvbnN0IGV4cHIgPSBfLmlzU3RyaW5nKGV4cHIwKSA/IGludGVycHJldEV4cHJlc3Npb24oZXhwcjApIDogZXhwcjA7XG4gICAgaWYgKCFleHByKVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICBpZiAoaXNFeHByZXNzaW9uT2JqZWN0KGV4cHIpKSB7XG4gICAgICAgIGNvbnN0IGwgPSBzaW1wbGlmeUV4cHJlc3Npb24oZXhwci5sKTtcbiAgICAgICAgY29uc3QgbyA9IGV4cHIubztcbiAgICAgICAgY29uc3QgciA9IHNpbXBsaWZ5RXhwcmVzc2lvbihleHByLnIpO1xuICAgICAgICBpZiAobGliXzEuaXNDb25zdGFudChsKSAmJiBsaWJfMS5pc0NvbnN0YW50KHIpICYmIF8uaXNOdW1iZXIobCkgJiYgXy5pc051bWJlcihyKSkge1xuICAgICAgICAgICAgLy8gVGhlIG9wZXJhbmRzIGNhbiBiZSBjb21iaW5lZDpcbiAgICAgICAgICAgIHJldHVybiBvID09PSAnKydcbiAgICAgICAgICAgICAgICA/IGwgKyByXG4gICAgICAgICAgICAgICAgOiBvID09PSAnLSdcbiAgICAgICAgICAgICAgICAgICAgPyBsIC0gclxuICAgICAgICAgICAgICAgICAgICA6IG8gPT09ICcqJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBsICogclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvID09PSAnLydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGwgLyByXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBvID09PSAnJSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBsICUgclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHsgbCwgbywgciB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGwsIG8sIHIgfTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG59XG5leHBvcnRzLnNpbXBsaWZ5RXhwcmVzc2lvbiA9IHNpbXBsaWZ5RXhwcmVzc2lvbjtcbmZ1bmN0aW9uIGlzRXhwcmVzc2lvbk9iamVjdChleHByKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBleHByID09PSAnb2JqZWN0JyAmJiBfLmhhcyhleHByLCAnbCcpICYmIF8uaGFzKGV4cHIsICdvJykgJiYgXy5oYXMoZXhwciwgJ3InKTtcbn1cbmZ1bmN0aW9uIHdvcmRJc09wZXJhdG9yKG9wZXJhdG9yTGlzdCwgd29yZCkge1xuICAgIGlmIChvcGVyYXRvckxpc3QuaW5kZXhPZih3b3JkKSAhPT0gLTEpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIFR1cm5zIFsnYScsICcoJywgJ2InLCAnYycsICcpJ10gaW50byBbJ2EnLCBbJ2InLCAnYyddXVxuLy8gb3IgWydhJywgJyYnLCAnIScsICdiJ10gaW50byBbJ2EnLCAnJicsIFsnJywgJyEnLCAnYiddXVxuZnVuY3Rpb24gd3JhcElubmVyRXhwcmVzc2lvbnMod29yZHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh3b3Jkc1tpXSA9PT0gJygnKSB7XG4gICAgICAgICAgICBjb25zdCB0bXAgPSB3cmFwSW5uZXJFeHByZXNzaW9ucyh3b3Jkcy5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGlubmVyIGV4cHJlc3Npb24gYW5kIHJlbW92ZSB0aGFcbiAgICAgICAgICAgIHdvcmRzW2ldID0gdG1wLmlubmVyO1xuICAgICAgICAgICAgd29yZHMuc3BsaWNlKGkgKyAxLCA5OTk5OSwgLi4udG1wLnJlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdvcmRzW2ldID09PSAnKScpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5uZXI6IHdvcmRzLnNsaWNlKDAsIGkpLFxuICAgICAgICAgICAgICAgIHJlc3Q6IHdvcmRzLnNsaWNlKGkgKyAxKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod29yZHNbaV0gPT09ICchJykge1xuICAgICAgICAgICAgY29uc3QgdG1wID0gd3JhcElubmVyRXhwcmVzc2lvbnMod29yZHMuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICAgIC8vIGluc2VydCBpbm5lciBleHByZXNzaW9uIGFmdGVyIHRoZSAnISdcbiAgICAgICAgICAgIHdvcmRzW2ldID0gWycnLCAnISddLmNvbmNhdCh0bXAuaW5uZXIpO1xuICAgICAgICAgICAgd29yZHMuc3BsaWNlKGkgKyAxLCA5OTk5OSwgLi4udG1wLnJlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGlubmVyOiB3b3JkcyxcbiAgICAgICAgcmVzdDogW10sXG4gICAgfTtcbn1cbmV4cG9ydHMud3JhcElubmVyRXhwcmVzc2lvbnMgPSB3cmFwSW5uZXJFeHByZXNzaW9ucztcbmZ1bmN0aW9uIHdvcmRzMkV4cHJlc3Npb24ob3BlcmF0b3JMaXN0LCB3b3Jkcykge1xuICAgIGlmICghd29yZHMgfHwgIXdvcmRzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3b3JkczJFeHByZXNzaW9uOiBzeW50YXggZXJyb3I6IHVuYmFsYW5jZWQgZXhwcmVzc2lvbicpO1xuICAgIHdoaWxlICh3b3Jkcy5sZW5ndGggPT09IDEgJiYgXy5pc0FycmF5KHdvcmRzWzBdKSlcbiAgICAgICAgd29yZHMgPSB3b3Jkc1swXTtcbiAgICBpZiAod29yZHMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gd29yZHNbMF07XG4gICAgLy8gRmluZCB0aGUgb3BlcmF0b3Igd2l0aCB0aGUgaGlnaGVzdCBwcmlvcml0eTpcbiAgICBsZXQgb3BlcmF0b3JJID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcGVyYXRvckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBvcGVyYXRvckxpc3RbaV07XG4gICAgICAgIGlmIChvcGVyYXRvckkgPT09IC0xKSB7XG4gICAgICAgICAgICBvcGVyYXRvckkgPSB3b3Jkcy5sYXN0SW5kZXhPZihvcGVyYXRvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wZXJhdG9ySSAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgbCA9IHdvcmRzLnNsaWNlKDAsIG9wZXJhdG9ySSk7XG4gICAgICAgIGNvbnN0IHIgPSB3b3Jkcy5zbGljZShvcGVyYXRvckkgKyAxKTtcbiAgICAgICAgY29uc3QgZXhwciA9IHtcbiAgICAgICAgICAgIGw6IHdvcmRzMkV4cHJlc3Npb24ob3BlcmF0b3JMaXN0LCBsKSxcbiAgICAgICAgICAgIG86IHdvcmRzW29wZXJhdG9ySV0sXG4gICAgICAgICAgICByOiB3b3JkczJFeHByZXNzaW9uKG9wZXJhdG9yTGlzdCwgciksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd29yZHMyRXhwcmVzc2lvbjogc3ludGF4IGVycm9yOiBvcGVyYXRvciBub3QgZm91bmQ6IFwiJyArIHdvcmRzLmpvaW4oJyAnKSArICdcIicpO1xufVxuLyoqIFZhbGlkYXRlcyBhbiBleHByZXNzaW9uLiBSZXR1cm5zIHRydWUgb24gc3VjY2VzcywgdGhyb3dzIGVycm9yIGlmIG5vdCAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHByZXNzaW9uKG9wZXJhdG9yTGlzdCwgZXhwcjAsIGJyZWFkY3J1bWJzKSB7XG4gICAgaWYgKCFicmVhZGNydW1icylcbiAgICAgICAgYnJlYWRjcnVtYnMgPSAnUk9PVCc7XG4gICAgaWYgKF8uaXNPYmplY3QoZXhwcjApICYmICFfLmlzQXJyYXkoZXhwcjApKSB7XG4gICAgICAgIGNvbnN0IGV4cHIgPSBleHByMDtcbiAgICAgICAgaWYgKCFfLmhhcyhleHByLCAnbCcpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YWxpZGF0ZUV4cHJlc3Npb246ICR7YnJlYWRjcnVtYnN9LmwgbWlzc2luZyBpbiAke0pTT04uc3RyaW5naWZ5KGV4cHIpfWApO1xuICAgICAgICBpZiAoIV8uaGFzKGV4cHIsICdvJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbGlkYXRlRXhwcmVzc2lvbjogJHticmVhZGNydW1ic30ubyBtaXNzaW5nIGluICR7SlNPTi5zdHJpbmdpZnkoZXhwcil9YCk7XG4gICAgICAgIGlmICghXy5oYXMoZXhwciwgJ3InKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsaWRhdGVFeHByZXNzaW9uOiAke2JyZWFkY3J1bWJzfS5yIG1pc3NpbmcgaW4gJHtKU09OLnN0cmluZ2lmeShleHByKX1gKTtcbiAgICAgICAgaWYgKCFfLmlzU3RyaW5nKGV4cHIubykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbGlkYXRlRXhwcmVzc2lvbjogJHticmVhZGNydW1ic30ubyBub3QgYSBzdHJpbmdgKTtcbiAgICAgICAgaWYgKCF3b3JkSXNPcGVyYXRvcihvcGVyYXRvckxpc3QsIGV4cHIubykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYnJlYWRjcnVtYnMgKyAnLm8gbm90IHZhbGlkOiBcIicgKyBleHByLm8gKyAnXCInKTtcbiAgICAgICAgcmV0dXJuICh2YWxpZGF0ZUV4cHJlc3Npb24ob3BlcmF0b3JMaXN0LCBleHByLmwsIGJyZWFkY3J1bWJzICsgJy5sJykgJiZcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwcmVzc2lvbihvcGVyYXRvckxpc3QsIGV4cHIuciwgYnJlYWRjcnVtYnMgKyAnLnInKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFfLmlzTnVsbChleHByMCkgJiYgIV8uaXNTdHJpbmcoZXhwcjApICYmICFfLmlzTnVtYmVyKGV4cHIwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbGlkYXRlRXhwcmVzc2lvbjogJHticmVhZGNydW1ic30gaXMgb2YgaW52YWxpZCB0eXBlYCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy52YWxpZGF0ZUV4cHJlc3Npb24gPSB2YWxpZGF0ZUV4cHJlc3Npb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHByZXNzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sb29rdXBFeHByZXNzaW9uID0gZXhwb3J0cy5yZXNvbHZlVGltZWxpbmVPYmogPSBleHBvcnRzLlJlc29sdmVyID0gdm9pZCAwO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi4vbGliXCIpO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlXCIpO1xuY29uc3QgZXhwcmVzc2lvbl8xID0gcmVxdWlyZShcIi4vZXhwcmVzc2lvblwiKTtcbmNvbnN0IHN0YXRlXzEgPSByZXF1aXJlKFwiLi9zdGF0ZVwiKTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4vY29tbW9uXCIpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL2NhY2hlXCIpO1xuY2xhc3MgUmVzb2x2ZXIge1xuICAgIC8qKlxuICAgICAqIEdvIHRocm91Z2ggYWxsIG9iamVjdHMgb24gdGhlIHRpbWVsaW5lIGFuZCBjYWxjdWxhdGUgYWxsIHRoZSB0aW1pbmdzLlxuICAgICAqIFJldHVybnMgYSBSZXNvbHZlZFRpbWVsaW5lIHdoaWNoIGNhbiBiZSBwaXBlZCBpbnRvIFJlc29sdmVyLmdldFN0YXRlKClcbiAgICAgKiBAcGFyYW0gdGltZWxpbmUgQXJyYXkgb2YgdGltZWxpbmUgb2JqZWN0c1xuICAgICAqIEBwYXJhbSBvcHRpb25zIFJlc29sdmUgb3B0aW9uc1xuICAgICAqL1xuICAgIHN0YXRpYyByZXNvbHZlVGltZWxpbmUodGltZWxpbmUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFfLmlzQXJyYXkodGltZWxpbmUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXNvbHZlVGltZWxpbmU6IHBhcmFtZXRlciB0aW1lbGluZSBtaXNzaW5nJyk7XG4gICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzb2x2ZVRpbWVsaW5lOiBwYXJhbWV0ZXIgb3B0aW9ucyBtaXNzaW5nJyk7XG4gICAgICAgIHZhbGlkYXRlXzEudmFsaWRhdGVUaW1lbGluZSh0aW1lbGluZSwgZmFsc2UpO1xuICAgICAgICBsaWJfMS5yZXNldElkKCk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkVGltZWxpbmUgPSB7XG4gICAgICAgICAgICBvcHRpb25zOiB7IC4uLm9wdGlvbnMgfSxcbiAgICAgICAgICAgIG9iamVjdHM6IHt9LFxuICAgICAgICAgICAgY2xhc3Nlczoge30sXG4gICAgICAgICAgICBsYXllcnM6IHt9LFxuICAgICAgICAgICAgc3RhdGlzdGljczoge1xuICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRDb3VudDogMCxcbiAgICAgICAgICAgICAgICByZXNvbHZlZENvdW50OiAwLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkSW5zdGFuY2VDb3VudDogMCxcbiAgICAgICAgICAgICAgICByZXNvbHZlZE9iamVjdENvdW50OiAwLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkR3JvdXBDb3VudDogMCxcbiAgICAgICAgICAgICAgICByZXNvbHZlZEtleWZyYW1lQ291bnQ6IDAsXG4gICAgICAgICAgICAgICAgcmVzb2x2aW5nQ291bnQ6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBTdGVwIDE6IHByZS1wb3B1bGF0ZSByZXNvbHZlZFRpbWVsaW5lIHdpdGggb2JqZWN0c1xuICAgICAgICBjb25zdCBhZGRUb1Jlc29sdmVkVGltZWxpbmUgPSAob2JqLCBsZXZlbERlZXAsIHBhcmVudElkLCBpc0tleWZyYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzW29iai5pZF0pXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEFsbCB0aW1lbGluZU9iamVjdHMgbXVzdCBiZSB1bmlxdWUhIChkdXBsaWNhdGU6IFwiJHtvYmouaWR9XCIpYCk7XG4gICAgICAgICAgICBjb25zdCBvID0gbGliXzEuZXh0ZW5kTWFuZGFkb3J5KF8uY2xvbmUob2JqKSwge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2aW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxEZWVwOiBsZXZlbERlZXAsXG4gICAgICAgICAgICAgICAgICAgIGlzU2VsZlJlZmVyZW5jaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0UmVmZXJlbmNlczogW10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgby5yZXNvbHZlZC5wYXJlbnRJZCA9IHBhcmVudElkO1xuICAgICAgICAgICAgICAgIG8ucmVzb2x2ZWQuZGlyZWN0UmVmZXJlbmNlcy5wdXNoKHBhcmVudElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0tleWZyYW1lKVxuICAgICAgICAgICAgICAgIG8ucmVzb2x2ZWQuaXNLZXlmcmFtZSA9IHRydWU7XG4gICAgICAgICAgICBjb21tb25fMS5hZGRPYmplY3RUb1Jlc29sdmVkVGltZWxpbmUocmVzb2x2ZWRUaW1lbGluZSwgbyk7XG4gICAgICAgICAgICAvLyBBZGQgY2hpbGRyZW46XG4gICAgICAgICAgICBpZiAob2JqLmlzR3JvdXAgJiYgb2JqLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmouY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBvYmouY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGFkZFRvUmVzb2x2ZWRUaW1lbGluZShjaGlsZCwgbGV2ZWxEZWVwICsgMSwgb2JqLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQga2V5ZnJhbWVzOlxuICAgICAgICAgICAgaWYgKG9iai5rZXlmcmFtZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5rZXlmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ZnJhbWUgPSBvYmoua2V5ZnJhbWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZjIgPSBsaWJfMS5leHRlbmRNYW5kYWRvcnkoXy5jbG9uZShrZXlmcmFtZSksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRvUmVzb2x2ZWRUaW1lbGluZShrZjIsIGxldmVsRGVlcCArIDEsIG9iai5pZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBvYmogPSB0aW1lbGluZVtpXTtcbiAgICAgICAgICAgIGFkZFRvUmVzb2x2ZWRUaW1lbGluZShvYmosIDApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0ZXAgMjogZ28gdGhvdWdoIGFuZCByZXNvbHZlIHRoZSBvYmplY3RzXG4gICAgICAgIGlmIChvcHRpb25zLmNhY2hlKSB7XG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIG9iamVjdHMgaGFzIGNoYW5nZWQgc2luY2UgbGFzdCB0aW1lXG4gICAgICAgICAgICBjb25zdCBjYWNoZSA9IGNhY2hlXzEuaW5pdGlhbGl6ZUNhY2hlKG9wdGlvbnMuY2FjaGUsIHJlc29sdmVkVGltZWxpbmUpO1xuICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBhbGwgbmV3IG9iamVjdHMsIGFuZCBkZXRlcm1pbmUgd2hldGhlciB0aGV5IGhhdmUgY2hhbmdlZDpcbiAgICAgICAgICAgIGNvbnN0IGFsbE5ld09iamVjdHMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZWRSZWZlcmVuY2VzID0ge307XG4gICAgICAgICAgICBjb25zdCBnZXRBbGxSZWZlcmVuY2VzVGhpc09iamVjdEFmZmVjdHMgPSAobmV3T2JqKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlcyA9IFsnIycgKyBuZXdPYmouaWRdO1xuICAgICAgICAgICAgICAgIGlmIChuZXdPYmouY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBuZXdPYmouY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKCcuJyArIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ld09iai5sYXllcilcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKCckJyArIG5ld09iai5sYXllcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmVyZW5jZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYWRkQ2hhbmdlZE9iamVjdCA9IChvYmopID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWZlcmVuY2VzID0gZ2V0QWxsUmVmZXJlbmNlc1RoaXNPYmplY3RBZmZlY3RzKG9iaik7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZWYgb2YgcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkUmVmZXJlbmNlc1tyZWZdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXy5lYWNoKHJlc29sdmVkVGltZWxpbmUub2JqZWN0cywgKG9iaikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZEhhc2ggPSBjYWNoZS5vYmpIYXNoZXNbb2JqLmlkXTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdIYXNoID0gY2FjaGVfMS5oYXNoVGltZWxpbmVPYmplY3Qob2JqKTtcbiAgICAgICAgICAgICAgICBhbGxOZXdPYmplY3RzW29iai5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghb2xkSGFzaCB8fCBvbGRIYXNoICE9PSBuZXdIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLm9iakhhc2hlc1tvYmouaWRdID0gbmV3SGFzaDtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2hhbmdlZE9iamVjdChvYmopO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRPYmogPSBjYWNoZS5yZXNvbHZlZFRpbWVsaW5lLm9iamVjdHNbb2JqLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZE9iailcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENoYW5nZWRPYmplY3Qob2xkT2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHRpbWluZy1hZmZlY3RpbmcgY2hhbmdlcyBkZXRlY3RlZFxuICAgICAgICAgICAgICAgICAgICAvLyBFdmVuIHRob3VnaCB0aGUgdGltZWxpbmUtcHJvcGVydGllcyBoYXNuJ3QgY2hhbmdlZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNvbnRlbnQgKGFuZCBvdGhlciBwcm9wZXJ0aWVzKSBtaWdodCBoYXZlOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRPYmogPSBjYWNoZS5yZXNvbHZlZFRpbWVsaW5lLm9iamVjdHNbb2JqLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUucmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzW29iai5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vYmosXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZDogb2xkT2JqLnJlc29sdmVkLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNhY2hlLmhhc09sZERhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBHbyB0aHJvdWdoIGFsbCBvbGQgaGFzaGVzLCByZW1vdmluZyB0aGUgb25lcyB0aGF0IGRvZXNuJ3QgZXhpc3QgYW55bW9yZVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb2JqSWQgaW4gY2FjaGUucmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsTmV3T2JqZWN0c1tvYmpJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IGNhY2hlLnJlc29sdmVkVGltZWxpbmUub2JqZWN0c1tvYmpJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGUub2JqSGFzaGVzW29iaklkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENoYW5nZWRPYmplY3Qob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJbnZhbGlkYXRlIG9iamVjdHMsIGJ5IGdyYWR1YWxseSByZW1vdmluZyB0aGUgaW52YWxpZGF0ZWQgb25lcyBmcm9tIHZhbGlkT2JqZWN0c1xuICAgICAgICAgICAgICAgIC8vIFByZXBhcmUgdmFsaWRPYmplY3RzOlxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkT2JqZWN0cyA9IHt9O1xuICAgICAgICAgICAgICAgIF8uZWFjaChyZXNvbHZlZFRpbWVsaW5lLm9iamVjdHMsIChvYmopID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRPYmplY3RzW29iai5pZF0gPSBvYmo7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLyoqIEFsbCByZWZlcmVuY2VzIHRoYXQgZGVwZW5kIG9uIGFub3RoZXIgcmVmZXJlbmNlIChpZSBvYmplY3RzLCBjbGFzc3Mgb3IgbGF5ZXJzKTogKi9cbiAgICAgICAgICAgICAgICBjb25zdCBhZmZlY3RSZWZlcmVuY2VNYXAgPSB7fTtcbiAgICAgICAgICAgICAgICBfLmVhY2gocmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzLCAob2JqKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBldmVyeXRoaW5nIHRoYXQgdGhpcyBvYmplY3QgYWZmZWN0czpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkT2JqID0gY2FjaGUucmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzW29iai5pZF07XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZmZlY3RlZFJlZmVyZW5jZXMgPSBnZXRBbGxSZWZlcmVuY2VzVGhpc09iamVjdEFmZmVjdHMob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRSZWZlcmVuY2VzID0gXy51bmlxKGFmZmVjdGVkUmVmZXJlbmNlcy5jb25jYXQoZ2V0QWxsUmVmZXJlbmNlc1RoaXNPYmplY3RBZmZlY3RzKGNhY2hlZE9iaikpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFmZmVjdGVkUmVmZXJlbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gYWZmZWN0ZWRSZWZlcmVuY2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqUmVmID0gJyMnICsgb2JqLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZiAhPT0gb2JqUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhZmZlY3RSZWZlcmVuY2VNYXBbb2JqUmVmXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0UmVmZXJlbmNlTWFwW29ialJlZl0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RSZWZlcmVuY2VNYXBbb2JqUmVmXS5wdXNoKHJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGV2ZXJ5dGhpbmcgdGhhdCB0aGlzIG9iamVjdCBpcyBhZmZlY3RlZCBieTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZWRSZWZlcmVuY2VzWycjJyArIG9iai5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvYmplY3QgaXMgZGlyZWN0bHkgc2FpZCB0byBiZSBpbnZhbGlkLCBubyBuZWVkIHRvIGFkZCBpdCB0byByZWZlcmVuY2luZ09iamVjdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBpdCdsbCBiZSBlYXNpbHkgaW52YWxpZGF0ZWQgYW55d2F5IGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiB3ZSBvbmx5IGhhdmUgdG8gY2hlY2sgZm9yIHRoZSBPTEQgb2JqZWN0LCBzaW5jZSBpZiB0aGUgb2xkIGFuZCB0aGUgbmV3IG9iamVjdCBkaWZmZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCB3b3VsZCBtZWFuIGl0J2xsIGJlIGRpcmVjdGx5IGludmFsaWRhdGVkIGFueXdheS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWRPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGZXRjaCBhbGwgcmVmZXJlbmNlcyBmb3IgdGhlIG9iamVjdCBmcm9tIHRoZSBsYXN0IHRpbWUgaXQgd2FzIHJlc29sdmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IFRoaXMgY2FuIGJlIGRvbmUsIHNpbmNlIF9pZl8gdGhlIG9iamVjdCB3YXMgY2hhbmdlZCBpbiBhbnkgd2F5IHNpbmNlIGxhc3QgcmVzb2x2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J2xsIGJlIGludmFsaWRhdGVkIGFueXdheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlcGVuZE9uUmVmZXJlbmNlcyA9IGNhY2hlXzEuZ2V0T2JqZWN0UmVmZXJlbmNlcyhjYWNoZWRPYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwZW5kT25SZWZlcmVuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IGRlcGVuZE9uUmVmZXJlbmNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhZmZlY3RSZWZlcmVuY2VNYXBbcmVmXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdFJlZmVyZW5jZU1hcFtyZWZdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdFJlZmVyZW5jZU1hcFtyZWZdLnB1c2goJyMnICsgb2JqLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBJbnZhbGlkYXRlIGFsbCBjaGFuZ2VkIG9iamVjdHMsIGFuZCByZWN1cnNpdmVseSBpbnZhbGlkYXRlIGFsbCBvYmplY3RzIHRoYXQgcmVmZXJlbmNlIHRob3NlIG9iamVjdHM6XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlZFJlZmVyZW5jZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlZmVyZW5jZSBvZiBPYmplY3Qua2V5cyhjaGFuZ2VkUmVmZXJlbmNlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZGF0ZU9iamVjdHNXaXRoUmVmZXJlbmNlKGhhbmRsZWRSZWZlcmVuY2VzLCByZWZlcmVuY2UsIGFmZmVjdFJlZmVyZW5jZU1hcCwgdmFsaWRPYmplY3RzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlIG9iamVjdHMgdGhhdCBhcmUgbGVmdCBpbiB2YWxpZE9iamVjdHMgYXQgdGhpcyBwb2ludCBhcmUgc3RpbGwgdmFsaWQuXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIHJldXNlIHRoZSBvbGQgcmVzb2x2aW5nIGZvciB0aG9zZTpcbiAgICAgICAgICAgICAgICBfLmVhY2godmFsaWRPYmplY3RzLCAob2JqKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FjaGUucmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzW29iai5pZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNvbWV0aGluZyB3ZW50IHdyb25nOiBcIiR7b2JqLmlkfVwiIGRvZXMgbm90IGV4aXN0IGluIGNhY2hlLnJlc29sdmVkVGltZWxpbmUub2JqZWN0c2ApO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFRpbWVsaW5lLm9iamVjdHNbb2JqLmlkXSA9IGNhY2hlLnJlc29sdmVkVGltZWxpbmUub2JqZWN0c1tvYmouaWRdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXy5lYWNoKHJlc29sdmVkVGltZWxpbmUub2JqZWN0cywgKG9iaikgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmVUaW1lbGluZU9iaihyZXNvbHZlZFRpbWVsaW5lLCBvYmopO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTYXZlIGZvciBuZXh0IHRpbWU6XG4gICAgICAgICAgICBjYWNoZS5yZXNvbHZlZFRpbWVsaW5lID0gcmVzb2x2ZWRUaW1lbGluZTtcbiAgICAgICAgICAgIGNhY2hlLmhhc09sZERhdGEgPSB0cnVlO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHN0YXRpc3RpY3MsIHNpbmNlIHRoYXQncyBub3QgYWNjdXJhdGUgYWZ0ZXIgaGF2aW5nIHVzZWQgdGhlIGNhY2hlOlxuICAgICAgICAgICAgcmVzb2x2ZWRUaW1lbGluZS5zdGF0aXN0aWNzLnVucmVzb2x2ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICByZXNvbHZlZFRpbWVsaW5lLnN0YXRpc3RpY3MucmVzb2x2ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICByZXNvbHZlZFRpbWVsaW5lLnN0YXRpc3RpY3MucmVzb2x2ZWRJbnN0YW5jZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHJlc29sdmVkVGltZWxpbmUuc3RhdGlzdGljcy5yZXNvbHZlZE9iamVjdENvdW50ID0gMDtcbiAgICAgICAgICAgIHJlc29sdmVkVGltZWxpbmUuc3RhdGlzdGljcy5yZXNvbHZlZEdyb3VwQ291bnQgPSAwO1xuICAgICAgICAgICAgcmVzb2x2ZWRUaW1lbGluZS5zdGF0aXN0aWNzLnJlc29sdmVkS2V5ZnJhbWVDb3VudCA9IDA7XG4gICAgICAgICAgICBfLmVhY2gocmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzLCAob2JqKSA9PiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlU3RhdGlzdGljcyhyZXNvbHZlZFRpbWVsaW5lLCBvYmopO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRUaW1lbGluZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBjYWNoZSBwcm92aWRlZCwganVzdCByZXNvbHZlIGFsbCBvYmplY3RzOlxuICAgICAgICAgICAgXy5lYWNoKHJlc29sdmVkVGltZWxpbmUub2JqZWN0cywgKG9iaikgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmVUaW1lbGluZU9iaihyZXNvbHZlZFRpbWVsaW5lLCBvYmopO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRUaW1lbGluZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQ2FsY3VsYXRlIHRoZSBzdGF0ZSBmb3IgYWxsIHBvaW50cyBpbiB0aW1lLiAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZUFsbFN0YXRlcyhyZXNvbHZlZFRpbWVsaW5lLCBjYWNoZSkge1xuICAgICAgICByZXR1cm4gc3RhdGVfMS5yZXNvbHZlU3RhdGVzKHJlc29sdmVkVGltZWxpbmUsIHVuZGVmaW5lZCwgY2FjaGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHN0YXRlIGF0IGEgZ2l2ZW4gcG9pbnQgaW4gdGltZS5cbiAgICAgKiBVc2luZyBhIFJlc29sdmVkVGltZWxpbmUgY2FsY3VsYXRlZCBieSBSZXNvbHZlci5yZXNvbHZlVGltZWxpbmUoKSBvclxuICAgICAqIGEgUmVzb2x2ZWRTdGF0ZXMgY2FsY3VsYXRlZCBieSBSZXNvbHZlci5yZXNvbHZlQWxsU3RhdGVzKClcbiAgICAgKiBAcGFyYW0gcmVzb2x2ZWQgUmVzb2x2ZWRUaW1lbGluZSBjYWxjdWxhdGVkIGJ5IFJlc29sdmVyLnJlc29sdmVUaW1lbGluZS5cbiAgICAgKiBAcGFyYW0gdGltZSBUaGUgcG9pbnQgaW4gdGltZSB3aGVyZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlXG4gICAgICogQHBhcmFtIGV2ZW50TGltaXQgKE9wdGlvbmFsKSBMaW1pdHMgdGhlIG51bWJlciBvZiByZXR1cm5lZCB1cGNvbWluZyBldmVudHMuXG4gICAgICovXG4gICAgc3RhdGljIGdldFN0YXRlKHJlc29sdmVkLCB0aW1lLCBldmVudExpbWl0KSB7XG4gICAgICAgIHJldHVybiBzdGF0ZV8xLmdldFN0YXRlKHJlc29sdmVkLCB0aW1lLCBldmVudExpbWl0KTtcbiAgICB9XG59XG5leHBvcnRzLlJlc29sdmVyID0gUmVzb2x2ZXI7XG5mdW5jdGlvbiByZXNvbHZlVGltZWxpbmVPYmoocmVzb2x2ZWRUaW1lbGluZSwgb2JqKSB7XG4gICAgaWYgKG9iai5yZXNvbHZlZC5yZXNvbHZlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChvYmoucmVzb2x2ZWQucmVzb2x2aW5nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENpcmN1bGFyIGRlcGVuZGVuY3kgd2hlbiB0cnlpbmcgdG8gcmVzb2x2ZSBcIiR7b2JqLmlkfVwiYCk7XG4gICAgb2JqLnJlc29sdmVkLnJlc29sdmluZyA9IHRydWU7XG4gICAgcmVzb2x2ZWRUaW1lbGluZS5zdGF0aXN0aWNzLnJlc29sdmluZ0NvdW50Kys7XG4gICAgbGV0IGluc3RhbmNlcyA9IFtdO1xuICAgIGxldCBkaXJlY3RSZWZlcmVuY2VzID0gW107XG4gICAgY29uc3QgZW5hYmxlcyA9IF8uaXNBcnJheShvYmouZW5hYmxlKSA/IG9iai5lbmFibGUgOiBbb2JqLmVuYWJsZV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVuYWJsZSA9IGVuYWJsZXNbaV07XG4gICAgICAgIGxldCBuZXdJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVwZWF0aW5nRXhwciA9IGVuYWJsZS5yZXBlYXRpbmcgIT09IHVuZGVmaW5lZCA/IGV4cHJlc3Npb25fMS5pbnRlcnByZXRFeHByZXNzaW9uKGVuYWJsZS5yZXBlYXRpbmcpIDogbnVsbDtcbiAgICAgICAgY29uc3QgbG9va2VkUmVwZWF0aW5nID0gbG9va3VwRXhwcmVzc2lvbihyZXNvbHZlZFRpbWVsaW5lLCBvYmosIHJlcGVhdGluZ0V4cHIsICdkdXJhdGlvbicpO1xuICAgICAgICBjb25zdCBsb29rZWR1cFJlcGVhdGluZyA9IGxvb2tlZFJlcGVhdGluZy5pbnN0YW5jZXM7XG4gICAgICAgIGRpcmVjdFJlZmVyZW5jZXMgPSBkaXJlY3RSZWZlcmVuY2VzLmNvbmNhdChsb29rZWRSZXBlYXRpbmcuYWxsUmVmZXJlbmNlcyk7XG4gICAgICAgIGlmIChfLmlzQXJyYXkobG9va2VkdXBSZXBlYXRpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvb2t1cEV4cHJlc3Npb24gc2hvdWxkIG5ldmVyIHJldHVybiBhbiBhcnJheSBmb3IgLmR1cmF0aW9uIGxvb2t1cGApOyAvLyBwZXJoYXBzIHRtcD8gbWF5YmUgcmV2aXNpdCB0aGlzIGF0IHNvbWUgcG9pbnRcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSBlbmFibGUud2hpbGUgIT09IHVuZGVmaW5lZCA/IGVuYWJsZS53aGlsZSA6IGVuYWJsZS5zdGFydCAhPT0gdW5kZWZpbmVkID8gZW5hYmxlLnN0YXJ0IDogJyc7XG4gICAgICAgIGlmIChlbmFibGUud2hpbGUgKyAnJyA9PT0gJzEnKSB7XG4gICAgICAgICAgICBzdGFydCA9ICd0cnVlJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbmFibGUud2hpbGUgKyAnJyA9PT0gJzAnKSB7XG4gICAgICAgICAgICBzdGFydCA9ICdmYWxzZSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRFeHByID0gZXhwcmVzc2lvbl8xLnNpbXBsaWZ5RXhwcmVzc2lvbihzdGFydCk7XG4gICAgICAgIGxldCBwYXJlbnRJbnN0YW5jZXMgPSBudWxsO1xuICAgICAgICBsZXQgaGFzUGFyZW50ID0gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydFJlZmVyc1RvUGFyZW50ID0gZmFsc2U7XG4gICAgICAgIGlmIChvYmoucmVzb2x2ZWQucGFyZW50SWQpIHtcbiAgICAgICAgICAgIGhhc1BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBsb29rdXAgPSBsb29rdXBFeHByZXNzaW9uKHJlc29sdmVkVGltZWxpbmUsIG9iaiwgZXhwcmVzc2lvbl8xLmludGVycHJldEV4cHJlc3Npb24oYCMke29iai5yZXNvbHZlZC5wYXJlbnRJZH1gKSwgJ3N0YXJ0Jyk7XG4gICAgICAgICAgICBwYXJlbnRJbnN0YW5jZXMgPSBsb29rdXAuaW5zdGFuY2VzOyAvLyBhIHN0YXJ0LXJlZmVyZW5jZSB3aWxsIGFsd2F5cyByZXR1cm4gYW4gYXJyYXksIG9yIG51bGxcbiAgICAgICAgICAgIGRpcmVjdFJlZmVyZW5jZXMgPSBkaXJlY3RSZWZlcmVuY2VzLmNvbmNhdChsb29rdXAuYWxsUmVmZXJlbmNlcyk7XG4gICAgICAgICAgICBpZiAobGliXzEuaXNDb25zdGFudChzdGFydEV4cHIpKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSB1c2UgcGFyZW50IGlmIHRoZSBleHByZXNzaW9uIHJlc29sdmVzIHRvIGEgbnVtYmVyIChpZSBkb2Vzbid0IGNvbnRhaW4gYW55IHJlZmVyZW5jZXMpXG4gICAgICAgICAgICAgICAgc3RhcnRSZWZlcnNUb1BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9va3VwU3RhcnQgPSBsb29rdXBFeHByZXNzaW9uKHJlc29sdmVkVGltZWxpbmUsIG9iaiwgc3RhcnRFeHByLCAnc3RhcnQnKTtcbiAgICAgICAgbGV0IGxvb2tlZHVwU3RhcnRzID0gbG9va3VwU3RhcnQuaW5zdGFuY2VzO1xuICAgICAgICBkaXJlY3RSZWZlcmVuY2VzID0gZGlyZWN0UmVmZXJlbmNlcy5jb25jYXQobG9va3VwU3RhcnQuYWxsUmVmZXJlbmNlcyk7XG4gICAgICAgIGlmIChzdGFydFJlZmVyc1RvUGFyZW50KSB7XG4gICAgICAgICAgICBsb29rZWR1cFN0YXJ0cyA9IGxpYl8xLmFwcGx5UGFyZW50SW5zdGFuY2VzKHBhcmVudEluc3RhbmNlcywgbG9va2VkdXBTdGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmFibGUud2hpbGUpIHtcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkobG9va2VkdXBTdGFydHMpKSB7XG4gICAgICAgICAgICAgICAgbmV3SW5zdGFuY2VzID0gbG9va2VkdXBTdGFydHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsb29rZWR1cFN0YXJ0cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ld0luc3RhbmNlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGxpYl8xLmdldElkKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbG9va2VkdXBTdGFydHMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBsb29rZWR1cFN0YXJ0cy5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBldmVudHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBpU3RhcnQgPSAwO1xuICAgICAgICAgICAgbGV0IGlFbmQgPSAwO1xuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShsb29rZWR1cFN0YXJ0cykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvb2tlZHVwU3RhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gbG9va2VkdXBTdGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IGluc3RhbmNlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IGluc3RhbmNlOiBpbnN0YW5jZSwgaWQ6IG9iai5pZCArICdfJyArIGlTdGFydCsrIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBpbnN0YW5jZS5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsb29rZWR1cFN0YXJ0cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGltZTogbG9va2VkdXBTdGFydHMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBsaWJfMS5nZXRJZCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBsb29rZWR1cFN0YXJ0cy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogbG9va2VkdXBTdGFydHMucmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogb2JqLmlkICsgJ18nICsgaVN0YXJ0KyssXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGxvb2tlZHVwU3RhcnRzLnJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5hYmxlLmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kRXhwciA9IGV4cHJlc3Npb25fMS5pbnRlcnByZXRFeHByZXNzaW9uKGVuYWJsZS5lbmQpO1xuICAgICAgICAgICAgICAgIGxldCBlbmRSZWZlcnNUb1BhcmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChvYmoucmVzb2x2ZWQucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpYl8xLmlzQ29uc3RhbnQoZW5kRXhwcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgdXNlIHBhcmVudCBpZiB0aGUgZXhwcmVzc2lvbiByZXNvbHZlcyB0byBhIG51bWJlciAoaWUgZG9lc24ndCBjb250YWluIGFueSByZWZlcmVuY2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kUmVmZXJzVG9QYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGxvb2tlZHVwRW5kcyB3aWxsIGNvbnRhaW4gYW4gaW52ZXJ0ZWQgbGlzdCBvZiBpbnN0YW5jZXMuIFRoZXJlZm9yZSAuc3RhcnQgbWVhbnMgYW4gZW5kXG4gICAgICAgICAgICAgICAgY29uc3QgbG9va3VwRW5kID0gZW5kRXhwciA/IGxvb2t1cEV4cHJlc3Npb24ocmVzb2x2ZWRUaW1lbGluZSwgb2JqLCBlbmRFeHByLCAnZW5kJykgOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBsb29rZWR1cEVuZHMgPSBsb29rdXBFbmQgPyBsb29rdXBFbmQuaW5zdGFuY2VzIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAobG9va3VwRW5kKVxuICAgICAgICAgICAgICAgICAgICBkaXJlY3RSZWZlcmVuY2VzID0gZGlyZWN0UmVmZXJlbmNlcy5jb25jYXQobG9va3VwRW5kLmFsbFJlZmVyZW5jZXMpO1xuICAgICAgICAgICAgICAgIGlmIChlbmRSZWZlcnNUb1BhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBsb29rZWR1cEVuZHMgPSBsaWJfMS5hcHBseVBhcmVudEluc3RhbmNlcyhwYXJlbnRJbnN0YW5jZXMsIGxvb2tlZHVwRW5kcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkobG9va2VkdXBFbmRzKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvb2tlZHVwRW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBsb29rZWR1cEVuZHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogaW5zdGFuY2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgaW5zdGFuY2U6IGluc3RhbmNlLCBpZDogb2JqLmlkICsgJ18nICsgaUVuZCsrIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogaW5zdGFuY2UucmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvb2tlZHVwRW5kcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBsb29rZWR1cEVuZHMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGxpYl8xLmdldElkKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBsb29rZWR1cEVuZHMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogbG9va2VkdXBFbmRzLnJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogb2JqLmlkICsgJ18nICsgaUVuZCsrLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGxvb2tlZHVwRW5kcy5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmFibGUuZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uRXhwciA9IGV4cHJlc3Npb25fMS5pbnRlcnByZXRFeHByZXNzaW9uKGVuYWJsZS5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9va3VwRHVyYXRpb24gPSBsb29rdXBFeHByZXNzaW9uKHJlc29sdmVkVGltZWxpbmUsIG9iaiwgZHVyYXRpb25FeHByLCAnZHVyYXRpb24nKTtcbiAgICAgICAgICAgICAgICBsZXQgbG9va2VkdXBEdXJhdGlvbiA9IGxvb2t1cER1cmF0aW9uLmluc3RhbmNlcztcbiAgICAgICAgICAgICAgICBkaXJlY3RSZWZlcmVuY2VzID0gZGlyZWN0UmVmZXJlbmNlcy5jb25jYXQobG9va3VwRHVyYXRpb24uYWxsUmVmZXJlbmNlcyk7XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNBcnJheShsb29rZWR1cER1cmF0aW9uKSAmJiBsb29rZWR1cER1cmF0aW9uLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBsb29rZWR1cER1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxvb2tlZHVwRHVyYXRpb25bMF0uc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBsb29rZWR1cER1cmF0aW9uWzBdLnJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkobG9va2VkdXBEdXJhdGlvbikgJiYgIWxvb2tlZHVwRHVyYXRpb24ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBsb29rZWR1cER1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc0FycmF5KGxvb2tlZHVwRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbG9va3VwRXhwcmVzc2lvbiBzaG91bGQgbmV2ZXIgcmV0dXJuIGFuIGFycmF5IGZvciAuZHVyYXRpb24gbG9va3VwYCk7IC8vIHBlcmhhcHMgdG1wPyBtYXliZSByZXZpc2l0IHRoaXMgYXQgc29tZSBwb2ludFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb29rZWR1cER1cmF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb29rZWR1cFJlcGVhdGluZyAhPT0gbnVsbCAmJiBsb29rZWR1cER1cmF0aW9uLnZhbHVlID4gbG9va2VkdXBSZXBlYXRpbmcudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBsb29rZWR1cER1cmF0aW9uLnZhbHVlID0gbG9va2VkdXBSZXBlYXRpbmcudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcExvb2tlZHVwRHVyYXRpb24gPSBsb29rZWR1cER1cmF0aW9uOyAvLyBjYXN0IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBldmVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBlLnRpbWUgKyB0bXBMb29rZWR1cER1cmF0aW9uLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZXMgPSBsaWJfMS5qb2luUmVmZXJlbmNlcyhlLnJlZmVyZW5jZXMsIHRtcExvb2tlZHVwRHVyYXRpb24ucmVmZXJlbmNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBlLmRhdGEuaW5zdGFuY2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IHJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiByZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3SW5zdGFuY2VzID0gbGliXzEuY29udmVydEV2ZW50c1RvSW5zdGFuY2VzKGV2ZW50cywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNQYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIGZpZ3VyZSBvdXQgd2hhdCBwYXJlbnQtaW5zdGFuY2UgdGhlIGluc3RhbmNlcyBhcmUgdGllZCB0bywgYW5kIGNhcCB0aGVtXG4gICAgICAgICAgICBjb25zdCBjYXBwZWRJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3SW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXdJbnN0YW5jZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZlcnJlZFBhcmVudEluc3RhbmNlID0gXy5maW5kKHBhcmVudEluc3RhbmNlcywgKHBhcmVudEluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UucmVmZXJlbmNlcy5pbmRleE9mKHBhcmVudEluc3RhbmNlLmlkKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmZXJyZWRQYXJlbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNoaWxkIHJlZmVycyB0byBpdHMgcGFyZW50LCB0aGVyZSBzaG91bGQgYmUgb25lIHNwZWNpZmljIGluc3RhbmNlIHRvIGNhcCBpbnRvXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXBwZWRJbnN0YW5jZSA9IGxpYl8xLmNhcEluc3RhbmNlcyhbaW5zdGFuY2VdLCBbcmVmZXJyZWRQYXJlbnRJbnN0YW5jZV0pWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhcHBlZEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYXBwZWRJbnN0YW5jZS5jYXBzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXBwZWRJbnN0YW5jZS5jYXBzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwcGVkSW5zdGFuY2UuY2Fwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHJlZmVycmVkUGFyZW50SW5zdGFuY2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiByZWZlcnJlZFBhcmVudEluc3RhbmNlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHJlZmVycmVkUGFyZW50SW5zdGFuY2UuZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcHBlZEluc3RhbmNlcy5wdXNoKGNhcHBlZEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjaGlsZCBkb2Vzbid0IHJlZmVyIHRvIGl0cyBwYXJlbnQsIGl0IHNob3VsZCBiZSBjYXBwZWQgd2l0aGluIGFsbCBvZiBpdHMgcGFyZW50IGluc3RhbmNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJbnN0YW5jZSA9IHBhcmVudEluc3RhbmNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXBwZWRJbnN0YW5jZSA9IGxpYl8xLmNhcEluc3RhbmNlcyhbaW5zdGFuY2VdLCBbcGFyZW50SW5zdGFuY2VdKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FwcGVkSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhcHBlZEluc3RhbmNlLmNhcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwcGVkSW5zdGFuY2UuY2FwcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwcGVkSW5zdGFuY2UuY2Fwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcGFyZW50SW5zdGFuY2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHBhcmVudEluc3RhbmNlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcGFyZW50SW5zdGFuY2UuZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwcGVkSW5zdGFuY2VzLnB1c2goY2FwcGVkSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0luc3RhbmNlcyA9IGNhcHBlZEluc3RhbmNlcztcbiAgICAgICAgfVxuICAgICAgICBuZXdJbnN0YW5jZXMgPSBsaWJfMS5hcHBseVJlcGVhdGluZ0luc3RhbmNlcyhuZXdJbnN0YW5jZXMsIGxvb2tlZHVwUmVwZWF0aW5nLCByZXNvbHZlZFRpbWVsaW5lLm9wdGlvbnMpO1xuICAgICAgICBpbnN0YW5jZXMgPSBpbnN0YW5jZXMuY29uY2F0KG5ld0luc3RhbmNlcyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgaW5zdGFuY2UgaWRzIGFyZSB1bmlxdWU6XG4gICAgY29uc3QgaWRzID0ge307XG4gICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICAgICAgaWYgKGlkc1tpbnN0YW5jZS5pZF0pIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmlkID0gYCR7aW5zdGFuY2UuaWR9XyR7bGliXzEuZ2V0SWQoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlkc1tpbnN0YW5jZS5pZF0gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob2JqLnNlYW1sZXNzICYmIGluc3RhbmNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGluc3RhbmNlcyA9IGxpYl8xLmNsZWFuSW5zdGFuY2VzKGluc3RhbmNlcywgdHJ1ZSwgZmFsc2UpO1xuICAgIH1cbiAgICBvYmoucmVzb2x2ZWQucmVzb2x2ZWQgPSB0cnVlO1xuICAgIG9iai5yZXNvbHZlZC5yZXNvbHZpbmcgPSBmYWxzZTtcbiAgICBvYmoucmVzb2x2ZWQuaW5zdGFuY2VzID0gaW5zdGFuY2VzO1xuICAgIG9iai5yZXNvbHZlZC5kaXJlY3RSZWZlcmVuY2VzID0gZGlyZWN0UmVmZXJlbmNlcztcbiAgICB1cGRhdGVTdGF0aXN0aWNzKHJlc29sdmVkVGltZWxpbmUsIG9iaik7XG59XG5leHBvcnRzLnJlc29sdmVUaW1lbGluZU9iaiA9IHJlc29sdmVUaW1lbGluZU9iajtcbmZ1bmN0aW9uIHVwZGF0ZVN0YXRpc3RpY3MocmVzb2x2ZWRUaW1lbGluZSwgb2JqKSB7XG4gICAgaWYgKG9iai5yZXNvbHZlZC5pbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc29sdmVkVGltZWxpbmUuc3RhdGlzdGljcy5yZXNvbHZlZEluc3RhbmNlQ291bnQgKz0gb2JqLnJlc29sdmVkLmluc3RhbmNlcy5sZW5ndGg7XG4gICAgICAgIHJlc29sdmVkVGltZWxpbmUuc3RhdGlzdGljcy5yZXNvbHZlZENvdW50ICs9IDE7XG4gICAgICAgIGlmIChvYmouaXNHcm91cCkge1xuICAgICAgICAgICAgcmVzb2x2ZWRUaW1lbGluZS5zdGF0aXN0aWNzLnJlc29sdmVkR3JvdXBDb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoucmVzb2x2ZWQuaXNLZXlmcmFtZSkge1xuICAgICAgICAgICAgcmVzb2x2ZWRUaW1lbGluZS5zdGF0aXN0aWNzLnJlc29sdmVkS2V5ZnJhbWVDb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZWRUaW1lbGluZS5zdGF0aXN0aWNzLnJlc29sdmVkT2JqZWN0Q291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZWRUaW1lbGluZS5zdGF0aXN0aWNzLnVucmVzb2x2ZWRDb3VudCArPSAxO1xuICAgIH1cbn1cbi8qKiBJbnZhbGlkYXRlIGFsbCBjaGFuZ2VkIG9iamVjdHMsIGFuZCByZWN1cnNpdmVseSBpbnZhbGlkYXRlIGFsbCBvYmplY3RzIHRoYXQgcmVmZXJlbmNlIHRob3NlIG9iamVjdHMgKi9cbmZ1bmN0aW9uIGludmFsaWRhdGVPYmplY3RzV2l0aFJlZmVyZW5jZShoYW5kbGVkUmVmZXJlbmNlcywgcmVmZXJlbmNlLCBhZmZlY3RSZWZlcmVuY2VNYXAsIHZhbGlkT2JqZWN0cykge1xuICAgIGlmIChoYW5kbGVkUmVmZXJlbmNlc1tyZWZlcmVuY2VdKVxuICAgICAgICByZXR1cm47IC8vIHRvIGF2b2lkIGluZmluaXRlIGxvb3BzXG4gICAgaGFuZGxlZFJlZmVyZW5jZXNbcmVmZXJlbmNlXSA9IHRydWU7XG4gICAgaWYgKHJlZmVyZW5jZVswXSA9PT0gJyMnKSB7XG4gICAgICAgIC8vIGFuIGlkXG4gICAgICAgIGNvbnN0IG9iaklkID0gcmVmZXJlbmNlLnNsaWNlKDEpO1xuICAgICAgICBpZiAodmFsaWRPYmplY3RzW29iaklkXSkge1xuICAgICAgICAgICAgZGVsZXRlIHZhbGlkT2JqZWN0c1tvYmpJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSW52YWxpZGF0ZSBhbGwgb2JqZWN0cyB0aGF0IGRlcGVuZCBvbiBhbnkgb2YgdGhlIHJlZmVyZW5jZXMgdGhhdCB0aGlzIHJlZmVyZW5jZSBhZmZlY3RzOlxuICAgIGNvbnN0IGFmZmVjdGVkUmVmZXJlbmNlcyA9IGFmZmVjdFJlZmVyZW5jZU1hcFtyZWZlcmVuY2VdO1xuICAgIGlmIChhZmZlY3RlZFJlZmVyZW5jZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZmZlY3RlZFJlZmVyZW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jaW5nUmVmZXJlbmNlID0gYWZmZWN0ZWRSZWZlcmVuY2VzW2ldO1xuICAgICAgICAgICAgaW52YWxpZGF0ZU9iamVjdHNXaXRoUmVmZXJlbmNlKGhhbmRsZWRSZWZlcmVuY2VzLCByZWZlcmVuY2luZ1JlZmVyZW5jZSwgYWZmZWN0UmVmZXJlbmNlTWFwLCB2YWxpZE9iamVjdHMpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBMb29rIHVwIGEgcmVmZXJlbmNlIG9uIHRoZSB0aW1lbGluZVxuICogUmV0dXJuIHZhbHVlczpcbiAqIEFycmF5PFRpbWVsaW5lT2JqZWN0SW5zdGFuY2U+OiBJbnN0YW5jZXMgb24gdGhlIHRpbWVsaW5lIHdoZXJlIHRoZSByZWZlcmVuY2UgZXhwcmVzc2lvbiBpcyB0cnVlXG4gKiBWYWx1ZVdpdGhSZWZlcmVuY2U6IEEgc2luZ3VsYXIgdmFsdWUgd2hpY2ggY2FuIGJlIGNvbWJpbmVkIGFyaXRobWV0aWNhbGx5IHdpdGggSW5zdGFuY2VzXG4gKiBudWxsOiBNZWFucyBcInNvbWV0aGluZyBpcyBpbnZhbGlkXCIsIGFuIG51bGwtdmFsdWUgd2lsbCBhbHdheXMgcmV0dXJuIG51bGwgd2hlbiBjb21iaW5lZCB3aXRoIG90aGVyIHZhbHVlc1xuICpcbiAqIEBwYXJhbSByZXNvbHZlZFRpbWVsaW5lXG4gKiBAcGFyYW0gb2JqXG4gKiBAcGFyYW0gZXhwclxuICogQHBhcmFtIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gbG9va3VwRXhwcmVzc2lvbihyZXNvbHZlZFRpbWVsaW5lLCBvYmosIGV4cHIsIGNvbnRleHQpIHtcbiAgICBpZiAoZXhwciA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHsgaW5zdGFuY2VzOiBudWxsLCBhbGxSZWZlcmVuY2VzOiBbXSB9O1xuICAgIGlmIChfLmlzU3RyaW5nKGV4cHIpICYmIGxpYl8xLmlzTnVtZXJpYyhleHByKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5zdGFuY2VzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQoZXhwciksXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogW10sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWxsUmVmZXJlbmNlczogW10sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKF8uaXNOdW1iZXIoZXhwcikpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluc3RhbmNlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBleHByLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IFtdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsbFJlZmVyZW5jZXM6IFtdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChfLmlzU3RyaW5nKGV4cHIpKSB7XG4gICAgICAgIGV4cHIgPSBleHByLnRyaW0oKTtcbiAgICAgICAgaWYgKGxpYl8xLmlzQ29uc3RhbnQoZXhwcikpIHtcbiAgICAgICAgICAgIGlmIChleHByLm1hdGNoKC9edHJ1ZSQvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFsbFJlZmVyZW5jZXM6IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChleHByLm1hdGNoKC9eZmFsc2UkL2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgYWxsUmVmZXJlbmNlczogW10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBMb29rIHVwIHN0cmluZ1xuICAgICAgICBsZXQgaW52ZXJ0ID0gZmFsc2U7XG4gICAgICAgIGxldCBpZ25vcmVGaXJzdElmWmVybyA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVmZXJlbmNlZE9ianMgPSBbXTtcbiAgICAgICAgbGV0IHJlZiA9IGNvbnRleHQ7XG4gICAgICAgIGxldCByZXN0ID0gJyc7XG4gICAgICAgIGxldCBvYmpJZHNUb1JlZmVyZW5jZSA9IFtdO1xuICAgICAgICBjb25zdCBhbGxSZWZlcmVuY2VzID0gW107XG4gICAgICAgIGxldCByZWZlcmVuY2VJc09rID0gZmFsc2U7XG4gICAgICAgIC8vIE1hdGNoIGlkLCBleGFtcGxlOiBcIiNvYmplY3RJZC5zdGFydFwiXG4gICAgICAgIGNvbnN0IG0gPSBleHByLm1hdGNoKC9eXFxXKiMoW14uXSspKC4qKS8pO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBtWzFdO1xuICAgICAgICAgICAgcmVzdCA9IG1bMl07XG4gICAgICAgICAgICByZWZlcmVuY2VJc09rID0gdHJ1ZTtcbiAgICAgICAgICAgIG9iaklkc1RvUmVmZXJlbmNlID0gW2lkXTtcbiAgICAgICAgICAgIGFsbFJlZmVyZW5jZXMucHVzaCgnIycgKyBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNYXRjaCBjbGFzcywgZXhhbXBsZTogXCIuY2xhc3NOYW1lLnN0YXJ0XCJcbiAgICAgICAgICAgIGNvbnN0IG0gPSBleHByLm1hdGNoKC9eXFxXKlxcLihbXi5dKykoLiopLyk7XG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IG1bMV07XG4gICAgICAgICAgICAgICAgcmVzdCA9IG1bMl07XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSXNPayA9IHRydWU7XG4gICAgICAgICAgICAgICAgb2JqSWRzVG9SZWZlcmVuY2UgPSByZXNvbHZlZFRpbWVsaW5lLmNsYXNzZXNbY2xhc3NOYW1lXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBhbGxSZWZlcmVuY2VzLnB1c2goJy4nICsgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1hdGNoIGxheWVyLCBleGFtcGxlOiBcIiRsYXllclwiXG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IGV4cHIubWF0Y2goL15cXFcqXFwkKFteLl0rKSguKikvKTtcbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXllciA9IG1bMV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3QgPSBtWzJdO1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VJc09rID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb2JqSWRzVG9SZWZlcmVuY2UgPSByZXNvbHZlZFRpbWVsaW5lLmxheWVyc1tsYXllcl0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGFsbFJlZmVyZW5jZXMucHVzaCgnJCcgKyBsYXllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqSWRzVG9SZWZlcmVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZk9iaklkID0gb2JqSWRzVG9SZWZlcmVuY2VbaV07XG4gICAgICAgICAgICBpZiAocmVmT2JqSWQgIT09IG9iai5pZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZk9iaiA9IHJlc29sdmVkVGltZWxpbmUub2JqZWN0c1tyZWZPYmpJZF07XG4gICAgICAgICAgICAgICAgaWYgKHJlZk9iaikge1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VkT2Jqcy5wdXNoKHJlZk9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTG9va3MgbGlrZSB0aGUgb2JqZWN0IGlzIHJlZmVyZW5jaW5nIGl0c2VsZiFcbiAgICAgICAgICAgICAgICBpZiAob2JqLnJlc29sdmVkLnJlc29sdmluZykge1xuICAgICAgICAgICAgICAgICAgICBvYmoucmVzb2x2ZWQuaXNTZWxmUmVmZXJlbmNpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlZmVyZW5jZUlzT2spIHtcbiAgICAgICAgICAgIHJldHVybiB7IGluc3RhbmNlczogbnVsbCwgYWxsUmVmZXJlbmNlczogW10gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnJlc29sdmVkLmlzU2VsZlJlZmVyZW5jaW5nKSB7XG4gICAgICAgICAgICAvLyBFeGNsdWRlIGFueSBzZWxmLXJlZmVyZW5jaW5nIG9iamVjdHM6XG4gICAgICAgICAgICByZWZlcmVuY2VkT2JqcyA9IF8uZmlsdGVyKHJlZmVyZW5jZWRPYmpzLCAocmVmT2JqKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFyZWZPYmoucmVzb2x2ZWQuaXNTZWxmUmVmZXJlbmNpbmc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmZXJlbmNlZE9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAocmVzdC5tYXRjaCgvc3RhcnQvKSlcbiAgICAgICAgICAgICAgICByZWYgPSAnc3RhcnQnO1xuICAgICAgICAgICAgaWYgKHJlc3QubWF0Y2goL2VuZC8pKVxuICAgICAgICAgICAgICAgIHJlZiA9ICdlbmQnO1xuICAgICAgICAgICAgaWYgKHJlc3QubWF0Y2goL2R1cmF0aW9uLykpXG4gICAgICAgICAgICAgICAgcmVmID0gJ2R1cmF0aW9uJztcbiAgICAgICAgICAgIGlmIChyZWYgPT09ICdkdXJhdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBEdXJhdGlvbiByZWZlcnMgdG8gdGhlIGZpcnN0IG9iamVjdCBvbiB0aGUgcmVzb2x2ZWQgdGltZWxpbmVcbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZUR1cmF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVmZXJlbmNlZE9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlZE9iaiA9IHJlZmVyZW5jZWRPYmpzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlVGltZWxpbmVPYmoocmVzb2x2ZWRUaW1lbGluZSwgcmVmZXJlbmNlZE9iaik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZlcmVuY2VkT2JqLnJlc29sdmVkLnJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLnJlc29sdmVkLmlzU2VsZlJlZmVyZW5jaW5nICYmIHJlZmVyZW5jZWRPYmoucmVzb2x2ZWQuaXNTZWxmUmVmZXJlbmNpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcXVlcnlpbmcgb2JqZWN0IGlzIHNlbGYtcmVmZXJlbmNpbmcsIGV4Y2x1ZGUgYW55IG90aGVyIHNlbGYtcmVmZXJlbmNpbmcgb2JqZWN0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RJbnN0YW5jZSA9IF8uZmlyc3QocmVmZXJlbmNlZE9iai5yZXNvbHZlZC5pbnN0YW5jZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gZmlyc3RJbnN0YW5jZS5lbmQgIT09IG51bGwgPyBmaXJzdEluc3RhbmNlLmVuZCAtIGZpcnN0SW5zdGFuY2Uuc3RhcnQgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlRHVyYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBsaWJfMS5qb2luUmVmZXJlbmNlcyhyZWZlcmVuY2VkT2JqLmlkLCBmaXJzdEluc3RhbmNlLnJlZmVyZW5jZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0RHVyYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdGFuY2VEdXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZCA9IGluc3RhbmNlRHVyYXRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3REdXJhdGlvbiA9PT0gbnVsbCB8fCBkLnZhbHVlIDwgZmlyc3REdXJhdGlvbi52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0RHVyYXRpb24gPSBkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBpbnN0YW5jZXM6IGZpcnN0RHVyYXRpb24sIGFsbFJlZmVyZW5jZXM6IGFsbFJlZmVyZW5jZXMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCByZXR1cm5JbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAocmVmID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmID09PSAnZW5kJykge1xuICAgICAgICAgICAgICAgICAgICBpbnZlcnQgPSAhaW52ZXJ0O1xuICAgICAgICAgICAgICAgICAgICBpZ25vcmVGaXJzdElmWmVybyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFVua25vd24gcmVmOiBcIiR7cmVmfVwiYCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWZlcmVuY2VkT2Jqcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZlcmVuY2VkT2JqID0gcmVmZXJlbmNlZE9ianNbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVUaW1lbGluZU9iaihyZXNvbHZlZFRpbWVsaW5lLCByZWZlcmVuY2VkT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZmVyZW5jZWRPYmoucmVzb2x2ZWQucmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmoucmVzb2x2ZWQuaXNTZWxmUmVmZXJlbmNpbmcgJiYgcmVmZXJlbmNlZE9iai5yZXNvbHZlZC5pc1NlbGZSZWZlcmVuY2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBxdWVyeWluZyBvYmplY3QgaXMgc2VsZi1yZWZlcmVuY2luZywgZXhjbHVkZSBhbnkgb3RoZXIgc2VsZi1yZWZlcmVuY2luZyBvYmplY3RzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5JbnN0YW5jZXMgPSByZXR1cm5JbnN0YW5jZXMuY29uY2F0KHJlZmVyZW5jZWRPYmoucmVzb2x2ZWQuaW5zdGFuY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuSW5zdGFuY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW52ZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5JbnN0YW5jZXMgPSBsaWJfMS5pbnZlcnRJbnN0YW5jZXMocmV0dXJuSW5zdGFuY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkluc3RhbmNlcyA9IGxpYl8xLmNsZWFuSW5zdGFuY2VzKHJldHVybkluc3RhbmNlcywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZUZpcnN0SWZaZXJvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IF8uZmlyc3QocmV0dXJuSW5zdGFuY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCAmJiBmaXJzdC5zdGFydCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkluc3RhbmNlcy5zcGxpY2UoMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaW5zdGFuY2VzOiByZXR1cm5JbnN0YW5jZXMsIGFsbFJlZmVyZW5jZXM6IGFsbFJlZmVyZW5jZXMgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGluc3RhbmNlczogW10sIGFsbFJlZmVyZW5jZXM6IGFsbFJlZmVyZW5jZXMgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBpbnN0YW5jZXM6IFtdLCBhbGxSZWZlcmVuY2VzOiBhbGxSZWZlcmVuY2VzIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChleHByKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gbG9va3VwRXhwcmVzc2lvbihyZXNvbHZlZFRpbWVsaW5lLCBvYmosIGV4cHIubCwgY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCByID0gbG9va3VwRXhwcmVzc2lvbihyZXNvbHZlZFRpbWVsaW5lLCBvYmosIGV4cHIuciwgY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBsb29rdXBFeHByID0ge1xuICAgICAgICAgICAgICAgIGw6IGwuaW5zdGFuY2VzLFxuICAgICAgICAgICAgICAgIG86IGV4cHIubyxcbiAgICAgICAgICAgICAgICByOiByLmluc3RhbmNlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBhbGxSZWZlcmVuY2VzID0gbC5hbGxSZWZlcmVuY2VzLmNvbmNhdChyLmFsbFJlZmVyZW5jZXMpO1xuICAgICAgICAgICAgaWYgKGxvb2t1cEV4cHIubyA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgLy8gRGlzY2FyZCBsLCBpbnZlcnQgYW5kIHJldHVybiByOlxuICAgICAgICAgICAgICAgIGlmIChsb29rdXBFeHByLnIgJiYgXy5pc0FycmF5KGxvb2t1cEV4cHIucikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlczogbGliXzEuaW52ZXJ0SW5zdGFuY2VzKGxvb2t1cEV4cHIuciksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxSZWZlcmVuY2VzOiBhbGxSZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgaW52ZXJ0IGEgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlczogbG9va3VwRXhwci5yLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsUmVmZXJlbmNlczogYWxsUmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc051bGwobG9va3VwRXhwci5sKSB8fCBfLmlzTnVsbChsb29rdXBFeHByLnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGluc3RhbmNlczogbnVsbCwgYWxsUmVmZXJlbmNlczogYWxsUmVmZXJlbmNlcyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobG9va3VwRXhwci5vID09PSAnJicgfHwgbG9va3VwRXhwci5vID09PSAnfCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRFdmVudHMgPSAoaW5zdGFuY2VzLCBsZWZ0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGFydCAhPT0gaW5zdGFuY2UuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50IGRvZXNuJ3QgYWN0dWFsbHkgZXhpc3QuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IGluc3RhbmNlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuZW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBpbnN0YW5jZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoXy5pc0FycmF5KGxvb2t1cEV4cHIubCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRFdmVudHMobG9va3VwRXhwci5sLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uaXNBcnJheShsb29rdXBFeHByLnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRXZlbnRzKGxvb2t1cEV4cHIuciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBldmVudHMgPSBsaWJfMS5zb3J0RXZlbnRzKGV2ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGNSZXN1bHQgPSBsb29rdXBFeHByLm8gPT09ICcmJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAobGVmdCwgcmlnaHQpID0+ICEhKGxlZnQgJiYgcmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGxvb2t1cEV4cHIubyA9PT0gJ3wnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAobGVmdCwgcmlnaHQpID0+ICEhKGxlZnQgfHwgcmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGVmdFZhbHVlID0gbGliXzEuaXNSZWZlcmVuY2UobG9va3VwRXhwci5sKSA/ICEhbG9va3VwRXhwci5sLnZhbHVlIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCByaWdodFZhbHVlID0gbGliXzEuaXNSZWZlcmVuY2UobG9va3VwRXhwci5yKSA/ICEhbG9va3VwRXhwci5yLnZhbHVlIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZWZ0SW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmlnaHRJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHRWYWx1ZSA9IGNhbGNSZXN1bHQobGVmdFZhbHVlLCByaWdodFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUluc3RhbmNlID0gKHRpbWUsIHZhbHVlLCByZWZlcmVuY2VzLCBjYXBzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBsaWJfMS5nZXRJZCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogdGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiByZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXBzOiBjYXBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IF8ubGFzdChpbnN0YW5jZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QuZW5kID0gdGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgdXBkYXRlIHJlZmVyZW5jZSBvbiBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUluc3RhbmNlKDAsIHJlc3VsdFZhbHVlLCBsaWJfMS5qb2luUmVmZXJlbmNlcyhsaWJfMS5pc1JlZmVyZW5jZShsb29rdXBFeHByLmwpID8gbG9va3VwRXhwci5sLnJlZmVyZW5jZXMgOiBbXSwgbGliXzEuaXNSZWZlcmVuY2UobG9va3VwRXhwci5yKSA/IGxvb2t1cEV4cHIuci5yZWZlcmVuY2VzIDogW10pLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gZXZlbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IGV2ZW50c1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFZhbHVlID0gZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0SW5zdGFuY2UgPSBlLmluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRWYWx1ZSA9IGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRJbnN0YW5jZSA9IGUuaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dC50aW1lICE9PSBlLnRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdSZXN1bHRWYWx1ZSA9IGNhbGNSZXN1bHQobGVmdFZhbHVlLCByaWdodFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRDYXBzID0gKGxlZnRJbnN0YW5jZSA/IGxlZnRJbnN0YW5jZS5jYXBzIHx8IFtdIDogW10pLmNvbmNhdChyaWdodEluc3RhbmNlID8gcmlnaHRJbnN0YW5jZS5jYXBzIHx8IFtdIDogW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdSZXN1bHRWYWx1ZSAhPT0gcmVzdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSW5zdGFuY2UoZS50aW1lLCBuZXdSZXN1bHRWYWx1ZSwgbGliXzEuam9pblJlZmVyZW5jZXMobGVmdEluc3RhbmNlID8gbGVmdEluc3RhbmNlLnJlZmVyZW5jZXMgOiBbXSwgcmlnaHRJbnN0YW5jZSA/IHJpZ2h0SW5zdGFuY2UucmVmZXJlbmNlcyA6IFtdKSwgcmVzdWx0Q2Fwcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlID0gbmV3UmVzdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGluc3RhbmNlczogaW5zdGFuY2VzLCBhbGxSZWZlcmVuY2VzOiBhbGxSZWZlcmVuY2VzIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcGVyYXRlSW5uZXIgPSBsb29rdXBFeHByLm8gPT09ICcrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhLnZhbHVlICsgYi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogbGliXzEuam9pblJlZmVyZW5jZXMoYS5yZWZlcmVuY2VzLCBiLnJlZmVyZW5jZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IGxvb2t1cEV4cHIubyA9PT0gJy0nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGEudmFsdWUgLSBiLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogbGliXzEuam9pblJlZmVyZW5jZXMoYS5yZWZlcmVuY2VzLCBiLnJlZmVyZW5jZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGxvb2t1cEV4cHIubyA9PT0gJyonXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGEudmFsdWUgKiBiLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGxpYl8xLmpvaW5SZWZlcmVuY2VzKGEucmVmZXJlbmNlcywgYi5yZWZlcmVuY2VzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBsb29rdXBFeHByLm8gPT09ICcvJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhLnZhbHVlIC8gYi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogbGliXzEuam9pblJlZmVyZW5jZXMoYS5yZWZlcmVuY2VzLCBiLnJlZmVyZW5jZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGxvb2t1cEV4cHIubyA9PT0gJyUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGEudmFsdWUgJSBiLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogbGliXzEuam9pblJlZmVyZW5jZXMoYS5yZWZlcmVuY2VzLCBiLnJlZmVyZW5jZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICgpID0+IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGUgPSAoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRlSW5uZXIoYSwgYik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGxpYl8xLm9wZXJhdGVPbkFycmF5cyhsb29rdXBFeHByLmwsIGxvb2t1cEV4cHIuciwgb3BlcmF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGluc3RhbmNlczogcmVzdWx0LCBhbGxSZWZlcmVuY2VzOiBhbGxSZWZlcmVuY2VzIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGluc3RhbmNlczogbnVsbCwgYWxsUmVmZXJlbmNlczogW10gfTtcbn1cbmV4cG9ydHMubG9va3VwRXhwcmVzc2lvbiA9IGxvb2t1cEV4cHJlc3Npb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXBwbHlLZXlmcmFtZUNvbnRlbnQgPSBleHBvcnRzLnJlc29sdmVTdGF0ZXMgPSBleHBvcnRzLmdldFN0YXRlID0gdm9pZCAwO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG5jb25zdCBlbnVtc18xID0gcmVxdWlyZShcIi4uL2FwaS9lbnVtc1wiKTtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4uL2xpYlwiKTtcbmZ1bmN0aW9uIGdldFN0YXRlKHJlc29sdmVkLCB0aW1lLCBldmVudExpbWl0ID0gMCkge1xuICAgIGNvbnN0IHJlc29sdmVkU3RhdGVzID0gaXNSZXNvbHZlZFN0YXRlcyhyZXNvbHZlZCkgPyByZXNvbHZlZCA6IHJlc29sdmVTdGF0ZXMocmVzb2x2ZWQsIHRpbWUpO1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICBsYXllcnM6IHt9LFxuICAgICAgICBuZXh0RXZlbnRzOiBfLmZpbHRlcihyZXNvbHZlZFN0YXRlcy5uZXh0RXZlbnRzLCAoZSkgPT4gZS50aW1lID4gdGltZSksXG4gICAgfTtcbiAgICBpZiAoZXZlbnRMaW1pdClcbiAgICAgICAgc3RhdGUubmV4dEV2ZW50cyA9IHN0YXRlLm5leHRFdmVudHMuc2xpY2UoMCwgZXZlbnRMaW1pdCk7XG4gICAgY29uc3QgbGF5ZXJLZXlzID0gT2JqZWN0LmtleXMocmVzb2x2ZWRTdGF0ZXMubGF5ZXJzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxheWVyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBsYXllciA9IGxheWVyS2V5c1tpXTtcbiAgICAgICAgY29uc3QgbyA9IGdldFN0YXRlQXRUaW1lKHJlc29sdmVkU3RhdGVzLnN0YXRlLCBsYXllciwgdGltZSk7XG4gICAgICAgIGlmIChvKVxuICAgICAgICAgICAgc3RhdGUubGF5ZXJzW2xheWVyXSA9IG87XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbn1cbmV4cG9ydHMuZ2V0U3RhdGUgPSBnZXRTdGF0ZTtcbmZ1bmN0aW9uIHJlc29sdmVTdGF0ZXMocmVzb2x2ZWQsIG9ubHlGb3JUaW1lLCBjYWNoZSkge1xuICAgIGNvbnN0IHJlc29sdmVkU3RhdGVzID0ge1xuICAgICAgICBvcHRpb25zOiByZXNvbHZlZC5vcHRpb25zLFxuICAgICAgICBzdGF0aXN0aWNzOiByZXNvbHZlZC5zdGF0aXN0aWNzLFxuICAgICAgICAvLyBUaGVzZSB3aWxsIGJlIHJlLWNyZWF0ZWQgZHVyaW5nIHRoZSBzdGF0ZS1yZXNvbHZpbmc6XG4gICAgICAgIG9iamVjdHM6IHt9LFxuICAgICAgICBjbGFzc2VzOiB7fSxcbiAgICAgICAgbGF5ZXJzOiB7fSxcbiAgICAgICAgc3RhdGU6IHt9LFxuICAgICAgICBuZXh0RXZlbnRzOiBbXSxcbiAgICB9O1xuICAgIGlmIChjYWNoZSAmJiAhb25seUZvclRpbWUgJiYgcmVzb2x2ZWQuc3RhdGlzdGljcy5yZXNvbHZpbmdDb3VudCA9PT0gMCAmJiBjYWNoZS5yZXNvbHZlZFN0YXRlcykge1xuICAgICAgICAvLyBOb3RoaW5nIGhhcyBjaGFuZ2VkIHNpbmNlIGxhc3QgdGltZSwganVzdCByZXR1cm4gdGhlIHN0YXRlcyByaWdodCBhd2F5OlxuICAgICAgICByZXR1cm4gY2FjaGUucmVzb2x2ZWRTdGF0ZXM7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkT2JqZWN0cyA9IF8udmFsdWVzKHJlc29sdmVkLm9iamVjdHMpO1xuICAgIC8vIFNvcnQgdG8gbWFrZSBzdXJlIHBhcmVudCBncm91cHMgYXJlIGV2YWx1YXRlZCBiZWZvcmUgdGhlaXIgY2hpbGRyZW46XG4gICAgcmVzb2x2ZWRPYmplY3RzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgaWYgKChhLnJlc29sdmVkLmxldmVsRGVlcCB8fCAwKSA+IChiLnJlc29sdmVkLmxldmVsRGVlcCB8fCAwKSlcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoKGEucmVzb2x2ZWQubGV2ZWxEZWVwIHx8IDApIDwgKGIucmVzb2x2ZWQubGV2ZWxEZWVwIHx8IDApKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYS5pZCA+IGIuaWQpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEuaWQgPCBiLmlkKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgICAvLyBTdGVwIDE6IENvbGxlY3QgYWxsIHBvaW50cy1vZi1pbnRlcmVzdCAod2hpY2ggcG9pbnRzIGluIHRpbWUgd2Ugd2FudCB0byBldmFsdWF0ZSlcbiAgICAvLyBhbmQgd2hpY2ggaW5zdGFuY2VzIHRoYXQgYXJlIGludGVyZXN0aW5nXG4gICAgY29uc3QgcG9pbnRzSW5UaW1lID0ge307XG4gICAgY29uc3QgYWRkUG9pbnRJblRpbWUgPSAodGltZSwgZW5hYmxlLCBvYmosIGluc3RhbmNlKSA9PiB7XG4gICAgICAgIGlmICghcG9pbnRzSW5UaW1lW3RpbWUgKyAnJ10pXG4gICAgICAgICAgICBwb2ludHNJblRpbWVbdGltZSArICcnXSA9IFtdO1xuICAgICAgICBwb2ludHNJblRpbWVbdGltZSArICcnXS5wdXNoKHsgb2JqLCBpbnN0YW5jZSwgZW5hYmxlOiBlbmFibGUgfSk7XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IG9iaiBvZiByZXNvbHZlZE9iamVjdHMpIHtcbiAgICAgICAgaWYgKCFvYmouZGlzYWJsZWQgJiYgb2JqLnJlc29sdmVkLnJlc29sdmVkKSB7XG4gICAgICAgICAgICBpZiAoIW9iai5yZXNvbHZlZC5pc0tleWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50VGltZXMgPSBnZXRUaW1lc0Zyb21QYXJlbnRzKHJlc29sdmVkLCBvYmopO1xuICAgICAgICAgICAgICAgIGlmIChvYmoubGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbGF5ZXIgaXMgZW1wdHksIGRvbid0IHB1dCBpbiBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIG9iai5yZXNvbHZlZC5pbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1c2VJbnN0YW5jZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25seUZvclRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VJbnN0YW5jZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbnN0YW5jZS5zdGFydCB8fCAwKSA8PSBvbmx5Rm9yVGltZSAmJiAoaW5zdGFuY2UuZW5kIHx8IEluZmluaXR5KSA+IG9ubHlGb3JUaW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZUluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZUV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVFdmVudHMucHVzaCh7IHRpbWU6IGluc3RhbmNlLnN0YXJ0LCBlbmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmVuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZUV2ZW50cy5wdXNoKHsgdGltZTogaW5zdGFuY2UuZW5kLCBlbmFibGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsc28gaW5jbHVkZSB0aW1lcyBmcm9tIHBhcmVudHMsIGFzIHRoZXkgY291bGQgYWZmZWN0IHRoZSBzdGF0ZSBvZiB0aGlzIGluc3RhbmNlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50VGltZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50VGltZSA9IHBhcmVudFRpbWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50VGltZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VGltZS50aW1lID4gKGluc3RhbmNlLnN0YXJ0IHx8IDApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUaW1lLnRpbWUgPCAoaW5zdGFuY2UuZW5kIHx8IEluZmluaXR5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZUV2ZW50cy5wdXNoKHBhcmVudFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgYSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZSBvbiBhbGwgcG9pbnRzIGluIHRpbWUgdGhhdCBjb3VsZCBhZmZlY3QgaXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lRXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVFdmVudCA9IHRpbWVFdmVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBvaW50SW5UaW1lKHRpbWVFdmVudC50aW1lLCB0aW1lRXZlbnQuZW5hYmxlLCBvYmosIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvYmoucmVzb2x2ZWQuaXNLZXlmcmFtZSAmJiBvYmoucmVzb2x2ZWQucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlmcmFtZSA9IG9iajtcbiAgICAgICAgICAgICAgICAvLyBBbHNvIGFkZCBrZXlmcmFtZXMgdG8gcG9pbnRzSW5UaW1lOlxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2Yga2V5ZnJhbWUucmVzb2x2ZWQuaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEtleWZyYW1lIHN0YXJ0IHRpbWVcbiAgICAgICAgICAgICAgICAgICAgYWRkUG9pbnRJblRpbWUoaW5zdGFuY2Uuc3RhcnQsIHRydWUsIGtleWZyYW1lLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEtleWZyYW1lIGVuZCB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5lbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBvaW50SW5UaW1lKGluc3RhbmNlLmVuZCwgZmFsc2UsIGtleWZyYW1lLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3RlcCAyOiBSZXNvbHZlIHRoZSBzdGF0ZSBmb3IgdGhlIHBvaW50cy1vZi1pbnRlcmVzdFxuICAgIC8vIFRoaXMgaXMgZG9uZSBieSBzd2VlcGluZyB0aGUgcG9pbnRzLW9mLWludGVyZXN0IGNocm9ub2xvZ2ljYWxseSxcbiAgICAvLyBkZXRlcm1pbmluZyB0aGUgc3RhdGUgZm9yIGV2ZXJ5IHBvaW50IGluIHRpbWUgYnkgYWRkaW5nICYgcmVtb3Zpbmcgb2JqZWN0cyBmcm9tIGFzcGlyaW5nSW5zdGFuY2VzXG4gICAgLy8gVGhlbiBzb3J0aW5nIGl0IHRvIGRldGVybWluZSB3aG8gdGFrZXMgcHJlY2VkZW5jZVxuICAgIGNvbnN0IGV2ZW50T2JqZWN0VGltZXMgPSB7fTtcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB7fTtcbiAgICBjb25zdCBhY3RpdmVPYmpJZHMgPSB7fTtcbiAgICBjb25zdCBhY3RpdmVLZXlmcmFtZXMgPSB7fTtcbiAgICBjb25zdCBhY3RpdmVLZXlmcmFtZXNDaGVja2VkID0ge307XG4gICAgLyoqIFRoZSBvYmplY3RzIGluIGFzcGlyaW5nSW5zdGFuY2VzICAqL1xuICAgIGNvbnN0IGFzcGlyaW5nSW5zdGFuY2VzID0ge307XG4gICAgY29uc3Qga2V5ZnJhbWVFdmVudHMgPSBbXTtcbiAgICBjb25zdCB0aW1lcyA9IE9iamVjdC5rZXlzKHBvaW50c0luVGltZSlcbiAgICAgICAgLm1hcCgodGltZSkgPT4gcGFyc2VGbG9hdCh0aW1lKSlcbiAgICAgICAgLy8gU29ydCBjaHJvbm9sb2dpY2FsbHk6XG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBwb2ludHMtb2YtaW50ZXJlc3QgdGltZXM6XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0aW1lID0gdGltZXNbaV07XG4gICAgICAgIGNvbnN0IGluc3RhbmNlc1RvQ2hlY2sgPSBwb2ludHNJblRpbWVbdGltZV07XG4gICAgICAgIGNvbnN0IGNoZWNrZWRPYmplY3RzVGhpc1RpbWUgPSB7fTtcbiAgICAgICAgaW5zdGFuY2VzVG9DaGVjay5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBpZiAoYS5vYmoucmVzb2x2ZWQgJiYgYi5vYmoucmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBLZXlmcmFtZXMgY29tZXMgZmlyc3Q6XG4gICAgICAgICAgICAgICAgaWYgKGEub2JqLnJlc29sdmVkLmlzS2V5ZnJhbWUgJiYgIWIub2JqLnJlc29sdmVkLmlzS2V5ZnJhbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoIWEub2JqLnJlc29sdmVkLmlzS2V5ZnJhbWUgJiYgYi5vYmoucmVzb2x2ZWQuaXNLZXlmcmFtZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgLy8gRW5kaW5nIGV2ZW50cyBjb21lIGJlZm9yZSBzdGFydGluZyBldmVudHM6XG4gICAgICAgICAgICAgICAgaWYgKGEuZW5hYmxlICYmICFiLmVuYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgaWYgKCFhLmVuYWJsZSAmJiBiLmVuYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIC8vIERlZXBlciBvYmplY3RzIChjaGlsZHJlbiBpbiBncm91cHMpIGNvbWVzIGxhdGVyLCB3ZSB3YW50IHRvIGNoZWNrIHRoZSBwYXJlbnQgZ3JvdXBzIGZpcnN0OlxuICAgICAgICAgICAgICAgIGlmICgoYS5vYmoucmVzb2x2ZWQubGV2ZWxEZWVwIHx8IDApID4gKGIub2JqLnJlc29sdmVkLmxldmVsRGVlcCB8fCAwKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgaWYgKChhLm9iai5yZXNvbHZlZC5sZXZlbERlZXAgfHwgMCkgPCAoYi5vYmoucmVzb2x2ZWQubGV2ZWxEZWVwIHx8IDApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5zdGFuY2VzVG9DaGVjay5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgbyA9IGluc3RhbmNlc1RvQ2hlY2tbal07XG4gICAgICAgICAgICBjb25zdCBvYmogPSBvLm9iajtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gby5pbnN0YW5jZTtcbiAgICAgICAgICAgIGxldCB0b0JlRW5hYmxlZCA9IChpbnN0YW5jZS5zdGFydCB8fCAwKSA8PSB0aW1lICYmIChpbnN0YW5jZS5lbmQgfHwgSW5maW5pdHkpID4gdGltZTtcbiAgICAgICAgICAgIGNvbnN0IGxheWVyID0gb2JqLmxheWVyICsgJyc7XG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gb2JqLmlkICsgJ18nICsgaW5zdGFuY2UuaWQgKyAnXycgKyBvLmVuYWJsZTtcbiAgICAgICAgICAgIGlmICghY2hlY2tlZE9iamVjdHNUaGlzVGltZVtpZGVudGlmaWVyXSkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgY2hlY2sgZWFjaCBvYmplY3QgYW5kIGV2ZW50LXR5cGUgb25jZSBmb3IgZXZlcnkgcG9pbnQgaW4gdGltZVxuICAgICAgICAgICAgICAgIGNoZWNrZWRPYmplY3RzVGhpc1RpbWVbaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghb2JqLnJlc29sdmVkLmlzS2V5ZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgb2JqZWN0IGhhcyBhIHBhcmVudCwgb25seSBzZXQgaWYgcGFyZW50IGlzIG9uIGEgbGF5ZXIgKGlmIGxheWVyIGlzIHNldCBmb3IgcGFyZW50KVxuICAgICAgICAgICAgICAgICAgICBpZiAodG9CZUVuYWJsZWQgJiYgb2JqLnJlc29sdmVkLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRPYmogPSBvYmoucmVzb2x2ZWQucGFyZW50SWQgPyByZXNvbHZlZC5vYmplY3RzW29iai5yZXNvbHZlZC5wYXJlbnRJZF0gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9CZUVuYWJsZWQgPSAhIShwYXJlbnRPYmogJiYgKCFwYXJlbnRPYmoubGF5ZXIgfHwgYWN0aXZlT2JqSWRzW3BhcmVudE9iai5pZF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFzcGlyaW5nSW5zdGFuY2VzW29iai5sYXllcl0pXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3BpcmluZ0luc3RhbmNlc1tvYmoubGF5ZXJdID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b0JlRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGluc3RhbmNlIHdhbnRzIHRvIGJlIGVuYWJsZWQgKGlzIHN0YXJ0aW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIGFzcGlyaW5nSW5zdGFuY2VzOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXNwaXJpbmdJbnN0YW5jZXNbb2JqLmxheWVyXS5wdXNoKHsgb2JqLCBpbnN0YW5jZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBpbnN0YW5jZSBkb2Vzbid0IHdhbnQgdG8gYmUgZW5hYmxlZCAoaXMgZW5kaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gYXNwaXJpbmdJbnN0YW5jZXM6XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3BpcmluZ0luc3RhbmNlc1tsYXllcl0gPSBfLnJlamVjdChhc3BpcmluZ0luc3RhbmNlc1tsYXllcl0gfHwgW10sIChvKSA9PiBvLm9iai5pZCA9PT0gb2JqLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFdmFsdWF0ZSB0aGUgbGF5ZXIgdG8gZGV0ZXJtaW5lIHdobyBoYXMgdGhlIHRocm9uZTpcbiAgICAgICAgICAgICAgICAgICAgYXNwaXJpbmdJbnN0YW5jZXNbbGF5ZXJdLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB3aG8gdGFrZXMgcHJlY2VkZW5jZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0LCBzb3J0IHVzaW5nIHByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGEub2JqLnByaW9yaXR5IHx8IDApIDwgKGIub2JqLnByaW9yaXR5IHx8IDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChhLm9iai5wcmlvcml0eSB8fCAwKSA+IChiLm9iai5wcmlvcml0eSB8fCAwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVuLCBzb3J0IHVzaW5nIHRoZSBzdGFydCB0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGEuaW5zdGFuY2Uuc3RhcnQgfHwgMCkgPCAoYi5pbnN0YW5jZS5zdGFydCB8fCAwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYS5pbnN0YW5jZS5zdGFydCB8fCAwKSA+IChiLmluc3RhbmNlLnN0YXJ0IHx8IDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExhc3QgcmVzb3J0OiBzb3J0IHVzaW5nIGlkOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEub2JqLmlkID4gYi5vYmouaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS5vYmouaWQgPCBiLm9iai5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdywgdGhlIG9uZSBvbiB0b3AgaGFzIHRoZSB0aHJvbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGN1cnJlbnQgc3RhdGU6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRPblRvcE9mTGF5ZXIgPSBhc3BpcmluZ0luc3RhbmNlc1tsYXllcl1bMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZPYmogPSBjdXJyZW50U3RhdGVbbGF5ZXJdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlT2xkT2JqID0gY3VycmVudE9uVG9wT2ZMYXllciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFwcmV2T2JqIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldk9iai5pZCAhPT0gY3VycmVudE9uVG9wT2ZMYXllci5vYmouaWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2T2JqLmluc3RhbmNlLmlkICE9PSBjdXJyZW50T25Ub3BPZkxheWVyLmluc3RhbmNlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlT2xkT2JqID0gIWN1cnJlbnRPblRvcE9mTGF5ZXIgJiYgcHJldk9iajtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VPbGRPYmogfHwgcmVtb3ZlT2xkT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldk9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhcCB0aGUgb2xkIGluc3RhbmNlLCBzbyBpdCdsbCBlbmQgYXQgdGhpcyBwb2ludCBpbiB0aW1lOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpYl8xLnNldEluc3RhbmNlRW5kVGltZShwcmV2T2JqLmluc3RhbmNlLCB0aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYWN0aXZlT2JqSWRzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhY3RpdmVPYmpJZHNbcHJldk9iai5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIG5leHRFdmVudHM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvbmx5Rm9yVGltZSB8fCB0aW1lID4gb25seUZvclRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRTdGF0ZXMubmV4dEV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGVudW1zXzEuRXZlbnRUeXBlLkVORCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpJZDogcHJldk9iai5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50T2JqZWN0VGltZXNbaW5zdGFuY2UuZW5kICsgJyddID0gZW51bXNfMS5FdmVudFR5cGUuRU5EO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVwbGFjZU9sZE9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBuZXcgb2JqZWN0IHRvIFN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgYSBuZXcgb2JqZWN0IGNsb25lOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld09iajtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFN0YXRlcy5vYmplY3RzW2N1cnJlbnRPblRvcE9mTGF5ZXIub2JqLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgYWxyZWFkeSBleGlzdGluZyBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdPYmogPSByZXNvbHZlZFN0YXRlcy5vYmplY3RzW2N1cnJlbnRPblRvcE9mTGF5ZXIub2JqLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld09iaiA9IF8uY2xvbmUoY3VycmVudE9uVG9wT2ZMYXllci5vYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld09iai5jb250ZW50ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShuZXdPYmouY29udGVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld09iai5yZXNvbHZlZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKG5ld09iai5yZXNvbHZlZCB8fCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tb25fMS5hZGRPYmplY3RUb1Jlc29sdmVkVGltZWxpbmUocmVzb2x2ZWRTdGF0ZXMsIG5ld09iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdJbnN0YW5jZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jdXJyZW50T25Ub3BPZkxheWVyLmluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIHNldHRpbmcgbmV3IHN0YXJ0ICYgZW5kIHRpbWVzIHNvIHRoZXkgbWF0Y2ggdXAgd2l0aCB0aGUgc3RhdGU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21JbnN0YW5jZUlkOiBjdXJyZW50T25Ub3BPZkxheWVyLmluc3RhbmNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kOiBjdXJyZW50T25Ub3BPZkxheWVyLmluc3RhbmNlLm9yaWdpbmFsRW5kICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjdXJyZW50T25Ub3BPZkxheWVyLmluc3RhbmNlLm9yaWdpbmFsRW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VycmVudE9uVG9wT2ZMYXllci5pbnN0YW5jZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydDogY3VycmVudE9uVG9wT2ZMYXllci5pbnN0YW5jZS5vcmlnaW5hbFN0YXJ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjdXJyZW50T25Ub3BPZkxheWVyLmluc3RhbmNlLm9yaWdpbmFsU3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50T25Ub3BPZkxheWVyLmluc3RhbmNlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgdGhlIGluc3RhbmNlIGlkIHVuaXF1ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3T2JqLnJlc29sdmVkLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdPYmoucmVzb2x2ZWQuaW5zdGFuY2VzW2ldLmlkID09PSBuZXdJbnN0YW5jZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJbnN0YW5jZS5pZCA9IG5ld0luc3RhbmNlLmlkICsgJ18kJyArIG5ld09iai5yZXNvbHZlZC5pbnN0YW5jZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld09iai5yZXNvbHZlZC5pbnN0YW5jZXMucHVzaChuZXdJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdPYmpJbnN0YW5jZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5uZXdPYmosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IG5ld0luc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgdG8gY3VycmVudCBzdGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZVtsYXllcl0gPSBuZXdPYmpJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBhY3RpdmVPYmpJZHM6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVPYmpJZHNbbmV3T2JqSW5zdGFuY2UuaWRdID0gbmV3T2JqSW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRyYWNraW5nIHN0YXRlIGFzIHdlbGw6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTdGF0ZUF0VGltZShyZXNvbHZlZFN0YXRlcy5zdGF0ZSwgbGF5ZXIsIHRpbWUsIG5ld09iakluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byBuZXh0RXZlbnRzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luc3RhbmNlLnN0YXJ0ID4gKG9ubHlGb3JUaW1lIHx8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRTdGF0ZXMubmV4dEV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZW51bXNfMS5FdmVudFR5cGUuU1RBUlQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ld0luc3RhbmNlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpJZDogb2JqLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50T2JqZWN0VGltZXNbbmV3SW5zdGFuY2Uuc3RhcnQgKyAnJ10gPSBlbnVtc18xLkV2ZW50VHlwZS5TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZW1vdmVPbGRPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGN1cnJlbnQgc3RhdGU6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY3VycmVudFN0YXRlW2xheWVyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdHJhY2tpbmcgc3RhdGUgYXMgd2VsbDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFN0YXRlQXRUaW1lKHJlc29sdmVkU3RhdGVzLnN0YXRlLCBsYXllciwgdGltZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElzIGEga2V5ZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ZnJhbWUgPSBvYmo7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBrZXlmcmFtZSB0byByZXNvbHZlZFN0YXRlcy5vYmplY3RzOlxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFN0YXRlcy5vYmplY3RzW2tleWZyYW1lLmlkXSA9IGtleWZyYW1lO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b0JlRW5hYmxlZCA9IChpbnN0YW5jZS5zdGFydCB8fCAwKSA8PSB0aW1lICYmIChpbnN0YW5jZS5lbmQgfHwgSW5maW5pdHkpID4gdGltZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvQmVFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdPYmpJbnN0YW5jZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5rZXlmcmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlS2V5ZnJhbWVzW2tleWZyYW1lLmlkXSA9IG5ld09iakluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFjdGl2ZUtleWZyYW1lc1trZXlmcmFtZS5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYWN0aXZlS2V5ZnJhbWVzQ2hlY2tlZFtrZXlmcmFtZS5pZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gR28gdGhyb3VnaCBrZXlmcmFtZXM6XG4gICAgICAgIGNvbnN0IGFjdGl2ZUtleWZyYW1lc09iaklkcyA9IE9iamVjdC5rZXlzKGFjdGl2ZUtleWZyYW1lcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlS2V5ZnJhbWVzT2JqSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBvYmpJZCA9IGFjdGl2ZUtleWZyYW1lc09iaklkc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IG9iakluc3RhbmNlID0gYWN0aXZlS2V5ZnJhbWVzW29iaklkXTtcbiAgICAgICAgICAgIGNvbnN0IGtleWZyYW1lID0gb2JqSW5zdGFuY2U7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG9iakluc3RhbmNlLmluc3RhbmNlO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGtleWZyYW1lJ3MgcGFyZW50IGlzIGN1cnJlbnRseSBhY3RpdmU/XG4gICAgICAgICAgICBpZiAoa2V5ZnJhbWUucmVzb2x2ZWQucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRPYmogPSBhY3RpdmVPYmpJZHNba2V5ZnJhbWUucmVzb2x2ZWQucGFyZW50SWRdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRPYmogJiYgcGFyZW50T2JqLmxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtleWZyYW1lIGlzIG9uIGFuIGFjdGl2ZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50T2JqSW5zdGFuY2UgPSBjdXJyZW50U3RhdGVbcGFyZW50T2JqLmxheWVyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudE9iakluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFjdGl2ZUtleWZyYW1lc0NoZWNrZWRbb2JqSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFzbid0IHN0YXJ0ZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlS2V5ZnJhbWVzQ2hlY2tlZFtvYmpJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IFRoZSBrZXlmcmFtZXMgYXJlIGEgbGl0dGxlIGJpdCBzcGVjaWFsLCBzaW5jZSB0aGVpciBjb250ZW50cyBhcmUgYXBwbGllZCB0byB0aGVpciBwYXJlbnRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoYXQgYXBwbGljYXRpb24gaXMgZG9uZSBpbiB0aGUgZ2V0U3RhdGVBdFRpbWUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGtleWZyYW1lIHRvIG5leHRFdmVudHM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ZnJhbWVFdmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGVudW1zXzEuRXZlbnRUeXBlLktFWUZSQU1FLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBpbnN0YW5jZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqSWQ6IGtleWZyYW1lLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhcCBlbmQgd2l0aGluIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZUVuZCA9IE1hdGgubWluKGluc3RhbmNlLmVuZCB8fCBJbmZpbml0eSwgcGFyZW50T2JqSW5zdGFuY2UuaW5zdGFuY2UuZW5kIHx8IEluZmluaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2VFbmQgPT09IEluZmluaXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUVuZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlRW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleWZyYW1lRXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZW51bXNfMS5FdmVudFR5cGUuS0VZRlJBTUUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBpbnN0YW5jZUVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaklkOiBrZXlmcmFtZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlOiB0aGUga2V5ZnJhbWU6cyBwYXJlbnQgaXNuJ3QgYWN0aXZlLCByZW1vdmUvc3RvcCB0aGUga2V5ZnJhbWUgdGhlbjpcbiAgICAgICAgICAgIGRlbGV0ZSBhY3RpdmVLZXlmcmFtZXNDaGVja2VkW29iaklkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgaW5zdGFuY2VzIG9mIGFsbCBvYmplY3RzIChleGNsdWRpbmcga2V5ZnJhbWVzKSBhcmUgcHJvcGVybHkgY2FsY3VsYXRlZCxcbiAgICAvLyB0YWtpbmcgaW50byBhY2NvdW50IHByaW9yaXRpZXMsIGNsYXNoZXMgZXRjLlxuICAgIGZvciAoY29uc3QgaWQgb2YgT2JqZWN0LmtleXMocmVzb2x2ZWRTdGF0ZXMub2JqZWN0cykpIHtcbiAgICAgICAgY29uc3Qga2V5ZnJhbWUgPSByZXNvbHZlZFN0YXRlcy5vYmplY3RzW2lkXTtcbiAgICAgICAgaWYgKGtleWZyYW1lLnJlc29sdmVkLmlzS2V5ZnJhbWUgJiYga2V5ZnJhbWUucmVzb2x2ZWQucGFyZW50SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHJlc29sdmVkU3RhdGVzLm9iamVjdHNba2V5ZnJhbWUucmVzb2x2ZWQucGFyZW50SWRdO1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIENhcCB0aGUga2V5ZnJhbWUgaW5zdGFuY2VzIHdpdGhpbiBpdHMgcGFyZW50cyBpbnN0YW5jZXM6XG4gICAgICAgICAgICAgICAga2V5ZnJhbWUucmVzb2x2ZWQuaW5zdGFuY2VzID0gbGliXzEuY2FwSW5zdGFuY2VzKGtleWZyYW1lLnJlc29sdmVkLmluc3RhbmNlcywgcGFyZW50LnJlc29sdmVkLmluc3RhbmNlcyk7XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHN1cmUgdGhlIGluc3RhbmNlcyBhcmUgaW4gdGhlIHN0YXRlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlmcmFtZS5yZXNvbHZlZC5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBrZXlmcmFtZS5yZXNvbHZlZC5pbnN0YW5jZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleWZyYW1lSW5zdGFuY2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5rZXlmcmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzS2V5ZnJhbWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlmcmFtZUVuZFRpbWU6IGluc3RhbmNlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGtleWZyYW1lIHRvIHRoZSB0cmFja2luZyBzdGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZnJhbWVBdFRpbWUocmVzb2x2ZWRTdGF0ZXMuc3RhdGUsIHBhcmVudC5sYXllciArICcnLCBpbnN0YW5jZS5zdGFydCwga2V5ZnJhbWVJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9iaiA9IHJlc29sdmVkU3RhdGVzLm9iamVjdHNbaWRdO1xuICAgICAgICBpZiAob2JqLnNlYW1sZXNzICYmIG9iai5yZXNvbHZlZC5pbnN0YW5jZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgb2JqLnJlc29sdmVkLmluc3RhbmNlcyA9IGxpYl8xLmNsZWFuSW5zdGFuY2VzKG9iai5yZXNvbHZlZC5pbnN0YW5jZXMsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBdCB0aGlzIHBvaW50LCBBTEwgaW5zdGFuY2VzIGFyZSBwcm9wZXJseSBjYWxjdWxhdGVkLlxuICAgIC8vIEdvIHRocm91Z2ggdGhlIGtleWZyYW1lIGV2ZW50cyBhbmQgYWRkIHRoZW0gdG8gbmV4dEV2ZW50czpcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleWZyYW1lRXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleWZyYW1lRXZlbnQgPSBrZXlmcmFtZUV2ZW50c1tpXTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGlmIChldmVudE9iamVjdFRpbWVzW2tleWZyYW1lRXZlbnQudGltZSArICcnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIHB1dCBhIGtleWZyYW1lIGV2ZW50IGlmIHRoZXJlJ3MgYWxyZWFkeSBhbm90aGVyIGV2ZW50IHRoZXJlXG4gICAgICAgICAgICByZXNvbHZlZFN0YXRlcy5uZXh0RXZlbnRzLnB1c2goa2V5ZnJhbWVFdmVudCk7XG4gICAgICAgICAgICBldmVudE9iamVjdFRpbWVzW2tleWZyYW1lRXZlbnQudGltZSArICcnXSA9IGVudW1zXzEuRXZlbnRUeXBlLktFWUZSQU1FO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvbmx5Rm9yVGltZSkge1xuICAgICAgICByZXNvbHZlZFN0YXRlcy5uZXh0RXZlbnRzID0gXy5maWx0ZXIocmVzb2x2ZWRTdGF0ZXMubmV4dEV2ZW50cywgKGUpID0+IGUudGltZSA+IG9ubHlGb3JUaW1lKTtcbiAgICB9XG4gICAgcmVzb2x2ZWRTdGF0ZXMubmV4dEV2ZW50cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGlmIChhLnRpbWUgPiBiLnRpbWUpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEudGltZSA8IGIudGltZSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEudHlwZSA+IGIudHlwZSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEudHlwZSA8IGIudHlwZSlcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoYS5vYmpJZCA8IGIub2JqSWQpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhLm9iaklkID4gYi5vYmpJZClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgICBpZiAoY2FjaGUgJiYgIW9ubHlGb3JUaW1lKSB7XG4gICAgICAgIGNhY2hlLnJlc29sdmVkU3RhdGVzID0gcmVzb2x2ZWRTdGF0ZXM7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlZFN0YXRlcztcbn1cbmV4cG9ydHMucmVzb2x2ZVN0YXRlcyA9IHJlc29sdmVTdGF0ZXM7XG5mdW5jdGlvbiBhcHBseUtleWZyYW1lQ29udGVudChwYXJlbnRDb250ZW50LCBrZXlmcmFtZUNvbnRlbnQpIHtcbiAgICBfLmVhY2goa2V5ZnJhbWVDb250ZW50LCAodmFsdWUsIGF0dHIpID0+IHtcbiAgICAgICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghXy5pc0FycmF5KHBhcmVudENvbnRlbnRbYXR0cl0pKVxuICAgICAgICAgICAgICAgIHBhcmVudENvbnRlbnRbYXR0cl0gPSBbXTtcbiAgICAgICAgICAgIGFwcGx5S2V5ZnJhbWVDb250ZW50KHBhcmVudENvbnRlbnRbYXR0cl0sIHZhbHVlKTtcbiAgICAgICAgICAgIHBhcmVudENvbnRlbnRbYXR0cl0uc3BsaWNlKHZhbHVlLmxlbmd0aCwgOTk5OTkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIV8uaXNPYmplY3QocGFyZW50Q29udGVudFthdHRyXSkgfHwgXy5pc0FycmF5KHBhcmVudENvbnRlbnRbYXR0cl0pKVxuICAgICAgICAgICAgICAgIHBhcmVudENvbnRlbnRbYXR0cl0gPSB7fTtcbiAgICAgICAgICAgIGFwcGx5S2V5ZnJhbWVDb250ZW50KHBhcmVudENvbnRlbnRbYXR0cl0sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudENvbnRlbnRbYXR0cl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5hcHBseUtleWZyYW1lQ29udGVudCA9IGFwcGx5S2V5ZnJhbWVDb250ZW50O1xuZnVuY3Rpb24gZ2V0VGltZXNGcm9tUGFyZW50cyhyZXNvbHZlZCwgb2JqKSB7XG4gICAgbGV0IHRpbWVzID0gW107XG4gICAgY29uc3QgcGFyZW50T2JqID0gb2JqLnJlc29sdmVkLnBhcmVudElkID8gcmVzb2x2ZWQub2JqZWN0c1tvYmoucmVzb2x2ZWQucGFyZW50SWRdIDogbnVsbDtcbiAgICBpZiAocGFyZW50T2JqICYmIHBhcmVudE9iai5yZXNvbHZlZC5yZXNvbHZlZCkge1xuICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIHBhcmVudE9iai5yZXNvbHZlZC5pbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIHRpbWVzLnB1c2goeyB0aW1lOiBpbnN0YW5jZS5zdGFydCwgZW5hYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlLmVuZClcbiAgICAgICAgICAgICAgICB0aW1lcy5wdXNoKHsgdGltZTogaW5zdGFuY2UuZW5kLCBlbmFibGU6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVzID0gdGltZXMuY29uY2F0KGdldFRpbWVzRnJvbVBhcmVudHMocmVzb2x2ZWQsIHBhcmVudE9iaikpO1xuICAgIH1cbiAgICByZXR1cm4gdGltZXM7XG59XG5mdW5jdGlvbiBzZXRTdGF0ZUF0VGltZShzdGF0ZXMsIGxheWVyLCB0aW1lLCBvYmpJbnN0YW5jZSkge1xuICAgIGlmICghc3RhdGVzW2xheWVyXSlcbiAgICAgICAgc3RhdGVzW2xheWVyXSA9IHt9O1xuICAgIHN0YXRlc1tsYXllcl1bdGltZSArICcnXSA9IG9iakluc3RhbmNlID8gW29iakluc3RhbmNlXSA6IG9iakluc3RhbmNlO1xufVxuZnVuY3Rpb24gYWRkS2V5ZnJhbWVBdFRpbWUoc3RhdGVzLCBsYXllciwgdGltZSwgb2JqSW5zdGFuY2VLZikge1xuICAgIGlmICghc3RhdGVzW2xheWVyXSlcbiAgICAgICAgc3RhdGVzW2xheWVyXSA9IHt9O1xuICAgIGNvbnN0IGlubmVyID0gc3RhdGVzW2xheWVyXVt0aW1lICsgJyddO1xuICAgIGlmICghaW5uZXIpIHtcbiAgICAgICAgc3RhdGVzW2xheWVyXVt0aW1lICsgJyddID0gW29iakluc3RhbmNlS2ZdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaW5uZXIucHVzaChvYmpJbnN0YW5jZUtmKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTdGF0ZUF0VGltZShzdGF0ZXMsIGxheWVyLCByZXF1ZXN0VGltZSkge1xuICAgIGNvbnN0IGxheWVyU3RhdGVzID0gc3RhdGVzW2xheWVyXSB8fCB7fTtcbiAgICBjb25zdCB0aW1lcyA9IF8ubWFwKF8ua2V5cyhsYXllclN0YXRlcyksICh0aW1lKSA9PiBwYXJzZUZsb2F0KHRpbWUpKTtcbiAgICB0aW1lcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9KTtcbiAgICBsZXQgc3RhdGUgPSBudWxsO1xuICAgIGxldCBpc0Nsb25lZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdGltZSA9IHRpbWVzW2ldO1xuICAgICAgICBpZiAodGltZSA8PSByZXF1ZXN0VGltZSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0YXRlSW5zdGFuY2VzID0gbGF5ZXJTdGF0ZXNbdGltZSArICcnXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGVJbnN0YW5jZXMgJiYgY3VycmVudFN0YXRlSW5zdGFuY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleWZyYW1lcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudFN0YXRlSW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRTdGF0ZUluc3RhbmNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSAmJiBjdXJyZW50U3RhdGUuaXNLZXlmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ZnJhbWVzLnB1c2goY3VycmVudFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gY3VycmVudFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNDbG9uZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlmcmFtZSA9IGtleWZyYW1lc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlICYmIGtleWZyYW1lLnJlc29sdmVkLnBhcmVudElkID09PSBzdGF0ZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChrZXlmcmFtZS5rZXlmcmFtZUVuZFRpbWUgfHwgSW5maW5pdHkpID4gcmVxdWVzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2xvbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2xvbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc3RhdGUuY29udGVudCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSB0aGUga2V5ZnJhbWUgb24gdGhlIHN0YXRlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5S2V5ZnJhbWVDb250ZW50KHN0YXRlLmNvbnRlbnQsIGtleWZyYW1lLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlzQ2xvbmVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBpc1Jlc29sdmVkU3RhdGVzKHJlc29sdmVkKSB7XG4gICAgcmV0dXJuICEhKHJlc29sdmVkICYmIHR5cGVvZiByZXNvbHZlZCA9PT0gJ29iamVjdCcgJiYgcmVzb2x2ZWQub2JqZWN0cyAmJiByZXNvbHZlZC5zdGF0ZSAmJiByZXNvbHZlZC5uZXh0RXZlbnRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZUtleWZyYW1lID0gZXhwb3J0cy52YWxpZGF0ZU9iamVjdCA9IGV4cG9ydHMudmFsaWRhdGVUaW1lbGluZSA9IHZvaWQgMDtcbmNvbnN0IF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0MChvYmosIHN0cmljdCwgdW5pcXVlSWRzKSB7XG4gICAgaWYgKCF1bmlxdWVJZHMpXG4gICAgICAgIHVuaXF1ZUlkcyA9IHt9O1xuICAgIGlmICghb2JqKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBpcyB1bmRlZmluZWRgKTtcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IGlzIG5vdCBhbiBvYmplY3RgKTtcbiAgICBpZiAoIW9iai5pZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgbWlzc2luZyBcImlkXCIgYXR0cmlidXRlYCk7XG4gICAgaWYgKHR5cGVvZiBvYmouaWQgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBcImlkXCIgYXR0cmlidXRlIGlzIG5vdCBhIHN0cmluZzogXCIke29iai5pZH1cImApO1xuICAgIGlmICh1bmlxdWVJZHNbb2JqLmlkXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgaWQgXCIke29iai5pZH1cIiBpcyBub3QgdW5pcXVlYCk7XG4gICAgdW5pcXVlSWRzW29iai5pZF0gPSB0cnVlO1xuICAgIGlmIChvYmoubGF5ZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgXCIke29iai5pZH1cIjogXCJsYXllclwiIGF0dHJpYnV0ZSBpcyB1bmRlZmluZWRgKTtcbiAgICBpZiAoIW9iai5jb250ZW50KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBcIiR7b2JqLmlkfVwiOiBcImNvbnRlbnRcIiBhdHRyaWJ1dGUgbXVzdCBiZSBzZXRgKTtcbiAgICBpZiAoIW9iai5lbmFibGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IFwiJHtvYmouaWR9XCI6IFwiZW5hYmxlXCIgYXR0cmlidXRlIG11c3QgYmUgc2V0YCk7XG4gICAgY29uc3QgZW5hYmxlcyA9IF8uaXNBcnJheShvYmouZW5hYmxlKSA/IG9iai5lbmFibGUgOiBbb2JqLmVuYWJsZV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVuYWJsZSA9IGVuYWJsZXNbaV07XG4gICAgICAgIGlmIChlbmFibGUuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBlbmFibGUud2hpbGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBcIiR7b2JqLmlkfVwiOiBcImVuYWJsZS5zdGFydFwiIGFuZCBcImVuYWJsZS53aGlsZVwiIGNhbm5vdCBiZSBjb21iaW5lZGApO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBlbmFibGUuZW5kICE9PSB1bmRlZmluZWQgJiYgZW5hYmxlLmR1cmF0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgXCIke29iai5pZH1cIjogXCJlbmFibGUuZW5kXCIgYW5kIFwiZW5hYmxlLmR1cmF0aW9uXCIgY2Fubm90IGJlIGNvbWJpbmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW5hYmxlLndoaWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZW5hYmxlLmVuZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IFwiJHtvYmouaWR9XCI6IFwiZW5hYmxlLndoaWxlXCIgYW5kIFwiZW5hYmxlLmVuZFwiIGNhbm5vdCBiZSBjb21iaW5lZGApO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBlbmFibGUuZHVyYXRpb24gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBcIiR7b2JqLmlkfVwiOiBcImVuYWJsZS53aGlsZVwiIGFuZCBcImVuYWJsZS5kdXJhdGlvblwiIGNhbm5vdCBiZSBjb21iaW5lZGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IFwiJHtvYmouaWR9XCI6IFwiZW5hYmxlLnN0YXJ0XCIgb3IgXCJlbmFibGUud2hpbGVcIiBtdXN0IGJlIHNldGApO1xuICAgIH1cbiAgICBpZiAob2JqLmtleWZyYW1lcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5rZXlmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleWZyYW1lID0gb2JqLmtleWZyYW1lc1tpXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVLZXlmcmFtZTAoa2V5ZnJhbWUsIHN0cmljdCwgdW5pcXVlSWRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgXCIke29iai5pZH1cIiBrZXlmcmFtZVske2l9XTogJHtlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvYmouY2xhc3Nlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5jbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBvYmouY2xhc3Nlc1tpXTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgJiYgdHlwZW9mIGNsYXNzTmFtZSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgXCIke29iai5pZH1cIjogXCJjbGFzc2VzWyR7aX1dXCIgaXMgbm90IGEgc3RyaW5nYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iai5jaGlsZHJlbiAmJiAhb2JqLmlzR3JvdXApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IFwiJHtvYmouaWR9XCI6IGF0dHJpYnV0ZSBcImNoaWxkcmVuXCIgaXMgc2V0IGJ1dCBcImlzR3JvdXBcIiBpcyBub3RgKTtcbiAgICBpZiAob2JqLmlzR3JvdXAgJiYgIW9iai5jaGlsZHJlbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgXCIke29iai5pZH1cIjogYXR0cmlidXRlIFwiaXNHcm91cFwiIGlzIHNldCBidXQgXCJjaGlsZHJlblwiIG1pc3NpbmdgKTtcbiAgICBpZiAob2JqLmNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG9iai5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVPYmplY3QwKGNoaWxkLCBzdHJpY3QsIHVuaXF1ZUlkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IFwiJHtvYmouaWR9XCIgY2hpbGRbJHtpfV06ICR7ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2JqLnByaW9yaXR5ICE9PSB1bmRlZmluZWQgJiYgIV8uaXNOdW1iZXIob2JqLnByaW9yaXR5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgXCIke29iai5pZH1cIjogYXR0cmlidXRlIFwicHJpb3JpdHlcIiBpcyBub3QgYSBudW1iZXJgKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlS2V5ZnJhbWUwKGtleWZyYW1lLCBzdHJpY3QsIHVuaXF1ZUlkcykge1xuICAgIGlmICghdW5pcXVlSWRzKVxuICAgICAgICB1bmlxdWVJZHMgPSB7fTtcbiAgICBpZiAoIWtleWZyYW1lKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleWZyYW1lIGlzIHVuZGVmaW5lZGApO1xuICAgIGlmICh0eXBlb2Yga2V5ZnJhbWUgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleWZyYW1lIGlzIG5vdCBhbiBvYmplY3RgKTtcbiAgICBpZiAoIWtleWZyYW1lLmlkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleWZyYW1lIG1pc3NpbmcgaWQgYXR0cmlidXRlYCk7XG4gICAgaWYgKHR5cGVvZiBrZXlmcmFtZS5pZCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ZnJhbWUgaWQgYXR0cmlidXRlIGlzIG5vdCBhIHN0cmluZzogXCIke2tleWZyYW1lLmlkfVwiYCk7XG4gICAgaWYgKHVuaXF1ZUlkc1trZXlmcmFtZS5pZF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ZnJhbWUgaWQgXCIke2tleWZyYW1lLmlkfVwiIGlzIG5vdCB1bmlxdWVgKTtcbiAgICB1bmlxdWVJZHNba2V5ZnJhbWUuaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWtleWZyYW1lLmNvbnRlbnQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ZnJhbWUgXCIke2tleWZyYW1lLmlkfVwiOiBcImNvbnRlbnRcIiBhdHRyaWJ1dGUgbXVzdCBiZSBzZXRgKTtcbiAgICBpZiAoIWtleWZyYW1lLmVuYWJsZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXlmcmFtZSBcIiR7a2V5ZnJhbWUuaWR9XCI6IFwiZW5hYmxlXCIgYXR0cmlidXRlIG11c3QgYmUgc2V0YCk7XG4gICAgY29uc3QgZW5hYmxlcyA9IF8uaXNBcnJheShrZXlmcmFtZS5lbmFibGUpID8ga2V5ZnJhbWUuZW5hYmxlIDogW2tleWZyYW1lLmVuYWJsZV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVuYWJsZSA9IGVuYWJsZXNbaV07XG4gICAgICAgIGlmIChlbmFibGUuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBlbmFibGUud2hpbGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleWZyYW1lIFwiJHtrZXlmcmFtZS5pZH1cIjogXCJlbmFibGUuc3RhcnRcIiBhbmQgXCJlbmFibGUud2hpbGVcIiBjYW5ub3QgYmUgY29tYmluZWRgKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZW5hYmxlLmVuZCAhPT0gdW5kZWZpbmVkICYmIGVuYWJsZS5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ZnJhbWUgXCIke2tleWZyYW1lLmlkfVwiOiBcImVuYWJsZS5lbmRcIiBhbmQgXCJlbmFibGUuZHVyYXRpb25cIiBjYW5ub3QgYmUgY29tYmluZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbmFibGUud2hpbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBlbmFibGUuZW5kICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXlmcmFtZSBcIiR7a2V5ZnJhbWUuaWR9XCI6IFwiZW5hYmxlLndoaWxlXCIgYW5kIFwiZW5hYmxlLmVuZFwiIGNhbm5vdCBiZSBjb21iaW5lZGApO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBlbmFibGUuZHVyYXRpb24gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleWZyYW1lIFwiJHtrZXlmcmFtZS5pZH1cIjogXCJlbmFibGUud2hpbGVcIiBhbmQgXCJlbmFibGUuZHVyYXRpb25cIiBjYW5ub3QgYmUgY29tYmluZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleWZyYW1lIFwiJHtrZXlmcmFtZS5pZH1cIjogXCJlbmFibGUuc3RhcnRcIiBvciBcImVuYWJsZS53aGlsZVwiIG11c3QgYmUgc2V0YCk7XG4gICAgfVxuICAgIGlmIChrZXlmcmFtZS5jbGFzc2VzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5ZnJhbWUuY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0ga2V5ZnJhbWUuY2xhc3Nlc1tpXTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgJiYgIV8uaXNTdHJpbmcoY2xhc3NOYW1lKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleWZyYW1lIFwiJHtrZXlmcmFtZS5pZH1cIjogXCJjbGFzc2VzWyR7aX1dXCIgaXMgbm90IGEgc3RyaW5nYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhbGwgb2JqZWN0cyBpbiB0aGUgdGltZWxpbmUuIFRocm93cyBhbiBlcnJvciBpZiBzb21ldGhpbmcncyB3cm9uZ1xuICogQHBhcmFtIHRpbWVsaW5lIFRoZSB0aW1lbGluZSB0byB2YWxpZGF0ZVxuICogQHBhcmFtIHN0cmljdCBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgc29tZSBzdHJpY3QgcnVsZXMgKHJ1bGVzIHRoYXQgY2FuIHBvc3NpYmx5IGJlIGlnbm9yZWQpXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVGltZWxpbmUodGltZWxpbmUsIHN0cmljdCkge1xuICAgIGNvbnN0IHVuaXF1ZUlkcyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZWxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb2JqID0gdGltZWxpbmVbaV07XG4gICAgICAgIHZhbGlkYXRlT2JqZWN0MChvYmosIHN0cmljdCwgdW5pcXVlSWRzKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlVGltZWxpbmUgPSB2YWxpZGF0ZVRpbWVsaW5lO1xuLyoqXG4gKiBWYWxpZGF0ZXMgYSBUaW1lbGluZS1vYmplY3QuIFRocm93cyBhbiBlcnJvciBpZiBzb21ldGhpbmcncyB3cm9uZ1xuICogQHBhcmFtIHRpbWVsaW5lIFRoZSB0aW1lbGluZSB0byB2YWxpZGF0ZVxuICogQHBhcmFtIHN0cmljdCBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgc29tZSBzdHJpY3QgcnVsZXMgKHJ1bGVzIHRoYXQgY2FuIHBvc3NpYmx5IGJlIGlnbm9yZWQpXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iaiwgc3RyaWN0KSB7XG4gICAgdmFsaWRhdGVPYmplY3QwKG9iaiwgc3RyaWN0KTtcbn1cbmV4cG9ydHMudmFsaWRhdGVPYmplY3QgPSB2YWxpZGF0ZU9iamVjdDtcbi8qKlxuICogVmFsaWRhdGVzIGEgVGltZWxpbmUta2V5ZnJhbWUuIFRocm93cyBhbiBlcnJvciBpZiBzb21ldGhpbmcncyB3cm9uZ1xuICogQHBhcmFtIHRpbWVsaW5lIFRoZSB0aW1lbGluZSB0byB2YWxpZGF0ZVxuICogQHBhcmFtIHN0cmljdCBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgc29tZSBzdHJpY3QgcnVsZXMgKHJ1bGVzIHRoYXQgY2FuIHBvc3NpYmx5IGJlIGlnbm9yZWQpXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlS2V5ZnJhbWUoa2V5ZnJhbWUsIHN0cmljdCkge1xuICAgIHZhbGlkYXRlS2V5ZnJhbWUwKGtleWZyYW1lLCBzdHJpY3QpO1xufVxuZXhwb3J0cy52YWxpZGF0ZUtleWZyYW1lID0gdmFsaWRhdGVLZXlmcmFtZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRlLmpzLm1hcCIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBnbG9iYWwsIGRlZmluZSwgU3lzdGVtLCBSZWZsZWN0LCBQcm9taXNlICovXHJcbnZhciBfX2V4dGVuZHM7XHJcbnZhciBfX2Fzc2lnbjtcclxudmFyIF9fcmVzdDtcclxudmFyIF9fZGVjb3JhdGU7XHJcbnZhciBfX3BhcmFtO1xyXG52YXIgX19tZXRhZGF0YTtcclxudmFyIF9fYXdhaXRlcjtcclxudmFyIF9fZ2VuZXJhdG9yO1xyXG52YXIgX19leHBvcnRTdGFyO1xyXG52YXIgX192YWx1ZXM7XHJcbnZhciBfX3JlYWQ7XHJcbnZhciBfX3NwcmVhZDtcclxudmFyIF9fc3ByZWFkQXJyYXlzO1xyXG52YXIgX19zcHJlYWRBcnJheTtcclxudmFyIF9fYXdhaXQ7XHJcbnZhciBfX2FzeW5jR2VuZXJhdG9yO1xyXG52YXIgX19hc3luY0RlbGVnYXRvcjtcclxudmFyIF9fYXN5bmNWYWx1ZXM7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdDtcclxudmFyIF9faW1wb3J0U3RhcjtcclxudmFyIF9faW1wb3J0RGVmYXVsdDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQ7XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0O1xyXG52YXIgX19jcmVhdGVCaW5kaW5nO1xyXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHR5cGVvZiB0aGlzID09PSBcIm9iamVjdFwiID8gdGhpcyA6IHt9O1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFwidHNsaWJcIiwgW1wiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKGV4cG9ydHMpIHsgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihleHBvcnRzKSkpOyB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihtb2R1bGUuZXhwb3J0cykpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cywgcHJldmlvdXMpIHtcclxuICAgICAgICBpZiAoZXhwb3J0cyAhPT0gcm9vdCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGlkLCB2KSB7IHJldHVybiBleHBvcnRzW2lkXSA9IHByZXZpb3VzID8gcHJldmlvdXMoaWQsIHYpIDogdjsgfTtcclxuICAgIH1cclxufSlcclxuKGZ1bmN0aW9uIChleHBvcnRlcikge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3Jlc3QgPSBmdW5jdGlvbiAocywgZSkge1xyXG4gICAgICAgIHZhciB0ID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZGVjb3JhdGUgPSBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgICAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3BhcmFtID0gZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdGVyID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZ2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgICAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgX19leHBvcnRTdGFyID0gZnVuY3Rpb24obSwgbykge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxuICAgIH07XHJcblxyXG4gICAgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG4gICAgfSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgICAgIG9bazJdID0gbVtrXTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9fdmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3JlYWQgPSBmdW5jdGlvbiAobywgbikge1xyXG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgICAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xyXG4gICAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xyXG4gICAgX19zcHJlYWRBcnJheXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3NwcmVhZEFycmF5ID0gZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICAgICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IGZyb20pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2F3YWl0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNEZWxlZ2F0b3IgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBpLCBwO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jVmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgICAgICByZXR1cm4gY29va2VkO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG4gICAgfSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2ltcG9ydFN0YXIgPSBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgX19pbXBvcnREZWZhdWx0ID0gZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgICAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgICAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICAgICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydGVyKFwiX19leHRlbmRzXCIsIF9fZXh0ZW5kcyk7XHJcbiAgICBleHBvcnRlcihcIl9fYXNzaWduXCIsIF9fYXNzaWduKTtcclxuICAgIGV4cG9ydGVyKFwiX19yZXN0XCIsIF9fcmVzdCk7XHJcbiAgICBleHBvcnRlcihcIl9fZGVjb3JhdGVcIiwgX19kZWNvcmF0ZSk7XHJcbiAgICBleHBvcnRlcihcIl9fcGFyYW1cIiwgX19wYXJhbSk7XHJcbiAgICBleHBvcnRlcihcIl9fbWV0YWRhdGFcIiwgX19tZXRhZGF0YSk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRlclwiLCBfX2F3YWl0ZXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2dlbmVyYXRvclwiLCBfX2dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fZXhwb3J0U3RhclwiLCBfX2V4cG9ydFN0YXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2NyZWF0ZUJpbmRpbmdcIiwgX19jcmVhdGVCaW5kaW5nKTtcclxuICAgIGV4cG9ydGVyKFwiX192YWx1ZXNcIiwgX192YWx1ZXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3JlYWRcIiwgX19yZWFkKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRcIiwgX19zcHJlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZEFycmF5c1wiLCBfX3NwcmVhZEFycmF5cyk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlcIiwgX19zcHJlYWRBcnJheSk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRcIiwgX19hd2FpdCk7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNHZW5lcmF0b3JcIiwgX19hc3luY0dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNEZWxlZ2F0b3JcIiwgX19hc3luY0RlbGVnYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNWYWx1ZXNcIiwgX19hc3luY1ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fbWFrZVRlbXBsYXRlT2JqZWN0XCIsIF9fbWFrZVRlbXBsYXRlT2JqZWN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19pbXBvcnRTdGFyXCIsIF9faW1wb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9faW1wb3J0RGVmYXVsdFwiLCBfX2ltcG9ydERlZmF1bHQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0XCIsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0XCIsIF9fY2xhc3NQcml2YXRlRmllbGRTZXQpO1xyXG59KTtcclxuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIGdsb2JhbCwgZGVmaW5lLCBTeXN0ZW0sIFJlZmxlY3QsIFByb21pc2UgKi9cclxudmFyIF9fZXh0ZW5kcztcclxudmFyIF9fYXNzaWduO1xyXG52YXIgX19yZXN0O1xyXG52YXIgX19kZWNvcmF0ZTtcclxudmFyIF9fcGFyYW07XHJcbnZhciBfX21ldGFkYXRhO1xyXG52YXIgX19hd2FpdGVyO1xyXG52YXIgX19nZW5lcmF0b3I7XHJcbnZhciBfX2V4cG9ydFN0YXI7XHJcbnZhciBfX3ZhbHVlcztcclxudmFyIF9fcmVhZDtcclxudmFyIF9fc3ByZWFkO1xyXG52YXIgX19hd2FpdDtcclxudmFyIF9fYXN5bmNHZW5lcmF0b3I7XHJcbnZhciBfX2FzeW5jRGVsZWdhdG9yO1xyXG52YXIgX19hc3luY1ZhbHVlcztcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0O1xyXG52YXIgX19pbXBvcnRTdGFyO1xyXG52YXIgX19pbXBvcnREZWZhdWx0O1xyXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHR5cGVvZiB0aGlzID09PSBcIm9iamVjdFwiID8gdGhpcyA6IHt9O1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFwidHNsaWJcIiwgW1wiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKGV4cG9ydHMpIHsgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihleHBvcnRzKSkpOyB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihtb2R1bGUuZXhwb3J0cykpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cywgcHJldmlvdXMpIHtcclxuICAgICAgICBpZiAoZXhwb3J0cyAhPT0gcm9vdCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGlkLCB2KSB7IHJldHVybiBleHBvcnRzW2lkXSA9IHByZXZpb3VzID8gcHJldmlvdXMoaWQsIHYpIDogdjsgfTtcclxuICAgIH1cclxufSlcclxuKGZ1bmN0aW9uIChleHBvcnRlcikge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3Jlc3QgPSBmdW5jdGlvbiAocywgZSkge1xyXG4gICAgICAgIHZhciB0ID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19kZWNvcmF0ZSA9IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgICAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcGFyYW0gPSBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fbWV0YWRhdGEgPSBmdW5jdGlvbiAobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2F3YWl0ZXIgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgX19nZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICAgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2V4cG9ydFN0YXIgPSBmdW5jdGlvbiAobSwgZXhwb3J0cykge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH07XHJcblxyXG4gICAgX192YWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICAgICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVhZCA9IGZ1bmN0aW9uIChvLCBuKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICAgICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jR2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgIH1cclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0RlbGVnYXRvciA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIGksIHA7XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNWYWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgICAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19tYWtlVGVtcGxhdGVPYmplY3QgPSBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcclxuICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgICAgIHJldHVybiBjb29rZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9faW1wb3J0U3RhciA9IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgX19pbXBvcnREZWZhdWx0ID0gZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRlcihcIl9fZXh0ZW5kc1wiLCBfX2V4dGVuZHMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2Fzc2lnblwiLCBfX2Fzc2lnbik7XHJcbiAgICBleHBvcnRlcihcIl9fcmVzdFwiLCBfX3Jlc3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2RlY29yYXRlXCIsIF9fZGVjb3JhdGUpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3BhcmFtXCIsIF9fcGFyYW0pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX21ldGFkYXRhXCIsIF9fbWV0YWRhdGEpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2F3YWl0ZXJcIiwgX19hd2FpdGVyKTtcclxuICAgIGV4cG9ydGVyKFwiX19nZW5lcmF0b3JcIiwgX19nZW5lcmF0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2V4cG9ydFN0YXJcIiwgX19leHBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX192YWx1ZXNcIiwgX192YWx1ZXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3JlYWRcIiwgX19yZWFkKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRcIiwgX19zcHJlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2F3YWl0XCIsIF9fYXdhaXQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jR2VuZXJhdG9yXCIsIF9fYXN5bmNHZW5lcmF0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jRGVsZWdhdG9yXCIsIF9fYXN5bmNEZWxlZ2F0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jVmFsdWVzXCIsIF9fYXN5bmNWYWx1ZXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX21ha2VUZW1wbGF0ZU9iamVjdFwiLCBfX21ha2VUZW1wbGF0ZU9iamVjdCk7XHJcbiAgICBleHBvcnRlcihcIl9faW1wb3J0U3RhclwiLCBfX2ltcG9ydFN0YXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2ltcG9ydERlZmF1bHRcIiwgX19pbXBvcnREZWZhdWx0KTtcclxufSk7XHJcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCd1bmRlcnNjb3JlJywgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50ID0gZ2xvYmFsLl87XG4gICAgdmFyIGV4cG9ydHMgPSBnbG9iYWwuXyA9IGZhY3RvcnkoKTtcbiAgICBleHBvcnRzLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7IGdsb2JhbC5fID0gY3VycmVudDsgcmV0dXJuIGV4cG9ydHM7IH07XG4gIH0oKSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkge1xuICAvLyAgICAgVW5kZXJzY29yZS5qcyAxLjEzLjFcbiAgLy8gICAgIGh0dHBzOi8vdW5kZXJzY29yZWpzLm9yZ1xuICAvLyAgICAgKGMpIDIwMDktMjAyMSBKZXJlbXkgQXNoa2VuYXMsIEp1bGlhbiBHb25nZ3JpanAsIGFuZCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAgLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICB2YXIgVkVSU0lPTiA9ICcxLjEzLjEnO1xuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIChgc2VsZmApIGluIHRoZSBicm93c2VyLCBgZ2xvYmFsYFxuICAvLyBvbiB0aGUgc2VydmVyLCBvciBgdGhpc2AgaW4gc29tZSB2aXJ0dWFsIG1hY2hpbmVzLiBXZSB1c2UgYHNlbGZgXG4gIC8vIGluc3RlYWQgb2YgYHdpbmRvd2AgZm9yIGBXZWJXb3JrZXJgIHN1cHBvcnQuXG4gIHZhciByb290ID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZi5zZWxmID09PSBzZWxmICYmIHNlbGYgfHxcbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsICYmIGdsb2JhbCB8fFxuICAgICAgICAgICAgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKSB8fFxuICAgICAgICAgICAge307XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIFN5bWJvbFByb3RvID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2wucHJvdG90eXBlIDogbnVsbDtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyIHB1c2ggPSBBcnJheVByb3RvLnB1c2gsXG4gICAgICBzbGljZSA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgICB0b1N0cmluZyA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBNb2Rlcm4gZmVhdHVyZSBkZXRlY3Rpb24uXG4gIHZhciBzdXBwb3J0c0FycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyxcbiAgICAgIHN1cHBvcnRzRGF0YVZpZXcgPSB0eXBlb2YgRGF0YVZpZXcgIT09ICd1bmRlZmluZWQnO1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSsqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhciBuYXRpdmVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIG5hdGl2ZUtleXMgPSBPYmplY3Qua2V5cyxcbiAgICAgIG5hdGl2ZUNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG4gICAgICBuYXRpdmVJc1ZpZXcgPSBzdXBwb3J0c0FycmF5QnVmZmVyICYmIEFycmF5QnVmZmVyLmlzVmlldztcblxuICAvLyBDcmVhdGUgcmVmZXJlbmNlcyB0byB0aGVzZSBidWlsdGluIGZ1bmN0aW9ucyBiZWNhdXNlIHdlIG92ZXJyaWRlIHRoZW0uXG4gIHZhciBfaXNOYU4gPSBpc05hTixcbiAgICAgIF9pc0Zpbml0ZSA9IGlzRmluaXRlO1xuXG4gIC8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXG4gIHZhciBoYXNFbnVtQnVnID0gIXt0b1N0cmluZzogbnVsbH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsXG4gICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG5cbiAgLy8gVGhlIGxhcmdlc3QgaW50ZWdlciB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCBleGFjdGx5LlxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuICAvLyBTb21lIGZ1bmN0aW9ucyB0YWtlIGEgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cywgb3IgYSBmZXcgZXhwZWN0ZWRcbiAgLy8gYXJndW1lbnRzIGF0IHRoZSBiZWdpbm5pbmcgYW5kIHRoZW4gYSB2YXJpYWJsZSBudW1iZXIgb2YgdmFsdWVzIHRvIG9wZXJhdGVcbiAgLy8gb24uIFRoaXMgaGVscGVyIGFjY3VtdWxhdGVzIGFsbCByZW1haW5pbmcgYXJndW1lbnRzIHBhc3QgdGhlIGZ1bmN0aW9u4oCZc1xuICAvLyBhcmd1bWVudCBsZW5ndGggKG9yIGFuIGV4cGxpY2l0IGBzdGFydEluZGV4YCksIGludG8gYW4gYXJyYXkgdGhhdCBiZWNvbWVzXG4gIC8vIHRoZSBsYXN0IGFyZ3VtZW50LiBTaW1pbGFyIHRvIEVTNuKAmXMgXCJyZXN0IHBhcmFtZXRlclwiLlxuICBmdW5jdGlvbiByZXN0QXJndW1lbnRzKGZ1bmMsIHN0YXJ0SW5kZXgpIHtcbiAgICBzdGFydEluZGV4ID0gc3RhcnRJbmRleCA9PSBudWxsID8gZnVuYy5sZW5ndGggLSAxIDogK3N0YXJ0SW5kZXg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KGFyZ3VtZW50cy5sZW5ndGggLSBzdGFydEluZGV4LCAwKSxcbiAgICAgICAgICByZXN0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXggKyBzdGFydEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoc3RhcnRJbmRleCkge1xuICAgICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpcywgcmVzdCk7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0sIHJlc3QpO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIHJlc3QpO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBBcnJheShzdGFydEluZGV4ICsgMSk7XG4gICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBzdGFydEluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGFyZ3Nbc3RhcnRJbmRleF0gPSByZXN0O1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xuICBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIGZ1bmN0aW9uIGlzTnVsbChvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xuICBmdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuICBmdW5jdGlvbiBpc0VsZW1lbnQob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgYHRvU3RyaW5nYC1iYXNlZCB0eXBlIHRlc3Rlci5cbiAgZnVuY3Rpb24gdGFnVGVzdGVyKG5hbWUpIHtcbiAgICB2YXIgdGFnID0gJ1tvYmplY3QgJyArIG5hbWUgKyAnXSc7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gdGFnO1xuICAgIH07XG4gIH1cblxuICB2YXIgaXNTdHJpbmcgPSB0YWdUZXN0ZXIoJ1N0cmluZycpO1xuXG4gIHZhciBpc051bWJlciA9IHRhZ1Rlc3RlcignTnVtYmVyJyk7XG5cbiAgdmFyIGlzRGF0ZSA9IHRhZ1Rlc3RlcignRGF0ZScpO1xuXG4gIHZhciBpc1JlZ0V4cCA9IHRhZ1Rlc3RlcignUmVnRXhwJyk7XG5cbiAgdmFyIGlzRXJyb3IgPSB0YWdUZXN0ZXIoJ0Vycm9yJyk7XG5cbiAgdmFyIGlzU3ltYm9sID0gdGFnVGVzdGVyKCdTeW1ib2wnKTtcblxuICB2YXIgaXNBcnJheUJ1ZmZlciA9IHRhZ1Rlc3RlcignQXJyYXlCdWZmZXInKTtcblxuICB2YXIgaXNGdW5jdGlvbiA9IHRhZ1Rlc3RlcignRnVuY3Rpb24nKTtcblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgYHR5cGVvZmAgYnVncyBpbiBvbGRcbiAgLy8gdjgsIElFIDExICgjMTYyMSksIFNhZmFyaSA4ICgjMTkyOSksIGFuZCBQaGFudG9tSlMgKCMyMjM2KS5cbiAgdmFyIG5vZGVsaXN0ID0gcm9vdC5kb2N1bWVudCAmJiByb290LmRvY3VtZW50LmNoaWxkTm9kZXM7XG4gIGlmICh0eXBlb2YgLy4vICE9ICdmdW5jdGlvbicgJiYgdHlwZW9mIEludDhBcnJheSAhPSAnb2JqZWN0JyAmJiB0eXBlb2Ygbm9kZWxpc3QgIT0gJ2Z1bmN0aW9uJykge1xuICAgIGlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBpc0Z1bmN0aW9uJDEgPSBpc0Z1bmN0aW9uO1xuXG4gIHZhciBoYXNPYmplY3RUYWcgPSB0YWdUZXN0ZXIoJ09iamVjdCcpO1xuXG4gIC8vIEluIElFIDEwIC0gRWRnZSAxMywgYERhdGFWaWV3YCBoYXMgc3RyaW5nIHRhZyBgJ1tvYmplY3QgT2JqZWN0XSdgLlxuICAvLyBJbiBJRSAxMSwgdGhlIG1vc3QgY29tbW9uIGFtb25nIHRoZW0sIHRoaXMgcHJvYmxlbSBhbHNvIGFwcGxpZXMgdG9cbiAgLy8gYE1hcGAsIGBXZWFrTWFwYCBhbmQgYFNldGAuXG4gIHZhciBoYXNTdHJpbmdUYWdCdWcgPSAoXG4gICAgICAgIHN1cHBvcnRzRGF0YVZpZXcgJiYgaGFzT2JqZWN0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoOCkpKVxuICAgICAgKSxcbiAgICAgIGlzSUUxMSA9ICh0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJyAmJiBoYXNPYmplY3RUYWcobmV3IE1hcCkpO1xuXG4gIHZhciBpc0RhdGFWaWV3ID0gdGFnVGVzdGVyKCdEYXRhVmlldycpO1xuXG4gIC8vIEluIElFIDEwIC0gRWRnZSAxMywgd2UgbmVlZCBhIGRpZmZlcmVudCBoZXVyaXN0aWNcbiAgLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGEgYERhdGFWaWV3YC5cbiAgZnVuY3Rpb24gaWUxMElzRGF0YVZpZXcob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGlzRnVuY3Rpb24kMShvYmouZ2V0SW50OCkgJiYgaXNBcnJheUJ1ZmZlcihvYmouYnVmZmVyKTtcbiAgfVxuXG4gIHZhciBpc0RhdGFWaWV3JDEgPSAoaGFzU3RyaW5nVGFnQnVnID8gaWUxMElzRGF0YVZpZXcgOiBpc0RhdGFWaWV3KTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgYEFycmF5LmlzQXJyYXlgLlxuICB2YXIgaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgdGFnVGVzdGVyKCdBcnJheScpO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRvIGNoZWNrIHdoZXRoZXIgYGtleWAgaXMgYW4gb3duIHByb3BlcnR5IG5hbWUgb2YgYG9iamAuXG4gIGZ1bmN0aW9uIGhhcyQxKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9XG5cbiAgdmFyIGlzQXJndW1lbnRzID0gdGFnVGVzdGVyKCdBcmd1bWVudHMnKTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIChmdW5jdGlvbigpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICAgIGlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBoYXMkMShvYmosICdjYWxsZWUnKTtcbiAgICAgIH07XG4gICAgfVxuICB9KCkpO1xuXG4gIHZhciBpc0FyZ3VtZW50cyQxID0gaXNBcmd1bWVudHM7XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBmdW5jdGlvbiBpc0Zpbml0ZSQxKG9iaikge1xuICAgIHJldHVybiAhaXNTeW1ib2wob2JqKSAmJiBfaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfVxuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD9cbiAgZnVuY3Rpb24gaXNOYU4kMShvYmopIHtcbiAgICByZXR1cm4gaXNOdW1iZXIob2JqKSAmJiBfaXNOYU4ob2JqKTtcbiAgfVxuXG4gIC8vIFByZWRpY2F0ZS1nZW5lcmF0aW5nIGZ1bmN0aW9uLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gQ29tbW9uIGludGVybmFsIGxvZ2ljIGZvciBgaXNBcnJheUxpa2VgIGFuZCBgaXNCdWZmZXJMaWtlYC5cbiAgZnVuY3Rpb24gY3JlYXRlU2l6ZVByb3BlcnR5Q2hlY2soZ2V0U2l6ZVByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBzaXplUHJvcGVydHkgPSBnZXRTaXplUHJvcGVydHkoY29sbGVjdGlvbik7XG4gICAgICByZXR1cm4gdHlwZW9mIHNpemVQcm9wZXJ0eSA9PSAnbnVtYmVyJyAmJiBzaXplUHJvcGVydHkgPj0gMCAmJiBzaXplUHJvcGVydHkgPD0gTUFYX0FSUkFZX0lOREVYO1xuICAgIH1cbiAgfVxuXG4gIC8vIEludGVybmFsIGhlbHBlciB0byBnZW5lcmF0ZSBhIGZ1bmN0aW9uIHRvIG9idGFpbiBwcm9wZXJ0eSBga2V5YCBmcm9tIGBvYmpgLlxuICBmdW5jdGlvbiBzaGFsbG93UHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8vIEludGVybmFsIGhlbHBlciB0byBvYnRhaW4gdGhlIGBieXRlTGVuZ3RoYCBwcm9wZXJ0eSBvZiBhbiBvYmplY3QuXG4gIHZhciBnZXRCeXRlTGVuZ3RoID0gc2hhbGxvd1Byb3BlcnR5KCdieXRlTGVuZ3RoJyk7XG5cbiAgLy8gSW50ZXJuYWwgaGVscGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHdlIHNob3VsZCBzcGVuZCBleHRlbnNpdmUgY2hlY2tzIGFnYWluc3RcbiAgLy8gYEFycmF5QnVmZmVyYCBldCBhbC5cbiAgdmFyIGlzQnVmZmVyTGlrZSA9IGNyZWF0ZVNpemVQcm9wZXJ0eUNoZWNrKGdldEJ5dGVMZW5ndGgpO1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSB0eXBlZCBhcnJheT9cbiAgdmFyIHR5cGVkQXJyYXlQYXR0ZXJuID0gL1xcW29iamVjdCAoKEl8VWkpbnQoOHwxNnwzMil8RmxvYXQoMzJ8NjQpfFVpbnQ4Q2xhbXBlZHxCaWcoSXxVaSludDY0KUFycmF5XFxdLztcbiAgZnVuY3Rpb24gaXNUeXBlZEFycmF5KG9iaikge1xuICAgIC8vIGBBcnJheUJ1ZmZlci5pc1ZpZXdgIGlzIHRoZSBtb3N0IGZ1dHVyZS1wcm9vZiwgc28gdXNlIGl0IHdoZW4gYXZhaWxhYmxlLlxuICAgIC8vIE90aGVyd2lzZSwgZmFsbCBiYWNrIG9uIHRoZSBhYm92ZSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgcmV0dXJuIG5hdGl2ZUlzVmlldyA/IChuYXRpdmVJc1ZpZXcob2JqKSAmJiAhaXNEYXRhVmlldyQxKG9iaikpIDpcbiAgICAgICAgICAgICAgICAgIGlzQnVmZmVyTGlrZShvYmopICYmIHR5cGVkQXJyYXlQYXR0ZXJuLnRlc3QodG9TdHJpbmcuY2FsbChvYmopKTtcbiAgfVxuXG4gIHZhciBpc1R5cGVkQXJyYXkkMSA9IHN1cHBvcnRzQXJyYXlCdWZmZXIgPyBpc1R5cGVkQXJyYXkgOiBjb25zdGFudChmYWxzZSk7XG5cbiAgLy8gSW50ZXJuYWwgaGVscGVyIHRvIG9idGFpbiB0aGUgYGxlbmd0aGAgcHJvcGVydHkgb2YgYW4gb2JqZWN0LlxuICB2YXIgZ2V0TGVuZ3RoID0gc2hhbGxvd1Byb3BlcnR5KCdsZW5ndGgnKTtcblxuICAvLyBJbnRlcm5hbCBoZWxwZXIgdG8gY3JlYXRlIGEgc2ltcGxlIGxvb2t1cCBzdHJ1Y3R1cmUuXG4gIC8vIGBjb2xsZWN0Tm9uRW51bVByb3BzYCB1c2VkIHRvIGRlcGVuZCBvbiBgXy5jb250YWluc2AsIGJ1dCB0aGlzIGxlZCB0b1xuICAvLyBjaXJjdWxhciBpbXBvcnRzLiBgZW11bGF0ZWRTZXRgIGlzIGEgb25lLW9mZiBzb2x1dGlvbiB0aGF0IG9ubHkgd29ya3MgZm9yXG4gIC8vIGFycmF5cyBvZiBzdHJpbmdzLlxuICBmdW5jdGlvbiBlbXVsYXRlZFNldChrZXlzKSB7XG4gICAgdmFyIGhhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBsID0ga2V5cy5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgKytpKSBoYXNoW2tleXNbaV1dID0gdHJ1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGFpbnM6IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaGFzaFtrZXldOyB9LFxuICAgICAgcHVzaDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGhhc2hba2V5XSA9IHRydWU7XG4gICAgICAgIHJldHVybiBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgaGVscGVyLiBDaGVja3MgYGtleXNgIGZvciB0aGUgcHJlc2VuY2Ugb2Yga2V5cyBpbiBJRSA8IDkgdGhhdCB3b24ndFxuICAvLyBiZSBpdGVyYXRlZCBieSBgZm9yIGtleSBpbiAuLi5gIGFuZCB0aHVzIG1pc3NlZC4gRXh0ZW5kcyBga2V5c2AgaW4gcGxhY2UgaWZcbiAgLy8gbmVlZGVkLlxuICBmdW5jdGlvbiBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cykge1xuICAgIGtleXMgPSBlbXVsYXRlZFNldChrZXlzKTtcbiAgICB2YXIgbm9uRW51bUlkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGg7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90byA9IGlzRnVuY3Rpb24kMShjb25zdHJ1Y3RvcikgJiYgY29uc3RydWN0b3IucHJvdG90eXBlIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChoYXMkMShvYmosIHByb3ApICYmICFrZXlzLmNvbnRhaW5zKHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIWtleXMuY29udGFpbnMocHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYC5cbiAgZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICBpZiAobmF0aXZlS2V5cykgcmV0dXJuIG5hdGl2ZUtleXMob2JqKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChoYXMkMShvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBTa2lwIHRoZSBtb3JlIGV4cGVuc2l2ZSBgdG9TdHJpbmdgLWJhc2VkIHR5cGUgY2hlY2tzIGlmIGBvYmpgIGhhcyBub1xuICAgIC8vIGAubGVuZ3RoYC5cbiAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKG9iaik7XG4gICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgKFxuICAgICAgaXNBcnJheShvYmopIHx8IGlzU3RyaW5nKG9iaikgfHwgaXNBcmd1bWVudHMkMShvYmopXG4gICAgKSkgcmV0dXJuIGxlbmd0aCA9PT0gMDtcbiAgICByZXR1cm4gZ2V0TGVuZ3RoKGtleXMob2JqKSkgPT09IDA7XG4gIH1cblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgZnVuY3Rpb24gaXNNYXRjaChvYmplY3QsIGF0dHJzKSB7XG4gICAgdmFyIF9rZXlzID0ga2V5cyhhdHRycyksIGxlbmd0aCA9IF9rZXlzLmxlbmd0aDtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xuICAgIHZhciBvYmogPSBPYmplY3Qob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gX2tleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0IGNhblxuICAvLyBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgZnVuY3Rpb25zIGFkZGVkXG4gIC8vIHRocm91Z2ggYF8ubWl4aW5gLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG4gIGZ1bmN0aW9uIF8kMShvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXyQxKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfJDEpKSByZXR1cm4gbmV3IF8kMShvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH1cblxuICBfJDEuVkVSU0lPTiA9IFZFUlNJT047XG5cbiAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXG4gIF8kMS5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveGllcyBmb3Igc29tZSBtZXRob2RzIHVzZWQgaW4gZW5naW5lIG9wZXJhdGlvbnNcbiAgLy8gc3VjaCBhcyBhcml0aG1ldGljIGFuZCBKU09OIHN0cmluZ2lmaWNhdGlvbi5cbiAgXyQxLnByb3RvdHlwZS52YWx1ZU9mID0gXyQxLnByb3RvdHlwZS50b0pTT04gPSBfJDEucHJvdG90eXBlLnZhbHVlO1xuXG4gIF8kMS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gU3RyaW5nKHRoaXMuX3dyYXBwZWQpO1xuICB9O1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRvIHdyYXAgb3Igc2hhbGxvdy1jb3B5IGFuIEFycmF5QnVmZmVyLFxuICAvLyB0eXBlZCBhcnJheSBvciBEYXRhVmlldyB0byBhIG5ldyB2aWV3LCByZXVzaW5nIHRoZSBidWZmZXIuXG4gIGZ1bmN0aW9uIHRvQnVmZmVyVmlldyhidWZmZXJTb3VyY2UpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICBidWZmZXJTb3VyY2UuYnVmZmVyIHx8IGJ1ZmZlclNvdXJjZSxcbiAgICAgIGJ1ZmZlclNvdXJjZS5ieXRlT2Zmc2V0IHx8IDAsXG4gICAgICBnZXRCeXRlTGVuZ3RoKGJ1ZmZlclNvdXJjZSlcbiAgICApO1xuICB9XG5cbiAgLy8gV2UgdXNlIHRoaXMgc3RyaW5nIHR3aWNlLCBzbyBnaXZlIGl0IGEgbmFtZSBmb3IgbWluaWZpY2F0aW9uLlxuICB2YXIgdGFnRGF0YVZpZXcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgXy5pc0VxdWFsYC5cbiAgZnVuY3Rpb24gZXEoYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHBzOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gYG51bGxgIG9yIGB1bmRlZmluZWRgIG9ubHkgZXF1YWwgdG8gaXRzZWxmIChzdHJpY3QgY29tcGFyaXNvbikuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgIGlmIChhICE9PSBhKSByZXR1cm4gYiAhPT0gYjtcbiAgICAvLyBFeGhhdXN0IHByaW1pdGl2ZSBjaGVja3NcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBhO1xuICAgIGlmICh0eXBlICE9PSAnZnVuY3Rpb24nICYmIHR5cGUgIT09ICdvYmplY3QnICYmIHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGRlZXBFcShhLCBiLCBhU3RhY2ssIGJTdGFjayk7XG4gIH1cblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYF8uaXNFcXVhbGAuXG4gIGZ1bmN0aW9uIGRlZXBFcShhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXyQxKSBhID0gYS5fd3JhcHBlZDtcbiAgICBpZiAoYiBpbnN0YW5jZW9mIF8kMSkgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gV29yayBhcm91bmQgYSBidWcgaW4gSUUgMTAgLSBFZGdlIDEzLlxuICAgIGlmIChoYXNTdHJpbmdUYWdCdWcgJiYgY2xhc3NOYW1lID09ICdbb2JqZWN0IE9iamVjdF0nICYmIGlzRGF0YVZpZXckMShhKSkge1xuICAgICAgaWYgKCFpc0RhdGFWaWV3JDEoYikpIHJldHVybiBmYWxzZTtcbiAgICAgIGNsYXNzTmFtZSA9IHRhZ0RhdGFWaWV3O1xuICAgIH1cbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gVGhlc2UgdHlwZXMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU4uXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgICAgY2FzZSAnW29iamVjdCBTeW1ib2xdJzpcbiAgICAgICAgcmV0dXJuIFN5bWJvbFByb3RvLnZhbHVlT2YuY2FsbChhKSA9PT0gU3ltYm9sUHJvdG8udmFsdWVPZi5jYWxsKGIpO1xuICAgICAgY2FzZSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nOlxuICAgICAgY2FzZSB0YWdEYXRhVmlldzpcbiAgICAgICAgLy8gQ29lcmNlIHRvIHR5cGVkIGFycmF5IHNvIHdlIGNhbiBmYWxsIHRocm91Z2guXG4gICAgICAgIHJldHVybiBkZWVwRXEodG9CdWZmZXJWaWV3KGEpLCB0b0J1ZmZlclZpZXcoYiksIGFTdGFjaywgYlN0YWNrKTtcbiAgICB9XG5cbiAgICB2YXIgYXJlQXJyYXlzID0gY2xhc3NOYW1lID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIGlmICghYXJlQXJyYXlzICYmIGlzVHlwZWRBcnJheSQxKGEpKSB7XG4gICAgICAgIHZhciBieXRlTGVuZ3RoID0gZ2V0Qnl0ZUxlbmd0aChhKTtcbiAgICAgICAgaWYgKGJ5dGVMZW5ndGggIT09IGdldEJ5dGVMZW5ndGgoYikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGEuYnVmZmVyID09PSBiLmJ1ZmZlciAmJiBhLmJ5dGVPZmZzZXQgPT09IGIuYnl0ZU9mZnNldCkgcmV0dXJuIHRydWU7XG4gICAgICAgIGFyZUFycmF5cyA9IHRydWU7XG4gICAgfVxuICAgIGlmICghYXJlQXJyYXlzKSB7XG4gICAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzIG9yIGBBcnJheWBzXG4gICAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvciwgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKGlzRnVuY3Rpb24kMShhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24kMShiQ3RvcikgJiYgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuXG4gICAgLy8gSW5pdGlhbGl6aW5nIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIC8vIEl0J3MgZG9uZSBoZXJlIHNpbmNlIHdlIG9ubHkgbmVlZCB0aGVtIGZvciBvYmplY3RzIGFuZCBhcnJheXMgY29tcGFyaXNvbi5cbiAgICBhU3RhY2sgPSBhU3RhY2sgfHwgW107XG4gICAgYlN0YWNrID0gYlN0YWNrIHx8IFtdO1xuICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG5cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICBpZiAoYXJlQXJyYXlzKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKCFlcShhW2xlbmd0aF0sIGJbbGVuZ3RoXSwgYVN0YWNrLCBiU3RhY2spKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgICAgdmFyIF9rZXlzID0ga2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0gX2tleXMubGVuZ3RoO1xuICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxuICAgICAgaWYgKGtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgICAga2V5ID0gX2tleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoaGFzJDEoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG4gIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiKTtcbiAgfVxuXG4gIC8vIFJldHJpZXZlIGFsbCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIGZ1bmN0aW9uIGFsbEtleXMob2JqKSB7XG4gICAgaWYgKCFpc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfVxuXG4gIC8vIFNpbmNlIHRoZSByZWd1bGFyIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCB0eXBlIHRlc3RzIGRvbid0IHdvcmsgZm9yXG4gIC8vIHNvbWUgdHlwZXMgaW4gSUUgMTEsIHdlIHVzZSBhIGZpbmdlcnByaW50aW5nIGhldXJpc3RpYyBpbnN0ZWFkLCBiYXNlZFxuICAvLyBvbiB0aGUgbWV0aG9kcy4gSXQncyBub3QgZ3JlYXQsIGJ1dCBpdCdzIHRoZSBiZXN0IHdlIGdvdC5cbiAgLy8gVGhlIGZpbmdlcnByaW50IG1ldGhvZCBsaXN0cyBhcmUgZGVmaW5lZCBiZWxvdy5cbiAgZnVuY3Rpb24gaWUxMWZpbmdlcnByaW50KG1ldGhvZHMpIHtcbiAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKG1ldGhvZHMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gYE1hcGAsIGBXZWFrTWFwYCBhbmQgYFNldGAgaGF2ZSBubyBlbnVtZXJhYmxlIGtleXMuXG4gICAgICB2YXIga2V5cyA9IGFsbEtleXMob2JqKTtcbiAgICAgIGlmIChnZXRMZW5ndGgoa2V5cykpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uJDEob2JqW21ldGhvZHNbaV1dKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UgYXJlIHRlc3RpbmcgYWdhaW5zdCBgV2Vha01hcGAsIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXRcbiAgICAgIC8vIGBvYmpgIGRvZXNuJ3QgaGF2ZSBhIGBmb3JFYWNoYCBtZXRob2QgaW4gb3JkZXIgdG8gZGlzdGluZ3Vpc2hcbiAgICAgIC8vIGl0IGZyb20gYSByZWd1bGFyIGBNYXBgLlxuICAgICAgcmV0dXJuIG1ldGhvZHMgIT09IHdlYWtNYXBNZXRob2RzIHx8ICFpc0Z1bmN0aW9uJDEob2JqW2ZvckVhY2hOYW1lXSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEluIHRoZSBpbnRlcmVzdCBvZiBjb21wYWN0IG1pbmlmaWNhdGlvbiwgd2Ugd3JpdGVcbiAgLy8gZWFjaCBzdHJpbmcgaW4gdGhlIGZpbmdlcnByaW50cyBvbmx5IG9uY2UuXG4gIHZhciBmb3JFYWNoTmFtZSA9ICdmb3JFYWNoJyxcbiAgICAgIGhhc05hbWUgPSAnaGFzJyxcbiAgICAgIGNvbW1vbkluaXQgPSBbJ2NsZWFyJywgJ2RlbGV0ZSddLFxuICAgICAgbWFwVGFpbCA9IFsnZ2V0JywgaGFzTmFtZSwgJ3NldCddO1xuXG4gIC8vIGBNYXBgLCBgV2Vha01hcGAgYW5kIGBTZXRgIGVhY2ggaGF2ZSBzbGlnaHRseSBkaWZmZXJlbnRcbiAgLy8gY29tYmluYXRpb25zIG9mIHRoZSBhYm92ZSBzdWJsaXN0cy5cbiAgdmFyIG1hcE1ldGhvZHMgPSBjb21tb25Jbml0LmNvbmNhdChmb3JFYWNoTmFtZSwgbWFwVGFpbCksXG4gICAgICB3ZWFrTWFwTWV0aG9kcyA9IGNvbW1vbkluaXQuY29uY2F0KG1hcFRhaWwpLFxuICAgICAgc2V0TWV0aG9kcyA9IFsnYWRkJ10uY29uY2F0KGNvbW1vbkluaXQsIGZvckVhY2hOYW1lLCBoYXNOYW1lKTtcblxuICB2YXIgaXNNYXAgPSBpc0lFMTEgPyBpZTExZmluZ2VycHJpbnQobWFwTWV0aG9kcykgOiB0YWdUZXN0ZXIoJ01hcCcpO1xuXG4gIHZhciBpc1dlYWtNYXAgPSBpc0lFMTEgPyBpZTExZmluZ2VycHJpbnQod2Vha01hcE1ldGhvZHMpIDogdGFnVGVzdGVyKCdXZWFrTWFwJyk7XG5cbiAgdmFyIGlzU2V0ID0gaXNJRTExID8gaWUxMWZpbmdlcnByaW50KHNldE1ldGhvZHMpIDogdGFnVGVzdGVyKCdTZXQnKTtcblxuICB2YXIgaXNXZWFrU2V0ID0gdGFnVGVzdGVyKCdXZWFrU2V0Jyk7XG5cbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICBmdW5jdGlvbiB2YWx1ZXMob2JqKSB7XG4gICAgdmFyIF9rZXlzID0ga2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBfa2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW19rZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICAvLyBUaGUgb3Bwb3NpdGUgb2YgYF8ub2JqZWN0YCB3aXRoIG9uZSBhcmd1bWVudC5cbiAgZnVuY3Rpb24gcGFpcnMob2JqKSB7XG4gICAgdmFyIF9rZXlzID0ga2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBfa2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtfa2V5c1tpXSwgb2JqW19rZXlzW2ldXV07XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbiAgfVxuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgZnVuY3Rpb24gaW52ZXJ0KG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgX2tleXMgPSBrZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IF9rZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW19rZXlzW2ldXV0gPSBfa2V5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uJDEob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH1cblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYXNzaWduZXIgZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihrZXlzRnVuYywgZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChkZWZhdWx0cykgb2JqID0gT2JqZWN0KG9iaik7XG4gICAgICBpZiAobGVuZ3RoIDwgMiB8fCBvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF0sXG4gICAgICAgICAgICBrZXlzID0ga2V5c0Z1bmMoc291cmNlKSxcbiAgICAgICAgICAgIGwgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoIWRlZmF1bHRzIHx8IG9ialtrZXldID09PSB2b2lkIDApIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICB2YXIgZXh0ZW5kID0gY3JlYXRlQXNzaWduZXIoYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pblxuICAvLyBvYmplY3QocykuXG4gIC8vIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduKVxuICB2YXIgZXh0ZW5kT3duID0gY3JlYXRlQXNzaWduZXIoa2V5cyk7XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgdmFyIGRlZmF1bHRzID0gY3JlYXRlQXNzaWduZXIoYWxsS2V5cywgdHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlIGEgbmFrZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGZvciBzdXJyb2dhdGUtcHJvdG90eXBlLXN3YXBwaW5nLlxuICBmdW5jdGlvbiBjdG9yKCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpe307XG4gIH1cblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBhbm90aGVyLlxuICBmdW5jdGlvbiBiYXNlQ3JlYXRlKHByb3RvdHlwZSkge1xuICAgIGlmICghaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICB2YXIgQ3RvciA9IGN0b3IoKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGdpdmVuIHByb3RvdHlwZSBvYmplY3QuXG4gIC8vIElmIGFkZGl0aW9uYWwgcHJvcGVydGllcyBhcmUgcHJvdmlkZWQgdGhlbiB0aGV5IHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4gIC8vIGNyZWF0ZWQgb2JqZWN0LlxuICBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBleHRlbmRPd24ocmVzdWx0LCBwcm9wcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICAgaWYgKCFpc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBpc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IGV4dGVuZCh7fSwgb2JqKTtcbiAgfVxuXG4gIC8vIEludm9rZXMgYGludGVyY2VwdG9yYCB3aXRoIHRoZSBgb2JqYCBhbmQgdGhlbiByZXR1cm5zIGBvYmpgLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIGZ1bmN0aW9uIHRhcChvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgLy8gTm9ybWFsaXplIGEgKGRlZXApIHByb3BlcnR5IGBwYXRoYCB0byBhcnJheS5cbiAgLy8gTGlrZSBgXy5pdGVyYXRlZWAsIHRoaXMgZnVuY3Rpb24gY2FuIGJlIGN1c3RvbWl6ZWQuXG4gIGZ1bmN0aW9uIHRvUGF0aCQxKHBhdGgpIHtcbiAgICByZXR1cm4gaXNBcnJheShwYXRoKSA/IHBhdGggOiBbcGF0aF07XG4gIH1cbiAgXyQxLnRvUGF0aCA9IHRvUGF0aCQxO1xuXG4gIC8vIEludGVybmFsIHdyYXBwZXIgZm9yIGBfLnRvUGF0aGAgdG8gZW5hYmxlIG1pbmlmaWNhdGlvbi5cbiAgLy8gU2ltaWxhciB0byBgY2JgIGZvciBgXy5pdGVyYXRlZWAuXG4gIGZ1bmN0aW9uIHRvUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIF8kMS50b1BhdGgocGF0aCk7XG4gIH1cblxuICAvLyBJbnRlcm5hbCBmdW5jdGlvbiB0byBvYnRhaW4gYSBuZXN0ZWQgcHJvcGVydHkgaW4gYG9iamAgYWxvbmcgYHBhdGhgLlxuICBmdW5jdGlvbiBkZWVwR2V0KG9iaiwgcGF0aCkge1xuICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgICBvYmogPSBvYmpbcGF0aFtpXV07XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGggPyBvYmogOiB2b2lkIDA7XG4gIH1cblxuICAvLyBHZXQgdGhlIHZhbHVlIG9mIHRoZSAoZGVlcCkgcHJvcGVydHkgb24gYHBhdGhgIGZyb20gYG9iamVjdGAuXG4gIC8vIElmIGFueSBwcm9wZXJ0eSBpbiBgcGF0aGAgZG9lcyBub3QgZXhpc3Qgb3IgaWYgdGhlIHZhbHVlIGlzXG4gIC8vIGB1bmRlZmluZWRgLCByZXR1cm4gYGRlZmF1bHRWYWx1ZWAgaW5zdGVhZC5cbiAgLy8gVGhlIGBwYXRoYCBpcyBub3JtYWxpemVkIHRocm91Z2ggYF8udG9QYXRoYC5cbiAgZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIHZhbHVlID0gZGVlcEdldChvYmplY3QsIHRvUGF0aChwYXRoKSk7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKHZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xuICB9XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseSBvblxuICAvLyBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLiBVbmxpa2UgdGhlIGludGVybmFsIGBoYXNgXG4gIC8vIGZ1bmN0aW9uLCB0aGlzIHB1YmxpYyB2ZXJzaW9uIGNhbiBhbHNvIHRyYXZlcnNlIG5lc3RlZCBwcm9wZXJ0aWVzLlxuICBmdW5jdGlvbiBoYXMob2JqLCBwYXRoKSB7XG4gICAgcGF0aCA9IHRvUGF0aChwYXRoKTtcbiAgICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHBhdGhbaV07XG4gICAgICBpZiAoIWhhcyQxKG9iaiwga2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgfVxuICAgIHJldHVybiAhIWxlbmd0aDtcbiAgfVxuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRlZXMuXG4gIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHByZWRpY2F0ZSBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mXG4gIC8vIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBmdW5jdGlvbiBtYXRjaGVyKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBleHRlbmRPd24oe30sIGF0dHJzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gaXNNYXRjaChvYmosIGF0dHJzKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gcGFzc2VkIGFuIG9iamVjdCwgd2lsbCB0cmF2ZXJzZSB0aGF0IG9iamVjdOKAmXNcbiAgLy8gcHJvcGVydGllcyBkb3duIHRoZSBnaXZlbiBgcGF0aGAsIHNwZWNpZmllZCBhcyBhbiBhcnJheSBvZiBrZXlzIG9yIGluZGljZXMuXG4gIGZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBkZWVwR2V0KG9iaiwgcGF0aCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBvcHRpbWl6ZUNiKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICAvLyBUaGUgMi1hcmd1bWVudCBjYXNlIGlzIG9taXR0ZWQgYmVjYXVzZSB3ZeKAmXJlIG5vdCB1c2luZyBpdC5cbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgY2FsbGJhY2tzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gZWFjaFxuICAvLyBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIHJlc3VsdCDigJQgZWl0aGVyIGBfLmlkZW50aXR5YCxcbiAgLy8gYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIGZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICAgIGlmIChpc0Z1bmN0aW9uJDEodmFsdWUpKSByZXR1cm4gb3B0aW1pemVDYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICAgIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpKSByZXR1cm4gbWF0Y2hlcih2YWx1ZSk7XG4gICAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbiAgfVxuXG4gIC8vIEV4dGVybmFsIHdyYXBwZXIgZm9yIG91ciBjYWxsYmFjayBnZW5lcmF0b3IuIFVzZXJzIG1heSBjdXN0b21pemVcbiAgLy8gYF8uaXRlcmF0ZWVgIGlmIHRoZXkgd2FudCBhZGRpdGlvbmFsIHByZWRpY2F0ZS9pdGVyYXRlZSBzaG9ydGhhbmQgc3R5bGVzLlxuICAvLyBUaGlzIGFic3RyYWN0aW9uIGhpZGVzIHRoZSBpbnRlcm5hbC1vbmx5IGBhcmdDb3VudGAgYXJndW1lbnQuXG4gIGZ1bmN0aW9uIGl0ZXJhdGVlKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGJhc2VJdGVyYXRlZSh2YWx1ZSwgY29udGV4dCwgSW5maW5pdHkpO1xuICB9XG4gIF8kMS5pdGVyYXRlZSA9IGl0ZXJhdGVlO1xuXG4gIC8vIFRoZSBmdW5jdGlvbiB3ZSBjYWxsIGludGVybmFsbHkgdG8gZ2VuZXJhdGUgYSBjYWxsYmFjay4gSXQgaW52b2tlc1xuICAvLyBgXy5pdGVyYXRlZWAgaWYgb3ZlcnJpZGRlbiwgb3RoZXJ3aXNlIGBiYXNlSXRlcmF0ZWVgLlxuICBmdW5jdGlvbiBjYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoXyQxLml0ZXJhdGVlICE9PSBpdGVyYXRlZSkgcmV0dXJuIF8kMS5pdGVyYXRlZSh2YWx1ZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIGJhc2VJdGVyYXRlZSh2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgYGl0ZXJhdGVlYCB0byBlYWNoIGVsZW1lbnQgb2YgYG9iamAuXG4gIC8vIEluIGNvbnRyYXN0IHRvIGBfLm1hcGAgaXQgcmV0dXJucyBhbiBvYmplY3QuXG4gIGZ1bmN0aW9uIG1hcE9iamVjdChvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIF9rZXlzID0ga2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSBfa2V5cy5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IF9rZXlzW2luZGV4XTtcbiAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb24uIE9mdGVuIHVzZWZ1bCBvdXRzaWRlIG9mIFVuZGVyc2NvcmUuXG4gIGZ1bmN0aW9uIG5vb3AoKXt9XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgcmV0dXJucyBhIGdpdmVuIHByb3BlcnR5LlxuICBmdW5jdGlvbiBwcm9wZXJ0eU9mKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIG5vb3A7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiBnZXQob2JqLCBwYXRoKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIGZ1bmN0aW9uIHRpbWVzKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9XG5cbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAgKGluY2x1c2l2ZSkuXG4gIGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCkge1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gIH1cblxuICAvLyBBIChwb3NzaWJseSBmYXN0ZXIpIHdheSB0byBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGFzIGFuIGludGVnZXIuXG4gIHZhciBub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaGVscGVyIHRvIGdlbmVyYXRlIGZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5nc1xuICAvLyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgZnVuY3Rpb24gY3JlYXRlRXNjYXBlcihtYXApIHtcbiAgICB2YXIgZXNjYXBlciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWFwW21hdGNoXTtcbiAgICB9O1xuICAgIC8vIFJlZ2V4ZXMgZm9yIGlkZW50aWZ5aW5nIGEga2V5IHRoYXQgbmVlZHMgdG8gYmUgZXNjYXBlZC5cbiAgICB2YXIgc291cmNlID0gJyg/OicgKyBrZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH1cblxuICAvLyBJbnRlcm5hbCBsaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICB2YXIgZXNjYXBlTWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjeDI3OycsXG4gICAgJ2AnOiAnJiN4NjA7J1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIGZvciBlc2NhcGluZyBzdHJpbmdzIHRvIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgdmFyIF9lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XG5cbiAgLy8gSW50ZXJuYWwgbGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciB1bmVzY2FwaW5nLlxuICB2YXIgdW5lc2NhcGVNYXAgPSBpbnZlcnQoZXNjYXBlTWFwKTtcblxuICAvLyBGdW5jdGlvbiBmb3IgdW5lc2NhcGluZyBzdHJpbmdzIGZyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgX3VuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiBDaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgdmFyIHRlbXBsYXRlU2V0dGluZ3MgPSBfJDEudGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZTogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZTogLzwlPShbXFxzXFxTXSs/KSU+L2csXG4gICAgZXNjYXBlOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xuICB9O1xuXG4gIC8vIFdoZW4gY3VzdG9taXppbmcgYF8udGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgdmFyIGVzY2FwZVJlZ0V4cCA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICBmdW5jdGlvbiBlc2NhcGVDaGFyKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9XG5cbiAgLy8gSW4gb3JkZXIgdG8gcHJldmVudCB0aGlyZC1wYXJ0eSBjb2RlIGluamVjdGlvbiB0aHJvdWdoXG4gIC8vIGBfLnRlbXBsYXRlU2V0dGluZ3MudmFyaWFibGVgLCB3ZSB0ZXN0IGl0IGFnYWluc3QgdGhlIGZvbGxvd2luZyByZWd1bGFyXG4gIC8vIGV4cHJlc3Npb24uIEl0IGlzIGludGVudGlvbmFsbHkgYSBiaXQgbW9yZSBsaWJlcmFsIHRoYW4ganVzdCBtYXRjaGluZyB2YWxpZFxuICAvLyBpZGVudGlmaWVycywgYnV0IHN0aWxsIHByZXZlbnRzIHBvc3NpYmxlIGxvb3Bob2xlcyB0aHJvdWdoIGRlZmF1bHRzIG9yXG4gIC8vIGRlc3RydWN0dXJpbmcgYXNzaWdubWVudC5cbiAgdmFyIGJhcmVJZGVudGlmaWVyID0gL15cXHMqKFxcd3xcXCQpK1xccyokLztcblxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICAvLyBOQjogYG9sZFNldHRpbmdzYCBvbmx5IGV4aXN0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIGZ1bmN0aW9uIHRlbXBsYXRlKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBkZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8kMS50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZVJlZ0V4cCwgZXNjYXBlQ2hhcik7XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2Zmc2V0LlxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZTtcbiAgICBpZiAoYXJndW1lbnQpIHtcbiAgICAgIC8vIEluc3VyZSBhZ2FpbnN0IHRoaXJkLXBhcnR5IGNvZGUgaW5qZWN0aW9uLiAoQ1ZFLTIwMjEtMjMzNTgpXG4gICAgICBpZiAoIWJhcmVJZGVudGlmaWVyLnRlc3QoYXJndW1lbnQpKSB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICd2YXJpYWJsZSBpcyBub3QgYSBiYXJlIGlkZW50aWZpZXI6ICcgKyBhcmd1bWVudFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICAgIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG4gICAgICBhcmd1bWVudCA9ICdvYmonO1xuICAgIH1cblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyAncmV0dXJuIF9fcDtcXG4nO1xuXG4gICAgdmFyIHJlbmRlcjtcbiAgICB0cnkge1xuICAgICAgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKGFyZ3VtZW50LCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfJDEpO1xuICAgIH07XG5cbiAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXG4gICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyBhcmd1bWVudCArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cblxuICAvLyBUcmF2ZXJzZXMgdGhlIGNoaWxkcmVuIG9mIGBvYmpgIGFsb25nIGBwYXRoYC4gSWYgYSBjaGlsZCBpcyBhIGZ1bmN0aW9uLCBpdFxuICAvLyBpcyBpbnZva2VkIHdpdGggaXRzIHBhcmVudCBhcyBjb250ZXh0LiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmluYWxcbiAgLy8gY2hpbGQsIG9yIGBmYWxsYmFja2AgaWYgYW55IGNoaWxkIGlzIHVuZGVmaW5lZC5cbiAgZnVuY3Rpb24gcmVzdWx0KG9iaiwgcGF0aCwgZmFsbGJhY2spIHtcbiAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24kMShmYWxsYmFjaykgPyBmYWxsYmFjay5jYWxsKG9iaikgOiBmYWxsYmFjaztcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9ialtwYXRoW2ldXTtcbiAgICAgIGlmIChwcm9wID09PSB2b2lkIDApIHtcbiAgICAgICAgcHJvcCA9IGZhbGxiYWNrO1xuICAgICAgICBpID0gbGVuZ3RoOyAvLyBFbnN1cmUgd2UgZG9uJ3QgY29udGludWUgaXRlcmF0aW5nLlxuICAgICAgfVxuICAgICAgb2JqID0gaXNGdW5jdGlvbiQxKHByb3ApID8gcHJvcC5jYWxsKG9iaikgOiBwcm9wO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH1cblxuICAvLyBTdGFydCBjaGFpbmluZyBhIHdyYXBwZWQgVW5kZXJzY29yZSBvYmplY3QuXG4gIGZ1bmN0aW9uIGNoYWluKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8kMShvYmopO1xuICAgIGluc3RhbmNlLl9jaGFpbiA9IHRydWU7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdG8gZXhlY3V0ZSBgc291cmNlRnVuY2AgYm91bmQgdG8gYGNvbnRleHRgIHdpdGggb3B0aW9uYWxcbiAgLy8gYGFyZ3NgLiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3Igb3IgYXMgYVxuICAvLyBub3JtYWwgZnVuY3Rpb24uXG4gIGZ1bmN0aW9uIGV4ZWN1dGVCb3VuZChzb3VyY2VGdW5jLCBib3VuZEZ1bmMsIGNvbnRleHQsIGNhbGxpbmdDb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB2YXIgc2VsZiA9IGJhc2VDcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmIChpc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLy8gUGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb24gYnkgY3JlYXRpbmcgYSB2ZXJzaW9uIHRoYXQgaGFzIGhhZCBzb21lIG9mIGl0c1xuICAvLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC4gYF9gIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciBieSBkZWZhdWx0LCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlXG4gIC8vIHByZS1maWxsZWQuIFNldCBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCBmb3IgYSBjdXN0b20gcGxhY2Vob2xkZXIgYXJndW1lbnQuXG4gIHZhciBwYXJ0aWFsID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihmdW5jLCBib3VuZEFyZ3MpIHtcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSBwYXJ0aWFsLnBsYWNlaG9sZGVyO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gYm91bmRBcmdzLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXSA9PT0gcGxhY2Vob2xkZXIgPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9KTtcblxuICBwYXJ0aWFsLnBsYWNlaG9sZGVyID0gXyQxO1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS5cbiAgdmFyIGJpbmQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ3MpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24kMShmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGJvdW5kID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihjYWxsQXJncykge1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgY29udGV4dCwgdGhpcywgYXJncy5jb25jYXQoY2FsbEFyZ3MpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH0pO1xuXG4gIC8vIEludGVybmFsIGhlbHBlciBmb3IgY29sbGVjdGlvbiBtZXRob2RzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgY29sbGVjdGlvblxuICAvLyBzaG91bGQgYmUgaXRlcmF0ZWQgYXMgYW4gYXJyYXkgb3IgYXMgYW4gb2JqZWN0LlxuICAvLyBSZWxhdGVkOiBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGhcbiAgLy8gQXZvaWRzIGEgdmVyeSBuYXN0eSBpT1MgOCBKSVQgYnVnIG9uIEFSTS02NC4gIzIwOTRcbiAgdmFyIGlzQXJyYXlMaWtlID0gY3JlYXRlU2l6ZVByb3BlcnR5Q2hlY2soZ2V0TGVuZ3RoKTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIGZ1bmN0aW9uIGZsYXR0ZW4kMShpbnB1dCwgZGVwdGgsIHN0cmljdCwgb3V0cHV0KSB7XG4gICAgb3V0cHV0ID0gb3V0cHV0IHx8IFtdO1xuICAgIGlmICghZGVwdGggJiYgZGVwdGggIT09IDApIHtcbiAgICAgIGRlcHRoID0gSW5maW5pdHk7XG4gICAgfSBlbHNlIGlmIChkZXB0aCA8PSAwKSB7XG4gICAgICByZXR1cm4gb3V0cHV0LmNvbmNhdChpbnB1dCk7XG4gICAgfVxuICAgIHZhciBpZHggPSBvdXRwdXQubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoaW5wdXQpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHMkMSh2YWx1ZSkpKSB7XG4gICAgICAgIC8vIEZsYXR0ZW4gY3VycmVudCBsZXZlbCBvZiBhcnJheSBvciBhcmd1bWVudHMgb2JqZWN0LlxuICAgICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgICAgZmxhdHRlbiQxKHZhbHVlLCBkZXB0aCAtIDEsIHN0cmljdCwgb3V0cHV0KTtcbiAgICAgICAgICBpZHggPSBvdXRwdXQubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChqIDwgbGVuKSBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICB2YXIgYmluZEFsbCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gICAga2V5cyA9IGZsYXR0ZW4kMShrZXlzLCBmYWxzZSwgZmFsc2UpO1xuICAgIHZhciBpbmRleCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChpbmRleCA8IDEpIHRocm93IG5ldyBFcnJvcignYmluZEFsbCBtdXN0IGJlIHBhc3NlZCBmdW5jdGlvbiBuYW1lcycpO1xuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICBvYmpba2V5XSA9IGJpbmQob2JqW2tleV0sIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH0pO1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW9pemUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBjYWNoZSA9IG1lbW9pemUuY2FjaGU7XG4gICAgICB2YXIgYWRkcmVzcyA9ICcnICsgKGhhc2hlciA/IGhhc2hlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5KTtcbiAgICAgIGlmICghaGFzJDEoY2FjaGUsIGFkZHJlc3MpKSBjYWNoZVthZGRyZXNzXSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBjYWNoZVthZGRyZXNzXTtcbiAgICB9O1xuICAgIG1lbW9pemUuY2FjaGUgPSB7fTtcbiAgICByZXR1cm4gbWVtb2l6ZTtcbiAgfVxuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICB2YXIgZGVsYXkgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0sIHdhaXQpO1xuICB9KTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgdmFyIGRlZmVyID0gcGFydGlhbChkZWxheSwgXyQxLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGltZW91dCwgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBub3coKTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgdGhyb3R0bGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX25vdyA9IG5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IF9ub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChfbm93IC0gcHJldmlvdXMpO1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBfbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB0aHJvdHRsZWQuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICBwcmV2aW91cyA9IDA7XG4gICAgICB0aW1lb3V0ID0gY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhyb3R0bGVkO1xuICB9XG5cbiAgLy8gV2hlbiBhIHNlcXVlbmNlIG9mIGNhbGxzIG9mIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBlbmRzLCB0aGUgYXJndW1lbnRcbiAgLy8gZnVuY3Rpb24gaXMgdHJpZ2dlcmVkLiBUaGUgZW5kIG9mIGEgc2VxdWVuY2UgaXMgZGVmaW5lZCBieSB0aGUgYHdhaXRgXG4gIC8vIHBhcmFtZXRlci4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0aGUgYXJndW1lbnQgZnVuY3Rpb24gd2lsbCBiZVxuICAvLyB0cmlnZ2VyZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2VxdWVuY2UgaW5zdGVhZCBvZiBhdCB0aGUgZW5kLlxuICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dCwgcHJldmlvdXMsIGFyZ3MsIHJlc3VsdCwgY29udGV4dDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhc3NlZCA9IG5vdygpIC0gcHJldmlvdXM7XG4gICAgICBpZiAod2FpdCA+IHBhc3NlZCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIHBhc3NlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIGJlY2F1c2UgYGZ1bmNgIGNhbiByZWN1cnNpdmVseSBpbnZva2UgYGRlYm91bmNlZGAuXG4gICAgICAgIGlmICghdGltZW91dCkgYXJncyA9IGNvbnRleHQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZGVib3VuY2VkID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihfYXJncykge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gX2FyZ3M7XG4gICAgICBwcmV2aW91cyA9IG5vdygpO1xuICAgICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgICAgaWYgKGltbWVkaWF0ZSkgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICBkZWJvdW5jZWQuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gYXJncyA9IGNvbnRleHQgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVib3VuY2VkO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgZnVuY3Rpb24gd3JhcChmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIHBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQtaW4gcHJlZGljYXRlLlxuICBmdW5jdGlvbiBuZWdhdGUocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgc3RhcnQgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSBzdGFydDtcbiAgICAgIHZhciByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgb24gYW5kIGFmdGVyIHRoZSBOdGggY2FsbC5cbiAgZnVuY3Rpb24gYWZ0ZXIodGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHVwIHRvIChidXQgbm90IGluY2x1ZGluZykgdGhlXG4gIC8vIE50aCBjYWxsLlxuICBmdW5jdGlvbiBiZWZvcmUodGltZXMsIGZ1bmMpIHtcbiAgICB2YXIgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA+IDApIHtcbiAgICAgICAgbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lcyA8PSAxKSBmdW5jID0gbnVsbDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgdmFyIG9uY2UgPSBwYXJ0aWFsKGJlZm9yZSwgMik7XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3Qga2V5IG9uIGFuIG9iamVjdCB0aGF0IHBhc3NlcyBhIHRydXRoIHRlc3QuXG4gIGZ1bmN0aW9uIGZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBfa2V5cyA9IGtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBfa2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gX2tleXNbaV07XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtrZXldLCBrZXksIG9iaikpIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKGRpcikge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICB2YXIgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSB0cnV0aCB0ZXN0LlxuICB2YXIgZmluZEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoMSk7XG5cbiAgLy8gUmV0dXJucyB0aGUgbGFzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgdHJ1dGggdGVzdC5cbiAgdmFyIGZpbmRMYXN0SW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigtMSk7XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCBvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgdmFyIHZhbHVlID0gaXRlcmF0ZWUob2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W21pZF0pIDwgdmFsdWUpIGxvdyA9IG1pZCArIDE7IGVsc2UgaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfVxuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHRoZSBgXy5pbmRleE9mYCBhbmQgYF8ubGFzdEluZGV4T2ZgIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gY3JlYXRlSW5kZXhGaW5kZXIoZGlyLCBwcmVkaWNhdGVGaW5kLCBzb3J0ZWRJbmRleCkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgaXRlbSwgaWR4KSB7XG4gICAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICBpZiAodHlwZW9mIGlkeCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgIGkgPSBpZHggPj0gMCA/IGlkeCA6IE1hdGgubWF4KGlkeCArIGxlbmd0aCwgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgaXNOYU4kMSk7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIHZhciBpbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoMSwgZmluZEluZGV4LCBzb3J0ZWRJbmRleCk7XG5cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksXG4gIC8vIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIHZhciBsYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBmaW5kTGFzdEluZGV4KTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuXG4gIGZ1bmN0aW9uIGZpbmQob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIga2V5RmluZGVyID0gaXNBcnJheUxpa2Uob2JqKSA/IGZpbmRJbmRleCA6IGZpbmRLZXk7XG4gICAgdmFyIGtleSA9IGtleUZpbmRlcihvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgaWYgKGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gLTEpIHJldHVybiBvYmpba2V5XTtcbiAgfVxuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYF8uZmluZGA6IGdldHRpbmcgdGhlIGZpcnN0XG4gIC8vIG9iamVjdCBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBmdW5jdGlvbiBmaW5kV2hlcmUob2JqLCBhdHRycykge1xuICAgIHJldHVybiBmaW5kKG9iaiwgbWF0Y2hlcihhdHRycykpO1xuICB9XG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lIGZvciBjb2xsZWN0aW9uIGZ1bmN0aW9ucywgYW4gYGVhY2hgXG4gIC8vIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIGZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGksIGxlbmd0aDtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9rZXlzID0ga2V5cyhvYmopO1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gX2tleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW19rZXlzW2ldXSwgX2tleXNbaV0sIG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgZnVuY3Rpb24gbWFwKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgX2tleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBrZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChfa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBfa2V5cyA/IF9rZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgcmVzdWx0c1tpbmRleF0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgaGVscGVyIHRvIGNyZWF0ZSBhIHJlZHVjaW5nIGZ1bmN0aW9uLCBpdGVyYXRpbmcgbGVmdCBvciByaWdodC5cbiAgZnVuY3Rpb24gY3JlYXRlUmVkdWNlKGRpcikge1xuICAgIC8vIFdyYXAgY29kZSB0aGF0IHJlYXNzaWducyBhcmd1bWVudCB2YXJpYWJsZXMgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbiB0aGFuXG4gICAgLy8gdGhlIG9uZSB0aGF0IGFjY2Vzc2VzIGBhcmd1bWVudHMubGVuZ3RoYCB0byBhdm9pZCBhIHBlcmYgaGl0LiAoIzE5OTEpXG4gICAgdmFyIHJlZHVjZXIgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBpbml0aWFsKSB7XG4gICAgICB2YXIgX2tleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBrZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKF9rZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgIG1lbW8gPSBvYmpbX2tleXMgPyBfa2V5c1tpbmRleF0gOiBpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGRpcjtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBfa2V5cyA/IF9rZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgICBtZW1vID0gaXRlcmF0ZWUobWVtbywgb2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMztcbiAgICAgIHJldHVybiByZWR1Y2VyKG9iaiwgb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgNCksIG1lbW8sIGluaXRpYWwpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIHZhciByZWR1Y2UgPSBjcmVhdGVSZWR1Y2UoMSk7XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIHZhciByZWR1Y2VSaWdodCA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgZnVuY3Rpb24gZmlsdGVyKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIGZ1bmN0aW9uIHJlamVjdChvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBmaWx0ZXIob2JqLCBuZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgZnVuY3Rpb24gZXZlcnkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBfa2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIGtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKF9rZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0gX2tleXMgPyBfa2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IHBhc3NlcyBhIHRydXRoIHRlc3QuXG4gIGZ1bmN0aW9uIHNvbWUob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBfa2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIGtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKF9rZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0gX2tleXMgPyBfa2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiBpdGVtICh1c2luZyBgPT09YCkuXG4gIGZ1bmN0aW9uIGNvbnRhaW5zKG9iaiwgaXRlbSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gdmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIGluZGV4T2Yob2JqLCBpdGVtLCBmcm9tSW5kZXgpID49IDA7XG4gIH1cblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgdmFyIGludm9rZSA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24ob2JqLCBwYXRoLCBhcmdzKSB7XG4gICAgdmFyIGNvbnRleHRQYXRoLCBmdW5jO1xuICAgIGlmIChpc0Z1bmN0aW9uJDEocGF0aCkpIHtcbiAgICAgIGZ1bmMgPSBwYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgICAgY29udGV4dFBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICAgIHBhdGggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBtYXAob2JqLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgbWV0aG9kID0gZnVuYztcbiAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgIGlmIChjb250ZXh0UGF0aCAmJiBjb250ZXh0UGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICBjb250ZXh0ID0gZGVlcEdldChjb250ZXh0LCBjb250ZXh0UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgbWV0aG9kID0gY29udGV4dFtwYXRoXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXRob2QgPT0gbnVsbCA/IG1ldGhvZCA6IG1ldGhvZC5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgXy5tYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBmdW5jdGlvbiBwbHVjayhvYmosIGtleSkge1xuICAgIHJldHVybiBtYXAob2JqLCBwcm9wZXJ0eShrZXkpKTtcbiAgfVxuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYF8uZmlsdGVyYDogc2VsZWN0aW5nIG9ubHlcbiAgLy8gb2JqZWN0cyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBmdW5jdGlvbiB3aGVyZShvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIGZpbHRlcihvYmosIG1hdGNoZXIoYXR0cnMpKTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgZnVuY3Rpb24gbWF4KG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gLUluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCB8fCB0eXBlb2YgaXRlcmF0ZWUgPT0gJ251bWJlcicgJiYgdHlwZW9mIG9ialswXSAhPSAnb2JqZWN0JyAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IHZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgPiByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIGVhY2gob2JqLCBmdW5jdGlvbih2LCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHYsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2O1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgZnVuY3Rpb24gbWluKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgfHwgdHlwZW9mIGl0ZXJhdGVlID09ICdudW1iZXInICYmIHR5cGVvZiBvYmpbMF0gIT0gJ29iamVjdCcgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiB2YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBlYWNoKG9iaiwgZnVuY3Rpb24odiwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2LCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHY7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24gdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIGZ1bmN0aW9uIHNhbXBsZShvYmosIG4sIGd1YXJkKSB7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuICAgICAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSB2YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbcmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHZhciBzYW1wbGUgPSBpc0FycmF5TGlrZShvYmopID8gY2xvbmUob2JqKSA6IHZhbHVlcyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoc2FtcGxlKTtcbiAgICBuID0gTWF0aC5tYXgoTWF0aC5taW4obiwgbGVuZ3RoKSwgMCk7XG4gICAgdmFyIGxhc3QgPSBsZW5ndGggLSAxO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBuOyBpbmRleCsrKSB7XG4gICAgICB2YXIgcmFuZCA9IHJhbmRvbShpbmRleCwgbGFzdCk7XG4gICAgICB2YXIgdGVtcCA9IHNhbXBsZVtpbmRleF07XG4gICAgICBzYW1wbGVbaW5kZXhdID0gc2FtcGxlW3JhbmRdO1xuICAgICAgc2FtcGxlW3JhbmRdID0gdGVtcDtcbiAgICB9XG4gICAgcmV0dXJuIHNhbXBsZS5zbGljZSgwLCBuKTtcbiAgfVxuXG4gIC8vIFNodWZmbGUgYSBjb2xsZWN0aW9uLlxuICBmdW5jdGlvbiBzaHVmZmxlKG9iaikge1xuICAgIHJldHVybiBzYW1wbGUob2JqLCBJbmZpbml0eSk7XG4gIH1cblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0ZWUuXG4gIGZ1bmN0aW9uIHNvcnRCeShvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gcGx1Y2sobWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgrKyxcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH1cblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIGZ1bmN0aW9uIGdyb3VwKGJlaGF2aW9yLCBwYXJ0aXRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHBhcnRpdGlvbiA/IFtbXSwgW11dIDoge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGtleSA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgICAgYmVoYXZpb3IocmVzdWx0LCB2YWx1ZSwga2V5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgdmFyIGdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoaGFzJDEocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTsgZWxzZSByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gIH0pO1xuXG4gIC8vIEluZGV4ZXMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiwgc2ltaWxhciB0byBgXy5ncm91cEJ5YCwgYnV0IGZvclxuICAvLyB3aGVuIHlvdSBrbm93IHRoYXQgeW91ciBpbmRleCB2YWx1ZXMgd2lsbCBiZSB1bmlxdWUuXG4gIHZhciBpbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIHZhciBjb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKGhhcyQxKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0rKzsgZWxzZSByZXN1bHRba2V5XSA9IDE7XG4gIH0pO1xuXG4gIC8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgcGFzcyB0aGUgZ2l2ZW5cbiAgLy8gdHJ1dGggdGVzdCwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHBhc3MgdGhlIHRydXRoIHRlc3QuXG4gIHZhciBwYXJ0aXRpb24gPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBwYXNzKSB7XG4gICAgcmVzdWx0W3Bhc3MgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XG4gIH0sIHRydWUpO1xuXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIHZhciByZVN0clN5bWJvbCA9IC9bXlxcdWQ4MDAtXFx1ZGZmZl18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXXxbXFx1ZDgwMC1cXHVkZmZmXS9nO1xuICBmdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKGlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNTdHJpbmcob2JqKSkge1xuICAgICAgLy8gS2VlcCBzdXJyb2dhdGUgcGFpciBjaGFyYWN0ZXJzIHRvZ2V0aGVyLlxuICAgICAgcmV0dXJuIG9iai5tYXRjaChyZVN0clN5bWJvbCk7XG4gICAgfVxuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSByZXR1cm4gbWFwKG9iaiwgaWRlbnRpdHkpO1xuICAgIHJldHVybiB2YWx1ZXMob2JqKTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGEgY29sbGVjdGlvbi5cbiAgZnVuY3Rpb24gc2l6ZShvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IGtleXMob2JqKS5sZW5ndGg7XG4gIH1cblxuICAvLyBJbnRlcm5hbCBgXy5waWNrYCBoZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYGtleWAgaXMgYW4gZW51bWVyYWJsZVxuICAvLyBwcm9wZXJ0eSBuYW1lIG9mIGBvYmpgLlxuICBmdW5jdGlvbiBrZXlJbk9iaih2YWx1ZSwga2V5LCBvYmopIHtcbiAgICByZXR1cm4ga2V5IGluIG9iajtcbiAgfVxuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIGFsbG93ZWQgcHJvcGVydGllcy5cbiAgdmFyIHBpY2sgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKG9iaiwga2V5cykge1xuICAgIHZhciByZXN1bHQgPSB7fSwgaXRlcmF0ZWUgPSBrZXlzWzBdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoaXNGdW5jdGlvbiQxKGl0ZXJhdGVlKSkge1xuICAgICAgaWYgKGtleXMubGVuZ3RoID4gMSkgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBrZXlzWzFdKTtcbiAgICAgIGtleXMgPSBhbGxLZXlzKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0ga2V5SW5PYmo7XG4gICAgICBrZXlzID0gZmxhdHRlbiQxKGtleXMsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGRpc2FsbG93ZWQgcHJvcGVydGllcy5cbiAgdmFyIG9taXQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKG9iaiwga2V5cykge1xuICAgIHZhciBpdGVyYXRlZSA9IGtleXNbMF0sIGNvbnRleHQ7XG4gICAgaWYgKGlzRnVuY3Rpb24kMShpdGVyYXRlZSkpIHtcbiAgICAgIGl0ZXJhdGVlID0gbmVnYXRlKGl0ZXJhdGVlKTtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDEpIGNvbnRleHQgPSBrZXlzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gbWFwKGZsYXR0ZW4kMShrZXlzLCBmYWxzZSwgZmFsc2UpLCBTdHJpbmcpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAhY29udGFpbnMoa2V5cywga2V5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwaWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9KTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gKG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKSkpO1xuICB9XG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIFRoZSAqKmd1YXJkKiogY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBmdW5jdGlvbiBmaXJzdChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCB8fCBhcnJheS5sZW5ndGggPCAxKSByZXR1cm4gbiA9PSBudWxsIHx8IGd1YXJkID8gdm9pZCAwIDogW107XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5WzBdO1xuICAgIHJldHVybiBpbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBgYXJyYXlgLiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZVxuICAvLyBgYXJyYXlgLlxuICBmdW5jdGlvbiByZXN0KGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH1cblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIGZ1bmN0aW9uIGxhc3QoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwgfHwgYXJyYXkubGVuZ3RoIDwgMSkgcmV0dXJuIG4gPT0gbnVsbCB8fCBndWFyZCA/IHZvaWQgMCA6IFtdO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gcmVzdChhcnJheSwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gbikpO1xuICB9XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgcmV0dXJuIGZpbHRlcihhcnJheSwgQm9vbGVhbik7XG4gIH1cblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IgdXAgdG8gYGRlcHRoYC5cbiAgLy8gUGFzc2luZyBgdHJ1ZWAgb3IgYGZhbHNlYCBhcyBgZGVwdGhgIG1lYW5zIGAxYCBvciBgSW5maW5pdHlgLCByZXNwZWN0aXZlbHkuXG4gIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXksIGRlcHRoKSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4kMShhcnJheSwgZGVwdGgsIGZhbHNlKTtcbiAgfVxuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgdmFyIGRpZmZlcmVuY2UgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGFycmF5LCByZXN0KSB7XG4gICAgcmVzdCA9IGZsYXR0ZW4kMShyZXN0LCB0cnVlLCB0cnVlKTtcbiAgICByZXR1cm4gZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIWNvbnRhaW5zKHJlc3QsIHZhbHVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgdmFsdWUocykuXG4gIHZhciB3aXRob3V0ID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihhcnJheSwgb3RoZXJBcnJheXMpIHtcbiAgICByZXR1cm4gZGlmZmVyZW5jZShhcnJheSwgb3RoZXJBcnJheXMpO1xuICB9KTtcblxuICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeVxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIFRoZSBmYXN0ZXIgYWxnb3JpdGhtIHdpbGwgbm90IHdvcmsgd2l0aCBhbiBpdGVyYXRlZSBpZiB0aGUgaXRlcmF0ZWVcbiAgLy8gaXMgbm90IGEgb25lLXRvLW9uZSBmdW5jdGlvbiwgc28gcHJvdmlkaW5nIGFuIGl0ZXJhdGVlIHdpbGwgZGlzYWJsZVxuICAvLyB0aGUgZmFzdGVyIGFsZ29yaXRobS5cbiAgZnVuY3Rpb24gdW5pcShhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpc0Jvb2xlYW4oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XG4gICAgICBpdGVyYXRlZSA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhdGVlICE9IG51bGwpIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldLFxuICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaSwgYXJyYXkpIDogdmFsdWU7XG4gICAgICBpZiAoaXNTb3J0ZWQgJiYgIWl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSBjb21wdXRlZCkgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWNvbnRhaW5zKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgdmFyIHVuaW9uID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihhcnJheXMpIHtcbiAgICByZXR1cm4gdW5pcShmbGF0dGVuJDEoYXJyYXlzLCB0cnVlLCB0cnVlKSk7XG4gIH0pO1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgZnVuY3Rpb24gaW50ZXJzZWN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGFycmF5W2ldO1xuICAgICAgaWYgKGNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xuICAgICAgdmFyIGo7XG4gICAgICBmb3IgKGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBDb21wbGVtZW50IG9mIHppcC4gVW56aXAgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgYW5kIGdyb3Vwc1xuICAvLyBlYWNoIGFycmF5J3MgZWxlbWVudHMgb24gc2hhcmVkIGluZGljZXMuXG4gIGZ1bmN0aW9uIHVuemlwKGFycmF5KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ICYmIG1heChhcnJheSwgZ2V0TGVuZ3RoKS5sZW5ndGggfHwgMDtcbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBwbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgdmFyIHppcCA9IHJlc3RBcmd1bWVudHModW56aXApO1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy4gUGFzc2luZyBieSBwYWlycyBpcyB0aGUgcmV2ZXJzZSBvZiBgXy5wYWlyc2AuXG4gIGZ1bmN0aW9uIG9iamVjdChsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBmdW5jdGlvbiByYW5nZShzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChzdG9wID09IG51bGwpIHtcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBpZiAoIXN0ZXApIHtcbiAgICAgIHN0ZXAgPSBzdG9wIDwgc3RhcnQgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKywgc3RhcnQgKz0gc3RlcCkge1xuICAgICAgcmFuZ2VbaWR4XSA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfVxuXG4gIC8vIENodW5rIGEgc2luZ2xlIGFycmF5IGludG8gbXVsdGlwbGUgYXJyYXlzLCBlYWNoIGNvbnRhaW5pbmcgYGNvdW50YCBvciBmZXdlclxuICAvLyBpdGVtcy5cbiAgZnVuY3Rpb24gY2h1bmsoYXJyYXksIGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IG51bGwgfHwgY291bnQgPCAxKSByZXR1cm4gW107XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChzbGljZS5jYWxsKGFycmF5LCBpLCBpICs9IGNvdW50KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIGZ1bmN0aW9uIGNoYWluUmVzdWx0KGluc3RhbmNlLCBvYmopIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX2NoYWluID8gXyQxKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfVxuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gICAgZWFjaChmdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfJDFbbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICBfJDEucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW3RoaXMuX3dyYXBwZWRdO1xuICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBjaGFpblJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8kMSwgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gXyQxO1xuICB9XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIGBBcnJheWAgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBlYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfJDEucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIGlmIChvYmogIT0gbnVsbCkge1xuICAgICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoKG5hbWUgPT09ICdzaGlmdCcgfHwgbmFtZSA9PT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgb2JqWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hhaW5SZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIGBBcnJheWAgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBlYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8kMS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgaWYgKG9iaiAhPSBudWxsKSBvYmogPSBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNoYWluUmVzdWx0KHRoaXMsIG9iaik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gTmFtZWQgRXhwb3J0c1xuXG4gIHZhciBhbGxFeHBvcnRzID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBWRVJTSU9OOiBWRVJTSU9OLFxuICAgIHJlc3RBcmd1bWVudHM6IHJlc3RBcmd1bWVudHMsXG4gICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgIGlzTnVsbDogaXNOdWxsLFxuICAgIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgICBpc0Jvb2xlYW46IGlzQm9vbGVhbixcbiAgICBpc0VsZW1lbnQ6IGlzRWxlbWVudCxcbiAgICBpc1N0cmluZzogaXNTdHJpbmcsXG4gICAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICAgIGlzRGF0ZTogaXNEYXRlLFxuICAgIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgICBpc0Vycm9yOiBpc0Vycm9yLFxuICAgIGlzU3ltYm9sOiBpc1N5bWJvbCxcbiAgICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICAgIGlzRGF0YVZpZXc6IGlzRGF0YVZpZXckMSxcbiAgICBpc0FycmF5OiBpc0FycmF5LFxuICAgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24kMSxcbiAgICBpc0FyZ3VtZW50czogaXNBcmd1bWVudHMkMSxcbiAgICBpc0Zpbml0ZTogaXNGaW5pdGUkMSxcbiAgICBpc05hTjogaXNOYU4kMSxcbiAgICBpc1R5cGVkQXJyYXk6IGlzVHlwZWRBcnJheSQxLFxuICAgIGlzRW1wdHk6IGlzRW1wdHksXG4gICAgaXNNYXRjaDogaXNNYXRjaCxcbiAgICBpc0VxdWFsOiBpc0VxdWFsLFxuICAgIGlzTWFwOiBpc01hcCxcbiAgICBpc1dlYWtNYXA6IGlzV2Vha01hcCxcbiAgICBpc1NldDogaXNTZXQsXG4gICAgaXNXZWFrU2V0OiBpc1dlYWtTZXQsXG4gICAga2V5czoga2V5cyxcbiAgICBhbGxLZXlzOiBhbGxLZXlzLFxuICAgIHZhbHVlczogdmFsdWVzLFxuICAgIHBhaXJzOiBwYWlycyxcbiAgICBpbnZlcnQ6IGludmVydCxcbiAgICBmdW5jdGlvbnM6IGZ1bmN0aW9ucyxcbiAgICBtZXRob2RzOiBmdW5jdGlvbnMsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgZXh0ZW5kT3duOiBleHRlbmRPd24sXG4gICAgYXNzaWduOiBleHRlbmRPd24sXG4gICAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgIGNsb25lOiBjbG9uZSxcbiAgICB0YXA6IHRhcCxcbiAgICBnZXQ6IGdldCxcbiAgICBoYXM6IGhhcyxcbiAgICBtYXBPYmplY3Q6IG1hcE9iamVjdCxcbiAgICBpZGVudGl0eTogaWRlbnRpdHksXG4gICAgY29uc3RhbnQ6IGNvbnN0YW50LFxuICAgIG5vb3A6IG5vb3AsXG4gICAgdG9QYXRoOiB0b1BhdGgkMSxcbiAgICBwcm9wZXJ0eTogcHJvcGVydHksXG4gICAgcHJvcGVydHlPZjogcHJvcGVydHlPZixcbiAgICBtYXRjaGVyOiBtYXRjaGVyLFxuICAgIG1hdGNoZXM6IG1hdGNoZXIsXG4gICAgdGltZXM6IHRpbWVzLFxuICAgIHJhbmRvbTogcmFuZG9tLFxuICAgIG5vdzogbm93LFxuICAgIGVzY2FwZTogX2VzY2FwZSxcbiAgICB1bmVzY2FwZTogX3VuZXNjYXBlLFxuICAgIHRlbXBsYXRlU2V0dGluZ3M6IHRlbXBsYXRlU2V0dGluZ3MsXG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgIHJlc3VsdDogcmVzdWx0LFxuICAgIHVuaXF1ZUlkOiB1bmlxdWVJZCxcbiAgICBjaGFpbjogY2hhaW4sXG4gICAgaXRlcmF0ZWU6IGl0ZXJhdGVlLFxuICAgIHBhcnRpYWw6IHBhcnRpYWwsXG4gICAgYmluZDogYmluZCxcbiAgICBiaW5kQWxsOiBiaW5kQWxsLFxuICAgIG1lbW9pemU6IG1lbW9pemUsXG4gICAgZGVsYXk6IGRlbGF5LFxuICAgIGRlZmVyOiBkZWZlcixcbiAgICB0aHJvdHRsZTogdGhyb3R0bGUsXG4gICAgZGVib3VuY2U6IGRlYm91bmNlLFxuICAgIHdyYXA6IHdyYXAsXG4gICAgbmVnYXRlOiBuZWdhdGUsXG4gICAgY29tcG9zZTogY29tcG9zZSxcbiAgICBhZnRlcjogYWZ0ZXIsXG4gICAgYmVmb3JlOiBiZWZvcmUsXG4gICAgb25jZTogb25jZSxcbiAgICBmaW5kS2V5OiBmaW5kS2V5LFxuICAgIGZpbmRJbmRleDogZmluZEluZGV4LFxuICAgIGZpbmRMYXN0SW5kZXg6IGZpbmRMYXN0SW5kZXgsXG4gICAgc29ydGVkSW5kZXg6IHNvcnRlZEluZGV4LFxuICAgIGluZGV4T2Y6IGluZGV4T2YsXG4gICAgbGFzdEluZGV4T2Y6IGxhc3RJbmRleE9mLFxuICAgIGZpbmQ6IGZpbmQsXG4gICAgZGV0ZWN0OiBmaW5kLFxuICAgIGZpbmRXaGVyZTogZmluZFdoZXJlLFxuICAgIGVhY2g6IGVhY2gsXG4gICAgZm9yRWFjaDogZWFjaCxcbiAgICBtYXA6IG1hcCxcbiAgICBjb2xsZWN0OiBtYXAsXG4gICAgcmVkdWNlOiByZWR1Y2UsXG4gICAgZm9sZGw6IHJlZHVjZSxcbiAgICBpbmplY3Q6IHJlZHVjZSxcbiAgICByZWR1Y2VSaWdodDogcmVkdWNlUmlnaHQsXG4gICAgZm9sZHI6IHJlZHVjZVJpZ2h0LFxuICAgIGZpbHRlcjogZmlsdGVyLFxuICAgIHNlbGVjdDogZmlsdGVyLFxuICAgIHJlamVjdDogcmVqZWN0LFxuICAgIGV2ZXJ5OiBldmVyeSxcbiAgICBhbGw6IGV2ZXJ5LFxuICAgIHNvbWU6IHNvbWUsXG4gICAgYW55OiBzb21lLFxuICAgIGNvbnRhaW5zOiBjb250YWlucyxcbiAgICBpbmNsdWRlczogY29udGFpbnMsXG4gICAgaW5jbHVkZTogY29udGFpbnMsXG4gICAgaW52b2tlOiBpbnZva2UsXG4gICAgcGx1Y2s6IHBsdWNrLFxuICAgIHdoZXJlOiB3aGVyZSxcbiAgICBtYXg6IG1heCxcbiAgICBtaW46IG1pbixcbiAgICBzaHVmZmxlOiBzaHVmZmxlLFxuICAgIHNhbXBsZTogc2FtcGxlLFxuICAgIHNvcnRCeTogc29ydEJ5LFxuICAgIGdyb3VwQnk6IGdyb3VwQnksXG4gICAgaW5kZXhCeTogaW5kZXhCeSxcbiAgICBjb3VudEJ5OiBjb3VudEJ5LFxuICAgIHBhcnRpdGlvbjogcGFydGl0aW9uLFxuICAgIHRvQXJyYXk6IHRvQXJyYXksXG4gICAgc2l6ZTogc2l6ZSxcbiAgICBwaWNrOiBwaWNrLFxuICAgIG9taXQ6IG9taXQsXG4gICAgZmlyc3Q6IGZpcnN0LFxuICAgIGhlYWQ6IGZpcnN0LFxuICAgIHRha2U6IGZpcnN0LFxuICAgIGluaXRpYWw6IGluaXRpYWwsXG4gICAgbGFzdDogbGFzdCxcbiAgICByZXN0OiByZXN0LFxuICAgIHRhaWw6IHJlc3QsXG4gICAgZHJvcDogcmVzdCxcbiAgICBjb21wYWN0OiBjb21wYWN0LFxuICAgIGZsYXR0ZW46IGZsYXR0ZW4sXG4gICAgd2l0aG91dDogd2l0aG91dCxcbiAgICB1bmlxOiB1bmlxLFxuICAgIHVuaXF1ZTogdW5pcSxcbiAgICB1bmlvbjogdW5pb24sXG4gICAgaW50ZXJzZWN0aW9uOiBpbnRlcnNlY3Rpb24sXG4gICAgZGlmZmVyZW5jZTogZGlmZmVyZW5jZSxcbiAgICB1bnppcDogdW56aXAsXG4gICAgdHJhbnNwb3NlOiB1bnppcCxcbiAgICB6aXA6IHppcCxcbiAgICBvYmplY3Q6IG9iamVjdCxcbiAgICByYW5nZTogcmFuZ2UsXG4gICAgY2h1bms6IGNodW5rLFxuICAgIG1peGluOiBtaXhpbixcbiAgICAnZGVmYXVsdCc6IF8kMVxuICB9O1xuXG4gIC8vIERlZmF1bHQgRXhwb3J0XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICB2YXIgXyA9IG1peGluKGFsbEV4cG9ydHMpO1xuICAvLyBMZWdhY3kgTm9kZS5qcyBBUEkuXG4gIF8uXyA9IF87XG5cbiAgcmV0dXJuIF87XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmRlcnNjb3JlLXVtZC5qcy5tYXBcbiJdfQ=="}