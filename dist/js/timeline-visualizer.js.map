{"version":3,"sources":["node_modules/browser-pack/_prelude.js","dist/index.js","dist/lib/timelineVisualizer.js","node_modules/events/events.js","node_modules/lodash.isequal/index.js","node_modules/superfly-timeline/dist/api/api.js","node_modules/superfly-timeline/dist/api/enums.js","node_modules/superfly-timeline/dist/index.js","node_modules/superfly-timeline/dist/lib.js","node_modules/superfly-timeline/dist/resolver/cache.js","node_modules/superfly-timeline/dist/resolver/common.js","node_modules/superfly-timeline/dist/resolver/expression.js","node_modules/superfly-timeline/dist/resolver/resolver.js","node_modules/superfly-timeline/dist/resolver/state.js","node_modules/superfly-timeline/dist/resolver/validate.js","node_modules/superfly-timeline/node_modules/tslib/tslib.js","node_modules/tslib/tslib.js","node_modules/underscore/underscore-umd.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7hCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxzDA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3jBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACp4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC7TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC5RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"timeline-visualizer.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst tslib_1 = require(\"tslib\");\r\ntslib_1.__exportStar(require(\"./lib/timelineVisualizer\"), exports);\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TimelineVisualizer = void 0;\r\nconst isEqual = require(\"lodash.isequal\");\r\nconst superfly_timeline_1 = require(\"superfly-timeline\");\r\nconst events_1 = require(\"events\");\r\n/** Step size/ time step. */\r\nconst DEFAULT_STEP_SIZE = 1;\r\n/** Width of label column. */\r\nconst LABEL_WIDTH_OF_TIMELINE = 0.25;\r\n/** Default zoom */\r\nconst DEFAULT_ZOOM_VALUE = 100;\r\n/** Factor to zoom by */\r\nconst ZOOM_FACTOR = 1.001;\r\n/** Factor to pan by (pan = PAN_FACTOR * STEP_SIZE) */\r\nconst PAN_FACTOR = 10;\r\n/** Maximum layer height */\r\nconst MAX_LAYER_HEIGHT = 60;\r\n/** Amount to move playhead per second. */\r\nconst DEFAULT_PLAYHEAD_SPEED = 1;\r\n/** BEGIN STYLING VALUES */\r\n/** Timeline background color. */\r\nconst COLOR_BACKGROUND = '#333333';\r\n/** Layer label background color. */\r\nconst COLOR_LABEL_BACKGROUND = '#666666';\r\n/** Color of the ruler lines */\r\nconst RULER_LINE_COLOR = '#999999';\r\n/** Width of the ruler lines */\r\nconst RULER_LINE_WIDTH = 1;\r\n/** Playhead color. */\r\nconst COLOR_PLAYHEAD = 'rgba(255, 0, 0, 0.5)';\r\n/** Playhead thickness. */\r\nconst THICKNESS_PLAYHEAD = 5;\r\n/** Color of line separating timeline rows. */\r\nconst COLOR_LINE = 'black';\r\n/** Height of line separating rows. */\r\nconst THICKNESS_LINE = 1;\r\n/** Text properties. */\r\nconst TEXT_FONT_FAMILY = 'Calibri';\r\nconst TEXT_FONT_SIZE = 16;\r\nconst TEXT_COLOR = 'white';\r\n/** Timeline object properties. */\r\nconst COLOR_TIMELINE_OBJECT_FILL = 'rgb(22, 102, 247, 0.75)';\r\nconst COLOR_TIMELINE_OBJECT_BORDER = 'rgba(232, 240, 255, 0.85)';\r\nconst THICKNESS_TIMELINE_OBJECT_BORDER = 1;\r\n/** Timeline object height as a proportion of the row height. */\r\nconst TIMELINE_OBJECT_HEIGHT = 1;\r\n/** END STYLING VALUES */\r\n/** BEGIN CONSTANTS FOR STATE MANAGEMENT */\r\nconst MOUSEIN = 0;\r\nconst MOUSEOUT = 1;\r\nclass TimelineVisualizer extends events_1.EventEmitter {\r\n    /**\r\n     * @param {string} canvasId The ID of the canvas object to draw within.\r\n     */\r\n    constructor(canvasId, options = {}) {\r\n        super();\r\n        // Step size.\r\n        this.stepSize = DEFAULT_STEP_SIZE;\r\n        /** @private @readonly Proportion of the canvas to be used for the layer labels column. */\r\n        this._layerLabelWidthProportionOfCanvas = LABEL_WIDTH_OF_TIMELINE;\r\n        /** Layers on timeline. */\r\n        this._layerLabels = {};\r\n        /** State of the timeline. */\r\n        this._timelineState = {};\r\n        /** Map of objects for determining hovered object */\r\n        this._hoveredObjectMap = {};\r\n        /** Start time of the current view. Defines the objects within view on the timeline [time] */\r\n        this._viewStartTime = 0;\r\n        /** Range of the current view [time] */\r\n        // private _viewTimeRange: number = 1\r\n        // private _drawTimeEnd: number\r\n        /** Store whether the mouse is held down, for scrolling. */\r\n        this._mouseDown = false;\r\n        /** Current zoom amount. */\r\n        this._timelineZoom = DEFAULT_ZOOM_VALUE;\r\n        /** Whether or not the playhead should move. */\r\n        this._playHeadPlaying = false;\r\n        /** Speed of the playhead [units / second] */\r\n        this._playSpeed = DEFAULT_PLAYHEAD_SPEED;\r\n        /** The current time position of the playhead. */\r\n        this._playHeadTime = 0;\r\n        /** The last time updateDraw() did a draw. */\r\n        this._updateDrawLastTime = 0;\r\n        /** Whether the mouse last moved over an object or out. */\r\n        this._lastHoverAction = MOUSEOUT;\r\n        /** Name of object that was last hovered over. */\r\n        this._lastHoveredHash = '';\r\n        /** If the visualizer automatically should re-resolve the timeline when navigating the viewport */\r\n        this._timelineResolveAuto = false;\r\n        /** At what time the timeline was resolved [time] */\r\n        this._timelineResolveStart = 0;\r\n        this._timelineResolveEnd = 0;\r\n        this._timelineResolveZoom = 1;\r\n        this._timelineResolveCount = 100;\r\n        this._timelineResolveCountAdjust = 1;\r\n        /** How much extra (outside the current viewport) the timeline should be resolved to [ratio] */\r\n        this._timelineResolveExpand = 3;\r\n        this.latestUpdateTime = 0;\r\n        this.reresolveTimeout = null;\r\n        this._mergeIterator = 0;\r\n        // Initialise other values.\r\n        this._canvasId = canvasId;\r\n        this.initCanvas();\r\n        this._drawPlayhead = !!options.drawPlayhead;\r\n        // Calculate width of label column.\r\n        this._layerLabelWidth = this._canvasWidth * this._layerLabelWidthProportionOfCanvas;\r\n        // Calculate timeline width and start point.\r\n        this._viewDrawX = this._layerLabelWidth;\r\n        this._viewDrawWidth = this._canvasWidth - this._layerLabelWidth;\r\n        // Draw background.\r\n        this.drawBackground();\r\n        // Draw playhead.\r\n        this.drawPlayhead();\r\n        this.updateDraw();\r\n    }\r\n    /**\r\n     * Initialises the canvas and registers canvas events.\r\n     */\r\n    initCanvas() {\r\n        // Create new canvas object.\r\n        this._canvasContainer = document.getElementById(this._canvasId);\r\n        if (!this._canvasContainer)\r\n            throw new Error(`Canvas \"${this._canvasId}\" not found`);\r\n        // Get rendering context.\r\n        this._canvas = this._canvasContainer.getContext('2d');\r\n        // Register canvas interaction event handlers.\r\n        this._canvasContainer.addEventListener('mousedown', (event) => this.canvasMouseDown(event));\r\n        this._canvasContainer.addEventListener('mouseup', (event) => this.canvasMouseUp(event));\r\n        this._canvasContainer.addEventListener('mousemove', (event) => this.canvasMouseMove(event));\r\n        this._canvasContainer.addEventListener('wheel', (event) => this.canvasScrollWheel(event));\r\n        // Get width and height of canvas.\r\n        this._canvasWidth = this._canvasContainer.width;\r\n        this._canvasHeight = this._canvasContainer.height;\r\n    }\r\n    /**\r\n     * Updates the timeline, should be called when actions are added/removed from a timeline\r\n     * but the same timeline is being drawn.\r\n     * @param {TimelineObject[]} timeline Timeline to draw.\r\n     * @param {ResolveOptions} options Resolve options.\r\n     */\r\n    updateTimeline(timeline, options) {\r\n        // If options have not been specified set time to 0.\r\n        if (options === undefined) {\r\n            options = {\r\n                time: 0,\r\n                limitCount: 10\r\n            };\r\n        }\r\n        this.latestTimeline = timeline;\r\n        this.latestOptions = options;\r\n        if (!options.limitTime) {\r\n            this._timelineResolveAuto = true;\r\n        }\r\n        else {\r\n            this._timelineResolveAuto = false;\r\n        }\r\n        const options2 = Object.assign({}, options);\r\n        if (this._timelineResolveAuto) {\r\n            this.updateTimelineResolveWindow();\r\n        }\r\n        if (this._resolvedStates === undefined) { // If first time this runs\r\n            // Set timeline start and end times.\r\n            if (options2.time !== undefined) {\r\n                this._viewStartTime = options2.time;\r\n            }\r\n            // Move playhead to start time.\r\n            this._playHeadTime = this._viewStartTime;\r\n        }\r\n        this._updateTimeline(true);\r\n    }\r\n    _updateTimeline(fromNewTimeline = false) {\r\n        const options2 = Object.assign({}, this.latestOptions);\r\n        if (this._timelineResolveAuto) {\r\n            options2.time = this._timelineResolveStart;\r\n            options2.limitTime = this._timelineResolveEnd;\r\n            options2.limitCount = Math.ceil(this._timelineResolveCount * this._timelineResolveCountAdjust);\r\n        }\r\n        // If the playhead is being drawn, the resolve time should be at the playhead time.\r\n        if (this._drawPlayhead && this._playHeadTime > options2.time) {\r\n            options2.time = this._playHeadTime;\r\n        }\r\n        // Resolve the timeline.\r\n        const startResolve = Date.now();\r\n        const resolvedTimeline = superfly_timeline_1.Resolver.resolveTimeline(this.latestTimeline, options2);\r\n        let newResolvedStates = superfly_timeline_1.Resolver.resolveAllStates(resolvedTimeline);\r\n        if (this._resolvedStates === undefined) { // If first time this runs\r\n            this._resolvedStates = newResolvedStates;\r\n        }\r\n        else {\r\n            if (this._drawPlayhead) {\r\n                // Trim the current timeline:\r\n                if (newResolvedStates) {\r\n                    // Merge the timelines.\r\n                    this._resolvedStates = this.mergeTimelineObjects(this._resolvedStates, newResolvedStates, fromNewTimeline);\r\n                }\r\n            }\r\n            else {\r\n                // Otherwise we only see one timeline at a time.\r\n                // Overwrite the previous timeline:\r\n                this._resolvedStates = newResolvedStates;\r\n            }\r\n        }\r\n        // Update layers.\r\n        this.updateLayerLabels();\r\n        this.latestUpdateTime = Date.now() - startResolve;\r\n        // Redraw the timeline.\r\n        this.redrawTimeline();\r\n        this.latestUpdateTime = Date.now() - startResolve;\r\n    }\r\n    /**\r\n     * Sets the viewport to a position, zoom, and playback speed.\r\n     * Playback speed currently not implemented.\r\n     * @param viewPort Object to update viewport with.\r\n     */\r\n    setViewPort(viewPort) {\r\n        // Whether the viewport has changed.\r\n        let changed = false;\r\n        // If zoom has been specified.\r\n        if (viewPort.zoom !== undefined) {\r\n            // Zoom to specified zoom.\r\n            this._timelineZoom = viewPort.zoom;\r\n            changed = true;\r\n        }\r\n        // If timestamp has been specified.\r\n        if (viewPort.timestamp !== undefined) {\r\n            // Set start time to specified time.\r\n            if (viewPort.timestamp > 0) {\r\n                this._viewStartTime = viewPort.timestamp;\r\n                changed = true;\r\n            }\r\n        }\r\n        if (viewPort.playViewPort !== undefined) {\r\n            this._playViewPort = viewPort.playViewPort;\r\n        }\r\n        // If the playback speed has been set, set the new playback speed.\r\n        if (viewPort.playSpeed !== undefined) {\r\n            if (!this._drawPlayhead)\r\n                throw new Error('setViewPort: viewPort.playSpeed was set, but drawPlayhead was not set in constructor');\r\n            this._playSpeed = viewPort.playSpeed;\r\n        }\r\n        // Set playhead playing/ not playing.\r\n        if (viewPort.playPlayhead !== undefined) {\r\n            if (!this._drawPlayhead)\r\n                throw new Error('setViewPort: viewPort.playPlayhead was set, but drawPlayhead was not set in constructor');\r\n            this._playHeadPlaying = viewPort.playPlayhead;\r\n        }\r\n        if (viewPort.playheadTime !== undefined) {\r\n            if (!this._drawPlayhead)\r\n                throw new Error('setViewPort: viewPort.playheadTime was set, but drawPlayhead was not set in constructor');\r\n            this._playHeadTime = Math.max(0, viewPort.playheadTime);\r\n            if (this._playHeadTime > 0)\r\n                this._updateDrawLastTime = this._playHeadTime;\r\n            changed = true;\r\n        }\r\n        // Redraw timeline if anything has changed.\r\n        if (changed === true) {\r\n            this.redrawTimeline();\r\n        }\r\n    }\r\n    /**\r\n     * Accessor for polling the currently hovered over object.\r\n     */\r\n    getHoveredObject() {\r\n        return this._hoveredOver;\r\n    }\r\n    /**\r\n     * Calculates the height to give to each row to fit all layers on screen.\r\n     * @param {String[]} layers Map of layers to use.\r\n     * @returns Height of rows.\r\n     */\r\n    calculateRowHeight(layers) {\r\n        return Math.min(MAX_LAYER_HEIGHT, this._canvasHeight / Object.keys(layers).length);\r\n    }\r\n    updateLayerLabels() {\r\n        // Store layers to draw.\r\n        const o = this.getLayersToDraw();\r\n        if (!isEqual(this._layerLabels, o.layers)) {\r\n            this._layerLabels = o.layers;\r\n            // Calculate row height.\r\n            this._rowHeight = this.calculateRowHeight(this._layerLabels);\r\n            // Set timeline object height.\r\n            this._timelineObjectHeight = this._rowHeight * TIMELINE_OBJECT_HEIGHT;\r\n            this._numberOfLayers = Object.keys(this._layerLabels).length;\r\n            this._rowsTotalHeight = this._rowHeight * this._numberOfLayers;\r\n        }\r\n    }\r\n    getLayers() {\r\n        const layers = Object.entries(this._layerLabels);\r\n        layers.sort((a, b) => a[1] - b[1]);\r\n        return layers.map(l => l[0]);\r\n    }\r\n    /**\r\n     * Draws the layer labels to the canvas.\r\n     */\r\n    drawLayerLabels() {\r\n        let row = 0;\r\n        // Iterate through layers.\r\n        for (let layerName of this.getLayers()) {\r\n            this._canvas.fillStyle = COLOR_LABEL_BACKGROUND;\r\n            this._canvas.fillRect(0, row * this._rowHeight, this._layerLabelWidth, this._rowHeight);\r\n            this._canvas.fillStyle = TEXT_COLOR;\r\n            this._canvas.font = TEXT_FONT_SIZE.toString() + 'px ' + TEXT_FONT_FAMILY;\r\n            this._canvas.textBaseline = 'middle';\r\n            this._canvas.fillText(layerName, 0, (row * this._rowHeight) + (this._rowHeight / 2), this._layerLabelWidth);\r\n            if (this._layerLabels[layerName] !== 0) {\r\n                this._canvas.fillStyle = COLOR_LINE;\r\n                this._canvas.fillRect(this._layerLabelWidth, row * this._rowHeight, this._viewDrawWidth, THICKNESS_LINE);\r\n            }\r\n            row++;\r\n        }\r\n    }\r\n    /**\r\n     * Draws the timeline background.\r\n     */\r\n    drawBackground() {\r\n        this._canvas.fillStyle = COLOR_BACKGROUND;\r\n        this._canvas.fillRect(0, 0, this._canvasWidth, this._canvasHeight);\r\n        this.drawBackgroundRuler();\r\n    }\r\n    /**\r\n     * Draw a ruler on top of background\r\n     */\r\n    drawBackgroundRuler() {\r\n        const range = this.viewRange;\r\n        const endTime = this.viewEndTime;\r\n        const circaNumberOfLines = 5;\r\n        const rounder = Math.pow(10, Math.floor(Math.log10(range / circaNumberOfLines))); // What to round the ruler to\r\n        const rounderNext = rounder * 10;\r\n        const numberOfLines = Math.floor(range / rounder);\r\n        const rulerDiff = rounder;\r\n        const startTime = Math.floor(this._viewStartTime / rounder) * rounder;\r\n        const opacity = (Math.min(1, circaNumberOfLines / numberOfLines));\r\n        if (rulerDiff) {\r\n            this._canvas.strokeStyle = RULER_LINE_COLOR;\r\n            this._canvas.lineWidth = RULER_LINE_WIDTH;\r\n            for (let rulerTime = startTime; rulerTime < endTime; rulerTime += rulerDiff) {\r\n                this._canvas.beginPath();\r\n                let x = this.timeToXCoord(rulerTime);\r\n                let distanceToNext = (rulerTime / rounderNext) % 1;\r\n                if (distanceToNext > 0.5)\r\n                    distanceToNext -= 1;\r\n                distanceToNext = Math.abs(distanceToNext);\r\n                if (distanceToNext < 0.01) {\r\n                    // Is a significant line\r\n                    this._canvas.globalAlpha = 1;\r\n                }\r\n                else {\r\n                    this._canvas.globalAlpha = opacity;\r\n                }\r\n                if (x >= this._viewDrawX) {\r\n                    this._canvas.moveTo(x, 0);\r\n                    this._canvas.lineTo(x, this._canvasHeight);\r\n                }\r\n                this._canvas.stroke();\r\n            }\r\n            this._canvas.globalAlpha = 1;\r\n        }\r\n    }\r\n    /**\r\n     * Draws the playhead initially.\r\n     */\r\n    drawPlayhead() {\r\n        // If the playhead should be draw.\r\n        if (this._drawPlayhead) {\r\n            if (this.istimeInView(this._playHeadTime)) {\r\n                this._canvas.fillStyle = COLOR_PLAYHEAD;\r\n                this._canvas.fillRect(this.timeToXCoord(this._playHeadTime), 0, THICKNESS_PLAYHEAD, this._canvasHeight);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Gets the layers to draw from the timeline.\r\n     */\r\n    getLayersToDraw() {\r\n        this._hoveredObjectMap = {};\r\n        const layersArray = this._resolvedStates ? Object.keys(this._resolvedStates.layers) : [];\r\n        layersArray.sort((a, b) => a.localeCompare(b));\r\n        const layers = {};\r\n        layersArray.forEach((layerName, index) => {\r\n            layers[layerName] = index;\r\n            this._hoveredObjectMap[layerName] = [];\r\n        });\r\n        return {\r\n            layers: layers,\r\n            layersArray: layersArray\r\n        };\r\n    }\r\n    /**\r\n     * Redraws the timeline to the canvas.\r\n     */\r\n    redrawTimeline() {\r\n        this._canvas.clearRect(0, 0, this._canvasWidth, this._canvasHeight);\r\n        this.drawBackground();\r\n        this.drawLayerLabels();\r\n        // Recompute objects positions\r\n        this._timelineState = this.getTimelineDrawState(this._resolvedStates);\r\n        // Draw the current state.\r\n        this.drawTimelineState(this._timelineState);\r\n        this.drawPlayhead();\r\n        this.checkAutomaticReresolve();\r\n    }\r\n    /**\r\n     * Draws a timeline state to the canvas.\r\n     * @param {TimelineDrawState} currentDrawState State to draw.\r\n     */\r\n    drawTimelineState(currentDrawState) {\r\n        for (let element in currentDrawState) {\r\n            const drawState = currentDrawState[element];\r\n            if (drawState.visible) {\r\n                this._canvas.fillStyle = COLOR_TIMELINE_OBJECT_FILL;\r\n                this._canvas.fillRect(drawState.left, drawState.top, drawState.width, drawState.height);\r\n                this._canvas.strokeStyle = COLOR_TIMELINE_OBJECT_BORDER;\r\n                this._canvas.lineWidth = THICKNESS_TIMELINE_OBJECT_BORDER;\r\n                this._canvas.strokeRect(drawState.left, drawState.top, drawState.width, drawState.height);\r\n                this._canvas.fillStyle = TEXT_COLOR;\r\n                this._canvas.font = TEXT_FONT_SIZE.toString() + 'px ' + TEXT_FONT_FAMILY;\r\n                this._canvas.textBaseline = 'top';\r\n                this._canvas.fillText(drawState.title, drawState.left, drawState.top);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns the draw states for all timeline objects.\r\n     * @param {ResolvedStates} timeline Timeline to draw.\r\n     * @returns {TimelineDrawState} State of time-based objects.\r\n     */\r\n    getTimelineDrawState(timeline) {\r\n        let currentDrawState = {};\r\n        if (timeline) {\r\n            for (let objId in timeline.objects) {\r\n                let timelineObj = timeline.objects[objId];\r\n                for (let _i = 0; _i < timelineObj.resolved.instances.length; _i++) {\r\n                    let instanceObj = timelineObj.resolved.instances[_i];\r\n                    let name = 'timelineObject:' + objId + ':' + instanceObj.id;\r\n                    currentDrawState[name] = this.createStateForObject(timelineObj, instanceObj.start, instanceObj.end);\r\n                    if (currentDrawState[name].visible === true) {\r\n                        if (!this._hoveredObjectMap[timelineObj.layer + ''])\r\n                            this._hoveredObjectMap[timelineObj.layer + ''] = [];\r\n                        this._hoveredObjectMap[timelineObj.layer + ''].push({\r\n                            startX: currentDrawState[name].left,\r\n                            endX: currentDrawState[name].left + currentDrawState[name].width,\r\n                            objectRefId: objId,\r\n                            instanceId: instanceObj.id,\r\n                            type: 'timelineObject',\r\n                            name: name\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return currentDrawState;\r\n    }\r\n    /**\r\n     * Creates a draw state for a timeline object.\r\n     * @param {string} layer Object's layer.\r\n     * @param {number} start Start time.\r\n     * @param {number} end End time.\r\n     * @returns {DrawState} State of the object to draw.\r\n     */\r\n    createStateForObject(obj, start, end) {\r\n        // Default state (hidden).\r\n        let state = {\r\n            height: 0,\r\n            left: 0,\r\n            top: 0,\r\n            width: 0,\r\n            visible: false,\r\n            title: 'N/A'\r\n        };\r\n        // State should be default if the object is not being shown.\r\n        if (this.showOnTimeline(start, end)) {\r\n            // Get object dimensions and position.\r\n            let objectWidth = this.getObjectWidth(start, end);\r\n            let xCoord = this.capXcoordToView(this.timeToXCoord(start));\r\n            let objectTop = this.getObjectOffsetFromTop(obj.layer + '');\r\n            // Set state properties.\r\n            state.height = this._timelineObjectHeight;\r\n            state.left = xCoord;\r\n            state.top = objectTop;\r\n            state.width = objectWidth;\r\n            state.visible = true;\r\n            state.title = obj.id;\r\n        }\r\n        return state;\r\n    }\r\n    /**\r\n     * Calculates the offset, in pixels from the start of the timeline for an object.\r\n     * @param {number} start start time of the object.\r\n     * @returns {number} Offset in pixels.\r\n     */\r\n    // private getObjectOffsetFromTimelineStart (start: number): number {\r\n    // \t// Calculate offset.\r\n    // \tlet offset = (start - this._viewStartTime) * this.pixelsWidthPerUnitTime\r\n    // \t// Offset cannot be to the left of the timeline start position.\r\n    // \tif (offset < 0) {\r\n    // \t\toffset = 0\r\n    // \t}\r\n    // \treturn offset\r\n    // }\r\n    /**\r\n     * Calculates the width, in pixels, of an object based on its duration.\r\n     * @param {number} start Start time of the object.\r\n     * @param {number} end End time of the object.\r\n     * @returns {number} Width in pixels.\r\n     */\r\n    getObjectWidth(startTime, endTime) {\r\n        if (!endTime)\r\n            return this._canvasWidth;\r\n        // If the start time is less than the timeline start, set to timeline start.\r\n        if (startTime < this._viewStartTime) {\r\n            startTime = this._viewStartTime;\r\n        }\r\n        // Calculate duration of the object remaining on the timeline.\r\n        let duration = endTime - startTime;\r\n        // Return end point position in pixels.\r\n        return duration * this.pixelsWidthPerUnitTime;\r\n    }\r\n    /**\r\n     * Determines whether to show an object on the timeline.\r\n     * @param {number} start Object start time.\r\n     * @param {number} end Object end time.\r\n     * @returns {true} if object should be shown on the timeline.\r\n     */\r\n    showOnTimeline(start, end) {\r\n        let isAfter = start >= this.viewEndTime;\r\n        let isBefore = (end || Infinity) <= this._viewStartTime;\r\n        return !isAfter && !isBefore;\r\n    }\r\n    /**\r\n     * Calculate position of object instance from top of timeline according to its layer.\r\n     * @param {string} layer Object's layer.\r\n     * @returns Position relative to top of canvas in pixels.\r\n     */\r\n    getObjectOffsetFromTop(layerName) {\r\n        let top = this._layerLabels[layerName];\r\n        return top * this._rowHeight;\r\n    }\r\n    /**\r\n     * Moves the playhead. Called periodically.\r\n     */\r\n    updateDraw() {\r\n        const now = Date.now();\r\n        // How long time since last update:\r\n        const dt = (this._updateDrawLastTime > 0 ?\r\n            now - this._updateDrawLastTime :\r\n            1) / 1000;\r\n        this._updateDrawLastTime = now;\r\n        const deltaTime = this._playSpeed * dt;\r\n        // Check playhead should be drawn.\r\n        let needRedraw = false;\r\n        if (this._playHeadPlaying && this._drawPlayhead) {\r\n            if (this._playViewPort &&\r\n                this.istimeInView(this._playHeadTime) // Only play if playhead is in view\r\n            ) {\r\n                this._viewStartTime += deltaTime;\r\n            }\r\n            // Move playhead forward\r\n            this._playHeadTime += deltaTime;\r\n            needRedraw = true;\r\n        }\r\n        if (needRedraw) {\r\n            this.redrawTimeline();\r\n        }\r\n        // call this function on next frame\r\n        window.requestAnimationFrame(() => this.updateDraw());\r\n    }\r\n    /**\r\n     * Handles mouse down event.\r\n     * @param event Mouse event.\r\n     */\r\n    canvasMouseDown(event) {\r\n        // Store mouse is down.\r\n        this._mouseDown = true;\r\n        // Store X position of mouse on click.\r\n        this._mouseLastX = event.clientX;\r\n        // Prevent event.\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n    }\r\n    /**\r\n     * Handles mouse up event.\r\n     * @param event Mouse event.\r\n     */\r\n    canvasMouseUp(event) {\r\n        // Mouse no longer down.\r\n        this._mouseDown = false;\r\n        // Reset scroll direction.\r\n        this._lastScrollDirection = 0;\r\n        // Prevent event.\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n    }\r\n    /**\r\n     * Handles mouse movement on canvas.\r\n     * @param event Mouse event.\r\n     */\r\n    canvasMouseMove(event) {\r\n        // If mouse is down.\r\n        if (this._mouseDown) {\r\n            // If we are beginning scrolling, we can move freely.\r\n            if (this._lastScrollDirection === undefined || this._lastScrollDirection === 0) {\r\n                // Store current mouse X.\r\n                this._mouseLastX = event.clientX;\r\n                // Calculate change in X.\r\n                let deltaX = event.clientX - this._mouseLastX;\r\n                // Store scrolling direction.\r\n                if (deltaX < 0) {\r\n                    this._lastScrollDirection = -1;\r\n                }\r\n                else {\r\n                    this._lastScrollDirection = 1;\r\n                }\r\n                // Scroll to new X position.\r\n                this.canvasScrollByDeltaX(-deltaX);\r\n            }\r\n            else {\r\n                // Calculate scroll direction.\r\n                let direction = this._mouseLastX - event.clientX;\r\n                // If changing direction, store new direction but don't scroll.\r\n                if (direction < 0 && this._lastScrollDirection === 1) {\r\n                    this._mouseLastX = event.clientX;\r\n                    this._lastScrollDirection = -1;\r\n                }\r\n                else if (direction > 0 && this._lastScrollDirection === -1) {\r\n                    this._mouseLastX = event.clientX;\r\n                    this._lastScrollDirection = 1;\r\n                }\r\n                else {\r\n                    // Calculate change in X.\r\n                    let deltaX = event.clientX - this._mouseLastX;\r\n                    // Store last X position.\r\n                    this._mouseLastX = event.clientX;\r\n                    // Move by change in X.\r\n                    this.canvasScrollByDeltaX(-deltaX);\r\n                }\r\n            }\r\n            // Redraw timeline.\r\n            this.redrawTimeline();\r\n        }\r\n        else {\r\n            // Whether an object is under the cursor.\r\n            let found = false;\r\n            // Find the object that is currently hovered over.\r\n            let mousePos = this.getMousePos(this._canvasContainer, event);\r\n            if (mousePos.x > this._viewDrawX) {\r\n                if (mousePos.y < this._rowsTotalHeight) {\r\n                    let selectedRow = Math.floor((mousePos.y / this._rowsTotalHeight) * this._numberOfLayers);\r\n                    let layer;\r\n                    Object.keys(this._layerLabels).forEach(layerName => {\r\n                        if (this._layerLabels[layerName] === selectedRow)\r\n                            layer = layerName;\r\n                    });\r\n                    let hoverMapData = (layer ? this._hoveredObjectMap[layer] : []) || [];\r\n                    hoverMapData.forEach(object => {\r\n                        if (object.startX <= mousePos.x && object.endX >= mousePos.x) {\r\n                            found = true;\r\n                            const hoverHash = object.type + object.objectRefId + object.instanceId; // hash-ish\r\n                            if (this._lastHoveredHash !== hoverHash) {\r\n                                // Get object metadata from the object name of the hovered object.\r\n                                // If we are hovering over a timeline object.\r\n                                if (object.type === 'timelineObject') {\r\n                                    // Get the timeline object and the instance being hovered over.\r\n                                    if (this._resolvedStates) {\r\n                                        let timelineObject = this._resolvedStates.objects[object.objectRefId];\r\n                                        let instance = timelineObject.resolved.instances.find(instance => instance.id === object.instanceId);\r\n                                        if (instance) {\r\n                                            // Construct hover info.\r\n                                            let hoverInfo = {\r\n                                                object: timelineObject,\r\n                                                instance: instance,\r\n                                                pointer: { xPostion: mousePos.x, yPosition: mousePos.y }\r\n                                            };\r\n                                            // Set currently hovered object.\r\n                                            this._hoveredOver = hoverInfo;\r\n                                            // Emit event.\r\n                                            this.emit('timeline:hover', { detail: this._hoveredOver });\r\n                                        }\r\n                                        // Store last items.\r\n                                        this._lastHoverAction = MOUSEIN;\r\n                                        this._lastHoveredHash = hoverHash;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            // Emit undefined when mouse out.\r\n            if (!found && this._lastHoverAction === MOUSEIN) {\r\n                this.emit('timeline:hover', { detail: undefined });\r\n                this._lastHoverAction = MOUSEOUT;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Handles scroll wheel events on the canvas.\r\n     * @param event Scroll event.\r\n     */\r\n    canvasScrollWheel(event) {\r\n        // Get mouse pointer coordinates on canvas.\r\n        let canvasCoord = this.getMousePos(this._canvasContainer, event);\r\n        // Don't scroll if mouse is not over timeline.\r\n        if (canvasCoord.x <= this._viewDrawX) {\r\n            return;\r\n        }\r\n        let changed = false;\r\n        // CTRL + scroll to zoom.\r\n        if (event.ctrlKey === true) {\r\n            if (event.deltaY) {\r\n                changed = true;\r\n                const zoomFactor = Math.pow(ZOOM_FACTOR, -event.deltaY);\r\n                this.zoomUnderCursor(canvasCoord.x, zoomFactor);\r\n            }\r\n        }\r\n        else if (event.deltaX !== 0) { // Scroll on x-axis\r\n            changed = true;\r\n            // Pan.\r\n            this.canvasScrollByDeltaX((event.deltaX * (PAN_FACTOR * this.stepSize)));\r\n        }\r\n        else if (event.deltaY !== 0 && event.altKey === true) { // Also scroll on alt-key + scroll y-axis\r\n            changed = true;\r\n            // Pan.\r\n            this.canvasScrollByDeltaX((event.deltaY * (PAN_FACTOR * this.stepSize)));\r\n        }\r\n        // Prevent event.\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        if (changed) {\r\n            // Redraw timeline.\r\n            this.redrawTimeline();\r\n        }\r\n    }\r\n    /**\r\n     * Scroll across the canvas by a specified X value.\r\n     * @param {number} deltaX Value to move by.\r\n     */\r\n    canvasScrollByDeltaX(deltaX) {\r\n        // Calculate new starting time.\r\n        let targetStart = this._viewStartTime + (deltaX / this.pixelsWidthPerUnitTime);\r\n        // Starting time cannot be < 0.\r\n        if (targetStart < 0) {\r\n            targetStart = 0;\r\n        }\r\n        // Optimisation, don't redraw if nothing has changed.\r\n        if (targetStart === this._viewStartTime) {\r\n            return;\r\n        }\r\n        this._viewStartTime = targetStart;\r\n    }\r\n    /**\r\n     * Zooms into/out of timeline, keeping the time under the cursor in the same position.\r\n     * @param cursorX Position of mouse cursor.\r\n     */\r\n    zoomUnderCursor(cursorX, zoomFactor) {\r\n        // Point in time of the cursor\r\n        let cursorTime = this.xCoordToTime(cursorX);\r\n        // Ratio (in view range) of the cursor\r\n        let cursorRatio = this.timeToRatio(cursorTime);\r\n        // Change zoom:\r\n        this._timelineZoom = this._timelineZoom * zoomFactor;\r\n        // Limit within current view\r\n        cursorRatio = Math.max(0, Math.min(1, cursorRatio));\r\n        // Calculate start\r\n        let targetStart = cursorTime - (cursorRatio * this.viewRange);\r\n        // Start cannot be less than 0\r\n        if (targetStart < 0) {\r\n            targetStart = 0;\r\n        }\r\n        // Set draw time\r\n        this._viewStartTime = targetStart;\r\n    }\r\n    /**\r\n     * Gets the mouse position relative to the top-left of the canvas [pixels]\r\n     * @param canvas\r\n     * @param evt\r\n     * @returns {x: number, y: number} Position.\r\n     */\r\n    getMousePos(canvas, evt) {\r\n        const rect = canvas.getBoundingClientRect();\r\n        return {\r\n            x: evt.clientX - rect.left,\r\n            y: evt.clientY - rect.top\r\n        };\r\n    }\r\n    /**\r\n     * Trims a timeline so that objects only exist within a specified time period.\r\n     * @param timeline Timeline to trim.\r\n     * @param trim Times to trim between.\r\n     */\r\n    trimTimeline(timeline, trim) {\r\n        // The new resolved objects.\r\n        let newObjects = {};\r\n        // Iterate through resolved objects.\r\n        Object.keys(timeline.objects).forEach((objId) => {\r\n            const obj = timeline.objects[objId];\r\n            const resultingInstances = [];\r\n            obj.resolved.instances.forEach(instance => {\r\n                // Whether to insert this object into the new timeline.\r\n                let useInstance = false;\r\n                let newInstance = Object.assign({}, instance); // clone\r\n                // If trimming the start time.\r\n                if (trim.start) {\r\n                    // If the object ends after the trim start time.\r\n                    if ((instance.end || Infinity) > trim.start) {\r\n                        useInstance = true;\r\n                        if (newInstance.start < trim.start) {\r\n                            newInstance.start = trim.start;\r\n                        }\r\n                    }\r\n                }\r\n                // If trimming the end time.\r\n                if (trim.end) {\r\n                    // If the object starts before the trim end time.\r\n                    if (instance.start < trim.end) {\r\n                        useInstance = true;\r\n                        if ((newInstance.end || Infinity) > trim.end) {\r\n                            newInstance.end = trim.end;\r\n                        }\r\n                    }\r\n                }\r\n                if (!trim.start && !trim.end) {\r\n                    useInstance = true;\r\n                }\r\n                if (useInstance &&\r\n                    newInstance.start < (newInstance.end || Infinity)) {\r\n                    resultingInstances.push(newInstance);\r\n                }\r\n            });\r\n            // If there isn't a resolved object for the new instance, create it.\r\n            if (!newObjects[objId]) {\r\n                let newObject = {\r\n                    content: obj.content,\r\n                    enable: obj.enable,\r\n                    id: obj.id,\r\n                    layer: obj.layer,\r\n                    resolved: {\r\n                        instances: [],\r\n                        levelDeep: obj.resolved.levelDeep,\r\n                        resolved: obj.resolved.resolved,\r\n                        resolving: obj.resolved.resolving,\r\n                        directReferences: obj.resolved.directReferences,\r\n                    }\r\n                };\r\n                newObjects[objId] = newObject;\r\n            }\r\n            newObjects[objId].resolved.instances = resultingInstances;\r\n        });\r\n        return {\r\n            classes: timeline.classes,\r\n            layers: timeline.layers,\r\n            objects: newObjects,\r\n            options: timeline.options,\r\n            statistics: timeline.statistics,\r\n            state: timeline.state,\r\n            nextEvents: timeline.nextEvents\r\n        };\r\n    }\r\n    /**\r\n     * Merges two timelines by merging instances of objects that intersect each other.\r\n     * @param past Older timeline.\r\n     * @param present Newer timeline.\r\n     * @returns {ResolvedTimeline} containing merged timelines.\r\n     */\r\n    mergeTimelineObjects(past, present, fromNewTimeline) {\r\n        const resultingObjects = {};\r\n        if (fromNewTimeline) {\r\n            past = this.trimTimeline(past, { end: this._playHeadTime });\r\n            present = this.trimTimeline(present, { start: this._playHeadTime });\r\n            // Because we want to keep old objects, this iterator is used to create unique old ids for them\r\n            this._mergeIterator++;\r\n            Object.keys(past.objects).forEach((objId) => {\r\n                const pastObj = past.objects[objId];\r\n                // @ts-ignore: hack to mark it as a \"past object\"\r\n                if (pastObj.__pastObj) {\r\n                    // Copy over it right away, it's old. Don't do anything else\r\n                    resultingObjects[objId] = pastObj;\r\n                    return;\r\n                }\r\n                // If an object exists in both timelines\r\n                const presentObj = present.objects[objId];\r\n                if (presentObj) {\r\n                    if (\r\n                    // Compare the objects, only look into merging them if they look identical\r\n                    isEqual(Object.assign({}, pastObj, { resolved: null }), Object.assign({}, presentObj, { resolved: null }))) {\r\n                        // This assumes that all past instances stop at a certain time at the very latest,\r\n                        // and that all new instances start at that time at the very earliest.\r\n                        // Iterate over all instances of those objects.\r\n                        const allInstances = {};\r\n                        pastObj.resolved.instances.forEach(pastInstance => {\r\n                            allInstances[pastInstance.end + ''] = pastInstance;\r\n                        });\r\n                        presentObj.resolved.instances.forEach(presentInstance => {\r\n                            if (allInstances[presentInstance.start + '']) {\r\n                                // The instances are next to each other, merge them into one:\r\n                                allInstances[presentInstance.start + ''].end = presentInstance.end;\r\n                            }\r\n                            else {\r\n                                allInstances[presentInstance.start + ''] = presentInstance;\r\n                            }\r\n                        });\r\n                        presentObj.resolved.instances = [];\r\n                        Object.keys(allInstances).forEach(key => {\r\n                            const instance = allInstances[key];\r\n                            presentObj.resolved.instances.push(instance);\r\n                        });\r\n                        // Copy over the new object\r\n                        resultingObjects[objId] = presentObj;\r\n                        return; // don't copy over old object\r\n                    }\r\n                    else {\r\n                        // The objects doesn't look identical\r\n                        // Copy over the new object\r\n                        resultingObjects[objId] = presentObj;\r\n                    }\r\n                }\r\n                else {\r\n                    // The old object doesn't exist in the new timeline\r\n                }\r\n                // @ts-ignore: hack to mark it as a \"past object\"\r\n                pastObj.__pastObj = true;\r\n                // Copy over the old object\r\n                resultingObjects[this._mergeIterator + '__' + objId] = pastObj;\r\n            });\r\n            // Iterate over the next objects\r\n            Object.keys(present.objects).forEach((objId) => {\r\n                const presentObj = present.objects[objId];\r\n                if (!past.objects[objId]) { // (if it did existed in the past, it has already been handled)\r\n                    // Just copy over the new object\r\n                    resultingObjects[objId] = presentObj;\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            // No new timeline, objects and instances are only added\r\n            Object.keys(past.objects).forEach((objId) => {\r\n                const pastObj = past.objects[objId];\r\n                resultingObjects[objId] = pastObj;\r\n            });\r\n            Object.keys(present.objects).forEach((objId) => {\r\n                const presentObj = present.objects[objId];\r\n                const existingObj = resultingObjects[objId];\r\n                if (existingObj) {\r\n                    // merge with old instances\r\n                    const existingInstances = {};\r\n                    existingObj.resolved.instances.forEach(instance => {\r\n                        existingInstances[instance.start + '_' + instance.end] = true;\r\n                    });\r\n                    presentObj.resolved.instances.forEach(instance => {\r\n                        // Only push instances that aren't already present:\r\n                        if (!existingInstances[instance.start + '_' + instance.end]) {\r\n                            existingObj.resolved.instances.push(instance);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    resultingObjects[objId] = presentObj;\r\n                }\r\n            });\r\n        }\r\n        const resultingLayers = {};\r\n        Object.keys(resultingObjects).forEach(key => {\r\n            const obj = resultingObjects[key];\r\n            const layer = obj.layer + '';\r\n            if (!resultingLayers[layer])\r\n                resultingLayers[layer] = [];\r\n            resultingLayers[layer].push(key);\r\n        });\r\n        return Object.assign(Object.assign({}, present), { objects: resultingObjects, layers: resultingLayers });\r\n    }\r\n    updateTimelineResolveWindow() {\r\n        const { start, end } = this.getExpandedStartEndTime(1);\r\n        this._timelineResolveStart = start;\r\n        this._timelineResolveEnd = end;\r\n        this._timelineResolveZoom = this._timelineZoom;\r\n        if (this.latestUpdateTime) {\r\n            // Calculate an optimal number of objects to create, so that the drawing still runs smoothly.\r\n            const targetResolveTime = 50; // ms\r\n            let ratio = targetResolveTime / this.latestUpdateTime;\r\n            this._timelineResolveCountAdjust = Math.max(0.1, Math.min(10, (1 + (this._timelineResolveCountAdjust * ratio)) / 2));\r\n        }\r\n    }\r\n    getExpandedStartEndTime(multiplier = 1) {\r\n        let start = this._viewStartTime;\r\n        let end = this.viewEndTime;\r\n        let duration = end - start;\r\n        let expand = duration * (this._timelineResolveExpand - 1) * multiplier;\r\n        start -= expand * 0.33;\r\n        end += expand * 0.66; // expand more into the future\r\n        start = Math.max(0, start);\r\n        end = Math.max(0, end);\r\n        const zoomDiff = Math.max(this._timelineResolveZoom, this._timelineZoom) /\r\n            Math.min(this._timelineResolveZoom, this._timelineZoom);\r\n        return { start, end, zoomDiff };\r\n    }\r\n    checkAutomaticReresolve() {\r\n        const { start, end, zoomDiff } = this.getExpandedStartEndTime(0.2);\r\n        if (this._timelineResolveAuto && (start < this._timelineResolveStart ||\r\n            end > this._timelineResolveEnd ||\r\n            zoomDiff > 3)) {\r\n            if (!this.reresolveTimeout) {\r\n                this.reresolveTimeout = setTimeout(() => {\r\n                    this.reresolveTimeout = null;\r\n                    this.updateTimelineResolveWindow();\r\n                    this._updateTimeline();\r\n                }, Math.max(100, this.latestUpdateTime * 5));\r\n            }\r\n        }\r\n    }\r\n    // --------------------- Conversions between position & time -------------\r\n    /**\r\n     * Calculate the X coordinate of a time value.\r\n     * @param {number} time The time to convert.\r\n     * @returns {number} The X coordinate of the time.\r\n     */\r\n    timeToXCoord(time) {\r\n        return this._viewDrawX + ((time - this._viewStartTime) * this.pixelsWidthPerUnitTime);\r\n    }\r\n    /**\r\n     * Calculate the time of a X coordinate.\r\n     * @param {number} time The X coordinate to convert.\r\n     * @returns {number} The time of the X coordinate.\r\n     */\r\n    xCoordToTime(position) {\r\n        return this._viewStartTime + ((position - this._viewDrawX) / this.pixelsWidthPerUnitTime);\r\n    }\r\n    /** Calculate the ratio of the time in current view (0 i beginning, 1 is end)  */\r\n    timeToRatio(time) {\r\n        return (time - this._viewStartTime) / this.viewRange;\r\n    }\r\n    /** Returns true if the position is within the current view  */\r\n    istimeInView(time) {\r\n        const ratio = this.timeToRatio(time);\r\n        return ratio >= 0 && ratio < 1;\r\n    }\r\n    capXcoordToView(position) {\r\n        return Math.max(this._viewDrawX, Math.min(this._viewDrawX + this._viewDrawWidth, position));\r\n    }\r\n    // -------------- Getters / Convenience functions ---------------------\r\n    /** Zoom factor [pixels / time] */\r\n    get pixelsWidthPerUnitTime() {\r\n        return (this._timelineZoom / 100);\r\n    }\r\n    /** The range of the view [time] */\r\n    get viewRange() {\r\n        return this._viewDrawWidth / this.pixelsWidthPerUnitTime;\r\n    }\r\n    /** The end time of the view [time] */\r\n    get viewEndTime() {\r\n        return this._viewStartTime + this.viewRange;\r\n    }\r\n}\r\nexports.TimelineVisualizer = TimelineVisualizer;\r\n//# sourceMappingURL=timelineVisualizer.js.map","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar objectCreate = Object.create || objectCreatePolyfill\nvar objectKeys = Object.keys || objectKeysPolyfill\nvar bind = Function.prototype.bind || functionBindPolyfill\n\nfunction EventEmitter() {\n  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {\n    this._events = objectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nvar hasDefineProperty;\ntry {\n  var o = {};\n  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });\n  hasDefineProperty = o.x === 0;\n} catch (err) { hasDefineProperty = false }\nif (hasDefineProperty) {\n  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n    enumerable: true,\n    get: function() {\n      return defaultMaxListeners;\n    },\n    set: function(arg) {\n      // check whether the input is a positive number (whose value is zero or\n      // greater and not a NaN).\n      if (typeof arg !== 'number' || arg < 0 || arg !== arg)\n        throw new TypeError('\"defaultMaxListeners\" must be a positive number');\n      defaultMaxListeners = arg;\n    }\n  });\n} else {\n  EventEmitter.defaultMaxListeners = defaultMaxListeners;\n}\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    if (arguments.length > 1)\n      er = arguments[1];\n    if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Unhandled \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n      // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n      // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = objectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n          listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n          prepend ? [listener, existing] : [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n            existing.length + ' \"' + String(type) + '\" listeners ' +\n            'added. Use emitter.setMaxListeners() to ' +\n            'increase limit.');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        if (typeof console === 'object' && console.warn) {\n          console.warn('%s: %s', w.name, w.message);\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    switch (arguments.length) {\n      case 0:\n        return this.listener.call(this.target);\n      case 1:\n        return this.listener.call(this.target, arguments[0]);\n      case 2:\n        return this.listener.call(this.target, arguments[0], arguments[1]);\n      case 3:\n        return this.listener.call(this.target, arguments[0], arguments[1],\n            arguments[2]);\n      default:\n        var args = new Array(arguments.length);\n        for (var i = 0; i < args.length; ++i)\n          args[i] = arguments[i];\n        this.listener.apply(this.target, args);\n    }\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = bind.call(onceWrapper, state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = objectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else\n          spliceOne(list, position);\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = objectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = objectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = objectKeys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = objectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (!events)\n    return [];\n\n  var evlistener = events[type];\n  if (!evlistener)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction objectCreatePolyfill(proto) {\n  var F = function() {};\n  F.prototype = proto;\n  return new F;\n}\nfunction objectKeysPolyfill(obj) {\n  var keys = [];\n  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {\n    keys.push(k);\n  }\n  return k;\n}\nfunction functionBindPolyfill(context) {\n  var fn = this;\n  return function () {\n    return fn.apply(context, arguments);\n  };\n}\n","/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = isEqual;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=api.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EventType = void 0;\nvar EventType;\n(function (EventType) {\n    EventType[EventType[\"START\"] = 0] = \"START\";\n    EventType[EventType[\"END\"] = 1] = \"END\";\n    EventType[EventType[\"KEYFRAME\"] = 2] = \"KEYFRAME\";\n})(EventType = exports.EventType || (exports.EventType = {}));\n//# sourceMappingURL=enums.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateKeyframe = exports.validateObject = exports.validateTimeline = exports.Resolver = void 0;\nconst tslib_1 = require(\"tslib\");\n(0, tslib_1.__exportStar)(require(\"./api/enums\"), exports);\n(0, tslib_1.__exportStar)(require(\"./api/api\"), exports);\nvar resolver_1 = require(\"./resolver/resolver\");\nObject.defineProperty(exports, \"Resolver\", { enumerable: true, get: function () { return resolver_1.Resolver; } });\nvar validate_1 = require(\"./resolver/validate\");\nObject.defineProperty(exports, \"validateTimeline\", { enumerable: true, get: function () { return validate_1.validateTimeline; } });\nObject.defineProperty(exports, \"validateObject\", { enumerable: true, get: function () { return validate_1.validateObject; } });\nObject.defineProperty(exports, \"validateKeyframe\", { enumerable: true, get: function () { return validate_1.validateKeyframe; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cleanCacheResult = exports.cacheResult = exports.applyParentInstances = exports.setInstanceStartTime = exports.setInstanceEndTime = exports.resetId = exports.getId = exports.joinCaps = exports.addCapsToResuming = exports.joinReferences = exports.isReference = exports.capInstances = exports.applyRepeatingInstances = exports.operateOnArrays = exports.invertInstances = exports.convertEventsToInstances = exports.cleanInstances = exports.sortEvents = exports.isNumeric = exports.isConstant = exports.extendMandadory = void 0;\nconst _ = require(\"underscore\");\n/**\n * Somewhat like _.extend, but with strong types & mandated additional properties\n * @param original Object to be extended\n * @param extendObj properties to add\n */\nfunction extendMandadory(original, extendObj) {\n    return _.extend(original, extendObj);\n}\nexports.extendMandadory = extendMandadory;\nfunction isConstant(str) {\n    return !!(isNumeric(str) || (_.isString(str) && (str.match(/^true$/) || str.match(/^false$/))));\n}\nexports.isConstant = isConstant;\nfunction isNumeric(str) {\n    if (str === null)\n        return false;\n    if (_.isNumber(str))\n        return true;\n    if (_.isString(str))\n        return !!(str.match(/^[-+]?[0-9.]+$/) && !_.isNaN(parseFloat(str)));\n    return false;\n}\nexports.isNumeric = isNumeric;\nfunction sortEvents(events) {\n    return events.sort((a, b) => {\n        if (a.time > b.time)\n            return 1;\n        if (a.time < b.time)\n            return -1;\n        const aId = a.data && (a.data.id || (a.data.instance && a.data.instance.id));\n        const bId = b.data && (b.data.id || (b.data.instance && b.data.instance.id));\n        if (aId && bId && aId === bId) {\n            // If the event refer to the same ID, let the ending event be first:\n            if (a.value && !b.value)\n                return -1;\n            if (!a.value && b.value)\n                return 1;\n        }\n        if (a.value && !b.value)\n            return 1;\n        if (!a.value && b.value)\n            return -1;\n        return 0;\n    });\n}\nexports.sortEvents = sortEvents;\n/**\n * Clean up instances, join overlapping etc..\n * @param instances\n */\nfunction cleanInstances(instances, allowMerge, allowZeroGaps = false) {\n    // First, optimize for certain common situations:\n    if (instances.length === 0)\n        return [];\n    if (instances.length === 1)\n        return instances;\n    const events = [];\n    for (let i = 0; i < instances.length; i++) {\n        const instance = instances[i];\n        events.push({\n            time: instance.start,\n            value: true,\n            data: { instance: instance },\n            references: instance.references,\n        });\n        if (instance.end !== null) {\n            events.push({\n                time: instance.end,\n                value: false,\n                data: { instance: instance },\n                references: instance.references,\n            });\n        }\n    }\n    return convertEventsToInstances(events, allowMerge, allowZeroGaps);\n}\nexports.cleanInstances = cleanInstances;\nfunction convertEventsToInstances(events, allowMerge, allowZeroGaps = false) {\n    sortEvents(events);\n    const activeInstances = {};\n    let activeInstanceId = null;\n    let previousActive = false;\n    const negativeInstances = {};\n    let previousNegative = false;\n    let negativeInstanceId = null;\n    const returnInstances = [];\n    for (let i = 0; i < events.length; i++) {\n        const event = events[i];\n        const eventId = event.data.id || event.data.instance.id;\n        const lastInstance = returnInstances[returnInstances.length - 1];\n        if (event.value) {\n            activeInstances[eventId] = event;\n            delete negativeInstances[eventId];\n        }\n        else {\n            delete activeInstances[eventId];\n            negativeInstances[eventId] = event;\n        }\n        if (Object.keys(activeInstances).length) {\n            // There is an active instance\n            if (!allowMerge && !allowZeroGaps && lastInstance && previousNegative) {\n                // There is previously an inActive (negative) instance\n                lastInstance.start = event.time;\n            }\n            else {\n                const o = handleActiveInstances(event, lastInstance, activeInstanceId, eventId, activeInstances, allowMerge, allowZeroGaps);\n                activeInstanceId = o.activeInstanceId;\n                if (o.returnInstance) {\n                    returnInstances.push(o.returnInstance);\n                }\n            }\n            previousActive = true;\n            previousNegative = false;\n        }\n        else {\n            // No instances are active\n            if (lastInstance && previousActive) {\n                lastInstance.end = event.time;\n            }\n            else {\n                if (Object.keys(negativeInstances).length) {\n                    // There is a negative instance running\n                    const o = handleActiveInstances(event, lastInstance, negativeInstanceId, eventId, negativeInstances, allowMerge, allowZeroGaps);\n                    negativeInstanceId = o.activeInstanceId;\n                    if (o.returnInstance) {\n                        returnInstances.push({\n                            ...o.returnInstance,\n                            start: o.returnInstance.end || 0,\n                            end: o.returnInstance.start,\n                        });\n                    }\n                    previousNegative = true;\n                }\n            }\n            previousActive = false;\n        }\n    }\n    return returnInstances;\n}\nexports.convertEventsToInstances = convertEventsToInstances;\nfunction handleActiveInstances(event, lastInstance, activeInstanceId, eventId, activeInstances, allowMerge, allowZeroGaps = false) {\n    let returnInstance = null;\n    if (!allowMerge &&\n        event.value &&\n        lastInstance &&\n        lastInstance.end === null &&\n        activeInstanceId !== null &&\n        activeInstanceId !== eventId) {\n        // Start a new instance:\n        lastInstance.end = event.time;\n        returnInstance = {\n            id: getId(),\n            start: event.time,\n            end: null,\n            references: event.references,\n            originalEnd: event.data.instance.originalEnd,\n            originalStart: event.data.instance.originalStart,\n        };\n        activeInstanceId = eventId;\n    }\n    else if (!allowMerge && !event.value && lastInstance && activeInstanceId === eventId) {\n        // The active instance stopped playing, but another is still playing\n        const latestInstance = _.reduce(activeInstances, (memo, instanceEvent, id) => {\n            if (memo === null || memo.event.time < instanceEvent.time) {\n                return {\n                    event: instanceEvent,\n                    id: id,\n                };\n            }\n            return memo;\n        }, null);\n        if (latestInstance) {\n            // Restart that instance now:\n            lastInstance.end = event.time;\n            returnInstance = {\n                id: eventId + '_' + getId(),\n                start: event.time,\n                end: null,\n                references: latestInstance.event.references,\n                originalEnd: event.data.instance.originalEnd,\n                originalStart: event.data.instance.originalStart,\n            };\n            activeInstanceId = latestInstance.id;\n        }\n    }\n    else if (allowMerge && !allowZeroGaps && lastInstance && lastInstance.end === event.time) {\n        // The previously running ended just now\n        // resume previous instance:\n        lastInstance.end = null;\n        lastInstance.references = joinReferences(lastInstance.references, event.references);\n        addCapsToResuming(lastInstance, event.data.instance.caps);\n    }\n    else if (!lastInstance || lastInstance.end !== null) {\n        // There is no previously running instance\n        // Start a new instance:\n        returnInstance = {\n            id: eventId,\n            start: event.time,\n            end: null,\n            references: event.references,\n            caps: event.data.instance.caps,\n            originalEnd: event.data.instance.originalEnd,\n            originalStart: event.data.instance.originalStart,\n        };\n        activeInstanceId = eventId;\n    }\n    else {\n        // There is already a running instance\n        lastInstance.references = joinReferences(lastInstance.references, event.references);\n        addCapsToResuming(lastInstance, event.data.instance.caps);\n    }\n    if (lastInstance && lastInstance.caps && !lastInstance.caps.length)\n        delete lastInstance.caps;\n    if (returnInstance &&\n        lastInstance &&\n        lastInstance.start === lastInstance.end &&\n        lastInstance.end === returnInstance.start) {\n        // replace the previous zero-length with this one instead\n        lastInstance.id = returnInstance.id;\n        lastInstance.start = returnInstance.start;\n        lastInstance.end = returnInstance.end;\n        lastInstance.references = returnInstance.references;\n        lastInstance.caps = returnInstance.caps;\n        lastInstance.originalStart = returnInstance.originalStart;\n        lastInstance.originalEnd = returnInstance.originalEnd;\n        returnInstance = null;\n    }\n    return {\n        activeInstanceId,\n        returnInstance,\n    };\n}\nfunction invertInstances(instances) {\n    if (instances.length) {\n        instances = cleanInstances(instances, true, true);\n        const invertedInstances = [];\n        if (instances[0].start !== 0) {\n            invertedInstances.push({\n                id: getId(),\n                isFirst: true,\n                start: 0,\n                end: null,\n                references: joinReferences(instances[0].references, instances[0].id),\n            });\n        }\n        for (let i = 0; i < instances.length; i++) {\n            const instance = instances[i];\n            const last = _.last(invertedInstances);\n            if (last) {\n                last.end = instance.start;\n            }\n            if (instance.end !== null) {\n                invertedInstances.push({\n                    id: getId(),\n                    start: instance.end,\n                    end: null,\n                    references: joinReferences(instance.references, instance.id),\n                    caps: instance.caps,\n                });\n            }\n        }\n        return invertedInstances;\n    }\n    else {\n        return [\n            {\n                id: getId(),\n                isFirst: true,\n                start: 0,\n                end: null,\n                references: [],\n            },\n        ];\n    }\n}\nexports.invertInstances = invertInstances;\n/**\n * Perform an action on 2 arrays. Behaves somewhat like the \".*\"-operator in Matlab\n * @param array0\n * @param array1\n * @param operate\n */\nfunction operateOnArrays(array0, array1, operate) {\n    if (array0 === null || array1 === null)\n        return null;\n    if (isReference(array0) && isReference(array1)) {\n        return operate(array0, array1);\n    }\n    const result = [];\n    const minLength = Math.min(_.isArray(array0) ? array0.length : Infinity, _.isArray(array1) ? array1.length : Infinity);\n    for (let i = 0; i < minLength; i++) {\n        const a = _.isArray(array0)\n            ? array0[i]\n            : { id: '', start: array0.value, end: array0.value, references: array0.references };\n        const b = _.isArray(array1)\n            ? array1[i]\n            : { id: '', start: array1.value, end: array1.value, references: array1.references };\n        const start = a.isFirst\n            ? { value: a.start, references: a.references }\n            : b.isFirst\n                ? { value: b.start, references: b.references }\n                : operate({ value: a.start, references: joinReferences(a.id, a.references) }, { value: b.start, references: joinReferences(b.id, b.references) });\n        const end = a.isFirst\n            ? a.end !== null\n                ? { value: a.end, references: a.references }\n                : null\n            : b.isFirst\n                ? b.end !== null\n                    ? { value: b.end, references: b.references }\n                    : null\n                : operate(a.end !== null ? { value: a.end, references: joinReferences(a.id, a.references) } : null, b.end !== null ? { value: b.end, references: joinReferences(b.id, b.references) } : null);\n        if (start !== null) {\n            result.push({\n                id: getId(),\n                start: start.value,\n                end: end === null ? null : end.value,\n                references: joinReferences(start.references, end !== null ? end.references : []),\n                caps: joinCaps(a.caps, b.caps),\n            });\n        }\n    }\n    return cleanInstances(result, false);\n}\nexports.operateOnArrays = operateOnArrays;\nfunction applyRepeatingInstances(instances, repeatTime0, options) {\n    if (repeatTime0 === null || !repeatTime0.value)\n        return instances;\n    const repeatTime = repeatTime0.value;\n    if (isReference(instances)) {\n        instances = [\n            {\n                id: '',\n                start: instances.value,\n                end: null,\n                references: instances.references,\n            },\n        ];\n    }\n    const repeatedInstances = [];\n    for (let i = 0; i < instances.length; i++) {\n        const instance = instances[i];\n        let startTime = Math.max(options.time - ((options.time - instance.start) % repeatTime), instance.start);\n        let endTime = instance.end === null ? null : instance.end + (startTime - instance.start);\n        const cap = (instance.caps ? _.find(instance.caps, (cap) => instance.references.indexOf(cap.id) !== -1) : null) || null;\n        const limit = options.limitCount || 2;\n        for (let i = 0; i < limit; i++) {\n            if (options.limitTime && startTime >= options.limitTime)\n                break;\n            const cappedStartTime = cap ? Math.max(cap.start, startTime) : startTime;\n            const cappedEndTime = cap && cap.end !== null && endTime !== null ? Math.min(cap.end, endTime) : endTime;\n            if ((cappedEndTime !== null && cappedEndTime !== void 0 ? cappedEndTime : Infinity) > cappedStartTime) {\n                repeatedInstances.push({\n                    id: getId(),\n                    start: cappedStartTime,\n                    end: cappedEndTime,\n                    references: joinReferences(instance.id, instance.references, repeatTime0.references),\n                });\n            }\n            startTime += repeatTime;\n            if (endTime !== null)\n                endTime += repeatTime;\n        }\n    }\n    return cleanInstances(repeatedInstances, false);\n}\nexports.applyRepeatingInstances = applyRepeatingInstances;\n/**\n * Cap instances so that they are within their parentInstances\n * @param instances\n * @param parentInstances\n */\nfunction capInstances(instances, parentInstances) {\n    var _a, _b, _c, _d, _e, _f;\n    if (isReference(parentInstances) || parentInstances === null)\n        return instances;\n    let returnInstances = [];\n    for (let i = 0; i < instances.length; i++) {\n        const instanceOrg = instances[i];\n        const addedInstanceTimes = new Set();\n        for (let j = 0; j < parentInstances.length; j++) {\n            const parent = parentInstances[j];\n            // First, check if the instance crosses the parent at all:\n            if (instanceOrg.start <= ((_a = parent.end) !== null && _a !== void 0 ? _a : Infinity) && ((_b = instanceOrg.end) !== null && _b !== void 0 ? _b : Infinity) >= parent.start) {\n                const instance = _.clone(instanceOrg);\n                // Cap start\n                if (instance.start < parent.start) {\n                    setInstanceStartTime(instance, parent.start);\n                }\n                // Cap end\n                if (((_c = instance.end) !== null && _c !== void 0 ? _c : Infinity) > ((_d = parent.end) !== null && _d !== void 0 ? _d : Infinity)) {\n                    setInstanceEndTime(instance, parent.end);\n                }\n                if (instance.start >= parent.start && ((_e = instance.end) !== null && _e !== void 0 ? _e : Infinity) <= ((_f = parent.end) !== null && _f !== void 0 ? _f : Infinity)) {\n                    // The instance is within the parent\n                    if (instance.start === instance.end && addedInstanceTimes.has(instance.start)) {\n                        // Don't add zero-length instances if there are already is instances covering that time\n                    }\n                    else {\n                        instance.references = joinReferences(instance.references, parent.references);\n                        returnInstances.push(instance);\n                        addedInstanceTimes.add(instance.start);\n                        if (instance.end)\n                            addedInstanceTimes.add(instance.end);\n                    }\n                }\n            }\n        }\n    }\n    returnInstances.sort((a, b) => a.start - b.start);\n    // Ensure unique ids:\n    const ids = {};\n    for (let i = 0; i < returnInstances.length; i++) {\n        const instance = returnInstances[i];\n        // tslint:disable-next-line\n        if (ids[instance.id] !== undefined) {\n            instance.id = instance.id + ++ids[instance.id];\n        }\n        else {\n            ids[instance.id] = 0;\n        }\n    }\n    // Clean up the instances, to remove duplicates\n    returnInstances = cleanInstances(returnInstances, true, true);\n    return returnInstances;\n}\nexports.capInstances = capInstances;\nfunction isReference(ref0) {\n    const ref = ref0;\n    return (typeof ref === 'object' &&\n        !_.isArray(ref) &&\n        ref.value !== undefined &&\n        _.isArray(ref.references) &&\n        ref !== null);\n}\nexports.isReference = isReference;\nfunction joinReferences(...references) {\n    const refMap = {};\n    const refs = [];\n    for (let i = 0; i < references.length; i++) {\n        const reference = references[i];\n        if (reference) {\n            if (typeof reference === 'string') {\n                if (!refMap[reference])\n                    refs.push(reference);\n                refMap[reference] = true;\n            }\n            else {\n                for (let j = 0; j < reference.length; j++) {\n                    const ref = reference[j];\n                    if (ref) {\n                        if (!refMap[ref])\n                            refs.push(ref);\n                        refMap[ref] = true;\n                    }\n                }\n            }\n        }\n    }\n    return refs.sort((a, b) => {\n        if (a > b)\n            return 1;\n        if (a < b)\n            return -1;\n        return 0;\n    });\n}\nexports.joinReferences = joinReferences;\nfunction addCapsToResuming(instance, ...caps) {\n    const capsToAdd = [];\n    const joinedCaps = joinCaps(...caps);\n    for (let i = 0; i < joinedCaps.length; i++) {\n        const cap = joinedCaps[i];\n        if (cap.end !== null && instance.end !== null && cap.end > instance.end) {\n            capsToAdd.push({\n                id: cap.id,\n                start: 0,\n                end: cap.end,\n            });\n        }\n    }\n    instance.caps = joinCaps(instance.caps, capsToAdd);\n}\nexports.addCapsToResuming = addCapsToResuming;\nfunction joinCaps(...caps) {\n    const capMap = {};\n    for (let i = 0; i < caps.length; i++) {\n        const caps2 = caps[i];\n        if (caps2) {\n            for (let j = 0; j < caps2.length; j++) {\n                const cap2 = caps2[j];\n                capMap[cap2.id] = cap2;\n            }\n        }\n    }\n    return Object.values(capMap);\n}\nexports.joinCaps = joinCaps;\nlet idCount = 0;\n/**\n * Returns a unique id\n */\nfunction getId() {\n    return '@' + (idCount++).toString(36);\n}\nexports.getId = getId;\nfunction resetId() {\n    idCount = 0;\n}\nexports.resetId = resetId;\nfunction setInstanceEndTime(instance, endTime) {\n    instance.originalEnd = instance.originalEnd !== undefined ? instance.originalEnd : instance.end;\n    instance.end = endTime;\n}\nexports.setInstanceEndTime = setInstanceEndTime;\nfunction setInstanceStartTime(instance, startTime) {\n    instance.originalStart = instance.originalStart !== undefined ? instance.originalStart : instance.start;\n    instance.start = startTime;\n}\nexports.setInstanceStartTime = setInstanceStartTime;\nfunction applyParentInstances(parentInstances, value) {\n    return operateOnArrays(parentInstances, value, operate);\n}\nexports.applyParentInstances = applyParentInstances;\nfunction operate(a, b) {\n    if (a === null || b === null)\n        return null;\n    return {\n        value: a.value + b.value,\n        references: joinReferences(a.references, b.references),\n    };\n}\nconst cacheResultCache = {};\nlet cleanCacheResultTimeout = null;\n/** Cache the result of function for a limited time */\nfunction cacheResult(name, fcn, limitTime = 1000) {\n    if (Math.random() < 0.01) {\n        if (cleanCacheResultTimeout)\n            clearTimeout(cleanCacheResultTimeout);\n        cleanCacheResultTimeout = setTimeout(() => {\n            cleanCacheResult();\n        }, 100);\n    }\n    const cache = cacheResultCache[name];\n    if (!cache || cache.ttl < Date.now()) {\n        const value = fcn();\n        cacheResultCache[name] = {\n            ttl: Date.now() + limitTime,\n            value: value,\n        };\n        return value;\n    }\n    else {\n        return cache.value;\n    }\n}\nexports.cacheResult = cacheResult;\nfunction cleanCacheResult() {\n    if (cleanCacheResultTimeout) {\n        clearTimeout(cleanCacheResultTimeout);\n        cleanCacheResultTimeout = null;\n    }\n    _.each(cacheResultCache, (cache, name) => {\n        if (cache.ttl < Date.now())\n            delete cacheResultCache[name];\n    });\n}\nexports.cleanCacheResult = cleanCacheResult;\n//# sourceMappingURL=lib.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getObjectReferences = exports.hashTimelineObject = exports.initializeCache = void 0;\nfunction initializeCache(cacheOrg, resolvedTimeline) {\n    const cache = cacheOrg;\n    if (!cache.objHashes)\n        cache.objHashes = {};\n    if (!cache.resolvedTimeline)\n        cache.resolvedTimeline = resolvedTimeline;\n    // Todo: make statistics work when using cache\n    return cache;\n}\nexports.initializeCache = initializeCache;\n/** Return a \"hash-string\" which changes whenever anything that affects timing of a timeline-object has changed. */\nfunction hashTimelineObject(obj) {\n    const thingsThatMatter = [\n        JSON.stringify(obj.enable),\n        obj.disabled + '',\n        obj.priority + '',\n        obj.resolved.parentId || '',\n        obj.resolved.isKeyframe + '',\n        obj.classes ? obj.classes.join('.') : '',\n        obj.layer + '',\n        obj.seamless + '',\n        /*\n        Note: The following properties are ignored, as they don't affect timing or resolving:\n         * id\n         * children\n         * keyframes\n         * isGroup\n         * content\n         */\n    ];\n    return thingsThatMatter.join(',');\n}\nexports.hashTimelineObject = hashTimelineObject;\nfunction getObjectReferences(obj) {\n    return obj.resolved.directReferences;\n}\nexports.getObjectReferences = getObjectReferences;\n//# sourceMappingURL=cache.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addObjectToResolvedTimeline = void 0;\nfunction addObjectToResolvedTimeline(resolvedTimeline, obj) {\n    resolvedTimeline.objects[obj.id] = obj;\n    if (obj.classes) {\n        for (let i = 0; i < obj.classes.length; i++) {\n            const className = obj.classes[i];\n            if (className) {\n                if (!resolvedTimeline.classes[className])\n                    resolvedTimeline.classes[className] = [];\n                resolvedTimeline.classes[className].push(obj.id);\n            }\n        }\n    }\n    if (obj.layer) {\n        if (!resolvedTimeline.layers[obj.layer])\n            resolvedTimeline.layers[obj.layer] = [];\n        resolvedTimeline.layers[obj.layer].push(obj.id);\n    }\n}\nexports.addObjectToResolvedTimeline = addObjectToResolvedTimeline;\n//# sourceMappingURL=common.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateExpression = exports.wrapInnerExpressions = exports.simplifyExpression = exports.interpretExpression = exports.OPERATORS = void 0;\nconst _ = require(\"underscore\");\nconst lib_1 = require(\"../lib\");\nexports.OPERATORS = ['&', '|', '+', '-', '*', '/', '%', '!'];\nconst REGEXP_OPERATORS = _.map(exports.OPERATORS, (o) => '\\\\' + o).join('');\nfunction interpretExpression(expression) {\n    if ((0, lib_1.isNumeric)(expression)) {\n        return parseFloat(expression);\n    }\n    else if (_.isString(expression)) {\n        const expressionString = expression;\n        return (0, lib_1.cacheResult)(expressionString, () => {\n            const expr = expressionString.replace(new RegExp('([' + REGEXP_OPERATORS + '\\\\(\\\\)])', 'g'), ' $1 '); // Make sure there's a space between every operator & operand\n            const words = _.compact(expr.split(' '));\n            if (words.length === 0)\n                return null; // empty expression\n            // Fix special case: a + - b\n            for (let i = words.length - 2; i >= 1; i--) {\n                if ((words[i] === '-' || words[i] === '+') && wordIsOperator(exports.OPERATORS, words[i - 1])) {\n                    words[i] = words[i] + words[i + 1];\n                    words.splice(i + 1, 1);\n                }\n            }\n            const innerExpression = wrapInnerExpressions(words);\n            if (innerExpression.rest.length)\n                throw new Error('interpretExpression: syntax error: parentheses don\\'t add up in \"' + expr + '\".');\n            if (innerExpression.inner.length % 2 !== 1)\n                throw new Error('interpretExpression: operands & operators don\\'t add up: \"' +\n                    innerExpression.inner.join(' ') +\n                    '\".');\n            const expression = words2Expression(exports.OPERATORS, innerExpression.inner);\n            validateExpression(exports.OPERATORS, expression);\n            return expression;\n        }, 100 * 1000);\n    }\n    else {\n        return expression;\n    }\n}\nexports.interpretExpression = interpretExpression;\n/** Try to simplify an expression, this includes:\n * * Combine constant operands, using arithmetic operators\n * ...more to come?\n */\nfunction simplifyExpression(expr0) {\n    const expr = _.isString(expr0) ? interpretExpression(expr0) : expr0;\n    if (!expr)\n        return expr;\n    if (isExpressionObject(expr)) {\n        const l = simplifyExpression(expr.l);\n        const o = expr.o;\n        const r = simplifyExpression(expr.r);\n        if ((0, lib_1.isConstant)(l) && (0, lib_1.isConstant)(r) && _.isNumber(l) && _.isNumber(r)) {\n            // The operands can be combined:\n            return o === '+'\n                ? l + r\n                : o === '-'\n                    ? l - r\n                    : o === '*'\n                        ? l * r\n                        : o === '/'\n                            ? l / r\n                            : o === '%'\n                                ? l % r\n                                : { l, o, r };\n        }\n        return { l, o, r };\n    }\n    return expr;\n}\nexports.simplifyExpression = simplifyExpression;\nfunction isExpressionObject(expr) {\n    return typeof expr === 'object' && _.has(expr, 'l') && _.has(expr, 'o') && _.has(expr, 'r');\n}\nfunction wordIsOperator(operatorList, word) {\n    if (operatorList.indexOf(word) !== -1)\n        return true;\n    return false;\n}\n// Turns ['a', '(', 'b', 'c', ')'] into ['a', ['b', 'c']]\n// or ['a', '&', '!', 'b'] into ['a', '&', ['', '!', 'b']]\nfunction wrapInnerExpressions(words) {\n    for (let i = 0; i < words.length; i++) {\n        if (words[i] === '(') {\n            const tmp = wrapInnerExpressions(words.slice(i + 1));\n            // insert inner expression and remove tha\n            words[i] = tmp.inner;\n            words.splice(i + 1, 99999, ...tmp.rest);\n        }\n        else if (words[i] === ')') {\n            return {\n                inner: words.slice(0, i),\n                rest: words.slice(i + 1),\n            };\n        }\n        else if (words[i] === '!') {\n            const tmp = wrapInnerExpressions(words.slice(i + 1));\n            // insert inner expression after the '!'\n            words[i] = ['', '!'].concat(tmp.inner);\n            words.splice(i + 1, 99999, ...tmp.rest);\n        }\n    }\n    return {\n        inner: words,\n        rest: [],\n    };\n}\nexports.wrapInnerExpressions = wrapInnerExpressions;\nfunction words2Expression(operatorList, words) {\n    if (!words || !words.length)\n        throw new Error('words2Expression: syntax error: unbalanced expression');\n    while (words.length === 1 && _.isArray(words[0]))\n        words = words[0];\n    if (words.length === 1)\n        return words[0];\n    // Find the operator with the highest priority:\n    let operatorI = -1;\n    for (let i = 0; i < operatorList.length; i++) {\n        const operator = operatorList[i];\n        if (operatorI === -1) {\n            operatorI = words.lastIndexOf(operator);\n        }\n    }\n    if (operatorI !== -1) {\n        const l = words.slice(0, operatorI);\n        const r = words.slice(operatorI + 1);\n        const expr = {\n            l: words2Expression(operatorList, l),\n            o: words[operatorI],\n            r: words2Expression(operatorList, r),\n        };\n        return expr;\n    }\n    else\n        throw new Error('words2Expression: syntax error: operator not found: \"' + words.join(' ') + '\"');\n}\n/** Validates an expression. Returns true on success, throws error if not */\nfunction validateExpression(operatorList, expr0, breadcrumbs) {\n    if (!breadcrumbs)\n        breadcrumbs = 'ROOT';\n    if (_.isObject(expr0) && !_.isArray(expr0)) {\n        const expr = expr0;\n        if (!_.has(expr, 'l'))\n            throw new Error(`validateExpression: ${breadcrumbs}.l missing in ${JSON.stringify(expr)}`);\n        if (!_.has(expr, 'o'))\n            throw new Error(`validateExpression: ${breadcrumbs}.o missing in ${JSON.stringify(expr)}`);\n        if (!_.has(expr, 'r'))\n            throw new Error(`validateExpression: ${breadcrumbs}.r missing in ${JSON.stringify(expr)}`);\n        if (!_.isString(expr.o))\n            throw new Error(`validateExpression: ${breadcrumbs}.o not a string`);\n        if (!wordIsOperator(operatorList, expr.o))\n            throw new Error(breadcrumbs + '.o not valid: \"' + expr.o + '\"');\n        return (validateExpression(operatorList, expr.l, breadcrumbs + '.l') &&\n            validateExpression(operatorList, expr.r, breadcrumbs + '.r'));\n    }\n    else if (!_.isNull(expr0) && !_.isString(expr0) && !_.isNumber(expr0)) {\n        throw new Error(`validateExpression: ${breadcrumbs} is of invalid type`);\n    }\n    return true;\n}\nexports.validateExpression = validateExpression;\n//# sourceMappingURL=expression.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lookupExpression = exports.resolveTimelineObj = exports.Resolver = void 0;\nconst _ = require(\"underscore\");\nconst lib_1 = require(\"../lib\");\nconst validate_1 = require(\"./validate\");\nconst expression_1 = require(\"./expression\");\nconst state_1 = require(\"./state\");\nconst common_1 = require(\"./common\");\nconst cache_1 = require(\"./cache\");\nclass Resolver {\n    /**\n     * Go through all objects on the timeline and calculate all the timings.\n     * Returns a ResolvedTimeline which can be piped into Resolver.getState()\n     * @param timeline Array of timeline objects\n     * @param options Resolve options\n     */\n    static resolveTimeline(timeline, options) {\n        if (!_.isArray(timeline))\n            throw new Error('resolveTimeline: parameter timeline missing');\n        if (!options)\n            throw new Error('resolveTimeline: parameter options missing');\n        (0, validate_1.validateTimeline)(timeline, false);\n        (0, lib_1.resetId)();\n        const resolvedTimeline = {\n            options: { ...options },\n            objects: {},\n            classes: {},\n            layers: {},\n            statistics: {\n                unresolvedCount: 0,\n                resolvedCount: 0,\n                resolvedInstanceCount: 0,\n                resolvedObjectCount: 0,\n                resolvedGroupCount: 0,\n                resolvedKeyframeCount: 0,\n                resolvingCount: 0,\n            },\n        };\n        // Step 1: pre-populate resolvedTimeline with objects\n        const addToResolvedTimeline = (obj, levelDeep, parentId, isKeyframe) => {\n            if (resolvedTimeline.objects[obj.id])\n                throw Error(`All timelineObjects must be unique! (duplicate: \"${obj.id}\")`);\n            const o = (0, lib_1.extendMandadory)(_.clone(obj), {\n                resolved: {\n                    resolved: false,\n                    resolving: false,\n                    instances: [],\n                    levelDeep: levelDeep,\n                    isSelfReferencing: false,\n                    directReferences: [],\n                },\n            });\n            if (parentId) {\n                o.resolved.parentId = parentId;\n                o.resolved.directReferences.push(parentId);\n            }\n            if (isKeyframe)\n                o.resolved.isKeyframe = true;\n            (0, common_1.addObjectToResolvedTimeline)(resolvedTimeline, o);\n            // Add children:\n            if (obj.isGroup && obj.children) {\n                for (let i = 0; i < obj.children.length; i++) {\n                    const child = obj.children[i];\n                    addToResolvedTimeline(child, levelDeep + 1, obj.id);\n                }\n            }\n            // Add keyframes:\n            if (obj.keyframes) {\n                for (let i = 0; i < obj.keyframes.length; i++) {\n                    const keyframe = obj.keyframes[i];\n                    const kf2 = (0, lib_1.extendMandadory)(_.clone(keyframe), {\n                        layer: '',\n                    });\n                    addToResolvedTimeline(kf2, levelDeep + 1, obj.id, true);\n                }\n            }\n        };\n        for (let i = 0; i < timeline.length; i++) {\n            const obj = timeline[i];\n            addToResolvedTimeline(obj, 0);\n        }\n        // Step 2: go though and resolve the objects\n        if (options.cache) {\n            // Figure out which objects has changed since last time\n            const cache = (0, cache_1.initializeCache)(options.cache, resolvedTimeline);\n            // Go through all new objects, and determine whether they have changed:\n            const allNewObjects = {};\n            const changedReferences = {};\n            const getAllReferencesThisObjectAffects = (newObj) => {\n                const references = ['#' + newObj.id];\n                if (newObj.classes) {\n                    for (const className of newObj.classes) {\n                        references.push('.' + className);\n                    }\n                }\n                if (newObj.layer)\n                    references.push('$' + newObj.layer);\n                return references;\n            };\n            const addChangedObject = (obj) => {\n                const references = getAllReferencesThisObjectAffects(obj);\n                for (const ref of references) {\n                    changedReferences[ref] = true;\n                }\n            };\n            for (const obj of Object.values(resolvedTimeline.objects)) {\n                const oldHash = cache.objHashes[obj.id];\n                const newHash = (0, cache_1.hashTimelineObject)(obj);\n                allNewObjects[obj.id] = true;\n                if (!oldHash || oldHash !== newHash) {\n                    cache.objHashes[obj.id] = newHash;\n                    addChangedObject(obj);\n                    const oldObj = cache.resolvedTimeline.objects[obj.id];\n                    if (oldObj)\n                        addChangedObject(oldObj);\n                }\n                else {\n                    // No timing-affecting changes detected\n                    // Even though the timeline-properties hasn't changed,\n                    // the content (and other properties) might have:\n                    const oldObj = cache.resolvedTimeline.objects[obj.id];\n                    cache.resolvedTimeline.objects[obj.id] = {\n                        ...obj,\n                        resolved: oldObj.resolved,\n                    };\n                }\n            }\n            if (cache.hasOldData) {\n                // Go through all old hashes, removing the ones that doesn't exist anymore\n                for (const objId in cache.resolvedTimeline.objects) {\n                    if (!allNewObjects[objId]) {\n                        const obj = cache.resolvedTimeline.objects[objId];\n                        delete cache.objHashes[objId];\n                        addChangedObject(obj);\n                    }\n                }\n                // Invalidate objects, by gradually removing the invalidated ones from validObjects\n                // Prepare validObjects:\n                const validObjects = {};\n                for (const obj of Object.values(resolvedTimeline.objects)) {\n                    validObjects[obj.id] = obj;\n                }\n                /** All references that depend on another reference (ie objects, classs or layers): */\n                const affectReferenceMap = {};\n                for (const obj of Object.values(resolvedTimeline.objects)) {\n                    // Add everything that this object affects:\n                    const cachedObj = cache.resolvedTimeline.objects[obj.id];\n                    let affectedReferences = getAllReferencesThisObjectAffects(obj);\n                    if (cachedObj) {\n                        affectedReferences = _.uniq(affectedReferences.concat(getAllReferencesThisObjectAffects(cachedObj)));\n                    }\n                    for (let i = 0; i < affectedReferences.length; i++) {\n                        const ref = affectedReferences[i];\n                        const objRef = '#' + obj.id;\n                        if (ref !== objRef) {\n                            if (!affectReferenceMap[objRef])\n                                affectReferenceMap[objRef] = [];\n                            affectReferenceMap[objRef].push(ref);\n                        }\n                    }\n                    // Add everything that this object is affected by:\n                    if (changedReferences['#' + obj.id]) {\n                        // The object is directly said to be invalid, no need to add it to referencingObjects,\n                        // since it'll be easily invalidated anyway later\n                    }\n                    else {\n                        // Note: we only have to check for the OLD object, since if the old and the new object differs,\n                        // that would mean it'll be directly invalidated anyway.\n                        if (cachedObj) {\n                            // Fetch all references for the object from the last time it was resolved.\n                            // Note: This can be done, since _if_ the object was changed in any way since last resolve\n                            // it'll be invalidated anyway\n                            const dependOnReferences = (0, cache_1.getObjectReferences)(cachedObj);\n                            for (let i = 0; i < dependOnReferences.length; i++) {\n                                const ref = dependOnReferences[i];\n                                if (!affectReferenceMap[ref])\n                                    affectReferenceMap[ref] = [];\n                                affectReferenceMap[ref].push('#' + obj.id);\n                            }\n                        }\n                    }\n                }\n                // Invalidate all changed objects, and recursively invalidate all objects that reference those objects:\n                const handledReferences = {};\n                for (const reference of Object.keys(changedReferences)) {\n                    invalidateObjectsWithReference(handledReferences, reference, affectReferenceMap, validObjects);\n                }\n                // The objects that are left in validObjects at this point are still valid.\n                // We can reuse the old resolving for those:\n                for (const obj of Object.values(validObjects)) {\n                    if (!cache.resolvedTimeline.objects[obj.id])\n                        throw new Error(`Something went wrong: \"${obj.id}\" does not exist in cache.resolvedTimeline.objects`);\n                    resolvedTimeline.objects[obj.id] = cache.resolvedTimeline.objects[obj.id];\n                }\n            }\n            for (const obj of Object.values(resolvedTimeline.objects)) {\n                resolveTimelineObj(resolvedTimeline, obj);\n            }\n            // Save for next time:\n            cache.resolvedTimeline = resolvedTimeline;\n            cache.hasOldData = true;\n            // Update statistics, since that's not accurate after having used the cache:\n            resolvedTimeline.statistics.unresolvedCount = 0;\n            resolvedTimeline.statistics.resolvedCount = 0;\n            resolvedTimeline.statistics.resolvedInstanceCount = 0;\n            resolvedTimeline.statistics.resolvedObjectCount = 0;\n            resolvedTimeline.statistics.resolvedGroupCount = 0;\n            resolvedTimeline.statistics.resolvedKeyframeCount = 0;\n            for (const obj of Object.values(resolvedTimeline.objects)) {\n                updateStatistics(resolvedTimeline, obj);\n            }\n            return resolvedTimeline;\n        }\n        else {\n            // If there are no cache provided, just resolve all objects:\n            for (const obj of Object.values(resolvedTimeline.objects)) {\n                resolveTimelineObj(resolvedTimeline, obj);\n            }\n            return resolvedTimeline;\n        }\n    }\n    /** Calculate the state for all points in time.  */\n    static resolveAllStates(resolvedTimeline, cache) {\n        return (0, state_1.resolveStates)(resolvedTimeline, cache);\n    }\n    /**\n     * Calculate the state at a given point in time.\n     * Using a ResolvedTimeline calculated by Resolver.resolveTimeline() or\n     * a ResolvedStates calculated by Resolver.resolveAllStates()\n     * @param resolved ResolvedTimeline calculated by Resolver.resolveTimeline.\n     * @param time The point in time where to calculate the state\n     * @param eventLimit (Optional) Limits the number of returned upcoming events.\n     */\n    static getState(resolved, time, eventLimit) {\n        return (0, state_1.getState)(resolved, time, eventLimit);\n    }\n}\nexports.Resolver = Resolver;\nfunction resolveTimelineObj(resolvedTimeline, obj) {\n    if (obj.resolved.resolved)\n        return;\n    if (obj.resolved.resolving)\n        throw new Error(`Circular dependency when trying to resolve \"${obj.id}\"`);\n    obj.resolved.resolving = true;\n    resolvedTimeline.statistics.resolvingCount++;\n    let instances = [];\n    let directReferences = [];\n    const enables = _.isArray(obj.enable) ? obj.enable : [obj.enable];\n    for (let i = 0; i < enables.length; i++) {\n        const enable = enables[i];\n        let newInstances = [];\n        const repeatingExpr = enable.repeating !== undefined ? (0, expression_1.interpretExpression)(enable.repeating) : null;\n        const lookedRepeating = lookupExpression(resolvedTimeline, obj, repeatingExpr, 'duration');\n        const lookedupRepeating = lookedRepeating.instances;\n        directReferences = directReferences.concat(lookedRepeating.allReferences);\n        if (_.isArray(lookedupRepeating)) {\n            throw new Error(`lookupExpression should never return an array for .duration lookup`); // perhaps tmp? maybe revisit this at some point\n        }\n        let start = enable.while !== undefined ? enable.while : enable.start !== undefined ? enable.start : '';\n        if (enable.while + '' === '1') {\n            start = 'true';\n        }\n        else if (enable.while + '' === '0') {\n            start = 'false';\n        }\n        const startExpr = (0, expression_1.simplifyExpression)(start);\n        let parentInstances = null;\n        let hasParent = false;\n        let startRefersToParent = false;\n        if (obj.resolved.parentId) {\n            hasParent = true;\n            const lookup = lookupExpression(resolvedTimeline, obj, (0, expression_1.interpretExpression)(`#${obj.resolved.parentId}`), 'start');\n            parentInstances = lookup.instances; // a start-reference will always return an array, or null\n            directReferences = directReferences.concat(lookup.allReferences);\n            if ((0, lib_1.isConstant)(startExpr)) {\n                // Only use parent if the expression resolves to a number (ie doesn't contain any references)\n                startRefersToParent = true;\n            }\n        }\n        const lookupStart = lookupExpression(resolvedTimeline, obj, startExpr, 'start');\n        let lookedupStarts = lookupStart.instances;\n        directReferences = directReferences.concat(lookupStart.allReferences);\n        if (startRefersToParent) {\n            lookedupStarts = (0, lib_1.applyParentInstances)(parentInstances, lookedupStarts);\n        }\n        if (enable.while) {\n            if (_.isArray(lookedupStarts)) {\n                newInstances = lookedupStarts;\n            }\n            else if (lookedupStarts !== null) {\n                newInstances = [\n                    {\n                        id: (0, lib_1.getId)(),\n                        start: lookedupStarts.value,\n                        end: null,\n                        references: lookedupStarts.references,\n                    },\n                ];\n            }\n        }\n        else {\n            const events = [];\n            let iStart = 0;\n            let iEnd = 0;\n            if (_.isArray(lookedupStarts)) {\n                for (let i = 0; i < lookedupStarts.length; i++) {\n                    const instance = lookedupStarts[i];\n                    events.push({\n                        time: instance.start,\n                        value: true,\n                        data: { instance: instance, id: obj.id + '_' + iStart++ },\n                        references: instance.references,\n                    });\n                }\n            }\n            else if (lookedupStarts !== null) {\n                events.push({\n                    time: lookedupStarts.value,\n                    value: true,\n                    data: {\n                        instance: {\n                            id: (0, lib_1.getId)(),\n                            start: lookedupStarts.value,\n                            end: null,\n                            references: lookedupStarts.references,\n                        },\n                        id: obj.id + '_' + iStart++,\n                    },\n                    references: lookedupStarts.references,\n                });\n            }\n            if (enable.end !== undefined) {\n                const endExpr = (0, expression_1.interpretExpression)(enable.end);\n                let endRefersToParent = false;\n                if (obj.resolved.parentId) {\n                    if ((0, lib_1.isConstant)(endExpr)) {\n                        // Only use parent if the expression resolves to a number (ie doesn't contain any references)\n                        endRefersToParent = true;\n                    }\n                }\n                // lookedupEnds will contain an inverted list of instances. Therefore .start means an end\n                const lookupEnd = endExpr ? lookupExpression(resolvedTimeline, obj, endExpr, 'end') : null;\n                let lookedupEnds = lookupEnd ? lookupEnd.instances : null;\n                if (lookupEnd)\n                    directReferences = directReferences.concat(lookupEnd.allReferences);\n                if (endRefersToParent) {\n                    lookedupEnds = (0, lib_1.applyParentInstances)(parentInstances, lookedupEnds);\n                }\n                if (_.isArray(lookedupEnds)) {\n                    for (let i = 0; i < lookedupEnds.length; i++) {\n                        const instance = lookedupEnds[i];\n                        events.push({\n                            time: instance.start,\n                            value: false,\n                            data: { instance: instance, id: obj.id + '_' + iEnd++ },\n                            references: instance.references,\n                        });\n                    }\n                }\n                else if (lookedupEnds !== null) {\n                    events.push({\n                        time: lookedupEnds.value,\n                        value: false,\n                        data: {\n                            instance: {\n                                id: (0, lib_1.getId)(),\n                                start: lookedupEnds.value,\n                                end: null,\n                                references: lookedupEnds.references,\n                            },\n                            id: obj.id + '_' + iEnd++,\n                        },\n                        references: lookedupEnds.references,\n                    });\n                }\n            }\n            else if (enable.duration !== undefined) {\n                const durationExpr = (0, expression_1.interpretExpression)(enable.duration);\n                const lookupDuration = lookupExpression(resolvedTimeline, obj, durationExpr, 'duration');\n                let lookedupDuration = lookupDuration.instances;\n                directReferences = directReferences.concat(lookupDuration.allReferences);\n                if (_.isArray(lookedupDuration) && lookedupDuration.length === 1) {\n                    lookedupDuration = {\n                        value: lookedupDuration[0].start,\n                        references: lookedupDuration[0].references,\n                    };\n                }\n                if (_.isArray(lookedupDuration) && !lookedupDuration.length)\n                    lookedupDuration = null;\n                if (_.isArray(lookedupDuration)) {\n                    throw new Error(`lookupExpression should never return an array for .duration lookup`); // perhaps tmp? maybe revisit this at some point\n                }\n                else if (lookedupDuration !== null) {\n                    if (lookedupRepeating !== null && lookedupDuration.value > lookedupRepeating.value)\n                        lookedupDuration.value = lookedupRepeating.value;\n                    const tmpLookedupDuration = lookedupDuration; // cast type\n                    for (let i = 0; i < events.length; i++) {\n                        const e = events[i];\n                        if (e.value) {\n                            const time = e.time + tmpLookedupDuration.value;\n                            const references = (0, lib_1.joinReferences)(e.references, tmpLookedupDuration.references);\n                            events.push({\n                                time: time,\n                                value: false,\n                                data: {\n                                    id: e.data.id,\n                                    instance: {\n                                        id: e.data.instance.id,\n                                        start: time,\n                                        end: null,\n                                        references: references,\n                                    },\n                                },\n                                references: references,\n                            });\n                        }\n                    }\n                }\n            }\n            newInstances = (0, lib_1.convertEventsToInstances)(events, false);\n        }\n        if (hasParent) {\n            // figure out what parent-instance the instances are tied to, and cap them\n            const cappedInstances = [];\n            for (let i = 0; i < newInstances.length; i++) {\n                const instance = newInstances[i];\n                if (parentInstances) {\n                    const referredParentInstance = _.find(parentInstances, (parentInstance) => {\n                        return instance.references.indexOf(parentInstance.id) !== -1;\n                    });\n                    if (referredParentInstance) {\n                        // If the child refers to its parent, there should be one specific instance to cap into\n                        const cappedInstance = (0, lib_1.capInstances)([instance], [referredParentInstance])[0];\n                        if (cappedInstance) {\n                            if (!cappedInstance.caps)\n                                cappedInstance.caps = [];\n                            cappedInstance.caps.push({\n                                id: referredParentInstance.id,\n                                start: referredParentInstance.start,\n                                end: referredParentInstance.end,\n                            });\n                            cappedInstances.push(cappedInstance);\n                        }\n                    }\n                    else {\n                        // If the child doesn't refer to its parent, it should be capped within all of its parent instances\n                        for (let i = 0; i < parentInstances.length; i++) {\n                            const parentInstance = parentInstances[i];\n                            const cappedInstance = (0, lib_1.capInstances)([instance], [parentInstance])[0];\n                            if (cappedInstance) {\n                                if (parentInstance) {\n                                    if (!cappedInstance.caps)\n                                        cappedInstance.caps = [];\n                                    cappedInstance.caps.push({\n                                        id: parentInstance.id,\n                                        start: parentInstance.start,\n                                        end: parentInstance.end,\n                                    });\n                                }\n                                cappedInstances.push(cappedInstance);\n                            }\n                        }\n                    }\n                }\n            }\n            newInstances = cappedInstances;\n        }\n        newInstances = (0, lib_1.applyRepeatingInstances)(newInstances, lookedupRepeating, resolvedTimeline.options);\n        instances = instances.concat(newInstances);\n    }\n    // Make sure the instance ids are unique:\n    const ids = {};\n    for (const instance of instances) {\n        if (ids[instance.id]) {\n            instance.id = `${instance.id}_${(0, lib_1.getId)()}`;\n        }\n        ids[instance.id] = true;\n    }\n    if (obj.seamless && instances.length > 1) {\n        instances = (0, lib_1.cleanInstances)(instances, true, false);\n    }\n    obj.resolved.resolved = true;\n    obj.resolved.resolving = false;\n    obj.resolved.instances = instances;\n    obj.resolved.directReferences = directReferences;\n    updateStatistics(resolvedTimeline, obj);\n}\nexports.resolveTimelineObj = resolveTimelineObj;\nfunction updateStatistics(resolvedTimeline, obj) {\n    if (obj.resolved.instances.length) {\n        resolvedTimeline.statistics.resolvedInstanceCount += obj.resolved.instances.length;\n        resolvedTimeline.statistics.resolvedCount += 1;\n        if (obj.isGroup) {\n            resolvedTimeline.statistics.resolvedGroupCount += 1;\n        }\n        if (obj.resolved.isKeyframe) {\n            resolvedTimeline.statistics.resolvedKeyframeCount += 1;\n        }\n        else {\n            resolvedTimeline.statistics.resolvedObjectCount += 1;\n        }\n    }\n    else {\n        resolvedTimeline.statistics.unresolvedCount += 1;\n    }\n}\n/** Invalidate all changed objects, and recursively invalidate all objects that reference those objects */\nfunction invalidateObjectsWithReference(handledReferences, reference, affectReferenceMap, validObjects) {\n    if (handledReferences[reference])\n        return; // to avoid infinite loops\n    handledReferences[reference] = true;\n    if (reference[0] === '#') {\n        // an id\n        const objId = reference.slice(1);\n        if (validObjects[objId]) {\n            delete validObjects[objId];\n        }\n    }\n    // Invalidate all objects that depend on any of the references that this reference affects:\n    const affectedReferences = affectReferenceMap[reference];\n    if (affectedReferences) {\n        for (let i = 0; i < affectedReferences.length; i++) {\n            const referencingReference = affectedReferences[i];\n            invalidateObjectsWithReference(handledReferences, referencingReference, affectReferenceMap, validObjects);\n        }\n    }\n}\n/**\n * Look up a reference on the timeline\n * Return values:\n * Array<TimelineObjectInstance>: Instances on the timeline where the reference expression is true\n * ValueWithReference: A singular value which can be combined arithmetically with Instances\n * null: Means \"something is invalid\", an null-value will always return null when combined with other values\n *\n * @param resolvedTimeline\n * @param obj\n * @param expr\n * @param context\n */\nfunction lookupExpression(resolvedTimeline, obj, expr, context) {\n    if (expr === null)\n        return { instances: null, allReferences: [] };\n    if (_.isString(expr) && (0, lib_1.isNumeric)(expr)) {\n        return {\n            instances: {\n                value: parseFloat(expr),\n                references: [],\n            },\n            allReferences: [],\n        };\n    }\n    else if (_.isNumber(expr)) {\n        return {\n            instances: {\n                value: expr,\n                references: [],\n            },\n            allReferences: [],\n        };\n    }\n    else if (_.isString(expr)) {\n        expr = expr.trim();\n        if ((0, lib_1.isConstant)(expr)) {\n            if (expr.match(/^true$/i)) {\n                return {\n                    instances: {\n                        value: 0,\n                        references: [],\n                    },\n                    allReferences: [],\n                };\n            }\n            else if (expr.match(/^false$/i)) {\n                return {\n                    instances: [],\n                    allReferences: [],\n                };\n            }\n        }\n        // Look up string\n        let invert = false;\n        let ignoreFirstIfZero = false;\n        let referencedObjs = [];\n        let ref = context;\n        let rest = '';\n        let objIdsToReference = [];\n        const allReferences = [];\n        let referenceIsOk = false;\n        // Match id, example: \"#objectId.start\"\n        const m = expr.match(/^\\W*#([^.]+)(.*)/);\n        if (m) {\n            const id = m[1];\n            rest = m[2];\n            referenceIsOk = true;\n            objIdsToReference = [id];\n            allReferences.push('#' + id);\n        }\n        else {\n            // Match class, example: \".className.start\"\n            const m = expr.match(/^\\W*\\.([^.]+)(.*)/);\n            if (m) {\n                const className = m[1];\n                rest = m[2];\n                referenceIsOk = true;\n                objIdsToReference = resolvedTimeline.classes[className] || [];\n                allReferences.push('.' + className);\n            }\n            else {\n                // Match layer, example: \"$layer\"\n                const m = expr.match(/^\\W*\\$([^.]+)(.*)/);\n                if (m) {\n                    const layer = m[1];\n                    rest = m[2];\n                    referenceIsOk = true;\n                    objIdsToReference = resolvedTimeline.layers[layer] || [];\n                    allReferences.push('$' + layer);\n                }\n            }\n        }\n        for (let i = 0; i < objIdsToReference.length; i++) {\n            const refObjId = objIdsToReference[i];\n            if (refObjId !== obj.id) {\n                const refObj = resolvedTimeline.objects[refObjId];\n                if (refObj) {\n                    referencedObjs.push(refObj);\n                }\n            }\n            else {\n                // Looks like the object is referencing itself!\n                if (obj.resolved.resolving) {\n                    obj.resolved.isSelfReferencing = true;\n                }\n            }\n        }\n        if (!referenceIsOk) {\n            return { instances: null, allReferences: [] };\n        }\n        if (obj.resolved.isSelfReferencing) {\n            // Exclude any self-referencing objects:\n            referencedObjs = _.filter(referencedObjs, (refObj) => {\n                return !refObj.resolved.isSelfReferencing;\n            });\n        }\n        if (referencedObjs.length) {\n            if (rest.match(/start/))\n                ref = 'start';\n            if (rest.match(/end/))\n                ref = 'end';\n            if (rest.match(/duration/))\n                ref = 'duration';\n            if (ref === 'duration') {\n                // Duration refers to the first object on the resolved timeline\n                const instanceDurations = [];\n                for (let i = 0; i < referencedObjs.length; i++) {\n                    const referencedObj = referencedObjs[i];\n                    resolveTimelineObj(resolvedTimeline, referencedObj);\n                    if (referencedObj.resolved.resolved) {\n                        if (obj.resolved.isSelfReferencing && referencedObj.resolved.isSelfReferencing) {\n                            // If the querying object is self-referencing, exclude any other self-referencing objects,\n                            // ignore the object\n                        }\n                        else {\n                            const firstInstance = _.first(referencedObj.resolved.instances);\n                            if (firstInstance) {\n                                const duration = firstInstance.end !== null ? firstInstance.end - firstInstance.start : null;\n                                if (duration !== null) {\n                                    instanceDurations.push({\n                                        value: duration,\n                                        references: (0, lib_1.joinReferences)(referencedObj.id, firstInstance.references),\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n                let firstDuration = null;\n                for (let i = 0; i < instanceDurations.length; i++) {\n                    const d = instanceDurations[i];\n                    if (firstDuration === null || d.value < firstDuration.value)\n                        firstDuration = d;\n                }\n                return { instances: firstDuration, allReferences: allReferences };\n            }\n            else {\n                let returnInstances = [];\n                if (ref === 'start') {\n                    // nothing\n                }\n                else if (ref === 'end') {\n                    invert = !invert;\n                    ignoreFirstIfZero = true;\n                }\n                else\n                    throw Error(`Unknown ref: \"${ref}\"`);\n                for (let i = 0; i < referencedObjs.length; i++) {\n                    const referencedObj = referencedObjs[i];\n                    resolveTimelineObj(resolvedTimeline, referencedObj);\n                    if (referencedObj.resolved.resolved) {\n                        if (obj.resolved.isSelfReferencing && referencedObj.resolved.isSelfReferencing) {\n                            // If the querying object is self-referencing, exclude any other self-referencing objects,\n                            // ignore the object\n                        }\n                        else {\n                            returnInstances = returnInstances.concat(referencedObj.resolved.instances);\n                        }\n                    }\n                }\n                if (returnInstances.length) {\n                    if (invert) {\n                        returnInstances = (0, lib_1.invertInstances)(returnInstances);\n                    }\n                    else {\n                        returnInstances = (0, lib_1.cleanInstances)(returnInstances, true, true);\n                    }\n                    if (ignoreFirstIfZero) {\n                        const first = _.first(returnInstances);\n                        if (first && first.start === 0) {\n                            returnInstances.splice(0, 1);\n                        }\n                    }\n                    return { instances: returnInstances, allReferences: allReferences };\n                }\n                else {\n                    return { instances: [], allReferences: allReferences };\n                }\n            }\n        }\n        else {\n            return { instances: [], allReferences: allReferences };\n        }\n    }\n    else {\n        if (expr) {\n            const l = lookupExpression(resolvedTimeline, obj, expr.l, context);\n            const r = lookupExpression(resolvedTimeline, obj, expr.r, context);\n            const lookupExpr = {\n                l: l.instances,\n                o: expr.o,\n                r: r.instances,\n            };\n            const allReferences = l.allReferences.concat(r.allReferences);\n            if (lookupExpr.o === '!') {\n                // Discard l, invert and return r:\n                if (lookupExpr.r && _.isArray(lookupExpr.r)) {\n                    return {\n                        instances: (0, lib_1.invertInstances)(lookupExpr.r),\n                        allReferences: allReferences,\n                    };\n                }\n                else {\n                    // We can't invert a value\n                    return {\n                        instances: lookupExpr.r,\n                        allReferences: allReferences,\n                    };\n                }\n            }\n            else {\n                if (_.isNull(lookupExpr.l) || _.isNull(lookupExpr.r)) {\n                    return { instances: null, allReferences: allReferences };\n                }\n                if (lookupExpr.o === '&' || lookupExpr.o === '|') {\n                    let events = [];\n                    const addEvents = (instances, left) => {\n                        for (let i = 0; i < instances.length; i++) {\n                            const instance = instances[i];\n                            if (instance.start !== instance.end) {\n                                // event doesn't actually exist...\n                                events.push({\n                                    left: left,\n                                    time: instance.start,\n                                    value: true,\n                                    references: [],\n                                    data: true,\n                                    instance: instance,\n                                });\n                                if (instance.end !== null) {\n                                    events.push({\n                                        left: left,\n                                        time: instance.end,\n                                        value: false,\n                                        references: [],\n                                        data: false,\n                                        instance: instance,\n                                    });\n                                }\n                            }\n                        }\n                    };\n                    if (_.isArray(lookupExpr.l))\n                        addEvents(lookupExpr.l, true);\n                    if (_.isArray(lookupExpr.r))\n                        addEvents(lookupExpr.r, false);\n                    events = (0, lib_1.sortEvents)(events);\n                    const calcResult = lookupExpr.o === '&'\n                        ? (left, right) => !!(left && right)\n                        : lookupExpr.o === '|'\n                            ? (left, right) => !!(left || right)\n                            : () => {\n                                return false;\n                            };\n                    let leftValue = (0, lib_1.isReference)(lookupExpr.l) ? !!lookupExpr.l.value : false;\n                    let rightValue = (0, lib_1.isReference)(lookupExpr.r) ? !!lookupExpr.r.value : false;\n                    let leftInstance = null;\n                    let rightInstance = null;\n                    let resultValue = calcResult(leftValue, rightValue);\n                    const instances = [];\n                    const updateInstance = (time, value, references, caps) => {\n                        if (value) {\n                            instances.push({\n                                id: (0, lib_1.getId)(),\n                                start: time,\n                                end: null,\n                                references: references,\n                                caps: caps,\n                            });\n                        }\n                        else {\n                            const last = _.last(instances);\n                            if (last) {\n                                last.end = time;\n                                // don't update reference on end\n                            }\n                        }\n                    };\n                    updateInstance(0, resultValue, (0, lib_1.joinReferences)((0, lib_1.isReference)(lookupExpr.l) ? lookupExpr.l.references : [], (0, lib_1.isReference)(lookupExpr.r) ? lookupExpr.r.references : []), []);\n                    for (let i = 0; i < events.length; i++) {\n                        const e = events[i];\n                        const next = events[i + 1];\n                        if (e.left) {\n                            leftValue = e.value;\n                            leftInstance = e.instance;\n                        }\n                        else {\n                            rightValue = e.value;\n                            rightInstance = e.instance;\n                        }\n                        if (!next || next.time !== e.time) {\n                            const newResultValue = calcResult(leftValue, rightValue);\n                            const resultCaps = (leftInstance ? leftInstance.caps || [] : []).concat(rightInstance ? rightInstance.caps || [] : []);\n                            if (newResultValue !== resultValue) {\n                                updateInstance(e.time, newResultValue, (0, lib_1.joinReferences)(leftInstance ? leftInstance.references : [], rightInstance ? rightInstance.references : []), resultCaps);\n                                resultValue = newResultValue;\n                            }\n                        }\n                    }\n                    return { instances: instances, allReferences: allReferences };\n                }\n                else {\n                    const operateInner = lookupExpr.o === '+'\n                        ? (a, b) => {\n                            return {\n                                value: a.value + b.value,\n                                references: (0, lib_1.joinReferences)(a.references, b.references),\n                            };\n                        }\n                        : lookupExpr.o === '-'\n                            ? (a, b) => {\n                                return {\n                                    value: a.value - b.value,\n                                    references: (0, lib_1.joinReferences)(a.references, b.references),\n                                };\n                            }\n                            : lookupExpr.o === '*'\n                                ? (a, b) => {\n                                    return {\n                                        value: a.value * b.value,\n                                        references: (0, lib_1.joinReferences)(a.references, b.references),\n                                    };\n                                }\n                                : lookupExpr.o === '/'\n                                    ? (a, b) => {\n                                        return {\n                                            value: a.value / b.value,\n                                            references: (0, lib_1.joinReferences)(a.references, b.references),\n                                        };\n                                    }\n                                    : lookupExpr.o === '%'\n                                        ? (a, b) => {\n                                            return {\n                                                value: a.value % b.value,\n                                                references: (0, lib_1.joinReferences)(a.references, b.references),\n                                            };\n                                        }\n                                        : () => null;\n                    const operate = (a, b) => {\n                        if (a === null || b === null)\n                            return null;\n                        return operateInner(a, b);\n                    };\n                    const result = (0, lib_1.operateOnArrays)(lookupExpr.l, lookupExpr.r, operate);\n                    return { instances: result, allReferences: allReferences };\n                }\n            }\n        }\n    }\n    return { instances: null, allReferences: [] };\n}\nexports.lookupExpression = lookupExpression;\n//# sourceMappingURL=resolver.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyKeyframeContent = exports.resolveStates = exports.getState = void 0;\nconst _ = require(\"underscore\");\nconst common_1 = require(\"./common\");\nconst enums_1 = require(\"../api/enums\");\nconst lib_1 = require(\"../lib\");\nfunction getState(resolved, time, eventLimit = 0) {\n    const resolvedStates = isResolvedStates(resolved) ? resolved : resolveStates(resolved);\n    const state = {\n        time: time,\n        layers: {},\n        nextEvents: _.filter(resolvedStates.nextEvents, (e) => e.time > time),\n    };\n    if (eventLimit)\n        state.nextEvents = state.nextEvents.slice(0, eventLimit);\n    const layerKeys = Object.keys(resolvedStates.layers);\n    for (let i = 0; i < layerKeys.length; i++) {\n        const layer = layerKeys[i];\n        const o = getStateAtTime(resolvedStates.state, layer, time);\n        if (o)\n            state.layers[layer] = o;\n    }\n    return state;\n}\nexports.getState = getState;\nfunction resolveStates(resolved, cache) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const resolvedStates = {\n        options: resolved.options,\n        statistics: resolved.statistics,\n        // These will be re-created during the state-resolving:\n        objects: {},\n        classes: {},\n        layers: {},\n        state: {},\n        nextEvents: [],\n    };\n    if (cache && resolved.statistics.resolvingCount === 0 && cache.resolvedStates) {\n        // Nothing has changed since last time, just return the states right away:\n        return cache.resolvedStates;\n    }\n    const resolvedObjects = _.values(resolved.objects);\n    // Sort to make sure parent groups are evaluated before their children:\n    resolvedObjects.sort((a, b) => {\n        if ((a.resolved.levelDeep || 0) > (b.resolved.levelDeep || 0))\n            return 1;\n        if ((a.resolved.levelDeep || 0) < (b.resolved.levelDeep || 0))\n            return -1;\n        if (a.id > b.id)\n            return 1;\n        if (a.id < b.id)\n            return -1;\n        return 0;\n    });\n    // Step 1: Collect all points-of-interest (which points in time we want to evaluate)\n    // and which instances that are interesting\n    const pointsInTime = {};\n    const addPointInTime = (time, checkId, order, obj, instance) => {\n        // Note on order: Ending events come before starting events\n        if (!pointsInTime[time + ''])\n            pointsInTime[time + ''] = [];\n        pointsInTime[time + ''].push({ obj, instance, checkId, order });\n    };\n    for (const obj of resolvedObjects) {\n        if (!obj.disabled && obj.resolved.resolved) {\n            if (!obj.resolved.isKeyframe) {\n                const parentTimes = getTimesFromParents(resolved, obj);\n                if (obj.layer) {\n                    // if layer is empty, don't put in state\n                    for (const instance of obj.resolved.instances) {\n                        const timeEvents = [];\n                        timeEvents.push({ time: instance.start, enable: true });\n                        if (instance.end)\n                            timeEvents.push({ time: instance.end, enable: false });\n                        // Also include times from parents, as they could affect the state of this instance:\n                        for (let i = 0; i < parentTimes.length; i++) {\n                            const parentTime = parentTimes[i];\n                            if (parentTime &&\n                                parentTime.time > (instance.start || 0) &&\n                                parentTime.time < ((_a = instance.end) !== null && _a !== void 0 ? _a : Infinity)) {\n                                timeEvents.push(parentTime);\n                            }\n                        }\n                        // Save a reference to this instance on all points in time that could affect it:\n                        for (let i = 0; i < timeEvents.length; i++) {\n                            const timeEvent = timeEvents[i];\n                            if (timeEvent.enable) {\n                                addPointInTime(timeEvent.time, 'start', 1, obj, instance);\n                            }\n                            else {\n                                addPointInTime(timeEvent.time, 'end', 0, obj, instance);\n                            }\n                        }\n                    }\n                }\n            }\n            else if (obj.resolved.isKeyframe && obj.resolved.parentId) {\n                const keyframe = obj;\n                // Also add keyframes to pointsInTime:\n                for (const instance of keyframe.resolved.instances) {\n                    // Keyframe start time\n                    addPointInTime(instance.start, 'start', 1, keyframe, instance);\n                    // Keyframe end time\n                    if (instance.end !== null) {\n                        addPointInTime(instance.end, 'end', 0, keyframe, instance);\n                    }\n                }\n            }\n        }\n    }\n    // Step 2: Resolve the state for the points-of-interest\n    // This is done by sweeping the points-of-interest chronologically,\n    // determining the state for every point in time by adding & removing objects from aspiringInstances\n    // Then sorting it to determine who takes precedence\n    const eventObjectTimes = {};\n    const currentState = {};\n    const activeObjIds = {};\n    const activeKeyframes = {};\n    const activeKeyframesChecked = {};\n    /** The objects in aspiringInstances  */\n    const aspiringInstances = {};\n    const keyframeEvents = [];\n    const times = Object.keys(pointsInTime)\n        .map((time) => parseFloat(time))\n        // Sort chronologically:\n        .sort((a, b) => a - b);\n    // Iterate through all points-of-interest times:\n    for (let i = 0; i < times.length; i++) {\n        const time = times[i];\n        const instancesToCheck = pointsInTime[time];\n        const checkedObjectsThisTime = {};\n        instancesToCheck.sort((a, b) => {\n            if (a.obj.resolved && b.obj.resolved) {\n                // Keyframes comes first:\n                if (a.obj.resolved.isKeyframe && !b.obj.resolved.isKeyframe)\n                    return -1;\n                if (!a.obj.resolved.isKeyframe && b.obj.resolved.isKeyframe)\n                    return 1;\n                if (a.order > b.order)\n                    return 1;\n                if (a.order < b.order)\n                    return -1;\n                // Deeper objects (children in groups) comes later, we want to check the parent groups first:\n                if ((a.obj.resolved.levelDeep || 0) > (b.obj.resolved.levelDeep || 0))\n                    return 1;\n                if ((a.obj.resolved.levelDeep || 0) < (b.obj.resolved.levelDeep || 0))\n                    return -1;\n            }\n            return 0;\n        });\n        for (let j = 0; j < instancesToCheck.length; j++) {\n            const o = instancesToCheck[j];\n            const obj = o.obj;\n            const instance = o.instance;\n            let toBeEnabled = (instance.start || 0) <= time && ((_b = instance.end) !== null && _b !== void 0 ? _b : Infinity) > time;\n            const layer = obj.layer + '';\n            const identifier = obj.id + '_' + instance.id + '_' + o.checkId;\n            if (!checkedObjectsThisTime[identifier]) {\n                // Only check each object and event-type once for every point in time\n                checkedObjectsThisTime[identifier] = true;\n                if (!obj.resolved.isKeyframe) {\n                    // If object has a parent, only set if parent is on a layer (if layer is set for parent)\n                    if (toBeEnabled && obj.resolved.parentId) {\n                        const parentObj = obj.resolved.parentId ? resolved.objects[obj.resolved.parentId] : null;\n                        toBeEnabled = !!(parentObj && (!parentObj.layer || activeObjIds[parentObj.id]));\n                    }\n                    if (!aspiringInstances[obj.layer])\n                        aspiringInstances[obj.layer] = [];\n                    if (toBeEnabled) {\n                        // The instance wants to be enabled (is starting)\n                        // Add to aspiringInstances:\n                        aspiringInstances[obj.layer].push({ obj, instance });\n                    }\n                    else {\n                        // The instance doesn't want to be enabled (is ending)\n                        // Remove from aspiringInstances:\n                        aspiringInstances[layer] = _.reject(aspiringInstances[layer] || [], (o) => o.obj.id === obj.id);\n                    }\n                    // Evaluate the layer to determine who has the throne:\n                    aspiringInstances[layer].sort((a, b) => {\n                        // Determine who takes precedence:\n                        // First, sort using priority\n                        if ((a.obj.priority || 0) < (b.obj.priority || 0))\n                            return 1;\n                        if ((a.obj.priority || 0) > (b.obj.priority || 0))\n                            return -1;\n                        // Then, sort using the start time\n                        if ((a.instance.start || 0) < (b.instance.start || 0))\n                            return 1;\n                        if ((a.instance.start || 0) > (b.instance.start || 0))\n                            return -1;\n                        // Last resort: sort using id:\n                        if (a.obj.id > b.obj.id)\n                            return 1;\n                        if (a.obj.id < b.obj.id)\n                            return -1;\n                        return 0;\n                    });\n                    // Now, the one on top has the throne\n                    // Update current state:\n                    const currentOnTopOfLayer = aspiringInstances[layer][0];\n                    const prevObj = currentState[layer];\n                    const replaceOldObj = currentOnTopOfLayer &&\n                        (!prevObj ||\n                            prevObj.id !== currentOnTopOfLayer.obj.id ||\n                            prevObj.instance.id !== currentOnTopOfLayer.instance.id);\n                    const removeOldObj = !currentOnTopOfLayer && prevObj;\n                    if (replaceOldObj || removeOldObj) {\n                        if (prevObj) {\n                            // Cap the old instance, so it'll end at this point in time:\n                            (0, lib_1.setInstanceEndTime)(prevObj.instance, time);\n                            // Update activeObjIds:\n                            delete activeObjIds[prevObj.id];\n                            // Add to nextEvents:\n                            resolvedStates.nextEvents.push({\n                                type: enums_1.EventType.END,\n                                time: time,\n                                objId: prevObj.id,\n                            });\n                            eventObjectTimes[instance.end + ''] = enums_1.EventType.END;\n                        }\n                    }\n                    let changed = false;\n                    if (replaceOldObj) {\n                        // Set the new object to State\n                        // Construct a new object clone:\n                        let newObj;\n                        if (resolvedStates.objects[currentOnTopOfLayer.obj.id]) {\n                            // Use the already existing one\n                            newObj = resolvedStates.objects[currentOnTopOfLayer.obj.id];\n                        }\n                        else {\n                            newObj = _.clone(currentOnTopOfLayer.obj);\n                            newObj.content = JSON.parse(JSON.stringify(newObj.content));\n                            newObj.resolved = {\n                                ...(newObj.resolved || {}),\n                                instances: [],\n                            };\n                            (0, common_1.addObjectToResolvedTimeline)(resolvedStates, newObj);\n                        }\n                        const newInstance = {\n                            ...currentOnTopOfLayer.instance,\n                            // We're setting new start & end times so they match up with the state:\n                            start: time,\n                            end: null,\n                            fromInstanceId: currentOnTopOfLayer.instance.id,\n                            originalEnd: currentOnTopOfLayer.instance.originalEnd !== undefined\n                                ? currentOnTopOfLayer.instance.originalEnd\n                                : currentOnTopOfLayer.instance.end,\n                            originalStart: currentOnTopOfLayer.instance.originalStart !== undefined\n                                ? currentOnTopOfLayer.instance.originalStart\n                                : currentOnTopOfLayer.instance.start,\n                        };\n                        // Make the instance id unique:\n                        for (let i = 0; i < newObj.resolved.instances.length; i++) {\n                            if (newObj.resolved.instances[i].id === newInstance.id) {\n                                newInstance.id = newInstance.id + '_$' + newObj.resolved.instances.length;\n                            }\n                        }\n                        newObj.resolved.instances.push(newInstance);\n                        const newObjInstance = {\n                            ...newObj,\n                            instance: newInstance,\n                        };\n                        // Save to current state:\n                        currentState[layer] = newObjInstance;\n                        // Update activeObjIds:\n                        activeObjIds[newObjInstance.id] = newObjInstance;\n                        // Add to nextEvents:\n                        resolvedStates.nextEvents.push({\n                            type: enums_1.EventType.START,\n                            time: newInstance.start,\n                            objId: obj.id,\n                        });\n                        eventObjectTimes[newInstance.start + ''] = enums_1.EventType.START;\n                        changed = true;\n                    }\n                    else if (removeOldObj) {\n                        // Remove from current state:\n                        delete currentState[layer];\n                        changed = true;\n                    }\n                    if (changed) {\n                        // Also make sure any children are updated:\n                        // Go through the object on hand, but also the one in the currentState\n                        const parentsToCheck = [];\n                        if (obj.isGroup)\n                            parentsToCheck.push(obj);\n                        if ((_c = currentState[layer]) === null || _c === void 0 ? void 0 : _c.isGroup)\n                            parentsToCheck.push(currentState[layer]);\n                        for (const parent of parentsToCheck) {\n                            if ((_d = parent.children) === null || _d === void 0 ? void 0 : _d.length) {\n                                for (const child0 of parent.children) {\n                                    const child = resolved.objects[child0.id];\n                                    for (const instance of child.resolved.instances) {\n                                        if (instance.start <= time && ((_e = instance.end) !== null && _e !== void 0 ? _e : Infinity) > time) {\n                                            // Add the child instance, because that might be affected:\n                                            addPointInTime(time, 'child', 99, child, instance);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                else {\n                    // Is a keyframe\n                    const keyframe = obj;\n                    // Add keyframe to resolvedStates.objects:\n                    resolvedStates.objects[keyframe.id] = keyframe;\n                    const toBeEnabled = (instance.start || 0) <= time && ((_f = instance.end) !== null && _f !== void 0 ? _f : Infinity) > time;\n                    if (toBeEnabled) {\n                        const newObjInstance = {\n                            ...keyframe,\n                            instance: instance,\n                        };\n                        activeKeyframes[keyframe.id] = newObjInstance;\n                    }\n                    else {\n                        delete activeKeyframes[keyframe.id];\n                        delete activeKeyframesChecked[keyframe.id];\n                    }\n                }\n            }\n        }\n        // Go through keyframes:\n        const activeKeyframesObjIds = Object.keys(activeKeyframes);\n        for (let i = 0; i < activeKeyframesObjIds.length; i++) {\n            const objId = activeKeyframesObjIds[i];\n            const objInstance = activeKeyframes[objId];\n            const keyframe = objInstance;\n            const instance = objInstance.instance;\n            // Check if the keyframe's parent is currently active?\n            if (keyframe.resolved.parentId) {\n                const parentObj = activeObjIds[keyframe.resolved.parentId];\n                if (parentObj && parentObj.layer) {\n                    // keyframe is on an active object\n                    const parentObjInstance = currentState[parentObj.layer];\n                    if (parentObjInstance) {\n                        if (!activeKeyframesChecked[objId]) {\n                            // hasn't started before\n                            activeKeyframesChecked[objId] = true;\n                            // Note: The keyframes are a little bit special, since their contents are applied to their parents.\n                            // That application is done in the getStateAtTime function.\n                            // Add keyframe to nextEvents:\n                            keyframeEvents.push({\n                                type: enums_1.EventType.KEYFRAME,\n                                time: instance.start,\n                                objId: keyframe.id,\n                            });\n                            // Cap end within parent\n                            let instanceEnd = Math.min((_g = instance.end) !== null && _g !== void 0 ? _g : Infinity, (_h = parentObjInstance.instance.end) !== null && _h !== void 0 ? _h : Infinity);\n                            if (instanceEnd === Infinity)\n                                instanceEnd = null;\n                            if (instanceEnd !== null) {\n                                keyframeEvents.push({\n                                    type: enums_1.EventType.KEYFRAME,\n                                    time: instanceEnd,\n                                    objId: keyframe.id,\n                                });\n                            }\n                        }\n                        continue;\n                    }\n                }\n            }\n            // else: the keyframe:s parent isn't active, remove/stop the keyframe then:\n            delete activeKeyframesChecked[objId];\n        }\n    }\n    // At this point, the instances of all objects (excluding keyframes) are properly calculated,\n    // taking into account priorities, clashes etc.\n    // Cap children inside their parents:\n    {\n        const allChildren = Object.values(resolvedStates.objects)\n            .filter((obj) => !!obj.resolved.parentId)\n            // Sort, so that the outermost are handled first:\n            .sort((a, b) => {\n            var _a, _b;\n            return ((_a = a.resolved.levelDeep) !== null && _a !== void 0 ? _a : 0) - ((_b = b.resolved.levelDeep) !== null && _b !== void 0 ? _b : 0);\n        });\n        for (const obj of allChildren) {\n            if (obj.resolved.parentId) {\n                const parent = resolvedStates.objects[obj.resolved.parentId];\n                if (parent) {\n                    obj.resolved.instances = (0, lib_1.cleanInstances)((0, lib_1.capInstances)(obj.resolved.instances, parent.resolved.instances), false, false);\n                }\n            }\n        }\n    }\n    // At this point, all instances of the objects should be properly calculated.\n    // Go through all instances of all objects to create temporary states of all layers and times:\n    {\n        const states = {};\n        for (const id of Object.keys(resolvedStates.objects)) {\n            const obj = resolvedStates.objects[id];\n            const layer = `${obj.layer}`;\n            if (!states[layer])\n                states[layer] = {};\n            const stateLayer = states[layer];\n            if (!obj.resolved.isKeyframe) {\n                for (const instance of obj.resolved.instances) {\n                    const startTime = instance.start + '';\n                    if (!stateLayer[startTime]) {\n                        stateLayer[startTime] = {\n                            startCount: 0,\n                            endCount: 0,\n                            objectInstance: null,\n                        };\n                    }\n                    const newObjInstance = {\n                        ...obj,\n                        instance: instance,\n                    };\n                    stateLayer[startTime].startCount++;\n                    stateLayer[startTime].objectInstance = newObjInstance;\n                    if (instance.end !== null) {\n                        const endTime = instance.end + '';\n                        if (!stateLayer[endTime]) {\n                            stateLayer[endTime] = {\n                                startCount: 0,\n                                endCount: 0,\n                                objectInstance: null,\n                            };\n                        }\n                        stateLayer[endTime].endCount++;\n                    }\n                }\n            }\n        }\n        // Go through the temporary states and apply the changes to the resolvedStates.state:\n        for (const layer of Object.keys(states)) {\n            let sum = 0;\n            const times = Object.keys(states[layer])\n                .map((time) => parseFloat(time))\n                // Sort chronologically:\n                .sort((a, b) => a - b);\n            for (let i = 0; i < times.length; i++) {\n                const time = times[i];\n                const s = states[layer][`${time}`];\n                sum += s.startCount;\n                sum -= s.endCount;\n                // Check for fatal bugs:\n                // If the sum is larger than one, more than one start was found at the same time, which should not be possible.\n                if (sum > 1)\n                    throw new Error(`Too many start events at ${layer} ${time}: ${sum}`);\n                // If the sum is less than zero, there have been more ends than starts, which should not be possible.\n                if (sum < 0)\n                    throw new Error(`Too many end events at ${layer} ${time}: ${sum}`);\n                // Apply the state:\n                if (!resolvedStates.state[layer])\n                    resolvedStates.state[layer] = {};\n                if (sum) {\n                    // This means that the object has started\n                    if (!s.objectInstance)\n                        throw new Error(`objectInstance not set, event though sum=${sum} at ${layer} ${time}`);\n                    resolvedStates.state[layer][time] = [s.objectInstance];\n                }\n                else {\n                    // This means that the object has ended\n                    resolvedStates.state[layer][time] = null;\n                }\n            }\n        }\n    }\n    // Cap keyframes inside their parents:\n    for (const id of Object.keys(resolvedStates.objects)) {\n        {\n            const keyframe = resolvedStates.objects[id];\n            if (keyframe.resolved.isKeyframe && keyframe.resolved.parentId) {\n                const parent = resolvedStates.objects[keyframe.resolved.parentId];\n                if (parent) {\n                    // Cap the keyframe instances within its parents instances:\n                    keyframe.resolved.instances = (0, lib_1.capInstances)(keyframe.resolved.instances, parent.resolved.instances);\n                    // Ensure sure the instances are in the state\n                    for (let i = 0; i < keyframe.resolved.instances.length; i++) {\n                        const instance = keyframe.resolved.instances[i];\n                        const keyframeInstance = {\n                            ...keyframe,\n                            instance: instance,\n                            isKeyframe: true,\n                            keyframeEndTime: instance.end,\n                        };\n                        // Add keyframe to the tracking state:\n                        addKeyframeAtTime(resolvedStates.state, parent.layer + '', instance.start, keyframeInstance);\n                    }\n                }\n            }\n        }\n        // Fix (merge) instances of seamless objects:\n        {\n            const obj = resolvedStates.objects[id];\n            if (obj.seamless && obj.resolved.instances.length > 1) {\n                obj.resolved.instances = (0, lib_1.cleanInstances)(obj.resolved.instances, true, false);\n            }\n        }\n    }\n    // At this point, ALL instances are properly calculated.\n    // Go through the keyframe events and add them to nextEvents:\n    for (let i = 0; i < keyframeEvents.length; i++) {\n        const keyframeEvent = keyframeEvents[i];\n        // tslint:disable-next-line\n        if (eventObjectTimes[keyframeEvent.time + ''] === undefined) {\n            // no need to put a keyframe event if there's already another event there\n            resolvedStates.nextEvents.push(keyframeEvent);\n            eventObjectTimes[keyframeEvent.time + ''] = enums_1.EventType.KEYFRAME;\n        }\n    }\n    resolvedStates.nextEvents.sort((a, b) => {\n        if (a.time > b.time)\n            return 1;\n        if (a.time < b.time)\n            return -1;\n        if (a.type > b.type)\n            return -1;\n        if (a.type < b.type)\n            return 1;\n        if (a.objId < b.objId)\n            return -1;\n        if (a.objId > b.objId)\n            return 1;\n        return 0;\n    });\n    if (cache) {\n        cache.resolvedStates = resolvedStates;\n    }\n    return resolvedStates;\n}\nexports.resolveStates = resolveStates;\nfunction applyKeyframeContent(parentContent, keyframeContent) {\n    for (const [attr, value] of Object.entries(keyframeContent)) {\n        if (_.isArray(value)) {\n            if (!_.isArray(parentContent[attr]))\n                parentContent[attr] = [];\n            applyKeyframeContent(parentContent[attr], value);\n            parentContent[attr].splice(value.length, 99999);\n        }\n        else if (_.isObject(value)) {\n            if (!_.isObject(parentContent[attr]) || _.isArray(parentContent[attr]))\n                parentContent[attr] = {};\n            applyKeyframeContent(parentContent[attr], value);\n        }\n        else {\n            parentContent[attr] = value;\n        }\n    }\n}\nexports.applyKeyframeContent = applyKeyframeContent;\nfunction getTimesFromParents(resolved, obj) {\n    let times = [];\n    const parentObj = obj.resolved.parentId ? resolved.objects[obj.resolved.parentId] : null;\n    if (parentObj && parentObj.resolved.resolved) {\n        for (const instance of parentObj.resolved.instances) {\n            times.push({ time: instance.start, enable: true });\n            if (instance.end)\n                times.push({ time: instance.end, enable: false });\n        }\n        times = times.concat(getTimesFromParents(resolved, parentObj));\n    }\n    return times;\n}\nfunction addKeyframeAtTime(states, layer, time, objInstanceKf) {\n    if (!states[layer])\n        states[layer] = {};\n    const inner = states[layer][time + ''];\n    if (!inner) {\n        states[layer][time + ''] = [objInstanceKf];\n    }\n    else {\n        inner.push(objInstanceKf);\n    }\n}\nfunction getStateAtTime(states, layer, requestTime) {\n    var _a;\n    const layerStates = states[layer] || {};\n    const times = Object.keys(layerStates)\n        .map((time) => parseFloat(time))\n        // Sort chronologically:\n        .sort((a, b) => {\n        return a - b;\n    });\n    let state = null;\n    let isCloned = false;\n    for (let i = 0; i < times.length; i++) {\n        const time = times[i];\n        if (time <= requestTime) {\n            const currentStateInstances = layerStates[time + ''];\n            if (currentStateInstances && currentStateInstances.length) {\n                const keyframes = [];\n                for (let i = 0; i < currentStateInstances.length; i++) {\n                    const currentState = currentStateInstances[i];\n                    if (currentState && currentState.isKeyframe) {\n                        keyframes.push(currentState);\n                    }\n                    else {\n                        state = currentState;\n                        isCloned = false;\n                    }\n                }\n                for (let i = 0; i < keyframes.length; i++) {\n                    const keyframe = keyframes[i];\n                    if (state && keyframe.resolved.parentId === state.id) {\n                        if (((_a = keyframe.keyframeEndTime) !== null && _a !== void 0 ? _a : Infinity) > requestTime) {\n                            if (!isCloned) {\n                                isCloned = true;\n                                state = {\n                                    ...state,\n                                    content: JSON.parse(JSON.stringify(state.content)),\n                                };\n                            }\n                            // Apply the keyframe on the state:\n                            applyKeyframeContent(state.content, keyframe.content);\n                        }\n                    }\n                }\n            }\n            else {\n                state = null;\n                isCloned = false;\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return state;\n}\nfunction isResolvedStates(resolved) {\n    return !!(resolved && typeof resolved === 'object' && resolved.objects && resolved.state && resolved.nextEvents);\n}\n//# sourceMappingURL=state.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateKeyframe = exports.validateObject = exports.validateTimeline = void 0;\nconst _ = require(\"underscore\");\nfunction validateObject0(obj, strict, uniqueIds) {\n    if (!uniqueIds)\n        uniqueIds = {};\n    if (!obj)\n        throw new Error(`Object is undefined`);\n    if (typeof obj !== 'object')\n        throw new Error(`Object is not an object`);\n    if (!obj.id)\n        throw new Error(`Object missing \"id\" attribute`);\n    if (typeof obj.id !== 'string')\n        throw new Error(`Object \"id\" attribute is not a string: \"${obj.id}\"`);\n    if (uniqueIds[obj.id])\n        throw new Error(`Object id \"${obj.id}\" is not unique`);\n    uniqueIds[obj.id] = true;\n    if (obj.layer === undefined)\n        throw new Error(`Object \"${obj.id}\": \"layer\" attribute is undefined`);\n    if (!obj.content)\n        throw new Error(`Object \"${obj.id}\": \"content\" attribute must be set`);\n    if (!obj.enable)\n        throw new Error(`Object \"${obj.id}\": \"enable\" attribute must be set`);\n    const enables = _.isArray(obj.enable) ? obj.enable : [obj.enable];\n    for (let i = 0; i < enables.length; i++) {\n        const enable = enables[i];\n        if (enable.start !== undefined) {\n            if (strict && enable.while !== undefined)\n                throw new Error(`Object \"${obj.id}\": \"enable.start\" and \"enable.while\" cannot be combined`);\n            if (strict && enable.end !== undefined && enable.duration !== undefined)\n                throw new Error(`Object \"${obj.id}\": \"enable.end\" and \"enable.duration\" cannot be combined`);\n        }\n        else if (enable.while !== undefined) {\n            if (strict && enable.end !== undefined)\n                throw new Error(`Object \"${obj.id}\": \"enable.while\" and \"enable.end\" cannot be combined`);\n            if (strict && enable.duration !== undefined)\n                throw new Error(`Object \"${obj.id}\": \"enable.while\" and \"enable.duration\" cannot be combined`);\n        }\n        else\n            throw new Error(`Object \"${obj.id}\": \"enable.start\" or \"enable.while\" must be set`);\n    }\n    if (obj.keyframes) {\n        for (let i = 0; i < obj.keyframes.length; i++) {\n            const keyframe = obj.keyframes[i];\n            try {\n                validateKeyframe0(keyframe, strict, uniqueIds);\n            }\n            catch (e) {\n                throw new Error(`Object \"${obj.id}\" keyframe[${i}]: ${e}`);\n            }\n        }\n    }\n    if (obj.classes) {\n        for (let i = 0; i < obj.classes.length; i++) {\n            const className = obj.classes[i];\n            if (className && typeof className !== 'string')\n                throw new Error(`Object \"${obj.id}\": \"classes[${i}]\" is not a string`);\n        }\n    }\n    if (obj.children && !obj.isGroup)\n        throw new Error(`Object \"${obj.id}\": attribute \"children\" is set but \"isGroup\" is not`);\n    if (obj.isGroup && !obj.children)\n        throw new Error(`Object \"${obj.id}\": attribute \"isGroup\" is set but \"children\" missing`);\n    if (obj.children) {\n        for (let i = 0; i < obj.children.length; i++) {\n            const child = obj.children[i];\n            try {\n                validateObject0(child, strict, uniqueIds);\n            }\n            catch (e) {\n                throw new Error(`Object \"${obj.id}\" child[${i}]: ${e}`);\n            }\n        }\n    }\n    if (obj.priority !== undefined && !_.isNumber(obj.priority))\n        throw new Error(`Object \"${obj.id}\": attribute \"priority\" is not a number`);\n}\nfunction validateKeyframe0(keyframe, strict, uniqueIds) {\n    if (!uniqueIds)\n        uniqueIds = {};\n    if (!keyframe)\n        throw new Error(`Keyframe is undefined`);\n    if (typeof keyframe !== 'object')\n        throw new Error(`Keyframe is not an object`);\n    if (!keyframe.id)\n        throw new Error(`Keyframe missing id attribute`);\n    if (typeof keyframe.id !== 'string')\n        throw new Error(`Keyframe id attribute is not a string: \"${keyframe.id}\"`);\n    if (uniqueIds[keyframe.id])\n        throw new Error(`Keyframe id \"${keyframe.id}\" is not unique`);\n    uniqueIds[keyframe.id] = true;\n    if (!keyframe.content)\n        throw new Error(`Keyframe \"${keyframe.id}\": \"content\" attribute must be set`);\n    if (!keyframe.enable)\n        throw new Error(`Keyframe \"${keyframe.id}\": \"enable\" attribute must be set`);\n    const enables = _.isArray(keyframe.enable) ? keyframe.enable : [keyframe.enable];\n    for (let i = 0; i < enables.length; i++) {\n        const enable = enables[i];\n        if (enable.start !== undefined) {\n            if (strict && enable.while !== undefined)\n                throw new Error(`Keyframe \"${keyframe.id}\": \"enable.start\" and \"enable.while\" cannot be combined`);\n            if (strict && enable.end !== undefined && enable.duration !== undefined)\n                throw new Error(`Keyframe \"${keyframe.id}\": \"enable.end\" and \"enable.duration\" cannot be combined`);\n        }\n        else if (enable.while !== undefined) {\n            if (strict && enable.end !== undefined)\n                throw new Error(`Keyframe \"${keyframe.id}\": \"enable.while\" and \"enable.end\" cannot be combined`);\n            if (strict && enable.duration !== undefined)\n                throw new Error(`Keyframe \"${keyframe.id}\": \"enable.while\" and \"enable.duration\" cannot be combined`);\n        }\n        else\n            throw new Error(`Keyframe \"${keyframe.id}\": \"enable.start\" or \"enable.while\" must be set`);\n    }\n    if (keyframe.classes) {\n        for (let i = 0; i < keyframe.classes.length; i++) {\n            const className = keyframe.classes[i];\n            if (className && !_.isString(className))\n                throw new Error(`Keyframe \"${keyframe.id}\": \"classes[${i}]\" is not a string`);\n        }\n    }\n}\n/**\n * Validates all objects in the timeline. Throws an error if something's wrong\n * @param timeline The timeline to validate\n * @param strict Set to true to enable some strict rules (rules that can possibly be ignored)\n */\nfunction validateTimeline(timeline, strict) {\n    const uniqueIds = {};\n    for (let i = 0; i < timeline.length; i++) {\n        const obj = timeline[i];\n        validateObject0(obj, strict, uniqueIds);\n    }\n}\nexports.validateTimeline = validateTimeline;\n/**\n * Validates a Timeline-object. Throws an error if something's wrong\n * @param timeline The timeline to validate\n * @param strict Set to true to enable some strict rules (rules that can possibly be ignored)\n */\nfunction validateObject(obj, strict) {\n    validateObject0(obj, strict);\n}\nexports.validateObject = validateObject;\n/**\n * Validates a Timeline-keyframe. Throws an error if something's wrong\n * @param timeline The timeline to validate\n * @param strict Set to true to enable some strict rules (rules that can possibly be ignored)\n */\nfunction validateKeyframe(keyframe, strict) {\n    validateKeyframe0(keyframe, strict);\n}\nexports.validateKeyframe = validateKeyframe;\n//# sourceMappingURL=validate.js.map","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global global, define, System, Reflect, Promise */\r\nvar __extends;\r\nvar __assign;\r\nvar __rest;\r\nvar __decorate;\r\nvar __param;\r\nvar __metadata;\r\nvar __awaiter;\r\nvar __generator;\r\nvar __exportStar;\r\nvar __values;\r\nvar __read;\r\nvar __spread;\r\nvar __spreadArrays;\r\nvar __spreadArray;\r\nvar __await;\r\nvar __asyncGenerator;\r\nvar __asyncDelegator;\r\nvar __asyncValues;\r\nvar __makeTemplateObject;\r\nvar __importStar;\r\nvar __importDefault;\r\nvar __classPrivateFieldGet;\r\nvar __classPrivateFieldSet;\r\nvar __classPrivateFieldIn;\r\nvar __createBinding;\r\n(function (factory) {\r\n    var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"tslib\", [\"exports\"], function (exports) { factory(createExporter(root, createExporter(exports))); });\r\n    }\r\n    else if (typeof module === \"object\" && typeof module.exports === \"object\") {\r\n        factory(createExporter(root, createExporter(module.exports)));\r\n    }\r\n    else {\r\n        factory(createExporter(root));\r\n    }\r\n    function createExporter(exports, previous) {\r\n        if (exports !== root) {\r\n            if (typeof Object.create === \"function\") {\r\n                Object.defineProperty(exports, \"__esModule\", { value: true });\r\n            }\r\n            else {\r\n                exports.__esModule = true;\r\n            }\r\n        }\r\n        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };\r\n    }\r\n})\r\n(function (exporter) {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\r\n    __extends = function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n\r\n    __assign = Object.assign || function (t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n\r\n    __rest = function (s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                    t[p[i]] = s[p[i]];\r\n            }\r\n        return t;\r\n    };\r\n\r\n    __decorate = function (decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    };\r\n\r\n    __param = function (paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    };\r\n\r\n    __metadata = function (metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    };\r\n\r\n    __awaiter = function (thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    };\r\n\r\n    __generator = function (thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    };\r\n\r\n    __exportStar = function(m, o) {\r\n        for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n    };\r\n\r\n    __createBinding = Object.create ? (function(o, m, k, k2) {\r\n        if (k2 === undefined) k2 = k;\r\n        var desc = Object.getOwnPropertyDescriptor(m, k);\r\n        if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n            desc = { enumerable: true, get: function() { return m[k]; } };\r\n        }\r\n        Object.defineProperty(o, k2, desc);\r\n    }) : (function(o, m, k, k2) {\r\n        if (k2 === undefined) k2 = k;\r\n        o[k2] = m[k];\r\n    });\r\n\r\n    __values = function (o) {\r\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n        if (m) return m.call(o);\r\n        if (o && typeof o.length === \"number\") return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n    };\r\n\r\n    __read = function (o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    };\r\n\r\n    /** @deprecated */\r\n    __spread = function () {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    };\r\n\r\n    /** @deprecated */\r\n    __spreadArrays = function () {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    };\r\n\r\n    __spreadArray = function (to, from, pack) {\r\n        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n            if (ar || !(i in from)) {\r\n                if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n                ar[i] = from[i];\r\n            }\r\n        }\r\n        return to.concat(ar || Array.prototype.slice.call(from));\r\n    };\r\n\r\n    __await = function (v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    };\r\n\r\n    __asyncGenerator = function (thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    };\r\n\r\n    __asyncDelegator = function (o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n    };\r\n\r\n    __asyncValues = function (o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n    };\r\n\r\n    __makeTemplateObject = function (cooked, raw) {\r\n        if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n        return cooked;\r\n    };\r\n\r\n    var __setModuleDefault = Object.create ? (function(o, v) {\r\n        Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n    }) : function(o, v) {\r\n        o[\"default\"] = v;\r\n    };\r\n\r\n    __importStar = function (mod) {\r\n        if (mod && mod.__esModule) return mod;\r\n        var result = {};\r\n        if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n        __setModuleDefault(result, mod);\r\n        return result;\r\n    };\r\n\r\n    __importDefault = function (mod) {\r\n        return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n    };\r\n\r\n    __classPrivateFieldGet = function (receiver, state, kind, f) {\r\n        if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n        if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n        return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n    };\r\n\r\n    __classPrivateFieldSet = function (receiver, state, value, kind, f) {\r\n        if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n        if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n        if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n        return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n    };\r\n\r\n    __classPrivateFieldIn = function (state, receiver) {\r\n        if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n        return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n    };\r\n\r\n    exporter(\"__extends\", __extends);\r\n    exporter(\"__assign\", __assign);\r\n    exporter(\"__rest\", __rest);\r\n    exporter(\"__decorate\", __decorate);\r\n    exporter(\"__param\", __param);\r\n    exporter(\"__metadata\", __metadata);\r\n    exporter(\"__awaiter\", __awaiter);\r\n    exporter(\"__generator\", __generator);\r\n    exporter(\"__exportStar\", __exportStar);\r\n    exporter(\"__createBinding\", __createBinding);\r\n    exporter(\"__values\", __values);\r\n    exporter(\"__read\", __read);\r\n    exporter(\"__spread\", __spread);\r\n    exporter(\"__spreadArrays\", __spreadArrays);\r\n    exporter(\"__spreadArray\", __spreadArray);\r\n    exporter(\"__await\", __await);\r\n    exporter(\"__asyncGenerator\", __asyncGenerator);\r\n    exporter(\"__asyncDelegator\", __asyncDelegator);\r\n    exporter(\"__asyncValues\", __asyncValues);\r\n    exporter(\"__makeTemplateObject\", __makeTemplateObject);\r\n    exporter(\"__importStar\", __importStar);\r\n    exporter(\"__importDefault\", __importDefault);\r\n    exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet);\r\n    exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet);\r\n    exporter(\"__classPrivateFieldIn\", __classPrivateFieldIn);\r\n});\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\n/* global global, define, System, Reflect, Promise */\r\nvar __extends;\r\nvar __assign;\r\nvar __rest;\r\nvar __decorate;\r\nvar __param;\r\nvar __metadata;\r\nvar __awaiter;\r\nvar __generator;\r\nvar __exportStar;\r\nvar __values;\r\nvar __read;\r\nvar __spread;\r\nvar __spreadArrays;\r\nvar __await;\r\nvar __asyncGenerator;\r\nvar __asyncDelegator;\r\nvar __asyncValues;\r\nvar __makeTemplateObject;\r\nvar __importStar;\r\nvar __importDefault;\r\nvar __classPrivateFieldGet;\r\nvar __classPrivateFieldSet;\r\nvar __createBinding;\r\n(function (factory) {\r\n    var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"tslib\", [\"exports\"], function (exports) { factory(createExporter(root, createExporter(exports))); });\r\n    }\r\n    else if (typeof module === \"object\" && typeof module.exports === \"object\") {\r\n        factory(createExporter(root, createExporter(module.exports)));\r\n    }\r\n    else {\r\n        factory(createExporter(root));\r\n    }\r\n    function createExporter(exports, previous) {\r\n        if (exports !== root) {\r\n            if (typeof Object.create === \"function\") {\r\n                Object.defineProperty(exports, \"__esModule\", { value: true });\r\n            }\r\n            else {\r\n                exports.__esModule = true;\r\n            }\r\n        }\r\n        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };\r\n    }\r\n})\r\n(function (exporter) {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\n    __extends = function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n\r\n    __assign = Object.assign || function (t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n\r\n    __rest = function (s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                    t[p[i]] = s[p[i]];\r\n            }\r\n        return t;\r\n    };\r\n\r\n    __decorate = function (decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    };\r\n\r\n    __param = function (paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    };\r\n\r\n    __metadata = function (metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    };\r\n\r\n    __awaiter = function (thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    };\r\n\r\n    __generator = function (thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    };\r\n\r\n    __createBinding = function(o, m, k, k2) {\r\n        if (k2 === undefined) k2 = k;\r\n        o[k2] = m[k];\r\n    };\r\n\r\n    __exportStar = function (m, exports) {\r\n        for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    };\r\n\r\n    __values = function (o) {\r\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n        if (m) return m.call(o);\r\n        if (o && typeof o.length === \"number\") return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n    };\r\n\r\n    __read = function (o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    };\r\n\r\n    __spread = function () {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    };\r\n\r\n    __spreadArrays = function () {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    };\r\n\r\n    __await = function (v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    };\r\n\r\n    __asyncGenerator = function (thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    };\r\n\r\n    __asyncDelegator = function (o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n    };\r\n\r\n    __asyncValues = function (o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n    };\r\n\r\n    __makeTemplateObject = function (cooked, raw) {\r\n        if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n        return cooked;\r\n    };\r\n\r\n    __importStar = function (mod) {\r\n        if (mod && mod.__esModule) return mod;\r\n        var result = {};\r\n        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n        result[\"default\"] = mod;\r\n        return result;\r\n    };\r\n\r\n    __importDefault = function (mod) {\r\n        return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n    };\r\n\r\n    __classPrivateFieldGet = function (receiver, privateMap) {\r\n        if (!privateMap.has(receiver)) {\r\n            throw new TypeError(\"attempted to get private field on non-instance\");\r\n        }\r\n        return privateMap.get(receiver);\r\n    };\r\n\r\n    __classPrivateFieldSet = function (receiver, privateMap, value) {\r\n        if (!privateMap.has(receiver)) {\r\n            throw new TypeError(\"attempted to set private field on non-instance\");\r\n        }\r\n        privateMap.set(receiver, value);\r\n        return value;\r\n    };\r\n\r\n    exporter(\"__extends\", __extends);\r\n    exporter(\"__assign\", __assign);\r\n    exporter(\"__rest\", __rest);\r\n    exporter(\"__decorate\", __decorate);\r\n    exporter(\"__param\", __param);\r\n    exporter(\"__metadata\", __metadata);\r\n    exporter(\"__awaiter\", __awaiter);\r\n    exporter(\"__generator\", __generator);\r\n    exporter(\"__exportStar\", __exportStar);\r\n    exporter(\"__createBinding\", __createBinding);\r\n    exporter(\"__values\", __values);\r\n    exporter(\"__read\", __read);\r\n    exporter(\"__spread\", __spread);\r\n    exporter(\"__spreadArrays\", __spreadArrays);\r\n    exporter(\"__await\", __await);\r\n    exporter(\"__asyncGenerator\", __asyncGenerator);\r\n    exporter(\"__asyncDelegator\", __asyncDelegator);\r\n    exporter(\"__asyncValues\", __asyncValues);\r\n    exporter(\"__makeTemplateObject\", __makeTemplateObject);\r\n    exporter(\"__importStar\", __importStar);\r\n    exporter(\"__importDefault\", __importDefault);\r\n    exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet);\r\n    exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet);\r\n});\r\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define('underscore', factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (function () {\n    var current = global._;\n    var exports = global._ = factory();\n    exports.noConflict = function () { global._ = current; return exports; };\n  }()));\n}(this, (function () {\n  //     Underscore.js 1.13.4\n  //     https://underscorejs.org\n  //     (c) 2009-2022 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters & Editors\n  //     Underscore may be freely distributed under the MIT license.\n\n  // Current version.\n  var VERSION = '1.13.4';\n\n  // Establish the root object, `window` (`self`) in the browser, `global`\n  // on the server, or `this` in some virtual machines. We use `self`\n  // instead of `window` for `WebWorker` support.\n  var root = (typeof self == 'object' && self.self === self && self) ||\n            (typeof global == 'object' && global.global === global && global) ||\n            Function('return this')() ||\n            {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype;\n  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n\n  // Modern feature detection.\n  var supportsArrayBuffer = typeof ArrayBuffer !== 'undefined',\n      supportsDataView = typeof DataView !== 'undefined';\n\n  // All **ECMAScript 5+** native function implementations that we hope to use\n  // are declared here.\n  var nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeCreate = Object.create,\n      nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;\n\n  // Create references to these builtin functions because we override them.\n  var _isNaN = isNaN,\n      _isFinite = isFinite;\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  // The largest integer that can be represented exactly.\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\n  // Some functions take a variable number of arguments, or a few expected\n  // arguments at the beginning and then a variable number of values to operate\n  // on. This helper accumulates all remaining arguments past the function’s\n  // argument length (or an explicit `startIndex`), into an array that becomes\n  // the last argument. Similar to ES6’s \"rest parameter\".\n  function restArguments(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n      var length = Math.max(arguments.length - startIndex, 0),\n          rest = Array(length),\n          index = 0;\n      for (; index < length; index++) {\n        rest[index] = arguments[index + startIndex];\n      }\n      switch (startIndex) {\n        case 0: return func.call(this, rest);\n        case 1: return func.call(this, arguments[0], rest);\n        case 2: return func.call(this, arguments[0], arguments[1], rest);\n      }\n      var args = Array(startIndex + 1);\n      for (index = 0; index < startIndex; index++) {\n        args[index] = arguments[index];\n      }\n      args[startIndex] = rest;\n      return func.apply(this, args);\n    };\n  }\n\n  // Is a given variable an object?\n  function isObject(obj) {\n    var type = typeof obj;\n    return type === 'function' || (type === 'object' && !!obj);\n  }\n\n  // Is a given value equal to null?\n  function isNull(obj) {\n    return obj === null;\n  }\n\n  // Is a given variable undefined?\n  function isUndefined(obj) {\n    return obj === void 0;\n  }\n\n  // Is a given value a boolean?\n  function isBoolean(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  }\n\n  // Is a given value a DOM element?\n  function isElement(obj) {\n    return !!(obj && obj.nodeType === 1);\n  }\n\n  // Internal function for creating a `toString`-based type tester.\n  function tagTester(name) {\n    var tag = '[object ' + name + ']';\n    return function(obj) {\n      return toString.call(obj) === tag;\n    };\n  }\n\n  var isString = tagTester('String');\n\n  var isNumber = tagTester('Number');\n\n  var isDate = tagTester('Date');\n\n  var isRegExp = tagTester('RegExp');\n\n  var isError = tagTester('Error');\n\n  var isSymbol = tagTester('Symbol');\n\n  var isArrayBuffer = tagTester('ArrayBuffer');\n\n  var isFunction = tagTester('Function');\n\n  // Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old\n  // v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).\n  var nodelist = root.document && root.document.childNodes;\n  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {\n    isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  var isFunction$1 = isFunction;\n\n  var hasObjectTag = tagTester('Object');\n\n  // In IE 10 - Edge 13, `DataView` has string tag `'[object Object]'`.\n  // In IE 11, the most common among them, this problem also applies to\n  // `Map`, `WeakMap` and `Set`.\n  var hasStringTagBug = (\n        supportsDataView && hasObjectTag(new DataView(new ArrayBuffer(8)))\n      ),\n      isIE11 = (typeof Map !== 'undefined' && hasObjectTag(new Map));\n\n  var isDataView = tagTester('DataView');\n\n  // In IE 10 - Edge 13, we need a different heuristic\n  // to determine whether an object is a `DataView`.\n  function ie10IsDataView(obj) {\n    return obj != null && isFunction$1(obj.getInt8) && isArrayBuffer(obj.buffer);\n  }\n\n  var isDataView$1 = (hasStringTagBug ? ie10IsDataView : isDataView);\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native `Array.isArray`.\n  var isArray = nativeIsArray || tagTester('Array');\n\n  // Internal function to check whether `key` is an own property name of `obj`.\n  function has$1(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  }\n\n  var isArguments = tagTester('Arguments');\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  (function() {\n    if (!isArguments(arguments)) {\n      isArguments = function(obj) {\n        return has$1(obj, 'callee');\n      };\n    }\n  }());\n\n  var isArguments$1 = isArguments;\n\n  // Is a given object a finite number?\n  function isFinite$1(obj) {\n    return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));\n  }\n\n  // Is the given value `NaN`?\n  function isNaN$1(obj) {\n    return isNumber(obj) && _isNaN(obj);\n  }\n\n  // Predicate-generating function. Often useful outside of Underscore.\n  function constant(value) {\n    return function() {\n      return value;\n    };\n  }\n\n  // Common internal logic for `isArrayLike` and `isBufferLike`.\n  function createSizePropertyCheck(getSizeProperty) {\n    return function(collection) {\n      var sizeProperty = getSizeProperty(collection);\n      return typeof sizeProperty == 'number' && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;\n    }\n  }\n\n  // Internal helper to generate a function to obtain property `key` from `obj`.\n  function shallowProperty(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  }\n\n  // Internal helper to obtain the `byteLength` property of an object.\n  var getByteLength = shallowProperty('byteLength');\n\n  // Internal helper to determine whether we should spend extensive checks against\n  // `ArrayBuffer` et al.\n  var isBufferLike = createSizePropertyCheck(getByteLength);\n\n  // Is a given value a typed array?\n  var typedArrayPattern = /\\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\\]/;\n  function isTypedArray(obj) {\n    // `ArrayBuffer.isView` is the most future-proof, so use it when available.\n    // Otherwise, fall back on the above regular expression.\n    return nativeIsView ? (nativeIsView(obj) && !isDataView$1(obj)) :\n                  isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));\n  }\n\n  var isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);\n\n  // Internal helper to obtain the `length` property of an object.\n  var getLength = shallowProperty('length');\n\n  // Internal helper to create a simple lookup structure.\n  // `collectNonEnumProps` used to depend on `_.contains`, but this led to\n  // circular imports. `emulatedSet` is a one-off solution that only works for\n  // arrays of strings.\n  function emulatedSet(keys) {\n    var hash = {};\n    for (var l = keys.length, i = 0; i < l; ++i) hash[keys[i]] = true;\n    return {\n      contains: function(key) { return hash[key] === true; },\n      push: function(key) {\n        hash[key] = true;\n        return keys.push(key);\n      }\n    };\n  }\n\n  // Internal helper. Checks `keys` for the presence of keys in IE < 9 that won't\n  // be iterated by `for key in ...` and thus missed. Extends `keys` in place if\n  // needed.\n  function collectNonEnumProps(obj, keys) {\n    keys = emulatedSet(keys);\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = (isFunction$1(constructor) && constructor.prototype) || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (has$1(obj, prop) && !keys.contains(prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) {\n        keys.push(prop);\n      }\n    }\n  }\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`.\n  function keys(obj) {\n    if (!isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (has$1(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  }\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  function isEmpty(obj) {\n    if (obj == null) return true;\n    // Skip the more expensive `toString`-based type checks if `obj` has no\n    // `.length`.\n    var length = getLength(obj);\n    if (typeof length == 'number' && (\n      isArray(obj) || isString(obj) || isArguments$1(obj)\n    )) return length === 0;\n    return getLength(keys(obj)) === 0;\n  }\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  function isMatch(object, attrs) {\n    var _keys = keys(attrs), length = _keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = _keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  }\n\n  // If Underscore is called as a function, it returns a wrapped object that can\n  // be used OO-style. This wrapper holds altered versions of all functions added\n  // through `_.mixin`. Wrapped objects may be chained.\n  function _$1(obj) {\n    if (obj instanceof _$1) return obj;\n    if (!(this instanceof _$1)) return new _$1(obj);\n    this._wrapped = obj;\n  }\n\n  _$1.VERSION = VERSION;\n\n  // Extracts the result from a wrapped and chained object.\n  _$1.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxies for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;\n\n  _$1.prototype.toString = function() {\n    return String(this._wrapped);\n  };\n\n  // Internal function to wrap or shallow-copy an ArrayBuffer,\n  // typed array or DataView to a new view, reusing the buffer.\n  function toBufferView(bufferSource) {\n    return new Uint8Array(\n      bufferSource.buffer || bufferSource,\n      bufferSource.byteOffset || 0,\n      getByteLength(bufferSource)\n    );\n  }\n\n  // We use this string twice, so give it a name for minification.\n  var tagDataView = '[object DataView]';\n\n  // Internal recursive comparison function for `_.isEqual`.\n  function eq(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // `null` or `undefined` only equal to itself (strict comparison).\n    if (a == null || b == null) return false;\n    // `NaN`s are equivalent, but non-reflexive.\n    if (a !== a) return b !== b;\n    // Exhaust primitive checks\n    var type = typeof a;\n    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\n    return deepEq(a, b, aStack, bStack);\n  }\n\n  // Internal recursive comparison function for `_.isEqual`.\n  function deepEq(a, b, aStack, bStack) {\n    // Unwrap any wrapped objects.\n    if (a instanceof _$1) a = a._wrapped;\n    if (b instanceof _$1) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    // Work around a bug in IE 10 - Edge 13.\n    if (hasStringTagBug && className == '[object Object]' && isDataView$1(a)) {\n      if (!isDataView$1(b)) return false;\n      className = tagDataView;\n    }\n    switch (className) {\n      // These types are compared by value.\n      case '[object RegExp]':\n        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN.\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n      case '[object Symbol]':\n        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\n      case '[object ArrayBuffer]':\n      case tagDataView:\n        // Coerce to typed array so we can fall through.\n        return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays && isTypedArray$1(a)) {\n        var byteLength = getByteLength(a);\n        if (byteLength !== getByteLength(b)) return false;\n        if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;\n        areArrays = true;\n    }\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor &&\n                               isFunction$1(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var _keys = keys(a), key;\n      length = _keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = _keys[length];\n        if (!(has$1(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  }\n\n  // Perform a deep comparison to check if two objects are equal.\n  function isEqual(a, b) {\n    return eq(a, b);\n  }\n\n  // Retrieve all the enumerable property names of an object.\n  function allKeys(obj) {\n    if (!isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  }\n\n  // Since the regular `Object.prototype.toString` type tests don't work for\n  // some types in IE 11, we use a fingerprinting heuristic instead, based\n  // on the methods. It's not great, but it's the best we got.\n  // The fingerprint method lists are defined below.\n  function ie11fingerprint(methods) {\n    var length = getLength(methods);\n    return function(obj) {\n      if (obj == null) return false;\n      // `Map`, `WeakMap` and `Set` have no enumerable keys.\n      var keys = allKeys(obj);\n      if (getLength(keys)) return false;\n      for (var i = 0; i < length; i++) {\n        if (!isFunction$1(obj[methods[i]])) return false;\n      }\n      // If we are testing against `WeakMap`, we need to ensure that\n      // `obj` doesn't have a `forEach` method in order to distinguish\n      // it from a regular `Map`.\n      return methods !== weakMapMethods || !isFunction$1(obj[forEachName]);\n    };\n  }\n\n  // In the interest of compact minification, we write\n  // each string in the fingerprints only once.\n  var forEachName = 'forEach',\n      hasName = 'has',\n      commonInit = ['clear', 'delete'],\n      mapTail = ['get', hasName, 'set'];\n\n  // `Map`, `WeakMap` and `Set` each have slightly different\n  // combinations of the above sublists.\n  var mapMethods = commonInit.concat(forEachName, mapTail),\n      weakMapMethods = commonInit.concat(mapTail),\n      setMethods = ['add'].concat(commonInit, forEachName, hasName);\n\n  var isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester('Map');\n\n  var isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester('WeakMap');\n\n  var isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester('Set');\n\n  var isWeakSet = tagTester('WeakSet');\n\n  // Retrieve the values of an object's properties.\n  function values(obj) {\n    var _keys = keys(obj);\n    var length = _keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[_keys[i]];\n    }\n    return values;\n  }\n\n  // Convert an object into a list of `[key, value]` pairs.\n  // The opposite of `_.object` with one argument.\n  function pairs(obj) {\n    var _keys = keys(obj);\n    var length = _keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [_keys[i], obj[_keys[i]]];\n    }\n    return pairs;\n  }\n\n  // Invert the keys and values of an object. The values must be serializable.\n  function invert(obj) {\n    var result = {};\n    var _keys = keys(obj);\n    for (var i = 0, length = _keys.length; i < length; i++) {\n      result[obj[_keys[i]]] = _keys[i];\n    }\n    return result;\n  }\n\n  // Return a sorted list of the function names available on the object.\n  function functions(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (isFunction$1(obj[key])) names.push(key);\n    }\n    return names.sort();\n  }\n\n  // An internal function for creating assigner functions.\n  function createAssigner(keysFunc, defaults) {\n    return function(obj) {\n      var length = arguments.length;\n      if (defaults) obj = Object(obj);\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!defaults || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  }\n\n  // Extend a given object with all the properties in passed-in object(s).\n  var extend = createAssigner(allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in\n  // object(s).\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  var extendOwn = createAssigner(keys);\n\n  // Fill in a given object with default properties.\n  var defaults = createAssigner(allKeys, true);\n\n  // Create a naked function reference for surrogate-prototype-swapping.\n  function ctor() {\n    return function(){};\n  }\n\n  // An internal function for creating a new object that inherits from another.\n  function baseCreate(prototype) {\n    if (!isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    var Ctor = ctor();\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  }\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  function create(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) extendOwn(result, props);\n    return result;\n  }\n\n  // Create a (shallow-cloned) duplicate of an object.\n  function clone(obj) {\n    if (!isObject(obj)) return obj;\n    return isArray(obj) ? obj.slice() : extend({}, obj);\n  }\n\n  // Invokes `interceptor` with the `obj` and then returns `obj`.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  function tap(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  }\n\n  // Normalize a (deep) property `path` to array.\n  // Like `_.iteratee`, this function can be customized.\n  function toPath$1(path) {\n    return isArray(path) ? path : [path];\n  }\n  _$1.toPath = toPath$1;\n\n  // Internal wrapper for `_.toPath` to enable minification.\n  // Similar to `cb` for `_.iteratee`.\n  function toPath(path) {\n    return _$1.toPath(path);\n  }\n\n  // Internal function to obtain a nested property in `obj` along `path`.\n  function deepGet(obj, path) {\n    var length = path.length;\n    for (var i = 0; i < length; i++) {\n      if (obj == null) return void 0;\n      obj = obj[path[i]];\n    }\n    return length ? obj : void 0;\n  }\n\n  // Get the value of the (deep) property on `path` from `object`.\n  // If any property in `path` does not exist or if the value is\n  // `undefined`, return `defaultValue` instead.\n  // The `path` is normalized through `_.toPath`.\n  function get(object, path, defaultValue) {\n    var value = deepGet(object, toPath(path));\n    return isUndefined(value) ? defaultValue : value;\n  }\n\n  // Shortcut function for checking if an object has a given property directly on\n  // itself (in other words, not on a prototype). Unlike the internal `has`\n  // function, this public version can also traverse nested properties.\n  function has(obj, path) {\n    path = toPath(path);\n    var length = path.length;\n    for (var i = 0; i < length; i++) {\n      var key = path[i];\n      if (!has$1(obj, key)) return false;\n      obj = obj[key];\n    }\n    return !!length;\n  }\n\n  // Keep the identity function around for default iteratees.\n  function identity(value) {\n    return value;\n  }\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  function matcher(attrs) {\n    attrs = extendOwn({}, attrs);\n    return function(obj) {\n      return isMatch(obj, attrs);\n    };\n  }\n\n  // Creates a function that, when passed an object, will traverse that object’s\n  // properties down the given `path`, specified as an array of keys or indices.\n  function property(path) {\n    path = toPath(path);\n    return function(obj) {\n      return deepGet(obj, path);\n    };\n  }\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  function optimizeCb(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      // The 2-argument case is omitted because we’re not using it.\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  }\n\n  // An internal function to generate callbacks that can be applied to each\n  // element in a collection, returning the desired result — either `_.identity`,\n  // an arbitrary callback, a property matcher, or a property accessor.\n  function baseIteratee(value, context, argCount) {\n    if (value == null) return identity;\n    if (isFunction$1(value)) return optimizeCb(value, context, argCount);\n    if (isObject(value) && !isArray(value)) return matcher(value);\n    return property(value);\n  }\n\n  // External wrapper for our callback generator. Users may customize\n  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.\n  // This abstraction hides the internal-only `argCount` argument.\n  function iteratee(value, context) {\n    return baseIteratee(value, context, Infinity);\n  }\n  _$1.iteratee = iteratee;\n\n  // The function we call internally to generate a callback. It invokes\n  // `_.iteratee` if overridden, otherwise `baseIteratee`.\n  function cb(value, context, argCount) {\n    if (_$1.iteratee !== iteratee) return _$1.iteratee(value, context);\n    return baseIteratee(value, context, argCount);\n  }\n\n  // Returns the results of applying the `iteratee` to each element of `obj`.\n  // In contrast to `_.map` it returns an object.\n  function mapObject(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var _keys = keys(obj),\n        length = _keys.length,\n        results = {};\n    for (var index = 0; index < length; index++) {\n      var currentKey = _keys[index];\n      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  }\n\n  // Predicate-generating function. Often useful outside of Underscore.\n  function noop(){}\n\n  // Generates a function for a given object that returns a given property.\n  function propertyOf(obj) {\n    if (obj == null) return noop;\n    return function(path) {\n      return get(obj, path);\n    };\n  }\n\n  // Run a function **n** times.\n  function times(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  }\n\n  // Return a random integer between `min` and `max` (inclusive).\n  function random(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  }\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  var now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n  // Internal helper to generate functions for escaping and unescaping strings\n  // to/from HTML interpolation.\n  function createEscaper(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped.\n    var source = '(?:' + keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  }\n\n  // Internal list of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n\n  // Function for escaping strings to HTML interpolation.\n  var _escape = createEscaper(escapeMap);\n\n  // Internal list of HTML entities for unescaping.\n  var unescapeMap = invert(escapeMap);\n\n  // Function for unescaping strings from HTML interpolation.\n  var _unescape = createEscaper(unescapeMap);\n\n  // By default, Underscore uses ERB-style template delimiters. Change the\n  // following template settings to use alternative delimiters.\n  var templateSettings = _$1.templateSettings = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape: /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `_.templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\": \"'\",\n    '\\\\': '\\\\',\n    '\\r': 'r',\n    '\\n': 'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escapeRegExp = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  function escapeChar(match) {\n    return '\\\\' + escapes[match];\n  }\n\n  // In order to prevent third-party code injection through\n  // `_.templateSettings.variable`, we test it against the following regular\n  // expression. It is intentionally a bit more liberal than just matching valid\n  // identifiers, but still prevents possible loopholes through defaults or\n  // destructuring assignment.\n  var bareIdentifier = /^\\s*(\\w|\\$)+\\s*$/;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  function template(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = defaults({}, settings, _$1.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offset.\n      return match;\n    });\n    source += \"';\\n\";\n\n    var argument = settings.variable;\n    if (argument) {\n      // Insure against third-party code injection. (CVE-2021-23358)\n      if (!bareIdentifier.test(argument)) throw new Error(\n        'variable is not a bare identifier: ' + argument\n      );\n    } else {\n      // If a variable is not specified, place data values in local scope.\n      source = 'with(obj||{}){\\n' + source + '}\\n';\n      argument = 'obj';\n    }\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    var render;\n    try {\n      render = new Function(argument, '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _$1);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  }\n\n  // Traverses the children of `obj` along `path`. If a child is a function, it\n  // is invoked with its parent as context. Returns the value of the final\n  // child, or `fallback` if any child is undefined.\n  function result(obj, path, fallback) {\n    path = toPath(path);\n    var length = path.length;\n    if (!length) {\n      return isFunction$1(fallback) ? fallback.call(obj) : fallback;\n    }\n    for (var i = 0; i < length; i++) {\n      var prop = obj == null ? void 0 : obj[path[i]];\n      if (prop === void 0) {\n        prop = fallback;\n        i = length; // Ensure we don't continue iterating.\n      }\n      obj = isFunction$1(prop) ? prop.call(obj) : prop;\n    }\n    return obj;\n  }\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  function uniqueId(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  }\n\n  // Start chaining a wrapped Underscore object.\n  function chain(obj) {\n    var instance = _$1(obj);\n    instance._chain = true;\n    return instance;\n  }\n\n  // Internal function to execute `sourceFunc` bound to `context` with optional\n  // `args`. Determines whether to execute a function as a constructor or as a\n  // normal function.\n  function executeBound(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (isObject(result)) return result;\n    return self;\n  }\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. `_` acts\n  // as a placeholder by default, allowing any combination of arguments to be\n  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.\n  var partial = restArguments(function(func, boundArgs) {\n    var placeholder = partial.placeholder;\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  });\n\n  partial.placeholder = _$1;\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally).\n  var bind = restArguments(function(func, context, args) {\n    if (!isFunction$1(func)) throw new TypeError('Bind must be called on a function');\n    var bound = restArguments(function(callArgs) {\n      return executeBound(func, bound, context, this, args.concat(callArgs));\n    });\n    return bound;\n  });\n\n  // Internal helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object.\n  // Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var isArrayLike = createSizePropertyCheck(getLength);\n\n  // Internal implementation of a recursive `flatten` function.\n  function flatten$1(input, depth, strict, output) {\n    output = output || [];\n    if (!depth && depth !== 0) {\n      depth = Infinity;\n    } else if (depth <= 0) {\n      return output.concat(input);\n    }\n    var idx = output.length;\n    for (var i = 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {\n        // Flatten current level of array or arguments object.\n        if (depth > 1) {\n          flatten$1(value, depth - 1, strict, output);\n          idx = output.length;\n        } else {\n          var j = 0, len = value.length;\n          while (j < len) output[idx++] = value[j++];\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  }\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  var bindAll = restArguments(function(obj, keys) {\n    keys = flatten$1(keys, false, false);\n    var index = keys.length;\n    if (index < 1) throw new Error('bindAll must be passed function names');\n    while (index--) {\n      var key = keys[index];\n      obj[key] = bind(obj[key], obj);\n    }\n    return obj;\n  });\n\n  // Memoize an expensive function by storing its results.\n  function memoize(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!has$1(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  }\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  var delay = restArguments(function(func, wait, args) {\n    return setTimeout(function() {\n      return func.apply(null, args);\n    }, wait);\n  });\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  var defer = partial(delay, _$1, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  function throttle(func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function() {\n      previous = options.leading === false ? 0 : now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function() {\n      var _now = now();\n      if (!previous && options.leading === false) previous = _now;\n      var remaining = wait - (_now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = _now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n\n    throttled.cancel = function() {\n      clearTimeout(timeout);\n      previous = 0;\n      timeout = context = args = null;\n    };\n\n    return throttled;\n  }\n\n  // When a sequence of calls of the returned function ends, the argument\n  // function is triggered. The end of a sequence is defined by the `wait`\n  // parameter. If `immediate` is passed, the argument function will be\n  // triggered at the beginning of the sequence instead of at the end.\n  function debounce(func, wait, immediate) {\n    var timeout, previous, args, result, context;\n\n    var later = function() {\n      var passed = now() - previous;\n      if (wait > passed) {\n        timeout = setTimeout(later, wait - passed);\n      } else {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n        // This check is needed because `func` can recursively invoke `debounced`.\n        if (!timeout) args = context = null;\n      }\n    };\n\n    var debounced = restArguments(function(_args) {\n      context = this;\n      args = _args;\n      previous = now();\n      if (!timeout) {\n        timeout = setTimeout(later, wait);\n        if (immediate) result = func.apply(context, args);\n      }\n      return result;\n    });\n\n    debounced.cancel = function() {\n      clearTimeout(timeout);\n      timeout = args = context = null;\n    };\n\n    return debounced;\n  }\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  function wrap(func, wrapper) {\n    return partial(wrapper, func);\n  }\n\n  // Returns a negated version of the passed-in predicate.\n  function negate(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  }\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  function compose() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  }\n\n  // Returns a function that will only be executed on and after the Nth call.\n  function after(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  }\n\n  // Returns a function that will only be executed up to (but not including) the\n  // Nth call.\n  function before(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  }\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  var once = partial(before, 2);\n\n  // Returns the first key on an object that passes a truth test.\n  function findKey(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var _keys = keys(obj), key;\n    for (var i = 0, length = _keys.length; i < length; i++) {\n      key = _keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  }\n\n  // Internal function to generate `_.findIndex` and `_.findLastIndex`.\n  function createPredicateIndexFinder(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  }\n\n  // Returns the first index on an array-like that passes a truth test.\n  var findIndex = createPredicateIndexFinder(1);\n\n  // Returns the last index on an array-like that passes a truth test.\n  var findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  function sortedIndex(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  }\n\n  // Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.\n  function createIndexFinder(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n          i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), isNaN$1);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  }\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  var indexOf = createIndexFinder(1, findIndex, sortedIndex);\n\n  // Return the position of the last occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  var lastIndexOf = createIndexFinder(-1, findLastIndex);\n\n  // Return the first value which passes a truth test.\n  function find(obj, predicate, context) {\n    var keyFinder = isArrayLike(obj) ? findIndex : findKey;\n    var key = keyFinder(obj, predicate, context);\n    if (key !== void 0 && key !== -1) return obj[key];\n  }\n\n  // Convenience version of a common use case of `_.find`: getting the first\n  // object containing specific `key:value` pairs.\n  function findWhere(obj, attrs) {\n    return find(obj, matcher(attrs));\n  }\n\n  // The cornerstone for collection functions, an `each`\n  // implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  function each(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var _keys = keys(obj);\n      for (i = 0, length = _keys.length; i < length; i++) {\n        iteratee(obj[_keys[i]], _keys[i], obj);\n      }\n    }\n    return obj;\n  }\n\n  // Return the results of applying the iteratee to each element.\n  function map(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var _keys = !isArrayLike(obj) && keys(obj),\n        length = (_keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = _keys ? _keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  }\n\n  // Internal helper to create a reducing function, iterating left or right.\n  function createReduce(dir) {\n    // Wrap code that reassigns argument variables in a separate function than\n    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)\n    var reducer = function(obj, iteratee, memo, initial) {\n      var _keys = !isArrayLike(obj) && keys(obj),\n          length = (_keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      if (!initial) {\n        memo = obj[_keys ? _keys[index] : index];\n        index += dir;\n      }\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = _keys ? _keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    };\n\n    return function(obj, iteratee, memo, context) {\n      var initial = arguments.length >= 3;\n      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);\n    };\n  }\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  var reduce = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  var reduceRight = createReduce(-1);\n\n  // Return all the elements that pass a truth test.\n  function filter(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  }\n\n  // Return all the elements for which a truth test fails.\n  function reject(obj, predicate, context) {\n    return filter(obj, negate(cb(predicate)), context);\n  }\n\n  // Determine whether all of the elements pass a truth test.\n  function every(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var _keys = !isArrayLike(obj) && keys(obj),\n        length = (_keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = _keys ? _keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  }\n\n  // Determine if at least one element in the object passes a truth test.\n  function some(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var _keys = !isArrayLike(obj) && keys(obj),\n        length = (_keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = _keys ? _keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  }\n\n  // Determine if the array or object contains a given item (using `===`).\n  function contains(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return indexOf(obj, item, fromIndex) >= 0;\n  }\n\n  // Invoke a method (with arguments) on every item in a collection.\n  var invoke = restArguments(function(obj, path, args) {\n    var contextPath, func;\n    if (isFunction$1(path)) {\n      func = path;\n    } else {\n      path = toPath(path);\n      contextPath = path.slice(0, -1);\n      path = path[path.length - 1];\n    }\n    return map(obj, function(context) {\n      var method = func;\n      if (!method) {\n        if (contextPath && contextPath.length) {\n          context = deepGet(context, contextPath);\n        }\n        if (context == null) return void 0;\n        method = context[path];\n      }\n      return method == null ? method : method.apply(context, args);\n    });\n  });\n\n  // Convenience version of a common use case of `_.map`: fetching a property.\n  function pluck(obj, key) {\n    return map(obj, property(key));\n  }\n\n  // Convenience version of a common use case of `_.filter`: selecting only\n  // objects containing specific `key:value` pairs.\n  function where(obj, attrs) {\n    return filter(obj, matcher(attrs));\n  }\n\n  // Return the maximum element (or element-based computation).\n  function max(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {\n      obj = isArrayLike(obj) ? obj : values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      each(obj, function(v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed > lastComputed || (computed === -Infinity && result === -Infinity)) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  }\n\n  // Return the minimum element (or element-based computation).\n  function min(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {\n      obj = isArrayLike(obj) ? obj : values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      each(obj, function(v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed < lastComputed || (computed === Infinity && result === Infinity)) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  }\n\n  // Safely create a real, live array from anything iterable.\n  var reStrSymbol = /[^\\ud800-\\udfff]|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff]/g;\n  function toArray(obj) {\n    if (!obj) return [];\n    if (isArray(obj)) return slice.call(obj);\n    if (isString(obj)) {\n      // Keep surrogate pair characters together.\n      return obj.match(reStrSymbol);\n    }\n    if (isArrayLike(obj)) return map(obj, identity);\n    return values(obj);\n  }\n\n  // Sample **n** random values from a collection using the modern version of the\n  // [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `_.map`.\n  function sample(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = values(obj);\n      return obj[random(obj.length - 1)];\n    }\n    var sample = toArray(obj);\n    var length = getLength(sample);\n    n = Math.max(Math.min(n, length), 0);\n    var last = length - 1;\n    for (var index = 0; index < n; index++) {\n      var rand = random(index, last);\n      var temp = sample[index];\n      sample[index] = sample[rand];\n      sample[rand] = temp;\n    }\n    return sample.slice(0, n);\n  }\n\n  // Shuffle a collection.\n  function shuffle(obj) {\n    return sample(obj, Infinity);\n  }\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  function sortBy(obj, iteratee, context) {\n    var index = 0;\n    iteratee = cb(iteratee, context);\n    return pluck(map(obj, function(value, key, list) {\n      return {\n        value: value,\n        index: index++,\n        criteria: iteratee(value, key, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  }\n\n  // An internal function used for aggregate \"group by\" operations.\n  function group(behavior, partition) {\n    return function(obj, iteratee, context) {\n      var result = partition ? [[], []] : {};\n      iteratee = cb(iteratee, context);\n      each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  }\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  var groupBy = group(function(result, value, key) {\n    if (has$1(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `_.groupBy`, but for\n  // when you know that your index values will be unique.\n  var indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  var countBy = group(function(result, value, key) {\n    if (has$1(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Split a collection into two arrays: one whose elements all pass the given\n  // truth test, and one whose elements all do not pass the truth test.\n  var partition = group(function(result, value, pass) {\n    result[pass ? 0 : 1].push(value);\n  }, true);\n\n  // Return the number of elements in a collection.\n  function size(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : keys(obj).length;\n  }\n\n  // Internal `_.pick` helper function to determine whether `key` is an enumerable\n  // property name of `obj`.\n  function keyInObj(value, key, obj) {\n    return key in obj;\n  }\n\n  // Return a copy of the object only containing the allowed properties.\n  var pick = restArguments(function(obj, keys) {\n    var result = {}, iteratee = keys[0];\n    if (obj == null) return result;\n    if (isFunction$1(iteratee)) {\n      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);\n      keys = allKeys(obj);\n    } else {\n      iteratee = keyInObj;\n      keys = flatten$1(keys, false, false);\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  });\n\n  // Return a copy of the object without the disallowed properties.\n  var omit = restArguments(function(obj, keys) {\n    var iteratee = keys[0], context;\n    if (isFunction$1(iteratee)) {\n      iteratee = negate(iteratee);\n      if (keys.length > 1) context = keys[1];\n    } else {\n      keys = map(flatten$1(keys, false, false), String);\n      iteratee = function(value, key) {\n        return !contains(keys, key);\n      };\n    }\n    return pick(obj, iteratee, context);\n  });\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  function initial(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  }\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  function first(array, n, guard) {\n    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];\n    if (n == null || guard) return array[0];\n    return initial(array, array.length - n);\n  }\n\n  // Returns everything but the first entry of the `array`. Especially useful on\n  // the `arguments` object. Passing an **n** will return the rest N values in the\n  // `array`.\n  function rest(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  }\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  function last(array, n, guard) {\n    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];\n    if (n == null || guard) return array[array.length - 1];\n    return rest(array, Math.max(0, array.length - n));\n  }\n\n  // Trim out all falsy values from an array.\n  function compact(array) {\n    return filter(array, Boolean);\n  }\n\n  // Flatten out an array, either recursively (by default), or up to `depth`.\n  // Passing `true` or `false` as `depth` means `1` or `Infinity`, respectively.\n  function flatten(array, depth) {\n    return flatten$1(array, depth, false);\n  }\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  var difference = restArguments(function(array, rest) {\n    rest = flatten$1(rest, true, true);\n    return filter(array, function(value){\n      return !contains(rest, value);\n    });\n  });\n\n  // Return a version of the array that does not contain the specified value(s).\n  var without = restArguments(function(array, otherArrays) {\n    return difference(array, otherArrays);\n  });\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // The faster algorithm will not work with an iteratee if the iteratee\n  // is not a one-to-one function, so providing an iteratee will disable\n  // the faster algorithm.\n  function uniq(array, isSorted, iteratee, context) {\n    if (!isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted && !iteratee) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  }\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  var union = restArguments(function(arrays) {\n    return uniq(flatten$1(arrays, true, true));\n  });\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  function intersection(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (contains(result, item)) continue;\n      var j;\n      for (j = 1; j < argsLength; j++) {\n        if (!contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  }\n\n  // Complement of zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices.\n  function unzip(array) {\n    var length = (array && max(array, getLength).length) || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = pluck(array, index);\n    }\n    return result;\n  }\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  var zip = restArguments(unzip);\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values. Passing by pairs is the reverse of `_.pairs`.\n  function object(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  }\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](https://docs.python.org/library/functions.html#range).\n  function range(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    if (!step) {\n      step = stop < start ? -1 : 1;\n    }\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  }\n\n  // Chunk a single array into multiple arrays, each containing `count` or fewer\n  // items.\n  function chunk(array, count) {\n    if (count == null || count < 1) return [];\n    var result = [];\n    var i = 0, length = array.length;\n    while (i < length) {\n      result.push(slice.call(array, i, i += count));\n    }\n    return result;\n  }\n\n  // Helper function to continue chaining intermediate results.\n  function chainResult(instance, obj) {\n    return instance._chain ? _$1(obj).chain() : obj;\n  }\n\n  // Add your own custom functions to the Underscore object.\n  function mixin(obj) {\n    each(functions(obj), function(name) {\n      var func = _$1[name] = obj[name];\n      _$1.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return chainResult(this, func.apply(_$1, args));\n      };\n    });\n    return _$1;\n  }\n\n  // Add all mutator `Array` functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _$1.prototype[name] = function() {\n      var obj = this._wrapped;\n      if (obj != null) {\n        method.apply(obj, arguments);\n        if ((name === 'shift' || name === 'splice') && obj.length === 0) {\n          delete obj[0];\n        }\n      }\n      return chainResult(this, obj);\n    };\n  });\n\n  // Add all accessor `Array` functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _$1.prototype[name] = function() {\n      var obj = this._wrapped;\n      if (obj != null) obj = method.apply(obj, arguments);\n      return chainResult(this, obj);\n    };\n  });\n\n  // Named Exports\n\n  var allExports = {\n    __proto__: null,\n    VERSION: VERSION,\n    restArguments: restArguments,\n    isObject: isObject,\n    isNull: isNull,\n    isUndefined: isUndefined,\n    isBoolean: isBoolean,\n    isElement: isElement,\n    isString: isString,\n    isNumber: isNumber,\n    isDate: isDate,\n    isRegExp: isRegExp,\n    isError: isError,\n    isSymbol: isSymbol,\n    isArrayBuffer: isArrayBuffer,\n    isDataView: isDataView$1,\n    isArray: isArray,\n    isFunction: isFunction$1,\n    isArguments: isArguments$1,\n    isFinite: isFinite$1,\n    isNaN: isNaN$1,\n    isTypedArray: isTypedArray$1,\n    isEmpty: isEmpty,\n    isMatch: isMatch,\n    isEqual: isEqual,\n    isMap: isMap,\n    isWeakMap: isWeakMap,\n    isSet: isSet,\n    isWeakSet: isWeakSet,\n    keys: keys,\n    allKeys: allKeys,\n    values: values,\n    pairs: pairs,\n    invert: invert,\n    functions: functions,\n    methods: functions,\n    extend: extend,\n    extendOwn: extendOwn,\n    assign: extendOwn,\n    defaults: defaults,\n    create: create,\n    clone: clone,\n    tap: tap,\n    get: get,\n    has: has,\n    mapObject: mapObject,\n    identity: identity,\n    constant: constant,\n    noop: noop,\n    toPath: toPath$1,\n    property: property,\n    propertyOf: propertyOf,\n    matcher: matcher,\n    matches: matcher,\n    times: times,\n    random: random,\n    now: now,\n    escape: _escape,\n    unescape: _unescape,\n    templateSettings: templateSettings,\n    template: template,\n    result: result,\n    uniqueId: uniqueId,\n    chain: chain,\n    iteratee: iteratee,\n    partial: partial,\n    bind: bind,\n    bindAll: bindAll,\n    memoize: memoize,\n    delay: delay,\n    defer: defer,\n    throttle: throttle,\n    debounce: debounce,\n    wrap: wrap,\n    negate: negate,\n    compose: compose,\n    after: after,\n    before: before,\n    once: once,\n    findKey: findKey,\n    findIndex: findIndex,\n    findLastIndex: findLastIndex,\n    sortedIndex: sortedIndex,\n    indexOf: indexOf,\n    lastIndexOf: lastIndexOf,\n    find: find,\n    detect: find,\n    findWhere: findWhere,\n    each: each,\n    forEach: each,\n    map: map,\n    collect: map,\n    reduce: reduce,\n    foldl: reduce,\n    inject: reduce,\n    reduceRight: reduceRight,\n    foldr: reduceRight,\n    filter: filter,\n    select: filter,\n    reject: reject,\n    every: every,\n    all: every,\n    some: some,\n    any: some,\n    contains: contains,\n    includes: contains,\n    include: contains,\n    invoke: invoke,\n    pluck: pluck,\n    where: where,\n    max: max,\n    min: min,\n    shuffle: shuffle,\n    sample: sample,\n    sortBy: sortBy,\n    groupBy: groupBy,\n    indexBy: indexBy,\n    countBy: countBy,\n    partition: partition,\n    toArray: toArray,\n    size: size,\n    pick: pick,\n    omit: omit,\n    first: first,\n    head: first,\n    take: first,\n    initial: initial,\n    last: last,\n    rest: rest,\n    tail: rest,\n    drop: rest,\n    compact: compact,\n    flatten: flatten,\n    without: without,\n    uniq: uniq,\n    unique: uniq,\n    union: union,\n    intersection: intersection,\n    difference: difference,\n    unzip: unzip,\n    transpose: unzip,\n    zip: zip,\n    object: object,\n    range: range,\n    chunk: chunk,\n    mixin: mixin,\n    'default': _$1\n  };\n\n  // Default Export\n\n  // Add all of the Underscore functions to the wrapper object.\n  var _ = mixin(allExports);\n  // Legacy Node.js API.\n  _._ = _;\n\n  return _;\n\n})));\n//# sourceMappingURL=underscore-umd.js.map\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2luZGV4LmpzIiwiZGlzdC9saWIvdGltZWxpbmVWaXN1YWxpemVyLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmlzZXF1YWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvZGlzdC9hcGkvYXBpLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyZmx5LXRpbWVsaW5lL2Rpc3QvYXBpL2VudW1zLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyZmx5LXRpbWVsaW5lL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvZGlzdC9saWIuanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvZGlzdC9yZXNvbHZlci9jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L3Jlc29sdmVyL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L3Jlc29sdmVyL2V4cHJlc3Npb24uanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvZGlzdC9yZXNvbHZlci9yZXNvbHZlci5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L3Jlc29sdmVyL3N0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyZmx5LXRpbWVsaW5lL2Rpc3QvcmVzb2x2ZXIvdmFsaWRhdGUuanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzIiwibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS11bWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3h6REE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdm5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvdGltZWxpbmVWaXN1YWxpemVyXCIpLCBleHBvcnRzKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5UaW1lbGluZVZpc3VhbGl6ZXIgPSB2b2lkIDA7XHJcbmNvbnN0IGlzRXF1YWwgPSByZXF1aXJlKFwibG9kYXNoLmlzZXF1YWxcIik7XHJcbmNvbnN0IHN1cGVyZmx5X3RpbWVsaW5lXzEgPSByZXF1aXJlKFwic3VwZXJmbHktdGltZWxpbmVcIik7XHJcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcclxuLyoqIFN0ZXAgc2l6ZS8gdGltZSBzdGVwLiAqL1xyXG5jb25zdCBERUZBVUxUX1NURVBfU0laRSA9IDE7XHJcbi8qKiBXaWR0aCBvZiBsYWJlbCBjb2x1bW4uICovXHJcbmNvbnN0IExBQkVMX1dJRFRIX09GX1RJTUVMSU5FID0gMC4yNTtcclxuLyoqIERlZmF1bHQgem9vbSAqL1xyXG5jb25zdCBERUZBVUxUX1pPT01fVkFMVUUgPSAxMDA7XHJcbi8qKiBGYWN0b3IgdG8gem9vbSBieSAqL1xyXG5jb25zdCBaT09NX0ZBQ1RPUiA9IDEuMDAxO1xyXG4vKiogRmFjdG9yIHRvIHBhbiBieSAocGFuID0gUEFOX0ZBQ1RPUiAqIFNURVBfU0laRSkgKi9cclxuY29uc3QgUEFOX0ZBQ1RPUiA9IDEwO1xyXG4vKiogTWF4aW11bSBsYXllciBoZWlnaHQgKi9cclxuY29uc3QgTUFYX0xBWUVSX0hFSUdIVCA9IDYwO1xyXG4vKiogQW1vdW50IHRvIG1vdmUgcGxheWhlYWQgcGVyIHNlY29uZC4gKi9cclxuY29uc3QgREVGQVVMVF9QTEFZSEVBRF9TUEVFRCA9IDE7XHJcbi8qKiBCRUdJTiBTVFlMSU5HIFZBTFVFUyAqL1xyXG4vKiogVGltZWxpbmUgYmFja2dyb3VuZCBjb2xvci4gKi9cclxuY29uc3QgQ09MT1JfQkFDS0dST1VORCA9ICcjMzMzMzMzJztcclxuLyoqIExheWVyIGxhYmVsIGJhY2tncm91bmQgY29sb3IuICovXHJcbmNvbnN0IENPTE9SX0xBQkVMX0JBQ0tHUk9VTkQgPSAnIzY2NjY2Nic7XHJcbi8qKiBDb2xvciBvZiB0aGUgcnVsZXIgbGluZXMgKi9cclxuY29uc3QgUlVMRVJfTElORV9DT0xPUiA9ICcjOTk5OTk5JztcclxuLyoqIFdpZHRoIG9mIHRoZSBydWxlciBsaW5lcyAqL1xyXG5jb25zdCBSVUxFUl9MSU5FX1dJRFRIID0gMTtcclxuLyoqIFBsYXloZWFkIGNvbG9yLiAqL1xyXG5jb25zdCBDT0xPUl9QTEFZSEVBRCA9ICdyZ2JhKDI1NSwgMCwgMCwgMC41KSc7XHJcbi8qKiBQbGF5aGVhZCB0aGlja25lc3MuICovXHJcbmNvbnN0IFRISUNLTkVTU19QTEFZSEVBRCA9IDU7XHJcbi8qKiBDb2xvciBvZiBsaW5lIHNlcGFyYXRpbmcgdGltZWxpbmUgcm93cy4gKi9cclxuY29uc3QgQ09MT1JfTElORSA9ICdibGFjayc7XHJcbi8qKiBIZWlnaHQgb2YgbGluZSBzZXBhcmF0aW5nIHJvd3MuICovXHJcbmNvbnN0IFRISUNLTkVTU19MSU5FID0gMTtcclxuLyoqIFRleHQgcHJvcGVydGllcy4gKi9cclxuY29uc3QgVEVYVF9GT05UX0ZBTUlMWSA9ICdDYWxpYnJpJztcclxuY29uc3QgVEVYVF9GT05UX1NJWkUgPSAxNjtcclxuY29uc3QgVEVYVF9DT0xPUiA9ICd3aGl0ZSc7XHJcbi8qKiBUaW1lbGluZSBvYmplY3QgcHJvcGVydGllcy4gKi9cclxuY29uc3QgQ09MT1JfVElNRUxJTkVfT0JKRUNUX0ZJTEwgPSAncmdiKDIyLCAxMDIsIDI0NywgMC43NSknO1xyXG5jb25zdCBDT0xPUl9USU1FTElORV9PQkpFQ1RfQk9SREVSID0gJ3JnYmEoMjMyLCAyNDAsIDI1NSwgMC44NSknO1xyXG5jb25zdCBUSElDS05FU1NfVElNRUxJTkVfT0JKRUNUX0JPUkRFUiA9IDE7XHJcbi8qKiBUaW1lbGluZSBvYmplY3QgaGVpZ2h0IGFzIGEgcHJvcG9ydGlvbiBvZiB0aGUgcm93IGhlaWdodC4gKi9cclxuY29uc3QgVElNRUxJTkVfT0JKRUNUX0hFSUdIVCA9IDE7XHJcbi8qKiBFTkQgU1RZTElORyBWQUxVRVMgKi9cclxuLyoqIEJFR0lOIENPTlNUQU5UUyBGT1IgU1RBVEUgTUFOQUdFTUVOVCAqL1xyXG5jb25zdCBNT1VTRUlOID0gMDtcclxuY29uc3QgTU9VU0VPVVQgPSAxO1xyXG5jbGFzcyBUaW1lbGluZVZpc3VhbGl6ZXIgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2FudmFzSWQgVGhlIElEIG9mIHRoZSBjYW52YXMgb2JqZWN0IHRvIGRyYXcgd2l0aGluLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjYW52YXNJZCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAvLyBTdGVwIHNpemUuXHJcbiAgICAgICAgdGhpcy5zdGVwU2l6ZSA9IERFRkFVTFRfU1RFUF9TSVpFO1xyXG4gICAgICAgIC8qKiBAcHJpdmF0ZSBAcmVhZG9ubHkgUHJvcG9ydGlvbiBvZiB0aGUgY2FudmFzIHRvIGJlIHVzZWQgZm9yIHRoZSBsYXllciBsYWJlbHMgY29sdW1uLiAqL1xyXG4gICAgICAgIHRoaXMuX2xheWVyTGFiZWxXaWR0aFByb3BvcnRpb25PZkNhbnZhcyA9IExBQkVMX1dJRFRIX09GX1RJTUVMSU5FO1xyXG4gICAgICAgIC8qKiBMYXllcnMgb24gdGltZWxpbmUuICovXHJcbiAgICAgICAgdGhpcy5fbGF5ZXJMYWJlbHMgPSB7fTtcclxuICAgICAgICAvKiogU3RhdGUgb2YgdGhlIHRpbWVsaW5lLiAqL1xyXG4gICAgICAgIHRoaXMuX3RpbWVsaW5lU3RhdGUgPSB7fTtcclxuICAgICAgICAvKiogTWFwIG9mIG9iamVjdHMgZm9yIGRldGVybWluaW5nIGhvdmVyZWQgb2JqZWN0ICovXHJcbiAgICAgICAgdGhpcy5faG92ZXJlZE9iamVjdE1hcCA9IHt9O1xyXG4gICAgICAgIC8qKiBTdGFydCB0aW1lIG9mIHRoZSBjdXJyZW50IHZpZXcuIERlZmluZXMgdGhlIG9iamVjdHMgd2l0aGluIHZpZXcgb24gdGhlIHRpbWVsaW5lIFt0aW1lXSAqL1xyXG4gICAgICAgIHRoaXMuX3ZpZXdTdGFydFRpbWUgPSAwO1xyXG4gICAgICAgIC8qKiBSYW5nZSBvZiB0aGUgY3VycmVudCB2aWV3IFt0aW1lXSAqL1xyXG4gICAgICAgIC8vIHByaXZhdGUgX3ZpZXdUaW1lUmFuZ2U6IG51bWJlciA9IDFcclxuICAgICAgICAvLyBwcml2YXRlIF9kcmF3VGltZUVuZDogbnVtYmVyXHJcbiAgICAgICAgLyoqIFN0b3JlIHdoZXRoZXIgdGhlIG1vdXNlIGlzIGhlbGQgZG93biwgZm9yIHNjcm9sbGluZy4gKi9cclxuICAgICAgICB0aGlzLl9tb3VzZURvd24gPSBmYWxzZTtcclxuICAgICAgICAvKiogQ3VycmVudCB6b29tIGFtb3VudC4gKi9cclxuICAgICAgICB0aGlzLl90aW1lbGluZVpvb20gPSBERUZBVUxUX1pPT01fVkFMVUU7XHJcbiAgICAgICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBwbGF5aGVhZCBzaG91bGQgbW92ZS4gKi9cclxuICAgICAgICB0aGlzLl9wbGF5SGVhZFBsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICAvKiogU3BlZWQgb2YgdGhlIHBsYXloZWFkIFt1bml0cyAvIHNlY29uZF0gKi9cclxuICAgICAgICB0aGlzLl9wbGF5U3BlZWQgPSBERUZBVUxUX1BMQVlIRUFEX1NQRUVEO1xyXG4gICAgICAgIC8qKiBUaGUgY3VycmVudCB0aW1lIHBvc2l0aW9uIG9mIHRoZSBwbGF5aGVhZC4gKi9cclxuICAgICAgICB0aGlzLl9wbGF5SGVhZFRpbWUgPSAwO1xyXG4gICAgICAgIC8qKiBUaGUgbGFzdCB0aW1lIHVwZGF0ZURyYXcoKSBkaWQgYSBkcmF3LiAqL1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZURyYXdMYXN0VGltZSA9IDA7XHJcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIG1vdXNlIGxhc3QgbW92ZWQgb3ZlciBhbiBvYmplY3Qgb3Igb3V0LiAqL1xyXG4gICAgICAgIHRoaXMuX2xhc3RIb3ZlckFjdGlvbiA9IE1PVVNFT1VUO1xyXG4gICAgICAgIC8qKiBOYW1lIG9mIG9iamVjdCB0aGF0IHdhcyBsYXN0IGhvdmVyZWQgb3Zlci4gKi9cclxuICAgICAgICB0aGlzLl9sYXN0SG92ZXJlZEhhc2ggPSAnJztcclxuICAgICAgICAvKiogSWYgdGhlIHZpc3VhbGl6ZXIgYXV0b21hdGljYWxseSBzaG91bGQgcmUtcmVzb2x2ZSB0aGUgdGltZWxpbmUgd2hlbiBuYXZpZ2F0aW5nIHRoZSB2aWV3cG9ydCAqL1xyXG4gICAgICAgIHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUF1dG8gPSBmYWxzZTtcclxuICAgICAgICAvKiogQXQgd2hhdCB0aW1lIHRoZSB0aW1lbGluZSB3YXMgcmVzb2x2ZWQgW3RpbWVdICovXHJcbiAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlU3RhcnQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUVuZCA9IDA7XHJcbiAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlWm9vbSA9IDE7XHJcbiAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlQ291bnQgPSAxMDA7XHJcbiAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlQ291bnRBZGp1c3QgPSAxO1xyXG4gICAgICAgIC8qKiBIb3cgbXVjaCBleHRyYSAob3V0c2lkZSB0aGUgY3VycmVudCB2aWV3cG9ydCkgdGhlIHRpbWVsaW5lIHNob3VsZCBiZSByZXNvbHZlZCB0byBbcmF0aW9dICovXHJcbiAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlRXhwYW5kID0gMztcclxuICAgICAgICB0aGlzLmxhdGVzdFVwZGF0ZVRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMucmVyZXNvbHZlVGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbWVyZ2VJdGVyYXRvciA9IDA7XHJcbiAgICAgICAgLy8gSW5pdGlhbGlzZSBvdGhlciB2YWx1ZXMuXHJcbiAgICAgICAgdGhpcy5fY2FudmFzSWQgPSBjYW52YXNJZDtcclxuICAgICAgICB0aGlzLmluaXRDYW52YXMoKTtcclxuICAgICAgICB0aGlzLl9kcmF3UGxheWhlYWQgPSAhIW9wdGlvbnMuZHJhd1BsYXloZWFkO1xyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB3aWR0aCBvZiBsYWJlbCBjb2x1bW4uXHJcbiAgICAgICAgdGhpcy5fbGF5ZXJMYWJlbFdpZHRoID0gdGhpcy5fY2FudmFzV2lkdGggKiB0aGlzLl9sYXllckxhYmVsV2lkdGhQcm9wb3J0aW9uT2ZDYW52YXM7XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRpbWVsaW5lIHdpZHRoIGFuZCBzdGFydCBwb2ludC5cclxuICAgICAgICB0aGlzLl92aWV3RHJhd1ggPSB0aGlzLl9sYXllckxhYmVsV2lkdGg7XHJcbiAgICAgICAgdGhpcy5fdmlld0RyYXdXaWR0aCA9IHRoaXMuX2NhbnZhc1dpZHRoIC0gdGhpcy5fbGF5ZXJMYWJlbFdpZHRoO1xyXG4gICAgICAgIC8vIERyYXcgYmFja2dyb3VuZC5cclxuICAgICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XHJcbiAgICAgICAgLy8gRHJhdyBwbGF5aGVhZC5cclxuICAgICAgICB0aGlzLmRyYXdQbGF5aGVhZCgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRHJhdygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXNlcyB0aGUgY2FudmFzIGFuZCByZWdpc3RlcnMgY2FudmFzIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgaW5pdENhbnZhcygpIHtcclxuICAgICAgICAvLyBDcmVhdGUgbmV3IGNhbnZhcyBvYmplY3QuXHJcbiAgICAgICAgdGhpcy5fY2FudmFzQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fY2FudmFzSWQpO1xyXG4gICAgICAgIGlmICghdGhpcy5fY2FudmFzQ29udGFpbmVyKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbnZhcyBcIiR7dGhpcy5fY2FudmFzSWR9XCIgbm90IGZvdW5kYCk7XHJcbiAgICAgICAgLy8gR2V0IHJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IHRoaXMuX2NhbnZhc0NvbnRhaW5lci5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIC8vIFJlZ2lzdGVyIGNhbnZhcyBpbnRlcmFjdGlvbiBldmVudCBoYW5kbGVycy5cclxuICAgICAgICB0aGlzLl9jYW52YXNDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGV2ZW50KSA9PiB0aGlzLmNhbnZhc01vdXNlRG93bihldmVudCkpO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhc0NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKGV2ZW50KSA9PiB0aGlzLmNhbnZhc01vdXNlVXAoZXZlbnQpKTtcclxuICAgICAgICB0aGlzLl9jYW52YXNDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGV2ZW50KSA9PiB0aGlzLmNhbnZhc01vdXNlTW92ZShldmVudCkpO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhc0NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIChldmVudCkgPT4gdGhpcy5jYW52YXNTY3JvbGxXaGVlbChldmVudCkpO1xyXG4gICAgICAgIC8vIEdldCB3aWR0aCBhbmQgaGVpZ2h0IG9mIGNhbnZhcy5cclxuICAgICAgICB0aGlzLl9jYW52YXNXaWR0aCA9IHRoaXMuX2NhbnZhc0NvbnRhaW5lci53aWR0aDtcclxuICAgICAgICB0aGlzLl9jYW52YXNIZWlnaHQgPSB0aGlzLl9jYW52YXNDb250YWluZXIuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB0aW1lbGluZSwgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIGFjdGlvbnMgYXJlIGFkZGVkL3JlbW92ZWQgZnJvbSBhIHRpbWVsaW5lXHJcbiAgICAgKiBidXQgdGhlIHNhbWUgdGltZWxpbmUgaXMgYmVpbmcgZHJhd24uXHJcbiAgICAgKiBAcGFyYW0ge1RpbWVsaW5lT2JqZWN0W119IHRpbWVsaW5lIFRpbWVsaW5lIHRvIGRyYXcuXHJcbiAgICAgKiBAcGFyYW0ge1Jlc29sdmVPcHRpb25zfSBvcHRpb25zIFJlc29sdmUgb3B0aW9ucy5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlVGltZWxpbmUodGltZWxpbmUsIG9wdGlvbnMpIHtcclxuICAgICAgICAvLyBJZiBvcHRpb25zIGhhdmUgbm90IGJlZW4gc3BlY2lmaWVkIHNldCB0aW1lIHRvIDAuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgdGltZTogMCxcclxuICAgICAgICAgICAgICAgIGxpbWl0Q291bnQ6IDEwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGF0ZXN0VGltZWxpbmUgPSB0aW1lbGluZTtcclxuICAgICAgICB0aGlzLmxhdGVzdE9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIGlmICghb3B0aW9ucy5saW1pdFRpbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlQXV0byA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lbGluZVJlc29sdmVBdXRvID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMyID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUF1dG8pIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVUaW1lbGluZVJlc29sdmVXaW5kb3coKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkU3RhdGVzID09PSB1bmRlZmluZWQpIHsgLy8gSWYgZmlyc3QgdGltZSB0aGlzIHJ1bnNcclxuICAgICAgICAgICAgLy8gU2V0IHRpbWVsaW5lIHN0YXJ0IGFuZCBlbmQgdGltZXMuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zMi50aW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdTdGFydFRpbWUgPSBvcHRpb25zMi50aW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE1vdmUgcGxheWhlYWQgdG8gc3RhcnQgdGltZS5cclxuICAgICAgICAgICAgdGhpcy5fcGxheUhlYWRUaW1lID0gdGhpcy5fdmlld1N0YXJ0VGltZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlVGltZWxpbmUodHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlVGltZWxpbmUoZnJvbU5ld1RpbWVsaW5lID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zMiA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMubGF0ZXN0T3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUF1dG8pIHtcclxuICAgICAgICAgICAgb3B0aW9uczIudGltZSA9IHRoaXMuX3RpbWVsaW5lUmVzb2x2ZVN0YXJ0O1xyXG4gICAgICAgICAgICBvcHRpb25zMi5saW1pdFRpbWUgPSB0aGlzLl90aW1lbGluZVJlc29sdmVFbmQ7XHJcbiAgICAgICAgICAgIG9wdGlvbnMyLmxpbWl0Q291bnQgPSBNYXRoLmNlaWwodGhpcy5fdGltZWxpbmVSZXNvbHZlQ291bnQgKiB0aGlzLl90aW1lbGluZVJlc29sdmVDb3VudEFkanVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZSBwbGF5aGVhZCBpcyBiZWluZyBkcmF3biwgdGhlIHJlc29sdmUgdGltZSBzaG91bGQgYmUgYXQgdGhlIHBsYXloZWFkIHRpbWUuXHJcbiAgICAgICAgaWYgKHRoaXMuX2RyYXdQbGF5aGVhZCAmJiB0aGlzLl9wbGF5SGVhZFRpbWUgPiBvcHRpb25zMi50aW1lKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMyLnRpbWUgPSB0aGlzLl9wbGF5SGVhZFRpbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlc29sdmUgdGhlIHRpbWVsaW5lLlxyXG4gICAgICAgIGNvbnN0IHN0YXJ0UmVzb2x2ZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRUaW1lbGluZSA9IHN1cGVyZmx5X3RpbWVsaW5lXzEuUmVzb2x2ZXIucmVzb2x2ZVRpbWVsaW5lKHRoaXMubGF0ZXN0VGltZWxpbmUsIG9wdGlvbnMyKTtcclxuICAgICAgICBsZXQgbmV3UmVzb2x2ZWRTdGF0ZXMgPSBzdXBlcmZseV90aW1lbGluZV8xLlJlc29sdmVyLnJlc29sdmVBbGxTdGF0ZXMocmVzb2x2ZWRUaW1lbGluZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkU3RhdGVzID09PSB1bmRlZmluZWQpIHsgLy8gSWYgZmlyc3QgdGltZSB0aGlzIHJ1bnNcclxuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWRTdGF0ZXMgPSBuZXdSZXNvbHZlZFN0YXRlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3UGxheWhlYWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRyaW0gdGhlIGN1cnJlbnQgdGltZWxpbmU6XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3UmVzb2x2ZWRTdGF0ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNZXJnZSB0aGUgdGltZWxpbmVzLlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVkU3RhdGVzID0gdGhpcy5tZXJnZVRpbWVsaW5lT2JqZWN0cyh0aGlzLl9yZXNvbHZlZFN0YXRlcywgbmV3UmVzb2x2ZWRTdGF0ZXMsIGZyb21OZXdUaW1lbGluZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2Ugb25seSBzZWUgb25lIHRpbWVsaW5lIGF0IGEgdGltZS5cclxuICAgICAgICAgICAgICAgIC8vIE92ZXJ3cml0ZSB0aGUgcHJldmlvdXMgdGltZWxpbmU6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlZFN0YXRlcyA9IG5ld1Jlc29sdmVkU3RhdGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBsYXllcnMuXHJcbiAgICAgICAgdGhpcy51cGRhdGVMYXllckxhYmVscygpO1xyXG4gICAgICAgIHRoaXMubGF0ZXN0VXBkYXRlVGltZSA9IERhdGUubm93KCkgLSBzdGFydFJlc29sdmU7XHJcbiAgICAgICAgLy8gUmVkcmF3IHRoZSB0aW1lbGluZS5cclxuICAgICAgICB0aGlzLnJlZHJhd1RpbWVsaW5lKCk7XHJcbiAgICAgICAgdGhpcy5sYXRlc3RVcGRhdGVUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0UmVzb2x2ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmlld3BvcnQgdG8gYSBwb3NpdGlvbiwgem9vbSwgYW5kIHBsYXliYWNrIHNwZWVkLlxyXG4gICAgICogUGxheWJhY2sgc3BlZWQgY3VycmVudGx5IG5vdCBpbXBsZW1lbnRlZC5cclxuICAgICAqIEBwYXJhbSB2aWV3UG9ydCBPYmplY3QgdG8gdXBkYXRlIHZpZXdwb3J0IHdpdGguXHJcbiAgICAgKi9cclxuICAgIHNldFZpZXdQb3J0KHZpZXdQb3J0KSB7XHJcbiAgICAgICAgLy8gV2hldGhlciB0aGUgdmlld3BvcnQgaGFzIGNoYW5nZWQuXHJcbiAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICAvLyBJZiB6b29tIGhhcyBiZWVuIHNwZWNpZmllZC5cclxuICAgICAgICBpZiAodmlld1BvcnQuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIFpvb20gdG8gc3BlY2lmaWVkIHpvb20uXHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lWm9vbSA9IHZpZXdQb3J0Lnpvb207XHJcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aW1lc3RhbXAgaGFzIGJlZW4gc3BlY2lmaWVkLlxyXG4gICAgICAgIGlmICh2aWV3UG9ydC50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBTZXQgc3RhcnQgdGltZSB0byBzcGVjaWZpZWQgdGltZS5cclxuICAgICAgICAgICAgaWYgKHZpZXdQb3J0LnRpbWVzdGFtcCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdTdGFydFRpbWUgPSB2aWV3UG9ydC50aW1lc3RhbXA7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmlld1BvcnQucGxheVZpZXdQb3J0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGxheVZpZXdQb3J0ID0gdmlld1BvcnQucGxheVZpZXdQb3J0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGUgcGxheWJhY2sgc3BlZWQgaGFzIGJlZW4gc2V0LCBzZXQgdGhlIG5ldyBwbGF5YmFjayBzcGVlZC5cclxuICAgICAgICBpZiAodmlld1BvcnQucGxheVNwZWVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kcmF3UGxheWhlYWQpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFZpZXdQb3J0OiB2aWV3UG9ydC5wbGF5U3BlZWQgd2FzIHNldCwgYnV0IGRyYXdQbGF5aGVhZCB3YXMgbm90IHNldCBpbiBjb25zdHJ1Y3RvcicpO1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5U3BlZWQgPSB2aWV3UG9ydC5wbGF5U3BlZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNldCBwbGF5aGVhZCBwbGF5aW5nLyBub3QgcGxheWluZy5cclxuICAgICAgICBpZiAodmlld1BvcnQucGxheVBsYXloZWFkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kcmF3UGxheWhlYWQpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFZpZXdQb3J0OiB2aWV3UG9ydC5wbGF5UGxheWhlYWQgd2FzIHNldCwgYnV0IGRyYXdQbGF5aGVhZCB3YXMgbm90IHNldCBpbiBjb25zdHJ1Y3RvcicpO1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5SGVhZFBsYXlpbmcgPSB2aWV3UG9ydC5wbGF5UGxheWhlYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2aWV3UG9ydC5wbGF5aGVhZFRpbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RyYXdQbGF5aGVhZClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0Vmlld1BvcnQ6IHZpZXdQb3J0LnBsYXloZWFkVGltZSB3YXMgc2V0LCBidXQgZHJhd1BsYXloZWFkIHdhcyBub3Qgc2V0IGluIGNvbnN0cnVjdG9yJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlIZWFkVGltZSA9IE1hdGgubWF4KDAsIHZpZXdQb3J0LnBsYXloZWFkVGltZSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9wbGF5SGVhZFRpbWUgPiAwKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRHJhd0xhc3RUaW1lID0gdGhpcy5fcGxheUhlYWRUaW1lO1xyXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVkcmF3IHRpbWVsaW5lIGlmIGFueXRoaW5nIGhhcyBjaGFuZ2VkLlxyXG4gICAgICAgIGlmIChjaGFuZ2VkID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVkcmF3VGltZWxpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFjY2Vzc29yIGZvciBwb2xsaW5nIHRoZSBjdXJyZW50bHkgaG92ZXJlZCBvdmVyIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgZ2V0SG92ZXJlZE9iamVjdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faG92ZXJlZE92ZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGhlaWdodCB0byBnaXZlIHRvIGVhY2ggcm93IHRvIGZpdCBhbGwgbGF5ZXJzIG9uIHNjcmVlbi5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGxheWVycyBNYXAgb2YgbGF5ZXJzIHRvIHVzZS5cclxuICAgICAqIEByZXR1cm5zIEhlaWdodCBvZiByb3dzLlxyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGVSb3dIZWlnaHQobGF5ZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1BWF9MQVlFUl9IRUlHSFQsIHRoaXMuX2NhbnZhc0hlaWdodCAvIE9iamVjdC5rZXlzKGxheWVycykubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUxheWVyTGFiZWxzKCkge1xyXG4gICAgICAgIC8vIFN0b3JlIGxheWVycyB0byBkcmF3LlxyXG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLmdldExheWVyc1RvRHJhdygpO1xyXG4gICAgICAgIGlmICghaXNFcXVhbCh0aGlzLl9sYXllckxhYmVscywgby5sYXllcnMpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyTGFiZWxzID0gby5sYXllcnM7XHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSByb3cgaGVpZ2h0LlxyXG4gICAgICAgICAgICB0aGlzLl9yb3dIZWlnaHQgPSB0aGlzLmNhbGN1bGF0ZVJvd0hlaWdodCh0aGlzLl9sYXllckxhYmVscyk7XHJcbiAgICAgICAgICAgIC8vIFNldCB0aW1lbGluZSBvYmplY3QgaGVpZ2h0LlxyXG4gICAgICAgICAgICB0aGlzLl90aW1lbGluZU9iamVjdEhlaWdodCA9IHRoaXMuX3Jvd0hlaWdodCAqIFRJTUVMSU5FX09CSkVDVF9IRUlHSFQ7XHJcbiAgICAgICAgICAgIHRoaXMuX251bWJlck9mTGF5ZXJzID0gT2JqZWN0LmtleXModGhpcy5fbGF5ZXJMYWJlbHMpLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5fcm93c1RvdGFsSGVpZ2h0ID0gdGhpcy5fcm93SGVpZ2h0ICogdGhpcy5fbnVtYmVyT2ZMYXllcnM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0TGF5ZXJzKCkge1xyXG4gICAgICAgIGNvbnN0IGxheWVycyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuX2xheWVyTGFiZWxzKTtcclxuICAgICAgICBsYXllcnMuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pO1xyXG4gICAgICAgIHJldHVybiBsYXllcnMubWFwKGwgPT4gbFswXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIHRoZSBsYXllciBsYWJlbHMgdG8gdGhlIGNhbnZhcy5cclxuICAgICAqL1xyXG4gICAgZHJhd0xheWVyTGFiZWxzKCkge1xyXG4gICAgICAgIGxldCByb3cgPSAwO1xyXG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBsYXllcnMuXHJcbiAgICAgICAgZm9yIChsZXQgbGF5ZXJOYW1lIG9mIHRoaXMuZ2V0TGF5ZXJzKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxTdHlsZSA9IENPTE9SX0xBQkVMX0JBQ0tHUk9VTkQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsUmVjdCgwLCByb3cgKiB0aGlzLl9yb3dIZWlnaHQsIHRoaXMuX2xheWVyTGFiZWxXaWR0aCwgdGhpcy5fcm93SGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxTdHlsZSA9IFRFWFRfQ09MT1I7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5mb250ID0gVEVYVF9GT05UX1NJWkUudG9TdHJpbmcoKSArICdweCAnICsgVEVYVF9GT05UX0ZBTUlMWTtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuZmlsbFRleHQobGF5ZXJOYW1lLCAwLCAocm93ICogdGhpcy5fcm93SGVpZ2h0KSArICh0aGlzLl9yb3dIZWlnaHQgLyAyKSwgdGhpcy5fbGF5ZXJMYWJlbFdpZHRoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVyTGFiZWxzW2xheWVyTmFtZV0gIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsU3R5bGUgPSBDT0xPUl9MSU5FO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxSZWN0KHRoaXMuX2xheWVyTGFiZWxXaWR0aCwgcm93ICogdGhpcy5fcm93SGVpZ2h0LCB0aGlzLl92aWV3RHJhd1dpZHRoLCBUSElDS05FU1NfTElORSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcm93Kys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgdGltZWxpbmUgYmFja2dyb3VuZC5cclxuICAgICAqL1xyXG4gICAgZHJhd0JhY2tncm91bmQoKSB7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxTdHlsZSA9IENPTE9SX0JBQ0tHUk9VTkQ7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxSZWN0KDAsIDAsIHRoaXMuX2NhbnZhc1dpZHRoLCB0aGlzLl9jYW52YXNIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuZHJhd0JhY2tncm91bmRSdWxlcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgcnVsZXIgb24gdG9wIG9mIGJhY2tncm91bmRcclxuICAgICAqL1xyXG4gICAgZHJhd0JhY2tncm91bmRSdWxlcigpIHtcclxuICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMudmlld1JhbmdlO1xyXG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSB0aGlzLnZpZXdFbmRUaW1lO1xyXG4gICAgICAgIGNvbnN0IGNpcmNhTnVtYmVyT2ZMaW5lcyA9IDU7XHJcbiAgICAgICAgY29uc3Qgcm91bmRlciA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nMTAocmFuZ2UgLyBjaXJjYU51bWJlck9mTGluZXMpKSk7IC8vIFdoYXQgdG8gcm91bmQgdGhlIHJ1bGVyIHRvXHJcbiAgICAgICAgY29uc3Qgcm91bmRlck5leHQgPSByb3VuZGVyICogMTA7XHJcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZMaW5lcyA9IE1hdGguZmxvb3IocmFuZ2UgLyByb3VuZGVyKTtcclxuICAgICAgICBjb25zdCBydWxlckRpZmYgPSByb3VuZGVyO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IE1hdGguZmxvb3IodGhpcy5fdmlld1N0YXJ0VGltZSAvIHJvdW5kZXIpICogcm91bmRlcjtcclxuICAgICAgICBjb25zdCBvcGFjaXR5ID0gKE1hdGgubWluKDEsIGNpcmNhTnVtYmVyT2ZMaW5lcyAvIG51bWJlck9mTGluZXMpKTtcclxuICAgICAgICBpZiAocnVsZXJEaWZmKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHJva2VTdHlsZSA9IFJVTEVSX0xJTkVfQ09MT1I7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5saW5lV2lkdGggPSBSVUxFUl9MSU5FX1dJRFRIO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBydWxlclRpbWUgPSBzdGFydFRpbWU7IHJ1bGVyVGltZSA8IGVuZFRpbWU7IHJ1bGVyVGltZSArPSBydWxlckRpZmYpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGxldCB4ID0gdGhpcy50aW1lVG9YQ29vcmQocnVsZXJUaW1lKTtcclxuICAgICAgICAgICAgICAgIGxldCBkaXN0YW5jZVRvTmV4dCA9IChydWxlclRpbWUgLyByb3VuZGVyTmV4dCkgJSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlVG9OZXh0ID4gMC41KVxyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlVG9OZXh0IC09IDE7XHJcbiAgICAgICAgICAgICAgICBkaXN0YW5jZVRvTmV4dCA9IE1hdGguYWJzKGRpc3RhbmNlVG9OZXh0KTtcclxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZVRvTmV4dCA8IDAuMDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJcyBhIHNpZ25pZmljYW50IGxpbmVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuZ2xvYmFsQWxwaGEgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLmdsb2JhbEFscGhhID0gb3BhY2l0eTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh4ID49IHRoaXMuX3ZpZXdEcmF3WCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5tb3ZlVG8oeCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLmxpbmVUbyh4LCB0aGlzLl9jYW52YXNIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0cm9rZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5nbG9iYWxBbHBoYSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgcGxheWhlYWQgaW5pdGlhbGx5LlxyXG4gICAgICovXHJcbiAgICBkcmF3UGxheWhlYWQoKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIHBsYXloZWFkIHNob3VsZCBiZSBkcmF3LlxyXG4gICAgICAgIGlmICh0aGlzLl9kcmF3UGxheWhlYWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXN0aW1lSW5WaWV3KHRoaXMuX3BsYXlIZWFkVGltZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsU3R5bGUgPSBDT0xPUl9QTEFZSEVBRDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsUmVjdCh0aGlzLnRpbWVUb1hDb29yZCh0aGlzLl9wbGF5SGVhZFRpbWUpLCAwLCBUSElDS05FU1NfUExBWUhFQUQsIHRoaXMuX2NhbnZhc0hlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGxheWVycyB0byBkcmF3IGZyb20gdGhlIHRpbWVsaW5lLlxyXG4gICAgICovXHJcbiAgICBnZXRMYXllcnNUb0RyYXcoKSB7XHJcbiAgICAgICAgdGhpcy5faG92ZXJlZE9iamVjdE1hcCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGxheWVyc0FycmF5ID0gdGhpcy5fcmVzb2x2ZWRTdGF0ZXMgPyBPYmplY3Qua2V5cyh0aGlzLl9yZXNvbHZlZFN0YXRlcy5sYXllcnMpIDogW107XHJcbiAgICAgICAgbGF5ZXJzQXJyYXkuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcclxuICAgICAgICBjb25zdCBsYXllcnMgPSB7fTtcclxuICAgICAgICBsYXllcnNBcnJheS5mb3JFYWNoKChsYXllck5hbWUsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGxheWVyc1tsYXllck5hbWVdID0gaW5kZXg7XHJcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyZWRPYmplY3RNYXBbbGF5ZXJOYW1lXSA9IFtdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxheWVyczogbGF5ZXJzLFxyXG4gICAgICAgICAgICBsYXllcnNBcnJheTogbGF5ZXJzQXJyYXlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWRyYXdzIHRoZSB0aW1lbGluZSB0byB0aGUgY2FudmFzLlxyXG4gICAgICovXHJcbiAgICByZWRyYXdUaW1lbGluZSgpIHtcclxuICAgICAgICB0aGlzLl9jYW52YXMuY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NhbnZhc1dpZHRoLCB0aGlzLl9jYW52YXNIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcclxuICAgICAgICB0aGlzLmRyYXdMYXllckxhYmVscygpO1xyXG4gICAgICAgIC8vIFJlY29tcHV0ZSBvYmplY3RzIHBvc2l0aW9uc1xyXG4gICAgICAgIHRoaXMuX3RpbWVsaW5lU3RhdGUgPSB0aGlzLmdldFRpbWVsaW5lRHJhd1N0YXRlKHRoaXMuX3Jlc29sdmVkU3RhdGVzKTtcclxuICAgICAgICAvLyBEcmF3IHRoZSBjdXJyZW50IHN0YXRlLlxyXG4gICAgICAgIHRoaXMuZHJhd1RpbWVsaW5lU3RhdGUodGhpcy5fdGltZWxpbmVTdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5kcmF3UGxheWhlYWQoKTtcclxuICAgICAgICB0aGlzLmNoZWNrQXV0b21hdGljUmVyZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgdGltZWxpbmUgc3RhdGUgdG8gdGhlIGNhbnZhcy5cclxuICAgICAqIEBwYXJhbSB7VGltZWxpbmVEcmF3U3RhdGV9IGN1cnJlbnREcmF3U3RhdGUgU3RhdGUgdG8gZHJhdy5cclxuICAgICAqL1xyXG4gICAgZHJhd1RpbWVsaW5lU3RhdGUoY3VycmVudERyYXdTdGF0ZSkge1xyXG4gICAgICAgIGZvciAobGV0IGVsZW1lbnQgaW4gY3VycmVudERyYXdTdGF0ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBkcmF3U3RhdGUgPSBjdXJyZW50RHJhd1N0YXRlW2VsZW1lbnRdO1xyXG4gICAgICAgICAgICBpZiAoZHJhd1N0YXRlLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsU3R5bGUgPSBDT0xPUl9USU1FTElORV9PQkpFQ1RfRklMTDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsUmVjdChkcmF3U3RhdGUubGVmdCwgZHJhd1N0YXRlLnRvcCwgZHJhd1N0YXRlLndpZHRoLCBkcmF3U3RhdGUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHJva2VTdHlsZSA9IENPTE9SX1RJTUVMSU5FX09CSkVDVF9CT1JERVI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMubGluZVdpZHRoID0gVEhJQ0tORVNTX1RJTUVMSU5FX09CSkVDVF9CT1JERVI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuc3Ryb2tlUmVjdChkcmF3U3RhdGUubGVmdCwgZHJhd1N0YXRlLnRvcCwgZHJhd1N0YXRlLndpZHRoLCBkcmF3U3RhdGUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsU3R5bGUgPSBURVhUX0NPTE9SO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLmZvbnQgPSBURVhUX0ZPTlRfU0laRS50b1N0cmluZygpICsgJ3B4ICcgKyBURVhUX0ZPTlRfRkFNSUxZO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLnRleHRCYXNlbGluZSA9ICd0b3AnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxUZXh0KGRyYXdTdGF0ZS50aXRsZSwgZHJhd1N0YXRlLmxlZnQsIGRyYXdTdGF0ZS50b3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkcmF3IHN0YXRlcyBmb3IgYWxsIHRpbWVsaW5lIG9iamVjdHMuXHJcbiAgICAgKiBAcGFyYW0ge1Jlc29sdmVkU3RhdGVzfSB0aW1lbGluZSBUaW1lbGluZSB0byBkcmF3LlxyXG4gICAgICogQHJldHVybnMge1RpbWVsaW5lRHJhd1N0YXRlfSBTdGF0ZSBvZiB0aW1lLWJhc2VkIG9iamVjdHMuXHJcbiAgICAgKi9cclxuICAgIGdldFRpbWVsaW5lRHJhd1N0YXRlKHRpbWVsaW5lKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnREcmF3U3RhdGUgPSB7fTtcclxuICAgICAgICBpZiAodGltZWxpbmUpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgb2JqSWQgaW4gdGltZWxpbmUub2JqZWN0cykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRpbWVsaW5lT2JqID0gdGltZWxpbmUub2JqZWN0c1tvYmpJZF07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBfaSA9IDA7IF9pIDwgdGltZWxpbmVPYmoucmVzb2x2ZWQuaW5zdGFuY2VzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZU9iaiA9IHRpbWVsaW5lT2JqLnJlc29sdmVkLmluc3RhbmNlc1tfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSAndGltZWxpbmVPYmplY3Q6JyArIG9iaklkICsgJzonICsgaW5zdGFuY2VPYmouaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERyYXdTdGF0ZVtuYW1lXSA9IHRoaXMuY3JlYXRlU3RhdGVGb3JPYmplY3QodGltZWxpbmVPYmosIGluc3RhbmNlT2JqLnN0YXJ0LCBpbnN0YW5jZU9iai5lbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RHJhd1N0YXRlW25hbWVdLnZpc2libGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ob3ZlcmVkT2JqZWN0TWFwW3RpbWVsaW5lT2JqLmxheWVyICsgJyddKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faG92ZXJlZE9iamVjdE1hcFt0aW1lbGluZU9iai5sYXllciArICcnXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ob3ZlcmVkT2JqZWN0TWFwW3RpbWVsaW5lT2JqLmxheWVyICsgJyddLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRYOiBjdXJyZW50RHJhd1N0YXRlW25hbWVdLmxlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRYOiBjdXJyZW50RHJhd1N0YXRlW25hbWVdLmxlZnQgKyBjdXJyZW50RHJhd1N0YXRlW25hbWVdLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0UmVmSWQ6IG9iaklkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZDogaW5zdGFuY2VPYmouaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGltZWxpbmVPYmplY3QnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnREcmF3U3RhdGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBkcmF3IHN0YXRlIGZvciBhIHRpbWVsaW5lIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciBPYmplY3QncyBsYXllci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCB0aW1lLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgdGltZS5cclxuICAgICAqIEByZXR1cm5zIHtEcmF3U3RhdGV9IFN0YXRlIG9mIHRoZSBvYmplY3QgdG8gZHJhdy5cclxuICAgICAqL1xyXG4gICAgY3JlYXRlU3RhdGVGb3JPYmplY3Qob2JqLCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgLy8gRGVmYXVsdCBzdGF0ZSAoaGlkZGVuKS5cclxuICAgICAgICBsZXQgc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIGhlaWdodDogMCxcclxuICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHRpdGxlOiAnTi9BJ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gU3RhdGUgc2hvdWxkIGJlIGRlZmF1bHQgaWYgdGhlIG9iamVjdCBpcyBub3QgYmVpbmcgc2hvd24uXHJcbiAgICAgICAgaWYgKHRoaXMuc2hvd09uVGltZWxpbmUoc3RhcnQsIGVuZCkpIHtcclxuICAgICAgICAgICAgLy8gR2V0IG9iamVjdCBkaW1lbnNpb25zIGFuZCBwb3NpdGlvbi5cclxuICAgICAgICAgICAgbGV0IG9iamVjdFdpZHRoID0gdGhpcy5nZXRPYmplY3RXaWR0aChzdGFydCwgZW5kKTtcclxuICAgICAgICAgICAgbGV0IHhDb29yZCA9IHRoaXMuY2FwWGNvb3JkVG9WaWV3KHRoaXMudGltZVRvWENvb3JkKHN0YXJ0KSk7XHJcbiAgICAgICAgICAgIGxldCBvYmplY3RUb3AgPSB0aGlzLmdldE9iamVjdE9mZnNldEZyb21Ub3Aob2JqLmxheWVyICsgJycpO1xyXG4gICAgICAgICAgICAvLyBTZXQgc3RhdGUgcHJvcGVydGllcy5cclxuICAgICAgICAgICAgc3RhdGUuaGVpZ2h0ID0gdGhpcy5fdGltZWxpbmVPYmplY3RIZWlnaHQ7XHJcbiAgICAgICAgICAgIHN0YXRlLmxlZnQgPSB4Q29vcmQ7XHJcbiAgICAgICAgICAgIHN0YXRlLnRvcCA9IG9iamVjdFRvcDtcclxuICAgICAgICAgICAgc3RhdGUud2lkdGggPSBvYmplY3RXaWR0aDtcclxuICAgICAgICAgICAgc3RhdGUudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHN0YXRlLnRpdGxlID0gb2JqLmlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG9mZnNldCwgaW4gcGl4ZWxzIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSB0aW1lbGluZSBmb3IgYW4gb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IHN0YXJ0IHRpbWUgb2YgdGhlIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE9mZnNldCBpbiBwaXhlbHMuXHJcbiAgICAgKi9cclxuICAgIC8vIHByaXZhdGUgZ2V0T2JqZWN0T2Zmc2V0RnJvbVRpbWVsaW5lU3RhcnQgKHN0YXJ0OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgLy8gXHQvLyBDYWxjdWxhdGUgb2Zmc2V0LlxyXG4gICAgLy8gXHRsZXQgb2Zmc2V0ID0gKHN0YXJ0IC0gdGhpcy5fdmlld1N0YXJ0VGltZSkgKiB0aGlzLnBpeGVsc1dpZHRoUGVyVW5pdFRpbWVcclxuICAgIC8vIFx0Ly8gT2Zmc2V0IGNhbm5vdCBiZSB0byB0aGUgbGVmdCBvZiB0aGUgdGltZWxpbmUgc3RhcnQgcG9zaXRpb24uXHJcbiAgICAvLyBcdGlmIChvZmZzZXQgPCAwKSB7XHJcbiAgICAvLyBcdFx0b2Zmc2V0ID0gMFxyXG4gICAgLy8gXHR9XHJcbiAgICAvLyBcdHJldHVybiBvZmZzZXRcclxuICAgIC8vIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgd2lkdGgsIGluIHBpeGVscywgb2YgYW4gb2JqZWN0IGJhc2VkIG9uIGl0cyBkdXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCB0aW1lIG9mIHRoZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCB0aW1lIG9mIHRoZSBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBXaWR0aCBpbiBwaXhlbHMuXHJcbiAgICAgKi9cclxuICAgIGdldE9iamVjdFdpZHRoKHN0YXJ0VGltZSwgZW5kVGltZSkge1xyXG4gICAgICAgIGlmICghZW5kVGltZSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhc1dpZHRoO1xyXG4gICAgICAgIC8vIElmIHRoZSBzdGFydCB0aW1lIGlzIGxlc3MgdGhhbiB0aGUgdGltZWxpbmUgc3RhcnQsIHNldCB0byB0aW1lbGluZSBzdGFydC5cclxuICAgICAgICBpZiAoc3RhcnRUaW1lIDwgdGhpcy5fdmlld1N0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICBzdGFydFRpbWUgPSB0aGlzLl92aWV3U3RhcnRUaW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDYWxjdWxhdGUgZHVyYXRpb24gb2YgdGhlIG9iamVjdCByZW1haW5pbmcgb24gdGhlIHRpbWVsaW5lLlxyXG4gICAgICAgIGxldCBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XHJcbiAgICAgICAgLy8gUmV0dXJuIGVuZCBwb2ludCBwb3NpdGlvbiBpbiBwaXhlbHMuXHJcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uICogdGhpcy5waXhlbHNXaWR0aFBlclVuaXRUaW1lO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gc2hvdyBhbiBvYmplY3Qgb24gdGhlIHRpbWVsaW5lLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IE9iamVjdCBzdGFydCB0aW1lLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBPYmplY3QgZW5kIHRpbWUuXHJcbiAgICAgKiBAcmV0dXJucyB7dHJ1ZX0gaWYgb2JqZWN0IHNob3VsZCBiZSBzaG93biBvbiB0aGUgdGltZWxpbmUuXHJcbiAgICAgKi9cclxuICAgIHNob3dPblRpbWVsaW5lKHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICBsZXQgaXNBZnRlciA9IHN0YXJ0ID49IHRoaXMudmlld0VuZFRpbWU7XHJcbiAgICAgICAgbGV0IGlzQmVmb3JlID0gKGVuZCB8fCBJbmZpbml0eSkgPD0gdGhpcy5fdmlld1N0YXJ0VGltZTtcclxuICAgICAgICByZXR1cm4gIWlzQWZ0ZXIgJiYgIWlzQmVmb3JlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgcG9zaXRpb24gb2Ygb2JqZWN0IGluc3RhbmNlIGZyb20gdG9wIG9mIHRpbWVsaW5lIGFjY29yZGluZyB0byBpdHMgbGF5ZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgT2JqZWN0J3MgbGF5ZXIuXHJcbiAgICAgKiBAcmV0dXJucyBQb3NpdGlvbiByZWxhdGl2ZSB0byB0b3Agb2YgY2FudmFzIGluIHBpeGVscy5cclxuICAgICAqL1xyXG4gICAgZ2V0T2JqZWN0T2Zmc2V0RnJvbVRvcChsYXllck5hbWUpIHtcclxuICAgICAgICBsZXQgdG9wID0gdGhpcy5fbGF5ZXJMYWJlbHNbbGF5ZXJOYW1lXTtcclxuICAgICAgICByZXR1cm4gdG9wICogdGhpcy5fcm93SGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyB0aGUgcGxheWhlYWQuIENhbGxlZCBwZXJpb2RpY2FsbHkuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZURyYXcoKSB7XHJcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAvLyBIb3cgbG9uZyB0aW1lIHNpbmNlIGxhc3QgdXBkYXRlOlxyXG4gICAgICAgIGNvbnN0IGR0ID0gKHRoaXMuX3VwZGF0ZURyYXdMYXN0VGltZSA+IDAgP1xyXG4gICAgICAgICAgICBub3cgLSB0aGlzLl91cGRhdGVEcmF3TGFzdFRpbWUgOlxyXG4gICAgICAgICAgICAxKSAvIDEwMDA7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlRHJhd0xhc3RUaW1lID0gbm93O1xyXG4gICAgICAgIGNvbnN0IGRlbHRhVGltZSA9IHRoaXMuX3BsYXlTcGVlZCAqIGR0O1xyXG4gICAgICAgIC8vIENoZWNrIHBsYXloZWFkIHNob3VsZCBiZSBkcmF3bi5cclxuICAgICAgICBsZXQgbmVlZFJlZHJhdyA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLl9wbGF5SGVhZFBsYXlpbmcgJiYgdGhpcy5fZHJhd1BsYXloZWFkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9wbGF5Vmlld1BvcnQgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuaXN0aW1lSW5WaWV3KHRoaXMuX3BsYXlIZWFkVGltZSkgLy8gT25seSBwbGF5IGlmIHBsYXloZWFkIGlzIGluIHZpZXdcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3U3RhcnRUaW1lICs9IGRlbHRhVGltZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBNb3ZlIHBsYXloZWFkIGZvcndhcmRcclxuICAgICAgICAgICAgdGhpcy5fcGxheUhlYWRUaW1lICs9IGRlbHRhVGltZTtcclxuICAgICAgICAgICAgbmVlZFJlZHJhdyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZWVkUmVkcmF3KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVkcmF3VGltZWxpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2FsbCB0aGlzIGZ1bmN0aW9uIG9uIG5leHQgZnJhbWVcclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMudXBkYXRlRHJhdygpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyBtb3VzZSBkb3duIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGV2ZW50IE1vdXNlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBjYW52YXNNb3VzZURvd24oZXZlbnQpIHtcclxuICAgICAgICAvLyBTdG9yZSBtb3VzZSBpcyBkb3duLlxyXG4gICAgICAgIHRoaXMuX21vdXNlRG93biA9IHRydWU7XHJcbiAgICAgICAgLy8gU3RvcmUgWCBwb3NpdGlvbiBvZiBtb3VzZSBvbiBjbGljay5cclxuICAgICAgICB0aGlzLl9tb3VzZUxhc3RYID0gZXZlbnQuY2xpZW50WDtcclxuICAgICAgICAvLyBQcmV2ZW50IGV2ZW50LlxyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgbW91c2UgdXAgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZXZlbnQgTW91c2UgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIGNhbnZhc01vdXNlVXAoZXZlbnQpIHtcclxuICAgICAgICAvLyBNb3VzZSBubyBsb25nZXIgZG93bi5cclxuICAgICAgICB0aGlzLl9tb3VzZURvd24gPSBmYWxzZTtcclxuICAgICAgICAvLyBSZXNldCBzY3JvbGwgZGlyZWN0aW9uLlxyXG4gICAgICAgIHRoaXMuX2xhc3RTY3JvbGxEaXJlY3Rpb24gPSAwO1xyXG4gICAgICAgIC8vIFByZXZlbnQgZXZlbnQuXHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyBtb3VzZSBtb3ZlbWVudCBvbiBjYW52YXMuXHJcbiAgICAgKiBAcGFyYW0gZXZlbnQgTW91c2UgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIGNhbnZhc01vdXNlTW92ZShldmVudCkge1xyXG4gICAgICAgIC8vIElmIG1vdXNlIGlzIGRvd24uXHJcbiAgICAgICAgaWYgKHRoaXMuX21vdXNlRG93bikge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgYmVnaW5uaW5nIHNjcm9sbGluZywgd2UgY2FuIG1vdmUgZnJlZWx5LlxyXG4gICAgICAgICAgICBpZiAodGhpcy5fbGFzdFNjcm9sbERpcmVjdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX2xhc3RTY3JvbGxEaXJlY3Rpb24gPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGN1cnJlbnQgbW91c2UgWC5cclxuICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlTGFzdFggPSBldmVudC5jbGllbnRYO1xyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNoYW5nZSBpbiBYLlxyXG4gICAgICAgICAgICAgICAgbGV0IGRlbHRhWCA9IGV2ZW50LmNsaWVudFggLSB0aGlzLl9tb3VzZUxhc3RYO1xyXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgc2Nyb2xsaW5nIGRpcmVjdGlvbi5cclxuICAgICAgICAgICAgICAgIGlmIChkZWx0YVggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFNjcm9sbERpcmVjdGlvbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFNjcm9sbERpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBTY3JvbGwgdG8gbmV3IFggcG9zaXRpb24uXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1Njcm9sbEJ5RGVsdGFYKC1kZWx0YVgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHNjcm9sbCBkaXJlY3Rpb24uXHJcbiAgICAgICAgICAgICAgICBsZXQgZGlyZWN0aW9uID0gdGhpcy5fbW91c2VMYXN0WCAtIGV2ZW50LmNsaWVudFg7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBjaGFuZ2luZyBkaXJlY3Rpb24sIHN0b3JlIG5ldyBkaXJlY3Rpb24gYnV0IGRvbid0IHNjcm9sbC5cclxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPCAwICYmIHRoaXMuX2xhc3RTY3JvbGxEaXJlY3Rpb24gPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZUxhc3RYID0gZXZlbnQuY2xpZW50WDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0U2Nyb2xsRGlyZWN0aW9uID0gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPiAwICYmIHRoaXMuX2xhc3RTY3JvbGxEaXJlY3Rpb24gPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW91c2VMYXN0WCA9IGV2ZW50LmNsaWVudFg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFNjcm9sbERpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgY2hhbmdlIGluIFguXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlbHRhWCA9IGV2ZW50LmNsaWVudFggLSB0aGlzLl9tb3VzZUxhc3RYO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIGxhc3QgWCBwb3NpdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZUxhc3RYID0gZXZlbnQuY2xpZW50WDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIGJ5IGNoYW5nZSBpbiBYLlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2Nyb2xsQnlEZWx0YVgoLWRlbHRhWCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmVkcmF3IHRpbWVsaW5lLlxyXG4gICAgICAgICAgICB0aGlzLnJlZHJhd1RpbWVsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBXaGV0aGVyIGFuIG9iamVjdCBpcyB1bmRlciB0aGUgY3Vyc29yLlxyXG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gRmluZCB0aGUgb2JqZWN0IHRoYXQgaXMgY3VycmVudGx5IGhvdmVyZWQgb3Zlci5cclxuICAgICAgICAgICAgbGV0IG1vdXNlUG9zID0gdGhpcy5nZXRNb3VzZVBvcyh0aGlzLl9jYW52YXNDb250YWluZXIsIGV2ZW50KTtcclxuICAgICAgICAgICAgaWYgKG1vdXNlUG9zLnggPiB0aGlzLl92aWV3RHJhd1gpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtb3VzZVBvcy55IDwgdGhpcy5fcm93c1RvdGFsSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkUm93ID0gTWF0aC5mbG9vcigobW91c2VQb3MueSAvIHRoaXMuX3Jvd3NUb3RhbEhlaWdodCkgKiB0aGlzLl9udW1iZXJPZkxheWVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxheWVyO1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2xheWVyTGFiZWxzKS5mb3JFYWNoKGxheWVyTmFtZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sYXllckxhYmVsc1tsYXllck5hbWVdID09PSBzZWxlY3RlZFJvdylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyID0gbGF5ZXJOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBob3Zlck1hcERhdGEgPSAobGF5ZXIgPyB0aGlzLl9ob3ZlcmVkT2JqZWN0TWFwW2xheWVyXSA6IFtdKSB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICBob3Zlck1hcERhdGEuZm9yRWFjaChvYmplY3QgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0LnN0YXJ0WCA8PSBtb3VzZVBvcy54ICYmIG9iamVjdC5lbmRYID49IG1vdXNlUG9zLngpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvdmVySGFzaCA9IG9iamVjdC50eXBlICsgb2JqZWN0Lm9iamVjdFJlZklkICsgb2JqZWN0Lmluc3RhbmNlSWQ7IC8vIGhhc2gtaXNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGFzdEhvdmVyZWRIYXNoICE9PSBob3Zlckhhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgb2JqZWN0IG1ldGFkYXRhIGZyb20gdGhlIG9iamVjdCBuYW1lIG9mIHRoZSBob3ZlcmVkIG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgaG92ZXJpbmcgb3ZlciBhIHRpbWVsaW5lIG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0LnR5cGUgPT09ICd0aW1lbGluZU9iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0aW1lbGluZSBvYmplY3QgYW5kIHRoZSBpbnN0YW5jZSBiZWluZyBob3ZlcmVkIG92ZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZXNvbHZlZFN0YXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRpbWVsaW5lT2JqZWN0ID0gdGhpcy5fcmVzb2x2ZWRTdGF0ZXMub2JqZWN0c1tvYmplY3Qub2JqZWN0UmVmSWRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gdGltZWxpbmVPYmplY3QucmVzb2x2ZWQuaW5zdGFuY2VzLmZpbmQoaW5zdGFuY2UgPT4gaW5zdGFuY2UuaWQgPT09IG9iamVjdC5pbnN0YW5jZUlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCBob3ZlciBpbmZvLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBob3ZlckluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGltZWxpbmVPYmplY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlcjogeyB4UG9zdGlvbjogbW91c2VQb3MueCwgeVBvc2l0aW9uOiBtb3VzZVBvcy55IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBjdXJyZW50bHkgaG92ZXJlZCBvYmplY3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faG92ZXJlZE92ZXIgPSBob3ZlckluZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW1pdCBldmVudC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3RpbWVsaW5lOmhvdmVyJywgeyBkZXRhaWw6IHRoaXMuX2hvdmVyZWRPdmVyIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgbGFzdCBpdGVtcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RIb3ZlckFjdGlvbiA9IE1PVVNFSU47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0SG92ZXJlZEhhc2ggPSBob3Zlckhhc2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBFbWl0IHVuZGVmaW5lZCB3aGVuIG1vdXNlIG91dC5cclxuICAgICAgICAgICAgaWYgKCFmb3VuZCAmJiB0aGlzLl9sYXN0SG92ZXJBY3Rpb24gPT09IE1PVVNFSU4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndGltZWxpbmU6aG92ZXInLCB7IGRldGFpbDogdW5kZWZpbmVkIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdEhvdmVyQWN0aW9uID0gTU9VU0VPVVQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgc2Nyb2xsIHdoZWVsIGV2ZW50cyBvbiB0aGUgY2FudmFzLlxyXG4gICAgICogQHBhcmFtIGV2ZW50IFNjcm9sbCBldmVudC5cclxuICAgICAqL1xyXG4gICAgY2FudmFzU2Nyb2xsV2hlZWwoZXZlbnQpIHtcclxuICAgICAgICAvLyBHZXQgbW91c2UgcG9pbnRlciBjb29yZGluYXRlcyBvbiBjYW52YXMuXHJcbiAgICAgICAgbGV0IGNhbnZhc0Nvb3JkID0gdGhpcy5nZXRNb3VzZVBvcyh0aGlzLl9jYW52YXNDb250YWluZXIsIGV2ZW50KTtcclxuICAgICAgICAvLyBEb24ndCBzY3JvbGwgaWYgbW91c2UgaXMgbm90IG92ZXIgdGltZWxpbmUuXHJcbiAgICAgICAgaWYgKGNhbnZhc0Nvb3JkLnggPD0gdGhpcy5fdmlld0RyYXdYKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICAvLyBDVFJMICsgc2Nyb2xsIHRvIHpvb20uXHJcbiAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmRlbHRhWSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB6b29tRmFjdG9yID0gTWF0aC5wb3coWk9PTV9GQUNUT1IsIC1ldmVudC5kZWx0YVkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy56b29tVW5kZXJDdXJzb3IoY2FudmFzQ29vcmQueCwgem9vbUZhY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuZGVsdGFYICE9PSAwKSB7IC8vIFNjcm9sbCBvbiB4LWF4aXNcclxuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIFBhbi5cclxuICAgICAgICAgICAgdGhpcy5jYW52YXNTY3JvbGxCeURlbHRhWCgoZXZlbnQuZGVsdGFYICogKFBBTl9GQUNUT1IgKiB0aGlzLnN0ZXBTaXplKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChldmVudC5kZWx0YVkgIT09IDAgJiYgZXZlbnQuYWx0S2V5ID09PSB0cnVlKSB7IC8vIEFsc28gc2Nyb2xsIG9uIGFsdC1rZXkgKyBzY3JvbGwgeS1heGlzXHJcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyBQYW4uXHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzU2Nyb2xsQnlEZWx0YVgoKGV2ZW50LmRlbHRhWSAqIChQQU5fRkFDVE9SICogdGhpcy5zdGVwU2l6ZSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJldmVudCBldmVudC5cclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIC8vIFJlZHJhdyB0aW1lbGluZS5cclxuICAgICAgICAgICAgdGhpcy5yZWRyYXdUaW1lbGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2Nyb2xsIGFjcm9zcyB0aGUgY2FudmFzIGJ5IGEgc3BlY2lmaWVkIFggdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFYIFZhbHVlIHRvIG1vdmUgYnkuXHJcbiAgICAgKi9cclxuICAgIGNhbnZhc1Njcm9sbEJ5RGVsdGFYKGRlbHRhWCkge1xyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgc3RhcnRpbmcgdGltZS5cclxuICAgICAgICBsZXQgdGFyZ2V0U3RhcnQgPSB0aGlzLl92aWV3U3RhcnRUaW1lICsgKGRlbHRhWCAvIHRoaXMucGl4ZWxzV2lkdGhQZXJVbml0VGltZSk7XHJcbiAgICAgICAgLy8gU3RhcnRpbmcgdGltZSBjYW5ub3QgYmUgPCAwLlxyXG4gICAgICAgIGlmICh0YXJnZXRTdGFydCA8IDApIHtcclxuICAgICAgICAgICAgdGFyZ2V0U3RhcnQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPcHRpbWlzYXRpb24sIGRvbid0IHJlZHJhdyBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkLlxyXG4gICAgICAgIGlmICh0YXJnZXRTdGFydCA9PT0gdGhpcy5fdmlld1N0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3ZpZXdTdGFydFRpbWUgPSB0YXJnZXRTdGFydDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogWm9vbXMgaW50by9vdXQgb2YgdGltZWxpbmUsIGtlZXBpbmcgdGhlIHRpbWUgdW5kZXIgdGhlIGN1cnNvciBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICAgICAqIEBwYXJhbSBjdXJzb3JYIFBvc2l0aW9uIG9mIG1vdXNlIGN1cnNvci5cclxuICAgICAqL1xyXG4gICAgem9vbVVuZGVyQ3Vyc29yKGN1cnNvclgsIHpvb21GYWN0b3IpIHtcclxuICAgICAgICAvLyBQb2ludCBpbiB0aW1lIG9mIHRoZSBjdXJzb3JcclxuICAgICAgICBsZXQgY3Vyc29yVGltZSA9IHRoaXMueENvb3JkVG9UaW1lKGN1cnNvclgpO1xyXG4gICAgICAgIC8vIFJhdGlvIChpbiB2aWV3IHJhbmdlKSBvZiB0aGUgY3Vyc29yXHJcbiAgICAgICAgbGV0IGN1cnNvclJhdGlvID0gdGhpcy50aW1lVG9SYXRpbyhjdXJzb3JUaW1lKTtcclxuICAgICAgICAvLyBDaGFuZ2Ugem9vbTpcclxuICAgICAgICB0aGlzLl90aW1lbGluZVpvb20gPSB0aGlzLl90aW1lbGluZVpvb20gKiB6b29tRmFjdG9yO1xyXG4gICAgICAgIC8vIExpbWl0IHdpdGhpbiBjdXJyZW50IHZpZXdcclxuICAgICAgICBjdXJzb3JSYXRpbyA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGN1cnNvclJhdGlvKSk7XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHN0YXJ0XHJcbiAgICAgICAgbGV0IHRhcmdldFN0YXJ0ID0gY3Vyc29yVGltZSAtIChjdXJzb3JSYXRpbyAqIHRoaXMudmlld1JhbmdlKTtcclxuICAgICAgICAvLyBTdGFydCBjYW5ub3QgYmUgbGVzcyB0aGFuIDBcclxuICAgICAgICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XHJcbiAgICAgICAgICAgIHRhcmdldFN0YXJ0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2V0IGRyYXcgdGltZVxyXG4gICAgICAgIHRoaXMuX3ZpZXdTdGFydFRpbWUgPSB0YXJnZXRTdGFydDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbW91c2UgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IG9mIHRoZSBjYW52YXMgW3BpeGVsc11cclxuICAgICAqIEBwYXJhbSBjYW52YXNcclxuICAgICAqIEBwYXJhbSBldnRcclxuICAgICAqIEByZXR1cm5zIHt4OiBudW1iZXIsIHk6IG51bWJlcn0gUG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldE1vdXNlUG9zKGNhbnZhcywgZXZ0KSB7XHJcbiAgICAgICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBldnQuY2xpZW50WCAtIHJlY3QubGVmdCxcclxuICAgICAgICAgICAgeTogZXZ0LmNsaWVudFkgLSByZWN0LnRvcFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyaW1zIGEgdGltZWxpbmUgc28gdGhhdCBvYmplY3RzIG9ubHkgZXhpc3Qgd2l0aGluIGEgc3BlY2lmaWVkIHRpbWUgcGVyaW9kLlxyXG4gICAgICogQHBhcmFtIHRpbWVsaW5lIFRpbWVsaW5lIHRvIHRyaW0uXHJcbiAgICAgKiBAcGFyYW0gdHJpbSBUaW1lcyB0byB0cmltIGJldHdlZW4uXHJcbiAgICAgKi9cclxuICAgIHRyaW1UaW1lbGluZSh0aW1lbGluZSwgdHJpbSkge1xyXG4gICAgICAgIC8vIFRoZSBuZXcgcmVzb2x2ZWQgb2JqZWN0cy5cclxuICAgICAgICBsZXQgbmV3T2JqZWN0cyA9IHt9O1xyXG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCByZXNvbHZlZCBvYmplY3RzLlxyXG4gICAgICAgIE9iamVjdC5rZXlzKHRpbWVsaW5lLm9iamVjdHMpLmZvckVhY2goKG9iaklkKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRpbWVsaW5lLm9iamVjdHNbb2JqSWRdO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRpbmdJbnN0YW5jZXMgPSBbXTtcclxuICAgICAgICAgICAgb2JqLnJlc29sdmVkLmluc3RhbmNlcy5mb3JFYWNoKGluc3RhbmNlID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFdoZXRoZXIgdG8gaW5zZXJ0IHRoaXMgb2JqZWN0IGludG8gdGhlIG5ldyB0aW1lbGluZS5cclxuICAgICAgICAgICAgICAgIGxldCB1c2VJbnN0YW5jZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5ld0luc3RhbmNlID0gT2JqZWN0LmFzc2lnbih7fSwgaW5zdGFuY2UpOyAvLyBjbG9uZVxyXG4gICAgICAgICAgICAgICAgLy8gSWYgdHJpbW1pbmcgdGhlIHN0YXJ0IHRpbWUuXHJcbiAgICAgICAgICAgICAgICBpZiAodHJpbS5zdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgZW5kcyBhZnRlciB0aGUgdHJpbSBzdGFydCB0aW1lLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoaW5zdGFuY2UuZW5kIHx8IEluZmluaXR5KSA+IHRyaW0uc3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlSW5zdGFuY2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3SW5zdGFuY2Uuc3RhcnQgPCB0cmltLnN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJbnN0YW5jZS5zdGFydCA9IHRyaW0uc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0cmltbWluZyB0aGUgZW5kIHRpbWUuXHJcbiAgICAgICAgICAgICAgICBpZiAodHJpbS5lbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IHN0YXJ0cyBiZWZvcmUgdGhlIHRyaW0gZW5kIHRpbWUuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXJ0IDwgdHJpbS5lbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlSW5zdGFuY2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG5ld0luc3RhbmNlLmVuZCB8fCBJbmZpbml0eSkgPiB0cmltLmVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5zdGFuY2UuZW5kID0gdHJpbS5lbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRyaW0uc3RhcnQgJiYgIXRyaW0uZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXNlSW5zdGFuY2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHVzZUluc3RhbmNlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3SW5zdGFuY2Uuc3RhcnQgPCAobmV3SW5zdGFuY2UuZW5kIHx8IEluZmluaXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0luc3RhbmNlcy5wdXNoKG5ld0luc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzbid0IGEgcmVzb2x2ZWQgb2JqZWN0IGZvciB0aGUgbmV3IGluc3RhbmNlLCBjcmVhdGUgaXQuXHJcbiAgICAgICAgICAgIGlmICghbmV3T2JqZWN0c1tvYmpJZF0pIHtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdPYmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogb2JqLmNvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlOiBvYmouZW5hYmxlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlkOiBvYmouaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IG9iai5sYXllcixcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbERlZXA6IG9iai5yZXNvbHZlZC5sZXZlbERlZXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkOiBvYmoucmVzb2x2ZWQucmVzb2x2ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmluZzogb2JqLnJlc29sdmVkLnJlc29sdmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0UmVmZXJlbmNlczogb2JqLnJlc29sdmVkLmRpcmVjdFJlZmVyZW5jZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIG5ld09iamVjdHNbb2JqSWRdID0gbmV3T2JqZWN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5ld09iamVjdHNbb2JqSWRdLnJlc29sdmVkLmluc3RhbmNlcyA9IHJlc3VsdGluZ0luc3RhbmNlcztcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjbGFzc2VzOiB0aW1lbGluZS5jbGFzc2VzLFxyXG4gICAgICAgICAgICBsYXllcnM6IHRpbWVsaW5lLmxheWVycyxcclxuICAgICAgICAgICAgb2JqZWN0czogbmV3T2JqZWN0cyxcclxuICAgICAgICAgICAgb3B0aW9uczogdGltZWxpbmUub3B0aW9ucyxcclxuICAgICAgICAgICAgc3RhdGlzdGljczogdGltZWxpbmUuc3RhdGlzdGljcyxcclxuICAgICAgICAgICAgc3RhdGU6IHRpbWVsaW5lLnN0YXRlLFxyXG4gICAgICAgICAgICBuZXh0RXZlbnRzOiB0aW1lbGluZS5uZXh0RXZlbnRzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWVyZ2VzIHR3byB0aW1lbGluZXMgYnkgbWVyZ2luZyBpbnN0YW5jZXMgb2Ygb2JqZWN0cyB0aGF0IGludGVyc2VjdCBlYWNoIG90aGVyLlxyXG4gICAgICogQHBhcmFtIHBhc3QgT2xkZXIgdGltZWxpbmUuXHJcbiAgICAgKiBAcGFyYW0gcHJlc2VudCBOZXdlciB0aW1lbGluZS5cclxuICAgICAqIEByZXR1cm5zIHtSZXNvbHZlZFRpbWVsaW5lfSBjb250YWluaW5nIG1lcmdlZCB0aW1lbGluZXMuXHJcbiAgICAgKi9cclxuICAgIG1lcmdlVGltZWxpbmVPYmplY3RzKHBhc3QsIHByZXNlbnQsIGZyb21OZXdUaW1lbGluZSkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdGluZ09iamVjdHMgPSB7fTtcclxuICAgICAgICBpZiAoZnJvbU5ld1RpbWVsaW5lKSB7XHJcbiAgICAgICAgICAgIHBhc3QgPSB0aGlzLnRyaW1UaW1lbGluZShwYXN0LCB7IGVuZDogdGhpcy5fcGxheUhlYWRUaW1lIH0pO1xyXG4gICAgICAgICAgICBwcmVzZW50ID0gdGhpcy50cmltVGltZWxpbmUocHJlc2VudCwgeyBzdGFydDogdGhpcy5fcGxheUhlYWRUaW1lIH0pO1xyXG4gICAgICAgICAgICAvLyBCZWNhdXNlIHdlIHdhbnQgdG8ga2VlcCBvbGQgb2JqZWN0cywgdGhpcyBpdGVyYXRvciBpcyB1c2VkIHRvIGNyZWF0ZSB1bmlxdWUgb2xkIGlkcyBmb3IgdGhlbVxyXG4gICAgICAgICAgICB0aGlzLl9tZXJnZUl0ZXJhdG9yKys7XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhc3Qub2JqZWN0cykuZm9yRWFjaCgob2JqSWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhc3RPYmogPSBwYXN0Lm9iamVjdHNbb2JqSWRdO1xyXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZTogaGFjayB0byBtYXJrIGl0IGFzIGEgXCJwYXN0IG9iamVjdFwiXHJcbiAgICAgICAgICAgICAgICBpZiAocGFzdE9iai5fX3Bhc3RPYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IG92ZXIgaXQgcmlnaHQgYXdheSwgaXQncyBvbGQuIERvbid0IGRvIGFueXRoaW5nIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdPYmplY3RzW29iaklkXSA9IHBhc3RPYmo7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gSWYgYW4gb2JqZWN0IGV4aXN0cyBpbiBib3RoIHRpbWVsaW5lc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJlc2VudE9iaiA9IHByZXNlbnQub2JqZWN0c1tvYmpJZF07XHJcbiAgICAgICAgICAgICAgICBpZiAocHJlc2VudE9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wYXJlIHRoZSBvYmplY3RzLCBvbmx5IGxvb2sgaW50byBtZXJnaW5nIHRoZW0gaWYgdGhleSBsb29rIGlkZW50aWNhbFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRXF1YWwoT2JqZWN0LmFzc2lnbih7fSwgcGFzdE9iaiwgeyByZXNvbHZlZDogbnVsbCB9KSwgT2JqZWN0LmFzc2lnbih7fSwgcHJlc2VudE9iaiwgeyByZXNvbHZlZDogbnVsbCB9KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgYWxsIHBhc3QgaW5zdGFuY2VzIHN0b3AgYXQgYSBjZXJ0YWluIHRpbWUgYXQgdGhlIHZlcnkgbGF0ZXN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhhdCBhbGwgbmV3IGluc3RhbmNlcyBzdGFydCBhdCB0aGF0IHRpbWUgYXQgdGhlIHZlcnkgZWFybGllc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgaW5zdGFuY2VzIG9mIHRob3NlIG9iamVjdHMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbEluc3RhbmNlcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXN0T2JqLnJlc29sdmVkLmluc3RhbmNlcy5mb3JFYWNoKHBhc3RJbnN0YW5jZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxJbnN0YW5jZXNbcGFzdEluc3RhbmNlLmVuZCArICcnXSA9IHBhc3RJbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnRPYmoucmVzb2x2ZWQuaW5zdGFuY2VzLmZvckVhY2gocHJlc2VudEluc3RhbmNlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxJbnN0YW5jZXNbcHJlc2VudEluc3RhbmNlLnN0YXJ0ICsgJyddKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGluc3RhbmNlcyBhcmUgbmV4dCB0byBlYWNoIG90aGVyLCBtZXJnZSB0aGVtIGludG8gb25lOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEluc3RhbmNlc1twcmVzZW50SW5zdGFuY2Uuc3RhcnQgKyAnJ10uZW5kID0gcHJlc2VudEluc3RhbmNlLmVuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEluc3RhbmNlc1twcmVzZW50SW5zdGFuY2Uuc3RhcnQgKyAnJ10gPSBwcmVzZW50SW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW50T2JqLnJlc29sdmVkLmluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhbGxJbnN0YW5jZXMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gYWxsSW5zdGFuY2VzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW50T2JqLnJlc29sdmVkLmluc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcHkgb3ZlciB0aGUgbmV3IG9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdPYmplY3RzW29iaklkXSA9IHByZXNlbnRPYmo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZG9uJ3QgY29weSBvdmVyIG9sZCBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvYmplY3RzIGRvZXNuJ3QgbG9vayBpZGVudGljYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBvdmVyIHRoZSBuZXcgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ09iamVjdHNbb2JqSWRdID0gcHJlc2VudE9iajtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb2xkIG9iamVjdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBuZXcgdGltZWxpbmVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IGhhY2sgdG8gbWFyayBpdCBhcyBhIFwicGFzdCBvYmplY3RcIlxyXG4gICAgICAgICAgICAgICAgcGFzdE9iai5fX3Bhc3RPYmogPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgLy8gQ29weSBvdmVyIHRoZSBvbGQgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICByZXN1bHRpbmdPYmplY3RzW3RoaXMuX21lcmdlSXRlcmF0b3IgKyAnX18nICsgb2JqSWRdID0gcGFzdE9iajtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgbmV4dCBvYmplY3RzXHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByZXNlbnQub2JqZWN0cykuZm9yRWFjaCgob2JqSWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXNlbnRPYmogPSBwcmVzZW50Lm9iamVjdHNbb2JqSWRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwYXN0Lm9iamVjdHNbb2JqSWRdKSB7IC8vIChpZiBpdCBkaWQgZXhpc3RlZCBpbiB0aGUgcGFzdCwgaXQgaGFzIGFscmVhZHkgYmVlbiBoYW5kbGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgY29weSBvdmVyIHRoZSBuZXcgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nT2JqZWN0c1tvYmpJZF0gPSBwcmVzZW50T2JqO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vIG5ldyB0aW1lbGluZSwgb2JqZWN0cyBhbmQgaW5zdGFuY2VzIGFyZSBvbmx5IGFkZGVkXHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhc3Qub2JqZWN0cykuZm9yRWFjaCgob2JqSWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhc3RPYmogPSBwYXN0Lm9iamVjdHNbb2JqSWRdO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0aW5nT2JqZWN0c1tvYmpJZF0gPSBwYXN0T2JqO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMocHJlc2VudC5vYmplY3RzKS5mb3JFYWNoKChvYmpJZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJlc2VudE9iaiA9IHByZXNlbnQub2JqZWN0c1tvYmpJZF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ09iaiA9IHJlc3VsdGluZ09iamVjdHNbb2JqSWRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nT2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2Ugd2l0aCBvbGQgaW5zdGFuY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdJbnN0YW5jZXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ09iai5yZXNvbHZlZC5pbnN0YW5jZXMuZm9yRWFjaChpbnN0YW5jZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5zdGFuY2VzW2luc3RhbmNlLnN0YXJ0ICsgJ18nICsgaW5zdGFuY2UuZW5kXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VudE9iai5yZXNvbHZlZC5pbnN0YW5jZXMuZm9yRWFjaChpbnN0YW5jZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgcHVzaCBpbnN0YW5jZXMgdGhhdCBhcmVuJ3QgYWxyZWFkeSBwcmVzZW50OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nSW5zdGFuY2VzW2luc3RhbmNlLnN0YXJ0ICsgJ18nICsgaW5zdGFuY2UuZW5kXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdPYmoucmVzb2x2ZWQuaW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdPYmplY3RzW29iaklkXSA9IHByZXNlbnRPYmo7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHRpbmdMYXllcnMgPSB7fTtcclxuICAgICAgICBPYmplY3Qua2V5cyhyZXN1bHRpbmdPYmplY3RzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHJlc3VsdGluZ09iamVjdHNba2V5XTtcclxuICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSBvYmoubGF5ZXIgKyAnJztcclxuICAgICAgICAgICAgaWYgKCFyZXN1bHRpbmdMYXllcnNbbGF5ZXJdKVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0aW5nTGF5ZXJzW2xheWVyXSA9IFtdO1xyXG4gICAgICAgICAgICByZXN1bHRpbmdMYXllcnNbbGF5ZXJdLnB1c2goa2V5KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmVzZW50KSwgeyBvYmplY3RzOiByZXN1bHRpbmdPYmplY3RzLCBsYXllcnM6IHJlc3VsdGluZ0xheWVycyB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVRpbWVsaW5lUmVzb2x2ZVdpbmRvdygpIHtcclxuICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHRoaXMuZ2V0RXhwYW5kZWRTdGFydEVuZFRpbWUoMSk7XHJcbiAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlU3RhcnQgPSBzdGFydDtcclxuICAgICAgICB0aGlzLl90aW1lbGluZVJlc29sdmVFbmQgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlWm9vbSA9IHRoaXMuX3RpbWVsaW5lWm9vbTtcclxuICAgICAgICBpZiAodGhpcy5sYXRlc3RVcGRhdGVUaW1lKSB7XHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBhbiBvcHRpbWFsIG51bWJlciBvZiBvYmplY3RzIHRvIGNyZWF0ZSwgc28gdGhhdCB0aGUgZHJhd2luZyBzdGlsbCBydW5zIHNtb290aGx5LlxyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRSZXNvbHZlVGltZSA9IDUwOyAvLyBtc1xyXG4gICAgICAgICAgICBsZXQgcmF0aW8gPSB0YXJnZXRSZXNvbHZlVGltZSAvIHRoaXMubGF0ZXN0VXBkYXRlVGltZTtcclxuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlQ291bnRBZGp1c3QgPSBNYXRoLm1heCgwLjEsIE1hdGgubWluKDEwLCAoMSArICh0aGlzLl90aW1lbGluZVJlc29sdmVDb3VudEFkanVzdCAqIHJhdGlvKSkgLyAyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0RXhwYW5kZWRTdGFydEVuZFRpbWUobXVsdGlwbGllciA9IDEpIHtcclxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLl92aWV3U3RhcnRUaW1lO1xyXG4gICAgICAgIGxldCBlbmQgPSB0aGlzLnZpZXdFbmRUaW1lO1xyXG4gICAgICAgIGxldCBkdXJhdGlvbiA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgICAgIGxldCBleHBhbmQgPSBkdXJhdGlvbiAqICh0aGlzLl90aW1lbGluZVJlc29sdmVFeHBhbmQgLSAxKSAqIG11bHRpcGxpZXI7XHJcbiAgICAgICAgc3RhcnQgLT0gZXhwYW5kICogMC4zMztcclxuICAgICAgICBlbmQgKz0gZXhwYW5kICogMC42NjsgLy8gZXhwYW5kIG1vcmUgaW50byB0aGUgZnV0dXJlXHJcbiAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydCk7XHJcbiAgICAgICAgZW5kID0gTWF0aC5tYXgoMCwgZW5kKTtcclxuICAgICAgICBjb25zdCB6b29tRGlmZiA9IE1hdGgubWF4KHRoaXMuX3RpbWVsaW5lUmVzb2x2ZVpvb20sIHRoaXMuX3RpbWVsaW5lWm9vbSkgL1xyXG4gICAgICAgICAgICBNYXRoLm1pbih0aGlzLl90aW1lbGluZVJlc29sdmVab29tLCB0aGlzLl90aW1lbGluZVpvb20pO1xyXG4gICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQsIHpvb21EaWZmIH07XHJcbiAgICB9XHJcbiAgICBjaGVja0F1dG9tYXRpY1JlcmVzb2x2ZSgpIHtcclxuICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQsIHpvb21EaWZmIH0gPSB0aGlzLmdldEV4cGFuZGVkU3RhcnRFbmRUaW1lKDAuMik7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUF1dG8gJiYgKHN0YXJ0IDwgdGhpcy5fdGltZWxpbmVSZXNvbHZlU3RhcnQgfHxcclxuICAgICAgICAgICAgZW5kID4gdGhpcy5fdGltZWxpbmVSZXNvbHZlRW5kIHx8XHJcbiAgICAgICAgICAgIHpvb21EaWZmID4gMykpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlcmVzb2x2ZVRpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVyZXNvbHZlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVyZXNvbHZlVGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUaW1lbGluZVJlc29sdmVXaW5kb3coKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVUaW1lbGluZSgpO1xyXG4gICAgICAgICAgICAgICAgfSwgTWF0aC5tYXgoMTAwLCB0aGlzLmxhdGVzdFVwZGF0ZVRpbWUgKiA1KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gQ29udmVyc2lvbnMgYmV0d2VlbiBwb3NpdGlvbiAmIHRpbWUgLS0tLS0tLS0tLS0tLVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgdGhlIFggY29vcmRpbmF0ZSBvZiBhIHRpbWUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaGUgdGltZSB0byBjb252ZXJ0LlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdGltZS5cclxuICAgICAqL1xyXG4gICAgdGltZVRvWENvb3JkKHRpbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlld0RyYXdYICsgKCh0aW1lIC0gdGhpcy5fdmlld1N0YXJ0VGltZSkgKiB0aGlzLnBpeGVsc1dpZHRoUGVyVW5pdFRpbWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHRpbWUgb2YgYSBYIGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaGUgWCBjb29yZGluYXRlIHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgdGltZSBvZiB0aGUgWCBjb29yZGluYXRlLlxyXG4gICAgICovXHJcbiAgICB4Q29vcmRUb1RpbWUocG9zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlld1N0YXJ0VGltZSArICgocG9zaXRpb24gLSB0aGlzLl92aWV3RHJhd1gpIC8gdGhpcy5waXhlbHNXaWR0aFBlclVuaXRUaW1lKTtcclxuICAgIH1cclxuICAgIC8qKiBDYWxjdWxhdGUgdGhlIHJhdGlvIG9mIHRoZSB0aW1lIGluIGN1cnJlbnQgdmlldyAoMCBpIGJlZ2lubmluZywgMSBpcyBlbmQpICAqL1xyXG4gICAgdGltZVRvUmF0aW8odGltZSkge1xyXG4gICAgICAgIHJldHVybiAodGltZSAtIHRoaXMuX3ZpZXdTdGFydFRpbWUpIC8gdGhpcy52aWV3UmFuZ2U7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBwb3NpdGlvbiBpcyB3aXRoaW4gdGhlIGN1cnJlbnQgdmlldyAgKi9cclxuICAgIGlzdGltZUluVmlldyh0aW1lKSB7XHJcbiAgICAgICAgY29uc3QgcmF0aW8gPSB0aGlzLnRpbWVUb1JhdGlvKHRpbWUpO1xyXG4gICAgICAgIHJldHVybiByYXRpbyA+PSAwICYmIHJhdGlvIDwgMTtcclxuICAgIH1cclxuICAgIGNhcFhjb29yZFRvVmlldyhwb3NpdGlvbikge1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLl92aWV3RHJhd1gsIE1hdGgubWluKHRoaXMuX3ZpZXdEcmF3WCArIHRoaXMuX3ZpZXdEcmF3V2lkdGgsIHBvc2l0aW9uKSk7XHJcbiAgICB9XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLSBHZXR0ZXJzIC8gQ29udmVuaWVuY2UgZnVuY3Rpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLyoqIFpvb20gZmFjdG9yIFtwaXhlbHMgLyB0aW1lXSAqL1xyXG4gICAgZ2V0IHBpeGVsc1dpZHRoUGVyVW5pdFRpbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl90aW1lbGluZVpvb20gLyAxMDApO1xyXG4gICAgfVxyXG4gICAgLyoqIFRoZSByYW5nZSBvZiB0aGUgdmlldyBbdGltZV0gKi9cclxuICAgIGdldCB2aWV3UmFuZ2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdEcmF3V2lkdGggLyB0aGlzLnBpeGVsc1dpZHRoUGVyVW5pdFRpbWU7XHJcbiAgICB9XHJcbiAgICAvKiogVGhlIGVuZCB0aW1lIG9mIHRoZSB2aWV3IFt0aW1lXSAqL1xyXG4gICAgZ2V0IHZpZXdFbmRUaW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3U3RhcnRUaW1lICsgdGhpcy52aWV3UmFuZ2U7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5UaW1lbGluZVZpc3VhbGl6ZXIgPSBUaW1lbGluZVZpc3VhbGl6ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVsaW5lVmlzdWFsaXplci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgb2JqZWN0Q3JlYXRlUG9seWZpbGxcbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgb2JqZWN0S2V5c1BvbHlmaWxsXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGZ1bmN0aW9uQmluZFBvbHlmaWxsXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX2V2ZW50cycpKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbnZhciBoYXNEZWZpbmVQcm9wZXJ0eTtcbnRyeSB7XG4gIHZhciBvID0ge307XG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCAneCcsIHsgdmFsdWU6IDAgfSk7XG4gIGhhc0RlZmluZVByb3BlcnR5ID0gby54ID09PSAwO1xufSBjYXRjaCAoZXJyKSB7IGhhc0RlZmluZVByb3BlcnR5ID0gZmFsc2UgfVxuaWYgKGhhc0RlZmluZVByb3BlcnR5KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIGlucHV0IGlzIGEgcG9zaXRpdmUgbnVtYmVyICh3aG9zZSB2YWx1ZSBpcyB6ZXJvIG9yXG4gICAgICAvLyBncmVhdGVyIGFuZCBub3QgYSBOYU4pLlxuICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgYXJnICE9PSBhcmcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZGVmYXVsdE1heExpc3RlbmVyc1wiIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gZGVmYXVsdE1heExpc3RlbmVycztcbn1cblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm5cIiBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbi8vIFRoZXNlIHN0YW5kYWxvbmUgZW1pdCogZnVuY3Rpb25zIGFyZSB1c2VkIHRvIG9wdGltaXplIGNhbGxpbmcgb2YgZXZlbnRcbi8vIGhhbmRsZXJzIGZvciBmYXN0IGNhc2VzIGJlY2F1c2UgZW1pdCgpIGl0c2VsZiBvZnRlbiBoYXMgYSB2YXJpYWJsZSBudW1iZXIgb2Zcbi8vIGFyZ3VtZW50cyBhbmQgY2FuIGJlIGRlb3B0aW1pemVkIGJlY2F1c2Ugb2YgdGhhdC4gVGhlc2UgZnVuY3Rpb25zIGFsd2F5cyBoYXZlXG4vLyB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCB0aHVzIGRvIG5vdCBnZXQgZGVvcHRpbWl6ZWQsIHNvIHRoZSBjb2RlXG4vLyBpbnNpZGUgdGhlbSBjYW4gZXhlY3V0ZSBmYXN0ZXIuXG5mdW5jdGlvbiBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJncykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgZXZlbnRzO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PSBudWxsKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoIWhhbmRsZXIpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBpc0ZuID0gdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbic7XG4gIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHN3aXRjaCAobGVuKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgY2FzZSAxOlxuICAgICAgZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgdGhpcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgZGVmYXVsdDpcbiAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmICghZXZlbnRzKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBpZiAoIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICAgIGlmIChtICYmIG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0pIHtcbiAgICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnIFwiJyArIFN0cmluZyh0eXBlKSArICdcIiBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0LicpO1xuICAgICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignJXM6ICVzJywgdy5uYW1lLCB3Lm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0pO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzJdKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IGJpbmQuY2FsbChvbmNlV3JhcHBlciwgc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmICghbGlzdClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKCFldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKCFldmVudHMpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoIWV2bGlzdGVuZXIpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdC5vd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbi8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKS5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpXG4gICAgbGlzdFtpXSA9IGxpc3Rba107XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb2JqZWN0Q3JlYXRlUG9seWZpbGwocHJvdG8pIHtcbiAgdmFyIEYgPSBmdW5jdGlvbigpIHt9O1xuICBGLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXR1cm4gbmV3IEY7XG59XG5mdW5jdGlvbiBvYmplY3RLZXlzUG9seWZpbGwob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGsgaW4gb2JqKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaykpIHtcbiAgICBrZXlzLnB1c2goayk7XG4gIH1cbiAgcmV0dXJuIGs7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkJpbmRQb2x5ZmlsbChjb250ZXh0KSB7XG4gIHZhciBmbiA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCIvKipcbiAqIExvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxuICAgIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpLFxuICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXG4gICAgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gKiBlcXVpdmFsZW50LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBvYmplY3QgPT09IG90aGVyO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFcXVhbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FdmVudFR5cGUgPSB2b2lkIDA7XG52YXIgRXZlbnRUeXBlO1xuKGZ1bmN0aW9uIChFdmVudFR5cGUpIHtcbiAgICBFdmVudFR5cGVbRXZlbnRUeXBlW1wiU1RBUlRcIl0gPSAwXSA9IFwiU1RBUlRcIjtcbiAgICBFdmVudFR5cGVbRXZlbnRUeXBlW1wiRU5EXCJdID0gMV0gPSBcIkVORFwiO1xuICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJLRVlGUkFNRVwiXSA9IDJdID0gXCJLRVlGUkFNRVwiO1xufSkoRXZlbnRUeXBlID0gZXhwb3J0cy5FdmVudFR5cGUgfHwgKGV4cG9ydHMuRXZlbnRUeXBlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZUtleWZyYW1lID0gZXhwb3J0cy52YWxpZGF0ZU9iamVjdCA9IGV4cG9ydHMudmFsaWRhdGVUaW1lbGluZSA9IGV4cG9ydHMuUmVzb2x2ZXIgPSB2b2lkIDA7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9hcGkvZW51bXNcIiksIGV4cG9ydHMpO1xuKDAsIHRzbGliXzEuX19leHBvcnRTdGFyKShyZXF1aXJlKFwiLi9hcGkvYXBpXCIpLCBleHBvcnRzKTtcbnZhciByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXIvcmVzb2x2ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXNvbHZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZXJfMS5SZXNvbHZlcjsgfSB9KTtcbnZhciB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXIvdmFsaWRhdGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YWxpZGF0ZVRpbWVsaW5lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWxpZGF0ZV8xLnZhbGlkYXRlVGltZWxpbmU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YWxpZGF0ZU9iamVjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfMS52YWxpZGF0ZU9iamVjdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhbGlkYXRlS2V5ZnJhbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlXzEudmFsaWRhdGVLZXlmcmFtZTsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jbGVhbkNhY2hlUmVzdWx0ID0gZXhwb3J0cy5jYWNoZVJlc3VsdCA9IGV4cG9ydHMuYXBwbHlQYXJlbnRJbnN0YW5jZXMgPSBleHBvcnRzLnNldEluc3RhbmNlU3RhcnRUaW1lID0gZXhwb3J0cy5zZXRJbnN0YW5jZUVuZFRpbWUgPSBleHBvcnRzLnJlc2V0SWQgPSBleHBvcnRzLmdldElkID0gZXhwb3J0cy5qb2luQ2FwcyA9IGV4cG9ydHMuYWRkQ2Fwc1RvUmVzdW1pbmcgPSBleHBvcnRzLmpvaW5SZWZlcmVuY2VzID0gZXhwb3J0cy5pc1JlZmVyZW5jZSA9IGV4cG9ydHMuY2FwSW5zdGFuY2VzID0gZXhwb3J0cy5hcHBseVJlcGVhdGluZ0luc3RhbmNlcyA9IGV4cG9ydHMub3BlcmF0ZU9uQXJyYXlzID0gZXhwb3J0cy5pbnZlcnRJbnN0YW5jZXMgPSBleHBvcnRzLmNvbnZlcnRFdmVudHNUb0luc3RhbmNlcyA9IGV4cG9ydHMuY2xlYW5JbnN0YW5jZXMgPSBleHBvcnRzLnNvcnRFdmVudHMgPSBleHBvcnRzLmlzTnVtZXJpYyA9IGV4cG9ydHMuaXNDb25zdGFudCA9IGV4cG9ydHMuZXh0ZW5kTWFuZGFkb3J5ID0gdm9pZCAwO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuLyoqXG4gKiBTb21ld2hhdCBsaWtlIF8uZXh0ZW5kLCBidXQgd2l0aCBzdHJvbmcgdHlwZXMgJiBtYW5kYXRlZCBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqIEBwYXJhbSBvcmlnaW5hbCBPYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSBleHRlbmRPYmogcHJvcGVydGllcyB0byBhZGRcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kTWFuZGFkb3J5KG9yaWdpbmFsLCBleHRlbmRPYmopIHtcbiAgICByZXR1cm4gXy5leHRlbmQob3JpZ2luYWwsIGV4dGVuZE9iaik7XG59XG5leHBvcnRzLmV4dGVuZE1hbmRhZG9yeSA9IGV4dGVuZE1hbmRhZG9yeTtcbmZ1bmN0aW9uIGlzQ29uc3RhbnQoc3RyKSB7XG4gICAgcmV0dXJuICEhKGlzTnVtZXJpYyhzdHIpIHx8IChfLmlzU3RyaW5nKHN0cikgJiYgKHN0ci5tYXRjaCgvXnRydWUkLykgfHwgc3RyLm1hdGNoKC9eZmFsc2UkLykpKSk7XG59XG5leHBvcnRzLmlzQ29uc3RhbnQgPSBpc0NvbnN0YW50O1xuZnVuY3Rpb24gaXNOdW1lcmljKHN0cikge1xuICAgIGlmIChzdHIgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoXy5pc051bWJlcihzdHIpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoXy5pc1N0cmluZyhzdHIpKVxuICAgICAgICByZXR1cm4gISEoc3RyLm1hdGNoKC9eWy0rXT9bMC05Ll0rJC8pICYmICFfLmlzTmFOKHBhcnNlRmxvYXQoc3RyKSkpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNOdW1lcmljID0gaXNOdW1lcmljO1xuZnVuY3Rpb24gc29ydEV2ZW50cyhldmVudHMpIHtcbiAgICByZXR1cm4gZXZlbnRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgaWYgKGEudGltZSA+IGIudGltZSlcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoYS50aW1lIDwgYi50aW1lKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBjb25zdCBhSWQgPSBhLmRhdGEgJiYgKGEuZGF0YS5pZCB8fCAoYS5kYXRhLmluc3RhbmNlICYmIGEuZGF0YS5pbnN0YW5jZS5pZCkpO1xuICAgICAgICBjb25zdCBiSWQgPSBiLmRhdGEgJiYgKGIuZGF0YS5pZCB8fCAoYi5kYXRhLmluc3RhbmNlICYmIGIuZGF0YS5pbnN0YW5jZS5pZCkpO1xuICAgICAgICBpZiAoYUlkICYmIGJJZCAmJiBhSWQgPT09IGJJZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGV2ZW50IHJlZmVyIHRvIHRoZSBzYW1lIElELCBsZXQgdGhlIGVuZGluZyBldmVudCBiZSBmaXJzdDpcbiAgICAgICAgICAgIGlmIChhLnZhbHVlICYmICFiLnZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmICghYS52YWx1ZSAmJiBiLnZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLnZhbHVlICYmICFiLnZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmICghYS52YWx1ZSAmJiBiLnZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9KTtcbn1cbmV4cG9ydHMuc29ydEV2ZW50cyA9IHNvcnRFdmVudHM7XG4vKipcbiAqIENsZWFuIHVwIGluc3RhbmNlcywgam9pbiBvdmVybGFwcGluZyBldGMuLlxuICogQHBhcmFtIGluc3RhbmNlc1xuICovXG5mdW5jdGlvbiBjbGVhbkluc3RhbmNlcyhpbnN0YW5jZXMsIGFsbG93TWVyZ2UsIGFsbG93WmVyb0dhcHMgPSBmYWxzZSkge1xuICAgIC8vIEZpcnN0LCBvcHRpbWl6ZSBmb3IgY2VydGFpbiBjb21tb24gc2l0dWF0aW9uczpcbiAgICBpZiAoaW5zdGFuY2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGlmIChpbnN0YW5jZXMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gaW5zdGFuY2VzO1xuICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzW2ldO1xuICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgICB0aW1lOiBpbnN0YW5jZS5zdGFydCxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgZGF0YTogeyBpbnN0YW5jZTogaW5zdGFuY2UgfSxcbiAgICAgICAgICAgIHJlZmVyZW5jZXM6IGluc3RhbmNlLnJlZmVyZW5jZXMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW5zdGFuY2UuZW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdGltZTogaW5zdGFuY2UuZW5kLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkYXRhOiB7IGluc3RhbmNlOiBpbnN0YW5jZSB9LFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGluc3RhbmNlLnJlZmVyZW5jZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udmVydEV2ZW50c1RvSW5zdGFuY2VzKGV2ZW50cywgYWxsb3dNZXJnZSwgYWxsb3daZXJvR2Fwcyk7XG59XG5leHBvcnRzLmNsZWFuSW5zdGFuY2VzID0gY2xlYW5JbnN0YW5jZXM7XG5mdW5jdGlvbiBjb252ZXJ0RXZlbnRzVG9JbnN0YW5jZXMoZXZlbnRzLCBhbGxvd01lcmdlLCBhbGxvd1plcm9HYXBzID0gZmFsc2UpIHtcbiAgICBzb3J0RXZlbnRzKGV2ZW50cyk7XG4gICAgY29uc3QgYWN0aXZlSW5zdGFuY2VzID0ge307XG4gICAgbGV0IGFjdGl2ZUluc3RhbmNlSWQgPSBudWxsO1xuICAgIGxldCBwcmV2aW91c0FjdGl2ZSA9IGZhbHNlO1xuICAgIGNvbnN0IG5lZ2F0aXZlSW5zdGFuY2VzID0ge307XG4gICAgbGV0IHByZXZpb3VzTmVnYXRpdmUgPSBmYWxzZTtcbiAgICBsZXQgbmVnYXRpdmVJbnN0YW5jZUlkID0gbnVsbDtcbiAgICBjb25zdCByZXR1cm5JbnN0YW5jZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBldmVudCA9IGV2ZW50c1tpXTtcbiAgICAgICAgY29uc3QgZXZlbnRJZCA9IGV2ZW50LmRhdGEuaWQgfHwgZXZlbnQuZGF0YS5pbnN0YW5jZS5pZDtcbiAgICAgICAgY29uc3QgbGFzdEluc3RhbmNlID0gcmV0dXJuSW5zdGFuY2VzW3JldHVybkluc3RhbmNlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGV2ZW50LnZhbHVlKSB7XG4gICAgICAgICAgICBhY3RpdmVJbnN0YW5jZXNbZXZlbnRJZF0gPSBldmVudDtcbiAgICAgICAgICAgIGRlbGV0ZSBuZWdhdGl2ZUluc3RhbmNlc1tldmVudElkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBhY3RpdmVJbnN0YW5jZXNbZXZlbnRJZF07XG4gICAgICAgICAgICBuZWdhdGl2ZUluc3RhbmNlc1tldmVudElkXSA9IGV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhhY3RpdmVJbnN0YW5jZXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgYW4gYWN0aXZlIGluc3RhbmNlXG4gICAgICAgICAgICBpZiAoIWFsbG93TWVyZ2UgJiYgIWFsbG93WmVyb0dhcHMgJiYgbGFzdEluc3RhbmNlICYmIHByZXZpb3VzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBwcmV2aW91c2x5IGFuIGluQWN0aXZlIChuZWdhdGl2ZSkgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICBsYXN0SW5zdGFuY2Uuc3RhcnQgPSBldmVudC50aW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbyA9IGhhbmRsZUFjdGl2ZUluc3RhbmNlcyhldmVudCwgbGFzdEluc3RhbmNlLCBhY3RpdmVJbnN0YW5jZUlkLCBldmVudElkLCBhY3RpdmVJbnN0YW5jZXMsIGFsbG93TWVyZ2UsIGFsbG93WmVyb0dhcHMpO1xuICAgICAgICAgICAgICAgIGFjdGl2ZUluc3RhbmNlSWQgPSBvLmFjdGl2ZUluc3RhbmNlSWQ7XG4gICAgICAgICAgICAgICAgaWYgKG8ucmV0dXJuSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuSW5zdGFuY2VzLnB1c2goby5yZXR1cm5JbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgcHJldmlvdXNOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gaW5zdGFuY2VzIGFyZSBhY3RpdmVcbiAgICAgICAgICAgIGlmIChsYXN0SW5zdGFuY2UgJiYgcHJldmlvdXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBsYXN0SW5zdGFuY2UuZW5kID0gZXZlbnQudGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhuZWdhdGl2ZUluc3RhbmNlcykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgbmVnYXRpdmUgaW5zdGFuY2UgcnVubmluZ1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvID0gaGFuZGxlQWN0aXZlSW5zdGFuY2VzKGV2ZW50LCBsYXN0SW5zdGFuY2UsIG5lZ2F0aXZlSW5zdGFuY2VJZCwgZXZlbnRJZCwgbmVnYXRpdmVJbnN0YW5jZXMsIGFsbG93TWVyZ2UsIGFsbG93WmVyb0dhcHMpO1xuICAgICAgICAgICAgICAgICAgICBuZWdhdGl2ZUluc3RhbmNlSWQgPSBvLmFjdGl2ZUluc3RhbmNlSWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvLnJldHVybkluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5JbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uby5yZXR1cm5JbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogby5yZXR1cm5JbnN0YW5jZS5lbmQgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG8ucmV0dXJuSW5zdGFuY2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c05lZ2F0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91c0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5JbnN0YW5jZXM7XG59XG5leHBvcnRzLmNvbnZlcnRFdmVudHNUb0luc3RhbmNlcyA9IGNvbnZlcnRFdmVudHNUb0luc3RhbmNlcztcbmZ1bmN0aW9uIGhhbmRsZUFjdGl2ZUluc3RhbmNlcyhldmVudCwgbGFzdEluc3RhbmNlLCBhY3RpdmVJbnN0YW5jZUlkLCBldmVudElkLCBhY3RpdmVJbnN0YW5jZXMsIGFsbG93TWVyZ2UsIGFsbG93WmVyb0dhcHMgPSBmYWxzZSkge1xuICAgIGxldCByZXR1cm5JbnN0YW5jZSA9IG51bGw7XG4gICAgaWYgKCFhbGxvd01lcmdlICYmXG4gICAgICAgIGV2ZW50LnZhbHVlICYmXG4gICAgICAgIGxhc3RJbnN0YW5jZSAmJlxuICAgICAgICBsYXN0SW5zdGFuY2UuZW5kID09PSBudWxsICYmXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlSWQgIT09IG51bGwgJiZcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VJZCAhPT0gZXZlbnRJZCkge1xuICAgICAgICAvLyBTdGFydCBhIG5ldyBpbnN0YW5jZTpcbiAgICAgICAgbGFzdEluc3RhbmNlLmVuZCA9IGV2ZW50LnRpbWU7XG4gICAgICAgIHJldHVybkluc3RhbmNlID0ge1xuICAgICAgICAgICAgaWQ6IGdldElkKCksXG4gICAgICAgICAgICBzdGFydDogZXZlbnQudGltZSxcbiAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgIHJlZmVyZW5jZXM6IGV2ZW50LnJlZmVyZW5jZXMsXG4gICAgICAgICAgICBvcmlnaW5hbEVuZDogZXZlbnQuZGF0YS5pbnN0YW5jZS5vcmlnaW5hbEVuZCxcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhcnQ6IGV2ZW50LmRhdGEuaW5zdGFuY2Uub3JpZ2luYWxTdGFydCxcbiAgICAgICAgfTtcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VJZCA9IGV2ZW50SWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFhbGxvd01lcmdlICYmICFldmVudC52YWx1ZSAmJiBsYXN0SW5zdGFuY2UgJiYgYWN0aXZlSW5zdGFuY2VJZCA9PT0gZXZlbnRJZCkge1xuICAgICAgICAvLyBUaGUgYWN0aXZlIGluc3RhbmNlIHN0b3BwZWQgcGxheWluZywgYnV0IGFub3RoZXIgaXMgc3RpbGwgcGxheWluZ1xuICAgICAgICBjb25zdCBsYXRlc3RJbnN0YW5jZSA9IF8ucmVkdWNlKGFjdGl2ZUluc3RhbmNlcywgKG1lbW8sIGluc3RhbmNlRXZlbnQsIGlkKSA9PiB7XG4gICAgICAgICAgICBpZiAobWVtbyA9PT0gbnVsbCB8fCBtZW1vLmV2ZW50LnRpbWUgPCBpbnN0YW5jZUV2ZW50LnRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogaW5zdGFuY2VFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgfSwgbnVsbCk7XG4gICAgICAgIGlmIChsYXRlc3RJbnN0YW5jZSkge1xuICAgICAgICAgICAgLy8gUmVzdGFydCB0aGF0IGluc3RhbmNlIG5vdzpcbiAgICAgICAgICAgIGxhc3RJbnN0YW5jZS5lbmQgPSBldmVudC50aW1lO1xuICAgICAgICAgICAgcmV0dXJuSW5zdGFuY2UgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGV2ZW50SWQgKyAnXycgKyBnZXRJZCgpLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBldmVudC50aW1lLFxuICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBsYXRlc3RJbnN0YW5jZS5ldmVudC5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kOiBldmVudC5kYXRhLmluc3RhbmNlLm9yaWdpbmFsRW5kLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnQ6IGV2ZW50LmRhdGEuaW5zdGFuY2Uub3JpZ2luYWxTdGFydCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhY3RpdmVJbnN0YW5jZUlkID0gbGF0ZXN0SW5zdGFuY2UuaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYWxsb3dNZXJnZSAmJiAhYWxsb3daZXJvR2FwcyAmJiBsYXN0SW5zdGFuY2UgJiYgbGFzdEluc3RhbmNlLmVuZCA9PT0gZXZlbnQudGltZSkge1xuICAgICAgICAvLyBUaGUgcHJldmlvdXNseSBydW5uaW5nIGVuZGVkIGp1c3Qgbm93XG4gICAgICAgIC8vIHJlc3VtZSBwcmV2aW91cyBpbnN0YW5jZTpcbiAgICAgICAgbGFzdEluc3RhbmNlLmVuZCA9IG51bGw7XG4gICAgICAgIGxhc3RJbnN0YW5jZS5yZWZlcmVuY2VzID0gam9pblJlZmVyZW5jZXMobGFzdEluc3RhbmNlLnJlZmVyZW5jZXMsIGV2ZW50LnJlZmVyZW5jZXMpO1xuICAgICAgICBhZGRDYXBzVG9SZXN1bWluZyhsYXN0SW5zdGFuY2UsIGV2ZW50LmRhdGEuaW5zdGFuY2UuY2Fwcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFsYXN0SW5zdGFuY2UgfHwgbGFzdEluc3RhbmNlLmVuZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGVyZSBpcyBubyBwcmV2aW91c2x5IHJ1bm5pbmcgaW5zdGFuY2VcbiAgICAgICAgLy8gU3RhcnQgYSBuZXcgaW5zdGFuY2U6XG4gICAgICAgIHJldHVybkluc3RhbmNlID0ge1xuICAgICAgICAgICAgaWQ6IGV2ZW50SWQsXG4gICAgICAgICAgICBzdGFydDogZXZlbnQudGltZSxcbiAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgIHJlZmVyZW5jZXM6IGV2ZW50LnJlZmVyZW5jZXMsXG4gICAgICAgICAgICBjYXBzOiBldmVudC5kYXRhLmluc3RhbmNlLmNhcHMsXG4gICAgICAgICAgICBvcmlnaW5hbEVuZDogZXZlbnQuZGF0YS5pbnN0YW5jZS5vcmlnaW5hbEVuZCxcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhcnQ6IGV2ZW50LmRhdGEuaW5zdGFuY2Uub3JpZ2luYWxTdGFydCxcbiAgICAgICAgfTtcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VJZCA9IGV2ZW50SWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUaGVyZSBpcyBhbHJlYWR5IGEgcnVubmluZyBpbnN0YW5jZVxuICAgICAgICBsYXN0SW5zdGFuY2UucmVmZXJlbmNlcyA9IGpvaW5SZWZlcmVuY2VzKGxhc3RJbnN0YW5jZS5yZWZlcmVuY2VzLCBldmVudC5yZWZlcmVuY2VzKTtcbiAgICAgICAgYWRkQ2Fwc1RvUmVzdW1pbmcobGFzdEluc3RhbmNlLCBldmVudC5kYXRhLmluc3RhbmNlLmNhcHMpO1xuICAgIH1cbiAgICBpZiAobGFzdEluc3RhbmNlICYmIGxhc3RJbnN0YW5jZS5jYXBzICYmICFsYXN0SW5zdGFuY2UuY2Fwcy5sZW5ndGgpXG4gICAgICAgIGRlbGV0ZSBsYXN0SW5zdGFuY2UuY2FwcztcbiAgICBpZiAocmV0dXJuSW5zdGFuY2UgJiZcbiAgICAgICAgbGFzdEluc3RhbmNlICYmXG4gICAgICAgIGxhc3RJbnN0YW5jZS5zdGFydCA9PT0gbGFzdEluc3RhbmNlLmVuZCAmJlxuICAgICAgICBsYXN0SW5zdGFuY2UuZW5kID09PSByZXR1cm5JbnN0YW5jZS5zdGFydCkge1xuICAgICAgICAvLyByZXBsYWNlIHRoZSBwcmV2aW91cyB6ZXJvLWxlbmd0aCB3aXRoIHRoaXMgb25lIGluc3RlYWRcbiAgICAgICAgbGFzdEluc3RhbmNlLmlkID0gcmV0dXJuSW5zdGFuY2UuaWQ7XG4gICAgICAgIGxhc3RJbnN0YW5jZS5zdGFydCA9IHJldHVybkluc3RhbmNlLnN0YXJ0O1xuICAgICAgICBsYXN0SW5zdGFuY2UuZW5kID0gcmV0dXJuSW5zdGFuY2UuZW5kO1xuICAgICAgICBsYXN0SW5zdGFuY2UucmVmZXJlbmNlcyA9IHJldHVybkluc3RhbmNlLnJlZmVyZW5jZXM7XG4gICAgICAgIGxhc3RJbnN0YW5jZS5jYXBzID0gcmV0dXJuSW5zdGFuY2UuY2FwcztcbiAgICAgICAgbGFzdEluc3RhbmNlLm9yaWdpbmFsU3RhcnQgPSByZXR1cm5JbnN0YW5jZS5vcmlnaW5hbFN0YXJ0O1xuICAgICAgICBsYXN0SW5zdGFuY2Uub3JpZ2luYWxFbmQgPSByZXR1cm5JbnN0YW5jZS5vcmlnaW5hbEVuZDtcbiAgICAgICAgcmV0dXJuSW5zdGFuY2UgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhY3RpdmVJbnN0YW5jZUlkLFxuICAgICAgICByZXR1cm5JbnN0YW5jZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gaW52ZXJ0SW5zdGFuY2VzKGluc3RhbmNlcykge1xuICAgIGlmIChpbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICAgIGluc3RhbmNlcyA9IGNsZWFuSW5zdGFuY2VzKGluc3RhbmNlcywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGludmVydGVkSW5zdGFuY2VzID0gW107XG4gICAgICAgIGlmIChpbnN0YW5jZXNbMF0uc3RhcnQgIT09IDApIHtcbiAgICAgICAgICAgIGludmVydGVkSW5zdGFuY2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBnZXRJZCgpLFxuICAgICAgICAgICAgICAgIGlzRmlyc3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGpvaW5SZWZlcmVuY2VzKGluc3RhbmNlc1swXS5yZWZlcmVuY2VzLCBpbnN0YW5jZXNbMF0uaWQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzW2ldO1xuICAgICAgICAgICAgY29uc3QgbGFzdCA9IF8ubGFzdChpbnZlcnRlZEluc3RhbmNlcyk7XG4gICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgIGxhc3QuZW5kID0gaW5zdGFuY2Uuc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuZW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW52ZXJ0ZWRJbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBnZXRJZCgpLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogaW5zdGFuY2UuZW5kLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGpvaW5SZWZlcmVuY2VzKGluc3RhbmNlLnJlZmVyZW5jZXMsIGluc3RhbmNlLmlkKSxcbiAgICAgICAgICAgICAgICAgICAgY2FwczogaW5zdGFuY2UuY2FwcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW52ZXJ0ZWRJbnN0YW5jZXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiBnZXRJZCgpLFxuICAgICAgICAgICAgICAgIGlzRmlyc3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IFtdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9XG59XG5leHBvcnRzLmludmVydEluc3RhbmNlcyA9IGludmVydEluc3RhbmNlcztcbi8qKlxuICogUGVyZm9ybSBhbiBhY3Rpb24gb24gMiBhcnJheXMuIEJlaGF2ZXMgc29tZXdoYXQgbGlrZSB0aGUgXCIuKlwiLW9wZXJhdG9yIGluIE1hdGxhYlxuICogQHBhcmFtIGFycmF5MFxuICogQHBhcmFtIGFycmF5MVxuICogQHBhcmFtIG9wZXJhdGVcbiAqL1xuZnVuY3Rpb24gb3BlcmF0ZU9uQXJyYXlzKGFycmF5MCwgYXJyYXkxLCBvcGVyYXRlKSB7XG4gICAgaWYgKGFycmF5MCA9PT0gbnVsbCB8fCBhcnJheTEgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChpc1JlZmVyZW5jZShhcnJheTApICYmIGlzUmVmZXJlbmNlKGFycmF5MSkpIHtcbiAgICAgICAgcmV0dXJuIG9wZXJhdGUoYXJyYXkwLCBhcnJheTEpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBtaW5MZW5ndGggPSBNYXRoLm1pbihfLmlzQXJyYXkoYXJyYXkwKSA/IGFycmF5MC5sZW5ndGggOiBJbmZpbml0eSwgXy5pc0FycmF5KGFycmF5MSkgPyBhcnJheTEubGVuZ3RoIDogSW5maW5pdHkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWluTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IF8uaXNBcnJheShhcnJheTApXG4gICAgICAgICAgICA/IGFycmF5MFtpXVxuICAgICAgICAgICAgOiB7IGlkOiAnJywgc3RhcnQ6IGFycmF5MC52YWx1ZSwgZW5kOiBhcnJheTAudmFsdWUsIHJlZmVyZW5jZXM6IGFycmF5MC5yZWZlcmVuY2VzIH07XG4gICAgICAgIGNvbnN0IGIgPSBfLmlzQXJyYXkoYXJyYXkxKVxuICAgICAgICAgICAgPyBhcnJheTFbaV1cbiAgICAgICAgICAgIDogeyBpZDogJycsIHN0YXJ0OiBhcnJheTEudmFsdWUsIGVuZDogYXJyYXkxLnZhbHVlLCByZWZlcmVuY2VzOiBhcnJheTEucmVmZXJlbmNlcyB9O1xuICAgICAgICBjb25zdCBzdGFydCA9IGEuaXNGaXJzdFxuICAgICAgICAgICAgPyB7IHZhbHVlOiBhLnN0YXJ0LCByZWZlcmVuY2VzOiBhLnJlZmVyZW5jZXMgfVxuICAgICAgICAgICAgOiBiLmlzRmlyc3RcbiAgICAgICAgICAgICAgICA/IHsgdmFsdWU6IGIuc3RhcnQsIHJlZmVyZW5jZXM6IGIucmVmZXJlbmNlcyB9XG4gICAgICAgICAgICAgICAgOiBvcGVyYXRlKHsgdmFsdWU6IGEuc3RhcnQsIHJlZmVyZW5jZXM6IGpvaW5SZWZlcmVuY2VzKGEuaWQsIGEucmVmZXJlbmNlcykgfSwgeyB2YWx1ZTogYi5zdGFydCwgcmVmZXJlbmNlczogam9pblJlZmVyZW5jZXMoYi5pZCwgYi5yZWZlcmVuY2VzKSB9KTtcbiAgICAgICAgY29uc3QgZW5kID0gYS5pc0ZpcnN0XG4gICAgICAgICAgICA/IGEuZW5kICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyB7IHZhbHVlOiBhLmVuZCwgcmVmZXJlbmNlczogYS5yZWZlcmVuY2VzIH1cbiAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgIDogYi5pc0ZpcnN0XG4gICAgICAgICAgICAgICAgPyBiLmVuZCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICA/IHsgdmFsdWU6IGIuZW5kLCByZWZlcmVuY2VzOiBiLnJlZmVyZW5jZXMgfVxuICAgICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgICA6IG9wZXJhdGUoYS5lbmQgIT09IG51bGwgPyB7IHZhbHVlOiBhLmVuZCwgcmVmZXJlbmNlczogam9pblJlZmVyZW5jZXMoYS5pZCwgYS5yZWZlcmVuY2VzKSB9IDogbnVsbCwgYi5lbmQgIT09IG51bGwgPyB7IHZhbHVlOiBiLmVuZCwgcmVmZXJlbmNlczogam9pblJlZmVyZW5jZXMoYi5pZCwgYi5yZWZlcmVuY2VzKSB9IDogbnVsbCk7XG4gICAgICAgIGlmIChzdGFydCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBnZXRJZCgpLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydC52YWx1ZSxcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZCA9PT0gbnVsbCA/IG51bGwgOiBlbmQudmFsdWUsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogam9pblJlZmVyZW5jZXMoc3RhcnQucmVmZXJlbmNlcywgZW5kICE9PSBudWxsID8gZW5kLnJlZmVyZW5jZXMgOiBbXSksXG4gICAgICAgICAgICAgICAgY2Fwczogam9pbkNhcHMoYS5jYXBzLCBiLmNhcHMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsZWFuSW5zdGFuY2VzKHJlc3VsdCwgZmFsc2UpO1xufVxuZXhwb3J0cy5vcGVyYXRlT25BcnJheXMgPSBvcGVyYXRlT25BcnJheXM7XG5mdW5jdGlvbiBhcHBseVJlcGVhdGluZ0luc3RhbmNlcyhpbnN0YW5jZXMsIHJlcGVhdFRpbWUwLCBvcHRpb25zKSB7XG4gICAgaWYgKHJlcGVhdFRpbWUwID09PSBudWxsIHx8ICFyZXBlYXRUaW1lMC52YWx1ZSlcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlcztcbiAgICBjb25zdCByZXBlYXRUaW1lID0gcmVwZWF0VGltZTAudmFsdWU7XG4gICAgaWYgKGlzUmVmZXJlbmNlKGluc3RhbmNlcykpIHtcbiAgICAgICAgaW5zdGFuY2VzID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiAnJyxcbiAgICAgICAgICAgICAgICBzdGFydDogaW5zdGFuY2VzLnZhbHVlLFxuICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBpbnN0YW5jZXMucmVmZXJlbmNlcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0IHJlcGVhdGVkSW5zdGFuY2VzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaV07XG4gICAgICAgIGxldCBzdGFydFRpbWUgPSBNYXRoLm1heChvcHRpb25zLnRpbWUgLSAoKG9wdGlvbnMudGltZSAtIGluc3RhbmNlLnN0YXJ0KSAlIHJlcGVhdFRpbWUpLCBpbnN0YW5jZS5zdGFydCk7XG4gICAgICAgIGxldCBlbmRUaW1lID0gaW5zdGFuY2UuZW5kID09PSBudWxsID8gbnVsbCA6IGluc3RhbmNlLmVuZCArIChzdGFydFRpbWUgLSBpbnN0YW5jZS5zdGFydCk7XG4gICAgICAgIGNvbnN0IGNhcCA9IChpbnN0YW5jZS5jYXBzID8gXy5maW5kKGluc3RhbmNlLmNhcHMsIChjYXApID0+IGluc3RhbmNlLnJlZmVyZW5jZXMuaW5kZXhPZihjYXAuaWQpICE9PSAtMSkgOiBudWxsKSB8fCBudWxsO1xuICAgICAgICBjb25zdCBsaW1pdCA9IG9wdGlvbnMubGltaXRDb3VudCB8fCAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxpbWl0VGltZSAmJiBzdGFydFRpbWUgPj0gb3B0aW9ucy5saW1pdFRpbWUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjb25zdCBjYXBwZWRTdGFydFRpbWUgPSBjYXAgPyBNYXRoLm1heChjYXAuc3RhcnQsIHN0YXJ0VGltZSkgOiBzdGFydFRpbWU7XG4gICAgICAgICAgICBjb25zdCBjYXBwZWRFbmRUaW1lID0gY2FwICYmIGNhcC5lbmQgIT09IG51bGwgJiYgZW5kVGltZSAhPT0gbnVsbCA/IE1hdGgubWluKGNhcC5lbmQsIGVuZFRpbWUpIDogZW5kVGltZTtcbiAgICAgICAgICAgIGlmICgoY2FwcGVkRW5kVGltZSAhPT0gbnVsbCAmJiBjYXBwZWRFbmRUaW1lICE9PSB2b2lkIDAgPyBjYXBwZWRFbmRUaW1lIDogSW5maW5pdHkpID4gY2FwcGVkU3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmVwZWF0ZWRJbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBnZXRJZCgpLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogY2FwcGVkU3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGNhcHBlZEVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGpvaW5SZWZlcmVuY2VzKGluc3RhbmNlLmlkLCBpbnN0YW5jZS5yZWZlcmVuY2VzLCByZXBlYXRUaW1lMC5yZWZlcmVuY2VzKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0VGltZSArPSByZXBlYXRUaW1lO1xuICAgICAgICAgICAgaWYgKGVuZFRpbWUgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgZW5kVGltZSArPSByZXBlYXRUaW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbGVhbkluc3RhbmNlcyhyZXBlYXRlZEluc3RhbmNlcywgZmFsc2UpO1xufVxuZXhwb3J0cy5hcHBseVJlcGVhdGluZ0luc3RhbmNlcyA9IGFwcGx5UmVwZWF0aW5nSW5zdGFuY2VzO1xuLyoqXG4gKiBDYXAgaW5zdGFuY2VzIHNvIHRoYXQgdGhleSBhcmUgd2l0aGluIHRoZWlyIHBhcmVudEluc3RhbmNlc1xuICogQHBhcmFtIGluc3RhbmNlc1xuICogQHBhcmFtIHBhcmVudEluc3RhbmNlc1xuICovXG5mdW5jdGlvbiBjYXBJbnN0YW5jZXMoaW5zdGFuY2VzLCBwYXJlbnRJbnN0YW5jZXMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICBpZiAoaXNSZWZlcmVuY2UocGFyZW50SW5zdGFuY2VzKSB8fCBwYXJlbnRJbnN0YW5jZXMgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBpbnN0YW5jZXM7XG4gICAgbGV0IHJldHVybkluc3RhbmNlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlT3JnID0gaW5zdGFuY2VzW2ldO1xuICAgICAgICBjb25zdCBhZGRlZEluc3RhbmNlVGltZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGFyZW50SW5zdGFuY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBwYXJlbnRJbnN0YW5jZXNbal07XG4gICAgICAgICAgICAvLyBGaXJzdCwgY2hlY2sgaWYgdGhlIGluc3RhbmNlIGNyb3NzZXMgdGhlIHBhcmVudCBhdCBhbGw6XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VPcmcuc3RhcnQgPD0gKChfYSA9IHBhcmVudC5lbmQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IEluZmluaXR5KSAmJiAoKF9iID0gaW5zdGFuY2VPcmcuZW5kKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBJbmZpbml0eSkgPj0gcGFyZW50LnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBfLmNsb25lKGluc3RhbmNlT3JnKTtcbiAgICAgICAgICAgICAgICAvLyBDYXAgc3RhcnRcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhcnQgPCBwYXJlbnQuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5zdGFuY2VTdGFydFRpbWUoaW5zdGFuY2UsIHBhcmVudC5zdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENhcCBlbmRcbiAgICAgICAgICAgICAgICBpZiAoKChfYyA9IGluc3RhbmNlLmVuZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogSW5maW5pdHkpID4gKChfZCA9IHBhcmVudC5lbmQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IEluZmluaXR5KSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRJbnN0YW5jZUVuZFRpbWUoaW5zdGFuY2UsIHBhcmVudC5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhcnQgPj0gcGFyZW50LnN0YXJ0ICYmICgoX2UgPSBpbnN0YW5jZS5lbmQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IEluZmluaXR5KSA8PSAoKF9mID0gcGFyZW50LmVuZCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogSW5maW5pdHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBpbnN0YW5jZSBpcyB3aXRoaW4gdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhcnQgPT09IGluc3RhbmNlLmVuZCAmJiBhZGRlZEluc3RhbmNlVGltZXMuaGFzKGluc3RhbmNlLnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIHplcm8tbGVuZ3RoIGluc3RhbmNlcyBpZiB0aGVyZSBhcmUgYWxyZWFkeSBpcyBpbnN0YW5jZXMgY292ZXJpbmcgdGhhdCB0aW1lXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5yZWZlcmVuY2VzID0gam9pblJlZmVyZW5jZXMoaW5zdGFuY2UucmVmZXJlbmNlcywgcGFyZW50LnJlZmVyZW5jZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuSW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWRJbnN0YW5jZVRpbWVzLmFkZChpbnN0YW5jZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuZW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkSW5zdGFuY2VUaW1lcy5hZGQoaW5zdGFuY2UuZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm5JbnN0YW5jZXMuc29ydCgoYSwgYikgPT4gYS5zdGFydCAtIGIuc3RhcnQpO1xuICAgIC8vIEVuc3VyZSB1bmlxdWUgaWRzOlxuICAgIGNvbnN0IGlkcyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0dXJuSW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gcmV0dXJuSW5zdGFuY2VzW2ldO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgaWYgKGlkc1tpbnN0YW5jZS5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5zdGFuY2UuaWQgPSBpbnN0YW5jZS5pZCArICsraWRzW2luc3RhbmNlLmlkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkc1tpbnN0YW5jZS5pZF0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENsZWFuIHVwIHRoZSBpbnN0YW5jZXMsIHRvIHJlbW92ZSBkdXBsaWNhdGVzXG4gICAgcmV0dXJuSW5zdGFuY2VzID0gY2xlYW5JbnN0YW5jZXMocmV0dXJuSW5zdGFuY2VzLCB0cnVlLCB0cnVlKTtcbiAgICByZXR1cm4gcmV0dXJuSW5zdGFuY2VzO1xufVxuZXhwb3J0cy5jYXBJbnN0YW5jZXMgPSBjYXBJbnN0YW5jZXM7XG5mdW5jdGlvbiBpc1JlZmVyZW5jZShyZWYwKSB7XG4gICAgY29uc3QgcmVmID0gcmVmMDtcbiAgICByZXR1cm4gKHR5cGVvZiByZWYgPT09ICdvYmplY3QnICYmXG4gICAgICAgICFfLmlzQXJyYXkocmVmKSAmJlxuICAgICAgICByZWYudmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBfLmlzQXJyYXkocmVmLnJlZmVyZW5jZXMpICYmXG4gICAgICAgIHJlZiAhPT0gbnVsbCk7XG59XG5leHBvcnRzLmlzUmVmZXJlbmNlID0gaXNSZWZlcmVuY2U7XG5mdW5jdGlvbiBqb2luUmVmZXJlbmNlcyguLi5yZWZlcmVuY2VzKSB7XG4gICAgY29uc3QgcmVmTWFwID0ge307XG4gICAgY29uc3QgcmVmcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVmZXJlbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCByZWZlcmVuY2UgPSByZWZlcmVuY2VzW2ldO1xuICAgICAgICBpZiAocmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlZmVyZW5jZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZk1hcFtyZWZlcmVuY2VdKVxuICAgICAgICAgICAgICAgICAgICByZWZzLnB1c2gocmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICByZWZNYXBbcmVmZXJlbmNlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlZmVyZW5jZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWYgPSByZWZlcmVuY2Vbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVmTWFwW3JlZl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcy5wdXNoKHJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZNYXBbcmVmXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlZnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBpZiAoYSA+IGIpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9KTtcbn1cbmV4cG9ydHMuam9pblJlZmVyZW5jZXMgPSBqb2luUmVmZXJlbmNlcztcbmZ1bmN0aW9uIGFkZENhcHNUb1Jlc3VtaW5nKGluc3RhbmNlLCAuLi5jYXBzKSB7XG4gICAgY29uc3QgY2Fwc1RvQWRkID0gW107XG4gICAgY29uc3Qgam9pbmVkQ2FwcyA9IGpvaW5DYXBzKC4uLmNhcHMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgam9pbmVkQ2Fwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjYXAgPSBqb2luZWRDYXBzW2ldO1xuICAgICAgICBpZiAoY2FwLmVuZCAhPT0gbnVsbCAmJiBpbnN0YW5jZS5lbmQgIT09IG51bGwgJiYgY2FwLmVuZCA+IGluc3RhbmNlLmVuZCkge1xuICAgICAgICAgICAgY2Fwc1RvQWRkLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBjYXAuaWQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICAgICAgZW5kOiBjYXAuZW5kLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFuY2UuY2FwcyA9IGpvaW5DYXBzKGluc3RhbmNlLmNhcHMsIGNhcHNUb0FkZCk7XG59XG5leHBvcnRzLmFkZENhcHNUb1Jlc3VtaW5nID0gYWRkQ2Fwc1RvUmVzdW1pbmc7XG5mdW5jdGlvbiBqb2luQ2FwcyguLi5jYXBzKSB7XG4gICAgY29uc3QgY2FwTWFwID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNhcHMyID0gY2Fwc1tpXTtcbiAgICAgICAgaWYgKGNhcHMyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNhcHMyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FwMiA9IGNhcHMyW2pdO1xuICAgICAgICAgICAgICAgIGNhcE1hcFtjYXAyLmlkXSA9IGNhcDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoY2FwTWFwKTtcbn1cbmV4cG9ydHMuam9pbkNhcHMgPSBqb2luQ2FwcztcbmxldCBpZENvdW50ID0gMDtcbi8qKlxuICogUmV0dXJucyBhIHVuaXF1ZSBpZFxuICovXG5mdW5jdGlvbiBnZXRJZCgpIHtcbiAgICByZXR1cm4gJ0AnICsgKGlkQ291bnQrKykudG9TdHJpbmcoMzYpO1xufVxuZXhwb3J0cy5nZXRJZCA9IGdldElkO1xuZnVuY3Rpb24gcmVzZXRJZCgpIHtcbiAgICBpZENvdW50ID0gMDtcbn1cbmV4cG9ydHMucmVzZXRJZCA9IHJlc2V0SWQ7XG5mdW5jdGlvbiBzZXRJbnN0YW5jZUVuZFRpbWUoaW5zdGFuY2UsIGVuZFRpbWUpIHtcbiAgICBpbnN0YW5jZS5vcmlnaW5hbEVuZCA9IGluc3RhbmNlLm9yaWdpbmFsRW5kICE9PSB1bmRlZmluZWQgPyBpbnN0YW5jZS5vcmlnaW5hbEVuZCA6IGluc3RhbmNlLmVuZDtcbiAgICBpbnN0YW5jZS5lbmQgPSBlbmRUaW1lO1xufVxuZXhwb3J0cy5zZXRJbnN0YW5jZUVuZFRpbWUgPSBzZXRJbnN0YW5jZUVuZFRpbWU7XG5mdW5jdGlvbiBzZXRJbnN0YW5jZVN0YXJ0VGltZShpbnN0YW5jZSwgc3RhcnRUaW1lKSB7XG4gICAgaW5zdGFuY2Uub3JpZ2luYWxTdGFydCA9IGluc3RhbmNlLm9yaWdpbmFsU3RhcnQgIT09IHVuZGVmaW5lZCA/IGluc3RhbmNlLm9yaWdpbmFsU3RhcnQgOiBpbnN0YW5jZS5zdGFydDtcbiAgICBpbnN0YW5jZS5zdGFydCA9IHN0YXJ0VGltZTtcbn1cbmV4cG9ydHMuc2V0SW5zdGFuY2VTdGFydFRpbWUgPSBzZXRJbnN0YW5jZVN0YXJ0VGltZTtcbmZ1bmN0aW9uIGFwcGx5UGFyZW50SW5zdGFuY2VzKHBhcmVudEluc3RhbmNlcywgdmFsdWUpIHtcbiAgICByZXR1cm4gb3BlcmF0ZU9uQXJyYXlzKHBhcmVudEluc3RhbmNlcywgdmFsdWUsIG9wZXJhdGUpO1xufVxuZXhwb3J0cy5hcHBseVBhcmVudEluc3RhbmNlcyA9IGFwcGx5UGFyZW50SW5zdGFuY2VzO1xuZnVuY3Rpb24gb3BlcmF0ZShhLCBiKSB7XG4gICAgaWYgKGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGEudmFsdWUgKyBiLnZhbHVlLFxuICAgICAgICByZWZlcmVuY2VzOiBqb2luUmVmZXJlbmNlcyhhLnJlZmVyZW5jZXMsIGIucmVmZXJlbmNlcyksXG4gICAgfTtcbn1cbmNvbnN0IGNhY2hlUmVzdWx0Q2FjaGUgPSB7fTtcbmxldCBjbGVhbkNhY2hlUmVzdWx0VGltZW91dCA9IG51bGw7XG4vKiogQ2FjaGUgdGhlIHJlc3VsdCBvZiBmdW5jdGlvbiBmb3IgYSBsaW1pdGVkIHRpbWUgKi9cbmZ1bmN0aW9uIGNhY2hlUmVzdWx0KG5hbWUsIGZjbiwgbGltaXRUaW1lID0gMTAwMCkge1xuICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMSkge1xuICAgICAgICBpZiAoY2xlYW5DYWNoZVJlc3VsdFRpbWVvdXQpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY2xlYW5DYWNoZVJlc3VsdFRpbWVvdXQpO1xuICAgICAgICBjbGVhbkNhY2hlUmVzdWx0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY2xlYW5DYWNoZVJlc3VsdCgpO1xuICAgICAgICB9LCAxMDApO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZSA9IGNhY2hlUmVzdWx0Q2FjaGVbbmFtZV07XG4gICAgaWYgKCFjYWNoZSB8fCBjYWNoZS50dGwgPCBEYXRlLm5vdygpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZmNuKCk7XG4gICAgICAgIGNhY2hlUmVzdWx0Q2FjaGVbbmFtZV0gPSB7XG4gICAgICAgICAgICB0dGw6IERhdGUubm93KCkgKyBsaW1pdFRpbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjYWNoZS52YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLmNhY2hlUmVzdWx0ID0gY2FjaGVSZXN1bHQ7XG5mdW5jdGlvbiBjbGVhbkNhY2hlUmVzdWx0KCkge1xuICAgIGlmIChjbGVhbkNhY2hlUmVzdWx0VGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoY2xlYW5DYWNoZVJlc3VsdFRpbWVvdXQpO1xuICAgICAgICBjbGVhbkNhY2hlUmVzdWx0VGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIF8uZWFjaChjYWNoZVJlc3VsdENhY2hlLCAoY2FjaGUsIG5hbWUpID0+IHtcbiAgICAgICAgaWYgKGNhY2hlLnR0bCA8IERhdGUubm93KCkpXG4gICAgICAgICAgICBkZWxldGUgY2FjaGVSZXN1bHRDYWNoZVtuYW1lXTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY2xlYW5DYWNoZVJlc3VsdCA9IGNsZWFuQ2FjaGVSZXN1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldE9iamVjdFJlZmVyZW5jZXMgPSBleHBvcnRzLmhhc2hUaW1lbGluZU9iamVjdCA9IGV4cG9ydHMuaW5pdGlhbGl6ZUNhY2hlID0gdm9pZCAwO1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUNhY2hlKGNhY2hlT3JnLCByZXNvbHZlZFRpbWVsaW5lKSB7XG4gICAgY29uc3QgY2FjaGUgPSBjYWNoZU9yZztcbiAgICBpZiAoIWNhY2hlLm9iakhhc2hlcylcbiAgICAgICAgY2FjaGUub2JqSGFzaGVzID0ge307XG4gICAgaWYgKCFjYWNoZS5yZXNvbHZlZFRpbWVsaW5lKVxuICAgICAgICBjYWNoZS5yZXNvbHZlZFRpbWVsaW5lID0gcmVzb2x2ZWRUaW1lbGluZTtcbiAgICAvLyBUb2RvOiBtYWtlIHN0YXRpc3RpY3Mgd29yayB3aGVuIHVzaW5nIGNhY2hlXG4gICAgcmV0dXJuIGNhY2hlO1xufVxuZXhwb3J0cy5pbml0aWFsaXplQ2FjaGUgPSBpbml0aWFsaXplQ2FjaGU7XG4vKiogUmV0dXJuIGEgXCJoYXNoLXN0cmluZ1wiIHdoaWNoIGNoYW5nZXMgd2hlbmV2ZXIgYW55dGhpbmcgdGhhdCBhZmZlY3RzIHRpbWluZyBvZiBhIHRpbWVsaW5lLW9iamVjdCBoYXMgY2hhbmdlZC4gKi9cbmZ1bmN0aW9uIGhhc2hUaW1lbGluZU9iamVjdChvYmopIHtcbiAgICBjb25zdCB0aGluZ3NUaGF0TWF0dGVyID0gW1xuICAgICAgICBKU09OLnN0cmluZ2lmeShvYmouZW5hYmxlKSxcbiAgICAgICAgb2JqLmRpc2FibGVkICsgJycsXG4gICAgICAgIG9iai5wcmlvcml0eSArICcnLFxuICAgICAgICBvYmoucmVzb2x2ZWQucGFyZW50SWQgfHwgJycsXG4gICAgICAgIG9iai5yZXNvbHZlZC5pc0tleWZyYW1lICsgJycsXG4gICAgICAgIG9iai5jbGFzc2VzID8gb2JqLmNsYXNzZXMuam9pbignLicpIDogJycsXG4gICAgICAgIG9iai5sYXllciArICcnLFxuICAgICAgICBvYmouc2VhbWxlc3MgKyAnJyxcbiAgICAgICAgLypcbiAgICAgICAgTm90ZTogVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBpZ25vcmVkLCBhcyB0aGV5IGRvbid0IGFmZmVjdCB0aW1pbmcgb3IgcmVzb2x2aW5nOlxuICAgICAgICAgKiBpZFxuICAgICAgICAgKiBjaGlsZHJlblxuICAgICAgICAgKiBrZXlmcmFtZXNcbiAgICAgICAgICogaXNHcm91cFxuICAgICAgICAgKiBjb250ZW50XG4gICAgICAgICAqL1xuICAgIF07XG4gICAgcmV0dXJuIHRoaW5nc1RoYXRNYXR0ZXIuam9pbignLCcpO1xufVxuZXhwb3J0cy5oYXNoVGltZWxpbmVPYmplY3QgPSBoYXNoVGltZWxpbmVPYmplY3Q7XG5mdW5jdGlvbiBnZXRPYmplY3RSZWZlcmVuY2VzKG9iaikge1xuICAgIHJldHVybiBvYmoucmVzb2x2ZWQuZGlyZWN0UmVmZXJlbmNlcztcbn1cbmV4cG9ydHMuZ2V0T2JqZWN0UmVmZXJlbmNlcyA9IGdldE9iamVjdFJlZmVyZW5jZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWNoZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkT2JqZWN0VG9SZXNvbHZlZFRpbWVsaW5lID0gdm9pZCAwO1xuZnVuY3Rpb24gYWRkT2JqZWN0VG9SZXNvbHZlZFRpbWVsaW5lKHJlc29sdmVkVGltZWxpbmUsIG9iaikge1xuICAgIHJlc29sdmVkVGltZWxpbmUub2JqZWN0c1tvYmouaWRdID0gb2JqO1xuICAgIGlmIChvYmouY2xhc3Nlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5jbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBvYmouY2xhc3Nlc1tpXTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVkVGltZWxpbmUuY2xhc3Nlc1tjbGFzc05hbWVdKVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFRpbWVsaW5lLmNsYXNzZXNbY2xhc3NOYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgIHJlc29sdmVkVGltZWxpbmUuY2xhc3Nlc1tjbGFzc05hbWVdLnB1c2gob2JqLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2JqLmxheWVyKSB7XG4gICAgICAgIGlmICghcmVzb2x2ZWRUaW1lbGluZS5sYXllcnNbb2JqLmxheWVyXSlcbiAgICAgICAgICAgIHJlc29sdmVkVGltZWxpbmUubGF5ZXJzW29iai5sYXllcl0gPSBbXTtcbiAgICAgICAgcmVzb2x2ZWRUaW1lbGluZS5sYXllcnNbb2JqLmxheWVyXS5wdXNoKG9iai5pZCk7XG4gICAgfVxufVxuZXhwb3J0cy5hZGRPYmplY3RUb1Jlc29sdmVkVGltZWxpbmUgPSBhZGRPYmplY3RUb1Jlc29sdmVkVGltZWxpbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlRXhwcmVzc2lvbiA9IGV4cG9ydHMud3JhcElubmVyRXhwcmVzc2lvbnMgPSBleHBvcnRzLnNpbXBsaWZ5RXhwcmVzc2lvbiA9IGV4cG9ydHMuaW50ZXJwcmV0RXhwcmVzc2lvbiA9IGV4cG9ydHMuT1BFUkFUT1JTID0gdm9pZCAwO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi4vbGliXCIpO1xuZXhwb3J0cy5PUEVSQVRPUlMgPSBbJyYnLCAnfCcsICcrJywgJy0nLCAnKicsICcvJywgJyUnLCAnISddO1xuY29uc3QgUkVHRVhQX09QRVJBVE9SUyA9IF8ubWFwKGV4cG9ydHMuT1BFUkFUT1JTLCAobykgPT4gJ1xcXFwnICsgbykuam9pbignJyk7XG5mdW5jdGlvbiBpbnRlcnByZXRFeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgICBpZiAoKDAsIGxpYl8xLmlzTnVtZXJpYykoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoZXhwcmVzc2lvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKF8uaXNTdHJpbmcoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvblN0cmluZyA9IGV4cHJlc3Npb247XG4gICAgICAgIHJldHVybiAoMCwgbGliXzEuY2FjaGVSZXN1bHQpKGV4cHJlc3Npb25TdHJpbmcsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSBleHByZXNzaW9uU3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cCgnKFsnICsgUkVHRVhQX09QRVJBVE9SUyArICdcXFxcKFxcXFwpXSknLCAnZycpLCAnICQxICcpOyAvLyBNYWtlIHN1cmUgdGhlcmUncyBhIHNwYWNlIGJldHdlZW4gZXZlcnkgb3BlcmF0b3IgJiBvcGVyYW5kXG4gICAgICAgICAgICBjb25zdCB3b3JkcyA9IF8uY29tcGFjdChleHByLnNwbGl0KCcgJykpO1xuICAgICAgICAgICAgaWYgKHdvcmRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gZW1wdHkgZXhwcmVzc2lvblxuICAgICAgICAgICAgLy8gRml4IHNwZWNpYWwgY2FzZTogYSArIC0gYlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHdvcmRzLmxlbmd0aCAtIDI7IGkgPj0gMTsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh3b3Jkc1tpXSA9PT0gJy0nIHx8IHdvcmRzW2ldID09PSAnKycpICYmIHdvcmRJc09wZXJhdG9yKGV4cG9ydHMuT1BFUkFUT1JTLCB3b3Jkc1tpIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmRzW2ldID0gd29yZHNbaV0gKyB3b3Jkc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHdvcmRzLnNwbGljZShpICsgMSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5uZXJFeHByZXNzaW9uID0gd3JhcElubmVyRXhwcmVzc2lvbnMod29yZHMpO1xuICAgICAgICAgICAgaWYgKGlubmVyRXhwcmVzc2lvbi5yZXN0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludGVycHJldEV4cHJlc3Npb246IHN5bnRheCBlcnJvcjogcGFyZW50aGVzZXMgZG9uXFwndCBhZGQgdXAgaW4gXCInICsgZXhwciArICdcIi4nKTtcbiAgICAgICAgICAgIGlmIChpbm5lckV4cHJlc3Npb24uaW5uZXIubGVuZ3RoICUgMiAhPT0gMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludGVycHJldEV4cHJlc3Npb246IG9wZXJhbmRzICYgb3BlcmF0b3JzIGRvblxcJ3QgYWRkIHVwOiBcIicgK1xuICAgICAgICAgICAgICAgICAgICBpbm5lckV4cHJlc3Npb24uaW5uZXIuam9pbignICcpICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiLicpO1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHdvcmRzMkV4cHJlc3Npb24oZXhwb3J0cy5PUEVSQVRPUlMsIGlubmVyRXhwcmVzc2lvbi5pbm5lcik7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cHJlc3Npb24oZXhwb3J0cy5PUEVSQVRPUlMsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICAgIH0sIDEwMCAqIDEwMDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgfVxufVxuZXhwb3J0cy5pbnRlcnByZXRFeHByZXNzaW9uID0gaW50ZXJwcmV0RXhwcmVzc2lvbjtcbi8qKiBUcnkgdG8gc2ltcGxpZnkgYW4gZXhwcmVzc2lvbiwgdGhpcyBpbmNsdWRlczpcbiAqICogQ29tYmluZSBjb25zdGFudCBvcGVyYW5kcywgdXNpbmcgYXJpdGhtZXRpYyBvcGVyYXRvcnNcbiAqIC4uLm1vcmUgdG8gY29tZT9cbiAqL1xuZnVuY3Rpb24gc2ltcGxpZnlFeHByZXNzaW9uKGV4cHIwKSB7XG4gICAgY29uc3QgZXhwciA9IF8uaXNTdHJpbmcoZXhwcjApID8gaW50ZXJwcmV0RXhwcmVzc2lvbihleHByMCkgOiBleHByMDtcbiAgICBpZiAoIWV4cHIpXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIGlmIChpc0V4cHJlc3Npb25PYmplY3QoZXhwcikpIHtcbiAgICAgICAgY29uc3QgbCA9IHNpbXBsaWZ5RXhwcmVzc2lvbihleHByLmwpO1xuICAgICAgICBjb25zdCBvID0gZXhwci5vO1xuICAgICAgICBjb25zdCByID0gc2ltcGxpZnlFeHByZXNzaW9uKGV4cHIucik7XG4gICAgICAgIGlmICgoMCwgbGliXzEuaXNDb25zdGFudCkobCkgJiYgKDAsIGxpYl8xLmlzQ29uc3RhbnQpKHIpICYmIF8uaXNOdW1iZXIobCkgJiYgXy5pc051bWJlcihyKSkge1xuICAgICAgICAgICAgLy8gVGhlIG9wZXJhbmRzIGNhbiBiZSBjb21iaW5lZDpcbiAgICAgICAgICAgIHJldHVybiBvID09PSAnKydcbiAgICAgICAgICAgICAgICA/IGwgKyByXG4gICAgICAgICAgICAgICAgOiBvID09PSAnLSdcbiAgICAgICAgICAgICAgICAgICAgPyBsIC0gclxuICAgICAgICAgICAgICAgICAgICA6IG8gPT09ICcqJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBsICogclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvID09PSAnLydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGwgLyByXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBvID09PSAnJSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBsICUgclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHsgbCwgbywgciB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGwsIG8sIHIgfTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG59XG5leHBvcnRzLnNpbXBsaWZ5RXhwcmVzc2lvbiA9IHNpbXBsaWZ5RXhwcmVzc2lvbjtcbmZ1bmN0aW9uIGlzRXhwcmVzc2lvbk9iamVjdChleHByKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBleHByID09PSAnb2JqZWN0JyAmJiBfLmhhcyhleHByLCAnbCcpICYmIF8uaGFzKGV4cHIsICdvJykgJiYgXy5oYXMoZXhwciwgJ3InKTtcbn1cbmZ1bmN0aW9uIHdvcmRJc09wZXJhdG9yKG9wZXJhdG9yTGlzdCwgd29yZCkge1xuICAgIGlmIChvcGVyYXRvckxpc3QuaW5kZXhPZih3b3JkKSAhPT0gLTEpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIFR1cm5zIFsnYScsICcoJywgJ2InLCAnYycsICcpJ10gaW50byBbJ2EnLCBbJ2InLCAnYyddXVxuLy8gb3IgWydhJywgJyYnLCAnIScsICdiJ10gaW50byBbJ2EnLCAnJicsIFsnJywgJyEnLCAnYiddXVxuZnVuY3Rpb24gd3JhcElubmVyRXhwcmVzc2lvbnMod29yZHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh3b3Jkc1tpXSA9PT0gJygnKSB7XG4gICAgICAgICAgICBjb25zdCB0bXAgPSB3cmFwSW5uZXJFeHByZXNzaW9ucyh3b3Jkcy5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGlubmVyIGV4cHJlc3Npb24gYW5kIHJlbW92ZSB0aGFcbiAgICAgICAgICAgIHdvcmRzW2ldID0gdG1wLmlubmVyO1xuICAgICAgICAgICAgd29yZHMuc3BsaWNlKGkgKyAxLCA5OTk5OSwgLi4udG1wLnJlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdvcmRzW2ldID09PSAnKScpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5uZXI6IHdvcmRzLnNsaWNlKDAsIGkpLFxuICAgICAgICAgICAgICAgIHJlc3Q6IHdvcmRzLnNsaWNlKGkgKyAxKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod29yZHNbaV0gPT09ICchJykge1xuICAgICAgICAgICAgY29uc3QgdG1wID0gd3JhcElubmVyRXhwcmVzc2lvbnMod29yZHMuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICAgIC8vIGluc2VydCBpbm5lciBleHByZXNzaW9uIGFmdGVyIHRoZSAnISdcbiAgICAgICAgICAgIHdvcmRzW2ldID0gWycnLCAnISddLmNvbmNhdCh0bXAuaW5uZXIpO1xuICAgICAgICAgICAgd29yZHMuc3BsaWNlKGkgKyAxLCA5OTk5OSwgLi4udG1wLnJlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGlubmVyOiB3b3JkcyxcbiAgICAgICAgcmVzdDogW10sXG4gICAgfTtcbn1cbmV4cG9ydHMud3JhcElubmVyRXhwcmVzc2lvbnMgPSB3cmFwSW5uZXJFeHByZXNzaW9ucztcbmZ1bmN0aW9uIHdvcmRzMkV4cHJlc3Npb24ob3BlcmF0b3JMaXN0LCB3b3Jkcykge1xuICAgIGlmICghd29yZHMgfHwgIXdvcmRzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3b3JkczJFeHByZXNzaW9uOiBzeW50YXggZXJyb3I6IHVuYmFsYW5jZWQgZXhwcmVzc2lvbicpO1xuICAgIHdoaWxlICh3b3Jkcy5sZW5ndGggPT09IDEgJiYgXy5pc0FycmF5KHdvcmRzWzBdKSlcbiAgICAgICAgd29yZHMgPSB3b3Jkc1swXTtcbiAgICBpZiAod29yZHMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gd29yZHNbMF07XG4gICAgLy8gRmluZCB0aGUgb3BlcmF0b3Igd2l0aCB0aGUgaGlnaGVzdCBwcmlvcml0eTpcbiAgICBsZXQgb3BlcmF0b3JJID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcGVyYXRvckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBvcGVyYXRvckxpc3RbaV07XG4gICAgICAgIGlmIChvcGVyYXRvckkgPT09IC0xKSB7XG4gICAgICAgICAgICBvcGVyYXRvckkgPSB3b3Jkcy5sYXN0SW5kZXhPZihvcGVyYXRvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wZXJhdG9ySSAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgbCA9IHdvcmRzLnNsaWNlKDAsIG9wZXJhdG9ySSk7XG4gICAgICAgIGNvbnN0IHIgPSB3b3Jkcy5zbGljZShvcGVyYXRvckkgKyAxKTtcbiAgICAgICAgY29uc3QgZXhwciA9IHtcbiAgICAgICAgICAgIGw6IHdvcmRzMkV4cHJlc3Npb24ob3BlcmF0b3JMaXN0LCBsKSxcbiAgICAgICAgICAgIG86IHdvcmRzW29wZXJhdG9ySV0sXG4gICAgICAgICAgICByOiB3b3JkczJFeHByZXNzaW9uKG9wZXJhdG9yTGlzdCwgciksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd29yZHMyRXhwcmVzc2lvbjogc3ludGF4IGVycm9yOiBvcGVyYXRvciBub3QgZm91bmQ6IFwiJyArIHdvcmRzLmpvaW4oJyAnKSArICdcIicpO1xufVxuLyoqIFZhbGlkYXRlcyBhbiBleHByZXNzaW9uLiBSZXR1cm5zIHRydWUgb24gc3VjY2VzcywgdGhyb3dzIGVycm9yIGlmIG5vdCAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHByZXNzaW9uKG9wZXJhdG9yTGlzdCwgZXhwcjAsIGJyZWFkY3J1bWJzKSB7XG4gICAgaWYgKCFicmVhZGNydW1icylcbiAgICAgICAgYnJlYWRjcnVtYnMgPSAnUk9PVCc7XG4gICAgaWYgKF8uaXNPYmplY3QoZXhwcjApICYmICFfLmlzQXJyYXkoZXhwcjApKSB7XG4gICAgICAgIGNvbnN0IGV4cHIgPSBleHByMDtcbiAgICAgICAgaWYgKCFfLmhhcyhleHByLCAnbCcpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YWxpZGF0ZUV4cHJlc3Npb246ICR7YnJlYWRjcnVtYnN9LmwgbWlzc2luZyBpbiAke0pTT04uc3RyaW5naWZ5KGV4cHIpfWApO1xuICAgICAgICBpZiAoIV8uaGFzKGV4cHIsICdvJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbGlkYXRlRXhwcmVzc2lvbjogJHticmVhZGNydW1ic30ubyBtaXNzaW5nIGluICR7SlNPTi5zdHJpbmdpZnkoZXhwcil9YCk7XG4gICAgICAgIGlmICghXy5oYXMoZXhwciwgJ3InKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsaWRhdGVFeHByZXNzaW9uOiAke2JyZWFkY3J1bWJzfS5yIG1pc3NpbmcgaW4gJHtKU09OLnN0cmluZ2lmeShleHByKX1gKTtcbiAgICAgICAgaWYgKCFfLmlzU3RyaW5nKGV4cHIubykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbGlkYXRlRXhwcmVzc2lvbjogJHticmVhZGNydW1ic30ubyBub3QgYSBzdHJpbmdgKTtcbiAgICAgICAgaWYgKCF3b3JkSXNPcGVyYXRvcihvcGVyYXRvckxpc3QsIGV4cHIubykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYnJlYWRjcnVtYnMgKyAnLm8gbm90IHZhbGlkOiBcIicgKyBleHByLm8gKyAnXCInKTtcbiAgICAgICAgcmV0dXJuICh2YWxpZGF0ZUV4cHJlc3Npb24ob3BlcmF0b3JMaXN0LCBleHByLmwsIGJyZWFkY3J1bWJzICsgJy5sJykgJiZcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwcmVzc2lvbihvcGVyYXRvckxpc3QsIGV4cHIuciwgYnJlYWRjcnVtYnMgKyAnLnInKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFfLmlzTnVsbChleHByMCkgJiYgIV8uaXNTdHJpbmcoZXhwcjApICYmICFfLmlzTnVtYmVyKGV4cHIwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbGlkYXRlRXhwcmVzc2lvbjogJHticmVhZGNydW1ic30gaXMgb2YgaW52YWxpZCB0eXBlYCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy52YWxpZGF0ZUV4cHJlc3Npb24gPSB2YWxpZGF0ZUV4cHJlc3Npb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHByZXNzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sb29rdXBFeHByZXNzaW9uID0gZXhwb3J0cy5yZXNvbHZlVGltZWxpbmVPYmogPSBleHBvcnRzLlJlc29sdmVyID0gdm9pZCAwO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi4vbGliXCIpO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlXCIpO1xuY29uc3QgZXhwcmVzc2lvbl8xID0gcmVxdWlyZShcIi4vZXhwcmVzc2lvblwiKTtcbmNvbnN0IHN0YXRlXzEgPSByZXF1aXJlKFwiLi9zdGF0ZVwiKTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4vY29tbW9uXCIpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL2NhY2hlXCIpO1xuY2xhc3MgUmVzb2x2ZXIge1xuICAgIC8qKlxuICAgICAqIEdvIHRocm91Z2ggYWxsIG9iamVjdHMgb24gdGhlIHRpbWVsaW5lIGFuZCBjYWxjdWxhdGUgYWxsIHRoZSB0aW1pbmdzLlxuICAgICAqIFJldHVybnMgYSBSZXNvbHZlZFRpbWVsaW5lIHdoaWNoIGNhbiBiZSBwaXBlZCBpbnRvIFJlc29sdmVyLmdldFN0YXRlKClcbiAgICAgKiBAcGFyYW0gdGltZWxpbmUgQXJyYXkgb2YgdGltZWxpbmUgb2JqZWN0c1xuICAgICAqIEBwYXJhbSBvcHRpb25zIFJlc29sdmUgb3B0aW9uc1xuICAgICAqL1xuICAgIHN0YXRpYyByZXNvbHZlVGltZWxpbmUodGltZWxpbmUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFfLmlzQXJyYXkodGltZWxpbmUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXNvbHZlVGltZWxpbmU6IHBhcmFtZXRlciB0aW1lbGluZSBtaXNzaW5nJyk7XG4gICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzb2x2ZVRpbWVsaW5lOiBwYXJhbWV0ZXIgb3B0aW9ucyBtaXNzaW5nJyk7XG4gICAgICAgICgwLCB2YWxpZGF0ZV8xLnZhbGlkYXRlVGltZWxpbmUpKHRpbWVsaW5lLCBmYWxzZSk7XG4gICAgICAgICgwLCBsaWJfMS5yZXNldElkKSgpO1xuICAgICAgICBjb25zdCByZXNvbHZlZFRpbWVsaW5lID0ge1xuICAgICAgICAgICAgb3B0aW9uczogeyAuLi5vcHRpb25zIH0sXG4gICAgICAgICAgICBvYmplY3RzOiB7fSxcbiAgICAgICAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgICAgICAgbGF5ZXJzOiB7fSxcbiAgICAgICAgICAgIHN0YXRpc3RpY3M6IHtcbiAgICAgICAgICAgICAgICB1bnJlc29sdmVkQ291bnQ6IDAsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRDb3VudDogMCxcbiAgICAgICAgICAgICAgICByZXNvbHZlZEluc3RhbmNlQ291bnQ6IDAsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRPYmplY3RDb3VudDogMCxcbiAgICAgICAgICAgICAgICByZXNvbHZlZEdyb3VwQ291bnQ6IDAsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRLZXlmcmFtZUNvdW50OiAwLFxuICAgICAgICAgICAgICAgIHJlc29sdmluZ0NvdW50OiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU3RlcCAxOiBwcmUtcG9wdWxhdGUgcmVzb2x2ZWRUaW1lbGluZSB3aXRoIG9iamVjdHNcbiAgICAgICAgY29uc3QgYWRkVG9SZXNvbHZlZFRpbWVsaW5lID0gKG9iaiwgbGV2ZWxEZWVwLCBwYXJlbnRJZCwgaXNLZXlmcmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkVGltZWxpbmUub2JqZWN0c1tvYmouaWRdKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBBbGwgdGltZWxpbmVPYmplY3RzIG11c3QgYmUgdW5pcXVlISAoZHVwbGljYXRlOiBcIiR7b2JqLmlkfVwiKWApO1xuICAgICAgICAgICAgY29uc3QgbyA9ICgwLCBsaWJfMS5leHRlbmRNYW5kYWRvcnkpKF8uY2xvbmUob2JqKSwge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2aW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxEZWVwOiBsZXZlbERlZXAsXG4gICAgICAgICAgICAgICAgICAgIGlzU2VsZlJlZmVyZW5jaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0UmVmZXJlbmNlczogW10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgby5yZXNvbHZlZC5wYXJlbnRJZCA9IHBhcmVudElkO1xuICAgICAgICAgICAgICAgIG8ucmVzb2x2ZWQuZGlyZWN0UmVmZXJlbmNlcy5wdXNoKHBhcmVudElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0tleWZyYW1lKVxuICAgICAgICAgICAgICAgIG8ucmVzb2x2ZWQuaXNLZXlmcmFtZSA9IHRydWU7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYWRkT2JqZWN0VG9SZXNvbHZlZFRpbWVsaW5lKShyZXNvbHZlZFRpbWVsaW5lLCBvKTtcbiAgICAgICAgICAgIC8vIEFkZCBjaGlsZHJlbjpcbiAgICAgICAgICAgIGlmIChvYmouaXNHcm91cCAmJiBvYmouY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG9iai5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgYWRkVG9SZXNvbHZlZFRpbWVsaW5lKGNoaWxkLCBsZXZlbERlZXAgKyAxLCBvYmouaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCBrZXlmcmFtZXM6XG4gICAgICAgICAgICBpZiAob2JqLmtleWZyYW1lcykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlmcmFtZSA9IG9iai5rZXlmcmFtZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtmMiA9ICgwLCBsaWJfMS5leHRlbmRNYW5kYWRvcnkpKF8uY2xvbmUoa2V5ZnJhbWUpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcjogJycsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhZGRUb1Jlc29sdmVkVGltZWxpbmUoa2YyLCBsZXZlbERlZXAgKyAxLCBvYmouaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0gdGltZWxpbmVbaV07XG4gICAgICAgICAgICBhZGRUb1Jlc29sdmVkVGltZWxpbmUob2JqLCAwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGVwIDI6IGdvIHRob3VnaCBhbmQgcmVzb2x2ZSB0aGUgb2JqZWN0c1xuICAgICAgICBpZiAob3B0aW9ucy5jYWNoZSkge1xuICAgICAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCBvYmplY3RzIGhhcyBjaGFuZ2VkIHNpbmNlIGxhc3QgdGltZVxuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSAoMCwgY2FjaGVfMS5pbml0aWFsaXplQ2FjaGUpKG9wdGlvbnMuY2FjaGUsIHJlc29sdmVkVGltZWxpbmUpO1xuICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBhbGwgbmV3IG9iamVjdHMsIGFuZCBkZXRlcm1pbmUgd2hldGhlciB0aGV5IGhhdmUgY2hhbmdlZDpcbiAgICAgICAgICAgIGNvbnN0IGFsbE5ld09iamVjdHMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZWRSZWZlcmVuY2VzID0ge307XG4gICAgICAgICAgICBjb25zdCBnZXRBbGxSZWZlcmVuY2VzVGhpc09iamVjdEFmZmVjdHMgPSAobmV3T2JqKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlcyA9IFsnIycgKyBuZXdPYmouaWRdO1xuICAgICAgICAgICAgICAgIGlmIChuZXdPYmouY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBuZXdPYmouY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKCcuJyArIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ld09iai5sYXllcilcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKCckJyArIG5ld09iai5sYXllcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmVyZW5jZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYWRkQ2hhbmdlZE9iamVjdCA9IChvYmopID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWZlcmVuY2VzID0gZ2V0QWxsUmVmZXJlbmNlc1RoaXNPYmplY3RBZmZlY3RzKG9iaik7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZWYgb2YgcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkUmVmZXJlbmNlc1tyZWZdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBvYmogb2YgT2JqZWN0LnZhbHVlcyhyZXNvbHZlZFRpbWVsaW5lLm9iamVjdHMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkSGFzaCA9IGNhY2hlLm9iakhhc2hlc1tvYmouaWRdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0hhc2ggPSAoMCwgY2FjaGVfMS5oYXNoVGltZWxpbmVPYmplY3QpKG9iaik7XG4gICAgICAgICAgICAgICAgYWxsTmV3T2JqZWN0c1tvYmouaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIW9sZEhhc2ggfHwgb2xkSGFzaCAhPT0gbmV3SGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5vYmpIYXNoZXNbb2JqLmlkXSA9IG5ld0hhc2g7XG4gICAgICAgICAgICAgICAgICAgIGFkZENoYW5nZWRPYmplY3Qob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkT2JqID0gY2FjaGUucmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzW29iai5pZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRPYmopXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDaGFuZ2VkT2JqZWN0KG9sZE9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyB0aW1pbmctYWZmZWN0aW5nIGNoYW5nZXMgZGV0ZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gRXZlbiB0aG91Z2ggdGhlIHRpbWVsaW5lLXByb3BlcnRpZXMgaGFzbid0IGNoYW5nZWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjb250ZW50IChhbmQgb3RoZXIgcHJvcGVydGllcykgbWlnaHQgaGF2ZTpcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkT2JqID0gY2FjaGUucmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzW29iai5pZF07XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnJlc29sdmVkVGltZWxpbmUub2JqZWN0c1tvYmouaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ub2JqLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQ6IG9sZE9iai5yZXNvbHZlZCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FjaGUuaGFzT2xkRGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggYWxsIG9sZCBoYXNoZXMsIHJlbW92aW5nIHRoZSBvbmVzIHRoYXQgZG9lc24ndCBleGlzdCBhbnltb3JlXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBvYmpJZCBpbiBjYWNoZS5yZXNvbHZlZFRpbWVsaW5lLm9iamVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxOZXdPYmplY3RzW29iaklkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gY2FjaGUucmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzW29iaklkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZS5vYmpIYXNoZXNbb2JqSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2hhbmdlZE9iamVjdChvYmopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEludmFsaWRhdGUgb2JqZWN0cywgYnkgZ3JhZHVhbGx5IHJlbW92aW5nIHRoZSBpbnZhbGlkYXRlZCBvbmVzIGZyb20gdmFsaWRPYmplY3RzXG4gICAgICAgICAgICAgICAgLy8gUHJlcGFyZSB2YWxpZE9iamVjdHM6XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRPYmplY3RzID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBvYmogb2YgT2JqZWN0LnZhbHVlcyhyZXNvbHZlZFRpbWVsaW5lLm9iamVjdHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkT2JqZWN0c1tvYmouaWRdID0gb2JqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiogQWxsIHJlZmVyZW5jZXMgdGhhdCBkZXBlbmQgb24gYW5vdGhlciByZWZlcmVuY2UgKGllIG9iamVjdHMsIGNsYXNzcyBvciBsYXllcnMpOiAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmZmVjdFJlZmVyZW5jZU1hcCA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb2JqIG9mIE9iamVjdC52YWx1ZXMocmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZXZlcnl0aGluZyB0aGF0IHRoaXMgb2JqZWN0IGFmZmVjdHM6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZE9iaiA9IGNhY2hlLnJlc29sdmVkVGltZWxpbmUub2JqZWN0c1tvYmouaWRdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWZmZWN0ZWRSZWZlcmVuY2VzID0gZ2V0QWxsUmVmZXJlbmNlc1RoaXNPYmplY3RBZmZlY3RzKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWRPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkUmVmZXJlbmNlcyA9IF8udW5pcShhZmZlY3RlZFJlZmVyZW5jZXMuY29uY2F0KGdldEFsbFJlZmVyZW5jZXNUaGlzT2JqZWN0QWZmZWN0cyhjYWNoZWRPYmopKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZmZlY3RlZFJlZmVyZW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IGFmZmVjdGVkUmVmZXJlbmNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9ialJlZiA9ICcjJyArIG9iai5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWYgIT09IG9ialJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWZmZWN0UmVmZXJlbmNlTWFwW29ialJlZl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdFJlZmVyZW5jZU1hcFtvYmpSZWZdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0UmVmZXJlbmNlTWFwW29ialJlZl0ucHVzaChyZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBldmVyeXRoaW5nIHRoYXQgdGhpcyBvYmplY3QgaXMgYWZmZWN0ZWQgYnk6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkUmVmZXJlbmNlc1snIycgKyBvYmouaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb2JqZWN0IGlzIGRpcmVjdGx5IHNhaWQgdG8gYmUgaW52YWxpZCwgbm8gbmVlZCB0byBhZGQgaXQgdG8gcmVmZXJlbmNpbmdPYmplY3RzLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgaXQnbGwgYmUgZWFzaWx5IGludmFsaWRhdGVkIGFueXdheSBsYXRlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogd2Ugb25seSBoYXZlIHRvIGNoZWNrIGZvciB0aGUgT0xEIG9iamVjdCwgc2luY2UgaWYgdGhlIG9sZCBhbmQgdGhlIG5ldyBvYmplY3QgZGlmZmVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgd291bGQgbWVhbiBpdCdsbCBiZSBkaXJlY3RseSBpbnZhbGlkYXRlZCBhbnl3YXkuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmV0Y2ggYWxsIHJlZmVyZW5jZXMgZm9yIHRoZSBvYmplY3QgZnJvbSB0aGUgbGFzdCB0aW1lIGl0IHdhcyByZXNvbHZlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBUaGlzIGNhbiBiZSBkb25lLCBzaW5jZSBfaWZfIHRoZSBvYmplY3Qgd2FzIGNoYW5nZWQgaW4gYW55IHdheSBzaW5jZSBsYXN0IHJlc29sdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdsbCBiZSBpbnZhbGlkYXRlZCBhbnl3YXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXBlbmRPblJlZmVyZW5jZXMgPSAoMCwgY2FjaGVfMS5nZXRPYmplY3RSZWZlcmVuY2VzKShjYWNoZWRPYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwZW5kT25SZWZlcmVuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IGRlcGVuZE9uUmVmZXJlbmNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhZmZlY3RSZWZlcmVuY2VNYXBbcmVmXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdFJlZmVyZW5jZU1hcFtyZWZdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdFJlZmVyZW5jZU1hcFtyZWZdLnB1c2goJyMnICsgb2JqLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSBhbGwgY2hhbmdlZCBvYmplY3RzLCBhbmQgcmVjdXJzaXZlbHkgaW52YWxpZGF0ZSBhbGwgb2JqZWN0cyB0aGF0IHJlZmVyZW5jZSB0aG9zZSBvYmplY3RzOlxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZWRSZWZlcmVuY2VzID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZWZlcmVuY2Ugb2YgT2JqZWN0LmtleXMoY2hhbmdlZFJlZmVyZW5jZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRhdGVPYmplY3RzV2l0aFJlZmVyZW5jZShoYW5kbGVkUmVmZXJlbmNlcywgcmVmZXJlbmNlLCBhZmZlY3RSZWZlcmVuY2VNYXAsIHZhbGlkT2JqZWN0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoZSBvYmplY3RzIHRoYXQgYXJlIGxlZnQgaW4gdmFsaWRPYmplY3RzIGF0IHRoaXMgcG9pbnQgYXJlIHN0aWxsIHZhbGlkLlxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiByZXVzZSB0aGUgb2xkIHJlc29sdmluZyBmb3IgdGhvc2U6XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBvYmogb2YgT2JqZWN0LnZhbHVlcyh2YWxpZE9iamVjdHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FjaGUucmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzW29iai5pZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNvbWV0aGluZyB3ZW50IHdyb25nOiBcIiR7b2JqLmlkfVwiIGRvZXMgbm90IGV4aXN0IGluIGNhY2hlLnJlc29sdmVkVGltZWxpbmUub2JqZWN0c2ApO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFRpbWVsaW5lLm9iamVjdHNbb2JqLmlkXSA9IGNhY2hlLnJlc29sdmVkVGltZWxpbmUub2JqZWN0c1tvYmouaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qgb2JqIG9mIE9iamVjdC52YWx1ZXMocmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzKSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVUaW1lbGluZU9iaihyZXNvbHZlZFRpbWVsaW5lLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2F2ZSBmb3IgbmV4dCB0aW1lOlxuICAgICAgICAgICAgY2FjaGUucmVzb2x2ZWRUaW1lbGluZSA9IHJlc29sdmVkVGltZWxpbmU7XG4gICAgICAgICAgICBjYWNoZS5oYXNPbGREYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0aXN0aWNzLCBzaW5jZSB0aGF0J3Mgbm90IGFjY3VyYXRlIGFmdGVyIGhhdmluZyB1c2VkIHRoZSBjYWNoZTpcbiAgICAgICAgICAgIHJlc29sdmVkVGltZWxpbmUuc3RhdGlzdGljcy51bnJlc29sdmVkQ291bnQgPSAwO1xuICAgICAgICAgICAgcmVzb2x2ZWRUaW1lbGluZS5zdGF0aXN0aWNzLnJlc29sdmVkQ291bnQgPSAwO1xuICAgICAgICAgICAgcmVzb2x2ZWRUaW1lbGluZS5zdGF0aXN0aWNzLnJlc29sdmVkSW5zdGFuY2VDb3VudCA9IDA7XG4gICAgICAgICAgICByZXNvbHZlZFRpbWVsaW5lLnN0YXRpc3RpY3MucmVzb2x2ZWRPYmplY3RDb3VudCA9IDA7XG4gICAgICAgICAgICByZXNvbHZlZFRpbWVsaW5lLnN0YXRpc3RpY3MucmVzb2x2ZWRHcm91cENvdW50ID0gMDtcbiAgICAgICAgICAgIHJlc29sdmVkVGltZWxpbmUuc3RhdGlzdGljcy5yZXNvbHZlZEtleWZyYW1lQ291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvYmogb2YgT2JqZWN0LnZhbHVlcyhyZXNvbHZlZFRpbWVsaW5lLm9iamVjdHMpKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlU3RhdGlzdGljcyhyZXNvbHZlZFRpbWVsaW5lLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkVGltZWxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gY2FjaGUgcHJvdmlkZWQsIGp1c3QgcmVzb2x2ZSBhbGwgb2JqZWN0czpcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb2JqIG9mIE9iamVjdC52YWx1ZXMocmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzKSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVUaW1lbGluZU9iaihyZXNvbHZlZFRpbWVsaW5lLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkVGltZWxpbmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIENhbGN1bGF0ZSB0aGUgc3RhdGUgZm9yIGFsbCBwb2ludHMgaW4gdGltZS4gICovXG4gICAgc3RhdGljIHJlc29sdmVBbGxTdGF0ZXMocmVzb2x2ZWRUaW1lbGluZSwgY2FjaGUpIHtcbiAgICAgICAgcmV0dXJuICgwLCBzdGF0ZV8xLnJlc29sdmVTdGF0ZXMpKHJlc29sdmVkVGltZWxpbmUsIGNhY2hlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBzdGF0ZSBhdCBhIGdpdmVuIHBvaW50IGluIHRpbWUuXG4gICAgICogVXNpbmcgYSBSZXNvbHZlZFRpbWVsaW5lIGNhbGN1bGF0ZWQgYnkgUmVzb2x2ZXIucmVzb2x2ZVRpbWVsaW5lKCkgb3JcbiAgICAgKiBhIFJlc29sdmVkU3RhdGVzIGNhbGN1bGF0ZWQgYnkgUmVzb2x2ZXIucmVzb2x2ZUFsbFN0YXRlcygpXG4gICAgICogQHBhcmFtIHJlc29sdmVkIFJlc29sdmVkVGltZWxpbmUgY2FsY3VsYXRlZCBieSBSZXNvbHZlci5yZXNvbHZlVGltZWxpbmUuXG4gICAgICogQHBhcmFtIHRpbWUgVGhlIHBvaW50IGluIHRpbWUgd2hlcmUgdG8gY2FsY3VsYXRlIHRoZSBzdGF0ZVxuICAgICAqIEBwYXJhbSBldmVudExpbWl0IChPcHRpb25hbCkgTGltaXRzIHRoZSBudW1iZXIgb2YgcmV0dXJuZWQgdXBjb21pbmcgZXZlbnRzLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTdGF0ZShyZXNvbHZlZCwgdGltZSwgZXZlbnRMaW1pdCkge1xuICAgICAgICByZXR1cm4gKDAsIHN0YXRlXzEuZ2V0U3RhdGUpKHJlc29sdmVkLCB0aW1lLCBldmVudExpbWl0KTtcbiAgICB9XG59XG5leHBvcnRzLlJlc29sdmVyID0gUmVzb2x2ZXI7XG5mdW5jdGlvbiByZXNvbHZlVGltZWxpbmVPYmoocmVzb2x2ZWRUaW1lbGluZSwgb2JqKSB7XG4gICAgaWYgKG9iai5yZXNvbHZlZC5yZXNvbHZlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChvYmoucmVzb2x2ZWQucmVzb2x2aW5nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENpcmN1bGFyIGRlcGVuZGVuY3kgd2hlbiB0cnlpbmcgdG8gcmVzb2x2ZSBcIiR7b2JqLmlkfVwiYCk7XG4gICAgb2JqLnJlc29sdmVkLnJlc29sdmluZyA9IHRydWU7XG4gICAgcmVzb2x2ZWRUaW1lbGluZS5zdGF0aXN0aWNzLnJlc29sdmluZ0NvdW50Kys7XG4gICAgbGV0IGluc3RhbmNlcyA9IFtdO1xuICAgIGxldCBkaXJlY3RSZWZlcmVuY2VzID0gW107XG4gICAgY29uc3QgZW5hYmxlcyA9IF8uaXNBcnJheShvYmouZW5hYmxlKSA/IG9iai5lbmFibGUgOiBbb2JqLmVuYWJsZV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVuYWJsZSA9IGVuYWJsZXNbaV07XG4gICAgICAgIGxldCBuZXdJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVwZWF0aW5nRXhwciA9IGVuYWJsZS5yZXBlYXRpbmcgIT09IHVuZGVmaW5lZCA/ICgwLCBleHByZXNzaW9uXzEuaW50ZXJwcmV0RXhwcmVzc2lvbikoZW5hYmxlLnJlcGVhdGluZykgOiBudWxsO1xuICAgICAgICBjb25zdCBsb29rZWRSZXBlYXRpbmcgPSBsb29rdXBFeHByZXNzaW9uKHJlc29sdmVkVGltZWxpbmUsIG9iaiwgcmVwZWF0aW5nRXhwciwgJ2R1cmF0aW9uJyk7XG4gICAgICAgIGNvbnN0IGxvb2tlZHVwUmVwZWF0aW5nID0gbG9va2VkUmVwZWF0aW5nLmluc3RhbmNlcztcbiAgICAgICAgZGlyZWN0UmVmZXJlbmNlcyA9IGRpcmVjdFJlZmVyZW5jZXMuY29uY2F0KGxvb2tlZFJlcGVhdGluZy5hbGxSZWZlcmVuY2VzKTtcbiAgICAgICAgaWYgKF8uaXNBcnJheShsb29rZWR1cFJlcGVhdGluZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbG9va3VwRXhwcmVzc2lvbiBzaG91bGQgbmV2ZXIgcmV0dXJuIGFuIGFycmF5IGZvciAuZHVyYXRpb24gbG9va3VwYCk7IC8vIHBlcmhhcHMgdG1wPyBtYXliZSByZXZpc2l0IHRoaXMgYXQgc29tZSBwb2ludFxuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IGVuYWJsZS53aGlsZSAhPT0gdW5kZWZpbmVkID8gZW5hYmxlLndoaWxlIDogZW5hYmxlLnN0YXJ0ICE9PSB1bmRlZmluZWQgPyBlbmFibGUuc3RhcnQgOiAnJztcbiAgICAgICAgaWYgKGVuYWJsZS53aGlsZSArICcnID09PSAnMScpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gJ3RydWUnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVuYWJsZS53aGlsZSArICcnID09PSAnMCcpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gJ2ZhbHNlJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydEV4cHIgPSAoMCwgZXhwcmVzc2lvbl8xLnNpbXBsaWZ5RXhwcmVzc2lvbikoc3RhcnQpO1xuICAgICAgICBsZXQgcGFyZW50SW5zdGFuY2VzID0gbnVsbDtcbiAgICAgICAgbGV0IGhhc1BhcmVudCA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnRSZWZlcnNUb1BhcmVudCA9IGZhbHNlO1xuICAgICAgICBpZiAob2JqLnJlc29sdmVkLnBhcmVudElkKSB7XG4gICAgICAgICAgICBoYXNQYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgbG9va3VwID0gbG9va3VwRXhwcmVzc2lvbihyZXNvbHZlZFRpbWVsaW5lLCBvYmosICgwLCBleHByZXNzaW9uXzEuaW50ZXJwcmV0RXhwcmVzc2lvbikoYCMke29iai5yZXNvbHZlZC5wYXJlbnRJZH1gKSwgJ3N0YXJ0Jyk7XG4gICAgICAgICAgICBwYXJlbnRJbnN0YW5jZXMgPSBsb29rdXAuaW5zdGFuY2VzOyAvLyBhIHN0YXJ0LXJlZmVyZW5jZSB3aWxsIGFsd2F5cyByZXR1cm4gYW4gYXJyYXksIG9yIG51bGxcbiAgICAgICAgICAgIGRpcmVjdFJlZmVyZW5jZXMgPSBkaXJlY3RSZWZlcmVuY2VzLmNvbmNhdChsb29rdXAuYWxsUmVmZXJlbmNlcyk7XG4gICAgICAgICAgICBpZiAoKDAsIGxpYl8xLmlzQ29uc3RhbnQpKHN0YXJ0RXhwcikpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHVzZSBwYXJlbnQgaWYgdGhlIGV4cHJlc3Npb24gcmVzb2x2ZXMgdG8gYSBudW1iZXIgKGllIGRvZXNuJ3QgY29udGFpbiBhbnkgcmVmZXJlbmNlcylcbiAgICAgICAgICAgICAgICBzdGFydFJlZmVyc1RvUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb29rdXBTdGFydCA9IGxvb2t1cEV4cHJlc3Npb24ocmVzb2x2ZWRUaW1lbGluZSwgb2JqLCBzdGFydEV4cHIsICdzdGFydCcpO1xuICAgICAgICBsZXQgbG9va2VkdXBTdGFydHMgPSBsb29rdXBTdGFydC5pbnN0YW5jZXM7XG4gICAgICAgIGRpcmVjdFJlZmVyZW5jZXMgPSBkaXJlY3RSZWZlcmVuY2VzLmNvbmNhdChsb29rdXBTdGFydC5hbGxSZWZlcmVuY2VzKTtcbiAgICAgICAgaWYgKHN0YXJ0UmVmZXJzVG9QYXJlbnQpIHtcbiAgICAgICAgICAgIGxvb2tlZHVwU3RhcnRzID0gKDAsIGxpYl8xLmFwcGx5UGFyZW50SW5zdGFuY2VzKShwYXJlbnRJbnN0YW5jZXMsIGxvb2tlZHVwU3RhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5hYmxlLndoaWxlKSB7XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KGxvb2tlZHVwU3RhcnRzKSkge1xuICAgICAgICAgICAgICAgIG5ld0luc3RhbmNlcyA9IGxvb2tlZHVwU3RhcnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobG9va2VkdXBTdGFydHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXdJbnN0YW5jZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAoMCwgbGliXzEuZ2V0SWQpKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbG9va2VkdXBTdGFydHMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBsb29rZWR1cFN0YXJ0cy5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBldmVudHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBpU3RhcnQgPSAwO1xuICAgICAgICAgICAgbGV0IGlFbmQgPSAwO1xuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShsb29rZWR1cFN0YXJ0cykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvb2tlZHVwU3RhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gbG9va2VkdXBTdGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IGluc3RhbmNlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IGluc3RhbmNlOiBpbnN0YW5jZSwgaWQ6IG9iai5pZCArICdfJyArIGlTdGFydCsrIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBpbnN0YW5jZS5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsb29rZWR1cFN0YXJ0cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGltZTogbG9va2VkdXBTdGFydHMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAoMCwgbGliXzEuZ2V0SWQpKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGxvb2tlZHVwU3RhcnRzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBsb29rZWR1cFN0YXJ0cy5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBvYmouaWQgKyAnXycgKyBpU3RhcnQrKyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogbG9va2VkdXBTdGFydHMucmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmFibGUuZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRFeHByID0gKDAsIGV4cHJlc3Npb25fMS5pbnRlcnByZXRFeHByZXNzaW9uKShlbmFibGUuZW5kKTtcbiAgICAgICAgICAgICAgICBsZXQgZW5kUmVmZXJzVG9QYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAob2JqLnJlc29sdmVkLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgbGliXzEuaXNDb25zdGFudCkoZW5kRXhwcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgdXNlIHBhcmVudCBpZiB0aGUgZXhwcmVzc2lvbiByZXNvbHZlcyB0byBhIG51bWJlciAoaWUgZG9lc24ndCBjb250YWluIGFueSByZWZlcmVuY2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kUmVmZXJzVG9QYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGxvb2tlZHVwRW5kcyB3aWxsIGNvbnRhaW4gYW4gaW52ZXJ0ZWQgbGlzdCBvZiBpbnN0YW5jZXMuIFRoZXJlZm9yZSAuc3RhcnQgbWVhbnMgYW4gZW5kXG4gICAgICAgICAgICAgICAgY29uc3QgbG9va3VwRW5kID0gZW5kRXhwciA/IGxvb2t1cEV4cHJlc3Npb24ocmVzb2x2ZWRUaW1lbGluZSwgb2JqLCBlbmRFeHByLCAnZW5kJykgOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBsb29rZWR1cEVuZHMgPSBsb29rdXBFbmQgPyBsb29rdXBFbmQuaW5zdGFuY2VzIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAobG9va3VwRW5kKVxuICAgICAgICAgICAgICAgICAgICBkaXJlY3RSZWZlcmVuY2VzID0gZGlyZWN0UmVmZXJlbmNlcy5jb25jYXQobG9va3VwRW5kLmFsbFJlZmVyZW5jZXMpO1xuICAgICAgICAgICAgICAgIGlmIChlbmRSZWZlcnNUb1BhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBsb29rZWR1cEVuZHMgPSAoMCwgbGliXzEuYXBwbHlQYXJlbnRJbnN0YW5jZXMpKHBhcmVudEluc3RhbmNlcywgbG9va2VkdXBFbmRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNBcnJheShsb29rZWR1cEVuZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9va2VkdXBFbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGxvb2tlZHVwRW5kc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBpbnN0YW5jZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBpbnN0YW5jZTogaW5zdGFuY2UsIGlkOiBvYmouaWQgKyAnXycgKyBpRW5kKysgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBpbnN0YW5jZS5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobG9va2VkdXBFbmRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IGxvb2tlZHVwRW5kcy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogKDAsIGxpYl8xLmdldElkKSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbG9va2VkdXBFbmRzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGxvb2tlZHVwRW5kcy5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG9iai5pZCArICdfJyArIGlFbmQrKyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBsb29rZWR1cEVuZHMucmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5hYmxlLmR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkdXJhdGlvbkV4cHIgPSAoMCwgZXhwcmVzc2lvbl8xLmludGVycHJldEV4cHJlc3Npb24pKGVuYWJsZS5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9va3VwRHVyYXRpb24gPSBsb29rdXBFeHByZXNzaW9uKHJlc29sdmVkVGltZWxpbmUsIG9iaiwgZHVyYXRpb25FeHByLCAnZHVyYXRpb24nKTtcbiAgICAgICAgICAgICAgICBsZXQgbG9va2VkdXBEdXJhdGlvbiA9IGxvb2t1cER1cmF0aW9uLmluc3RhbmNlcztcbiAgICAgICAgICAgICAgICBkaXJlY3RSZWZlcmVuY2VzID0gZGlyZWN0UmVmZXJlbmNlcy5jb25jYXQobG9va3VwRHVyYXRpb24uYWxsUmVmZXJlbmNlcyk7XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNBcnJheShsb29rZWR1cER1cmF0aW9uKSAmJiBsb29rZWR1cER1cmF0aW9uLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBsb29rZWR1cER1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxvb2tlZHVwRHVyYXRpb25bMF0uc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBsb29rZWR1cER1cmF0aW9uWzBdLnJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkobG9va2VkdXBEdXJhdGlvbikgJiYgIWxvb2tlZHVwRHVyYXRpb24ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBsb29rZWR1cER1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc0FycmF5KGxvb2tlZHVwRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbG9va3VwRXhwcmVzc2lvbiBzaG91bGQgbmV2ZXIgcmV0dXJuIGFuIGFycmF5IGZvciAuZHVyYXRpb24gbG9va3VwYCk7IC8vIHBlcmhhcHMgdG1wPyBtYXliZSByZXZpc2l0IHRoaXMgYXQgc29tZSBwb2ludFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb29rZWR1cER1cmF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb29rZWR1cFJlcGVhdGluZyAhPT0gbnVsbCAmJiBsb29rZWR1cER1cmF0aW9uLnZhbHVlID4gbG9va2VkdXBSZXBlYXRpbmcudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBsb29rZWR1cER1cmF0aW9uLnZhbHVlID0gbG9va2VkdXBSZXBlYXRpbmcudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcExvb2tlZHVwRHVyYXRpb24gPSBsb29rZWR1cER1cmF0aW9uOyAvLyBjYXN0IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBldmVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBlLnRpbWUgKyB0bXBMb29rZWR1cER1cmF0aW9uLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZXMgPSAoMCwgbGliXzEuam9pblJlZmVyZW5jZXMpKGUucmVmZXJlbmNlcywgdG1wTG9va2VkdXBEdXJhdGlvbi5yZWZlcmVuY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGUuZGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGUuZGF0YS5pbnN0YW5jZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogdGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogcmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IHJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdJbnN0YW5jZXMgPSAoMCwgbGliXzEuY29udmVydEV2ZW50c1RvSW5zdGFuY2VzKShldmVudHMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzUGFyZW50KSB7XG4gICAgICAgICAgICAvLyBmaWd1cmUgb3V0IHdoYXQgcGFyZW50LWluc3RhbmNlIHRoZSBpbnN0YW5jZXMgYXJlIHRpZWQgdG8sIGFuZCBjYXAgdGhlbVxuICAgICAgICAgICAgY29uc3QgY2FwcGVkSW5zdGFuY2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0luc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3SW5zdGFuY2VzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmZXJyZWRQYXJlbnRJbnN0YW5jZSA9IF8uZmluZChwYXJlbnRJbnN0YW5jZXMsIChwYXJlbnRJbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnJlZmVyZW5jZXMuaW5kZXhPZihwYXJlbnRJbnN0YW5jZS5pZCkgIT09IC0xO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZmVycmVkUGFyZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjaGlsZCByZWZlcnMgdG8gaXRzIHBhcmVudCwgdGhlcmUgc2hvdWxkIGJlIG9uZSBzcGVjaWZpYyBpbnN0YW5jZSB0byBjYXAgaW50b1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FwcGVkSW5zdGFuY2UgPSAoMCwgbGliXzEuY2FwSW5zdGFuY2VzKShbaW5zdGFuY2VdLCBbcmVmZXJyZWRQYXJlbnRJbnN0YW5jZV0pWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhcHBlZEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYXBwZWRJbnN0YW5jZS5jYXBzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXBwZWRJbnN0YW5jZS5jYXBzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwcGVkSW5zdGFuY2UuY2Fwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHJlZmVycmVkUGFyZW50SW5zdGFuY2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiByZWZlcnJlZFBhcmVudEluc3RhbmNlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHJlZmVycmVkUGFyZW50SW5zdGFuY2UuZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcHBlZEluc3RhbmNlcy5wdXNoKGNhcHBlZEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjaGlsZCBkb2Vzbid0IHJlZmVyIHRvIGl0cyBwYXJlbnQsIGl0IHNob3VsZCBiZSBjYXBwZWQgd2l0aGluIGFsbCBvZiBpdHMgcGFyZW50IGluc3RhbmNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJbnN0YW5jZSA9IHBhcmVudEluc3RhbmNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXBwZWRJbnN0YW5jZSA9ICgwLCBsaWJfMS5jYXBJbnN0YW5jZXMpKFtpbnN0YW5jZV0sIFtwYXJlbnRJbnN0YW5jZV0pWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXBwZWRJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FwcGVkSW5zdGFuY2UuY2FwcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXBwZWRJbnN0YW5jZS5jYXBzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXBwZWRJbnN0YW5jZS5jYXBzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBwYXJlbnRJbnN0YW5jZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcGFyZW50SW5zdGFuY2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwYXJlbnRJbnN0YW5jZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXBwZWRJbnN0YW5jZXMucHVzaChjYXBwZWRJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3SW5zdGFuY2VzID0gY2FwcGVkSW5zdGFuY2VzO1xuICAgICAgICB9XG4gICAgICAgIG5ld0luc3RhbmNlcyA9ICgwLCBsaWJfMS5hcHBseVJlcGVhdGluZ0luc3RhbmNlcykobmV3SW5zdGFuY2VzLCBsb29rZWR1cFJlcGVhdGluZywgcmVzb2x2ZWRUaW1lbGluZS5vcHRpb25zKTtcbiAgICAgICAgaW5zdGFuY2VzID0gaW5zdGFuY2VzLmNvbmNhdChuZXdJbnN0YW5jZXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGluc3RhbmNlIGlkcyBhcmUgdW5pcXVlOlxuICAgIGNvbnN0IGlkcyA9IHt9O1xuICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgICAgIGlmIChpZHNbaW5zdGFuY2UuaWRdKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5pZCA9IGAke2luc3RhbmNlLmlkfV8keygwLCBsaWJfMS5nZXRJZCkoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlkc1tpbnN0YW5jZS5pZF0gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob2JqLnNlYW1sZXNzICYmIGluc3RhbmNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGluc3RhbmNlcyA9ICgwLCBsaWJfMS5jbGVhbkluc3RhbmNlcykoaW5zdGFuY2VzLCB0cnVlLCBmYWxzZSk7XG4gICAgfVxuICAgIG9iai5yZXNvbHZlZC5yZXNvbHZlZCA9IHRydWU7XG4gICAgb2JqLnJlc29sdmVkLnJlc29sdmluZyA9IGZhbHNlO1xuICAgIG9iai5yZXNvbHZlZC5pbnN0YW5jZXMgPSBpbnN0YW5jZXM7XG4gICAgb2JqLnJlc29sdmVkLmRpcmVjdFJlZmVyZW5jZXMgPSBkaXJlY3RSZWZlcmVuY2VzO1xuICAgIHVwZGF0ZVN0YXRpc3RpY3MocmVzb2x2ZWRUaW1lbGluZSwgb2JqKTtcbn1cbmV4cG9ydHMucmVzb2x2ZVRpbWVsaW5lT2JqID0gcmVzb2x2ZVRpbWVsaW5lT2JqO1xuZnVuY3Rpb24gdXBkYXRlU3RhdGlzdGljcyhyZXNvbHZlZFRpbWVsaW5lLCBvYmopIHtcbiAgICBpZiAob2JqLnJlc29sdmVkLmluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzb2x2ZWRUaW1lbGluZS5zdGF0aXN0aWNzLnJlc29sdmVkSW5zdGFuY2VDb3VudCArPSBvYmoucmVzb2x2ZWQuaW5zdGFuY2VzLmxlbmd0aDtcbiAgICAgICAgcmVzb2x2ZWRUaW1lbGluZS5zdGF0aXN0aWNzLnJlc29sdmVkQ291bnQgKz0gMTtcbiAgICAgICAgaWYgKG9iai5pc0dyb3VwKSB7XG4gICAgICAgICAgICByZXNvbHZlZFRpbWVsaW5lLnN0YXRpc3RpY3MucmVzb2x2ZWRHcm91cENvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5yZXNvbHZlZC5pc0tleWZyYW1lKSB7XG4gICAgICAgICAgICByZXNvbHZlZFRpbWVsaW5lLnN0YXRpc3RpY3MucmVzb2x2ZWRLZXlmcmFtZUNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlZFRpbWVsaW5lLnN0YXRpc3RpY3MucmVzb2x2ZWRPYmplY3RDb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXNvbHZlZFRpbWVsaW5lLnN0YXRpc3RpY3MudW5yZXNvbHZlZENvdW50ICs9IDE7XG4gICAgfVxufVxuLyoqIEludmFsaWRhdGUgYWxsIGNoYW5nZWQgb2JqZWN0cywgYW5kIHJlY3Vyc2l2ZWx5IGludmFsaWRhdGUgYWxsIG9iamVjdHMgdGhhdCByZWZlcmVuY2UgdGhvc2Ugb2JqZWN0cyAqL1xuZnVuY3Rpb24gaW52YWxpZGF0ZU9iamVjdHNXaXRoUmVmZXJlbmNlKGhhbmRsZWRSZWZlcmVuY2VzLCByZWZlcmVuY2UsIGFmZmVjdFJlZmVyZW5jZU1hcCwgdmFsaWRPYmplY3RzKSB7XG4gICAgaWYgKGhhbmRsZWRSZWZlcmVuY2VzW3JlZmVyZW5jZV0pXG4gICAgICAgIHJldHVybjsgLy8gdG8gYXZvaWQgaW5maW5pdGUgbG9vcHNcbiAgICBoYW5kbGVkUmVmZXJlbmNlc1tyZWZlcmVuY2VdID0gdHJ1ZTtcbiAgICBpZiAocmVmZXJlbmNlWzBdID09PSAnIycpIHtcbiAgICAgICAgLy8gYW4gaWRcbiAgICAgICAgY29uc3Qgb2JqSWQgPSByZWZlcmVuY2Uuc2xpY2UoMSk7XG4gICAgICAgIGlmICh2YWxpZE9iamVjdHNbb2JqSWRdKSB7XG4gICAgICAgICAgICBkZWxldGUgdmFsaWRPYmplY3RzW29iaklkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJbnZhbGlkYXRlIGFsbCBvYmplY3RzIHRoYXQgZGVwZW5kIG9uIGFueSBvZiB0aGUgcmVmZXJlbmNlcyB0aGF0IHRoaXMgcmVmZXJlbmNlIGFmZmVjdHM6XG4gICAgY29uc3QgYWZmZWN0ZWRSZWZlcmVuY2VzID0gYWZmZWN0UmVmZXJlbmNlTWFwW3JlZmVyZW5jZV07XG4gICAgaWYgKGFmZmVjdGVkUmVmZXJlbmNlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFmZmVjdGVkUmVmZXJlbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNpbmdSZWZlcmVuY2UgPSBhZmZlY3RlZFJlZmVyZW5jZXNbaV07XG4gICAgICAgICAgICBpbnZhbGlkYXRlT2JqZWN0c1dpdGhSZWZlcmVuY2UoaGFuZGxlZFJlZmVyZW5jZXMsIHJlZmVyZW5jaW5nUmVmZXJlbmNlLCBhZmZlY3RSZWZlcmVuY2VNYXAsIHZhbGlkT2JqZWN0cyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIExvb2sgdXAgYSByZWZlcmVuY2Ugb24gdGhlIHRpbWVsaW5lXG4gKiBSZXR1cm4gdmFsdWVzOlxuICogQXJyYXk8VGltZWxpbmVPYmplY3RJbnN0YW5jZT46IEluc3RhbmNlcyBvbiB0aGUgdGltZWxpbmUgd2hlcmUgdGhlIHJlZmVyZW5jZSBleHByZXNzaW9uIGlzIHRydWVcbiAqIFZhbHVlV2l0aFJlZmVyZW5jZTogQSBzaW5ndWxhciB2YWx1ZSB3aGljaCBjYW4gYmUgY29tYmluZWQgYXJpdGhtZXRpY2FsbHkgd2l0aCBJbnN0YW5jZXNcbiAqIG51bGw6IE1lYW5zIFwic29tZXRoaW5nIGlzIGludmFsaWRcIiwgYW4gbnVsbC12YWx1ZSB3aWxsIGFsd2F5cyByZXR1cm4gbnVsbCB3aGVuIGNvbWJpbmVkIHdpdGggb3RoZXIgdmFsdWVzXG4gKlxuICogQHBhcmFtIHJlc29sdmVkVGltZWxpbmVcbiAqIEBwYXJhbSBvYmpcbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gY29udGV4dFxuICovXG5mdW5jdGlvbiBsb29rdXBFeHByZXNzaW9uKHJlc29sdmVkVGltZWxpbmUsIG9iaiwgZXhwciwgY29udGV4dCkge1xuICAgIGlmIChleHByID09PSBudWxsKVxuICAgICAgICByZXR1cm4geyBpbnN0YW5jZXM6IG51bGwsIGFsbFJlZmVyZW5jZXM6IFtdIH07XG4gICAgaWYgKF8uaXNTdHJpbmcoZXhwcikgJiYgKDAsIGxpYl8xLmlzTnVtZXJpYykoZXhwcikpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluc3RhbmNlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KGV4cHIpLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IFtdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsbFJlZmVyZW5jZXM6IFtdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChfLmlzTnVtYmVyKGV4cHIpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YW5jZXM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXhwcixcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbGxSZWZlcmVuY2VzOiBbXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXy5pc1N0cmluZyhleHByKSkge1xuICAgICAgICBleHByID0gZXhwci50cmltKCk7XG4gICAgICAgIGlmICgoMCwgbGliXzEuaXNDb25zdGFudCkoZXhwcikpIHtcbiAgICAgICAgICAgIGlmIChleHByLm1hdGNoKC9edHJ1ZSQvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFsbFJlZmVyZW5jZXM6IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChleHByLm1hdGNoKC9eZmFsc2UkL2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgYWxsUmVmZXJlbmNlczogW10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBMb29rIHVwIHN0cmluZ1xuICAgICAgICBsZXQgaW52ZXJ0ID0gZmFsc2U7XG4gICAgICAgIGxldCBpZ25vcmVGaXJzdElmWmVybyA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVmZXJlbmNlZE9ianMgPSBbXTtcbiAgICAgICAgbGV0IHJlZiA9IGNvbnRleHQ7XG4gICAgICAgIGxldCByZXN0ID0gJyc7XG4gICAgICAgIGxldCBvYmpJZHNUb1JlZmVyZW5jZSA9IFtdO1xuICAgICAgICBjb25zdCBhbGxSZWZlcmVuY2VzID0gW107XG4gICAgICAgIGxldCByZWZlcmVuY2VJc09rID0gZmFsc2U7XG4gICAgICAgIC8vIE1hdGNoIGlkLCBleGFtcGxlOiBcIiNvYmplY3RJZC5zdGFydFwiXG4gICAgICAgIGNvbnN0IG0gPSBleHByLm1hdGNoKC9eXFxXKiMoW14uXSspKC4qKS8pO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBtWzFdO1xuICAgICAgICAgICAgcmVzdCA9IG1bMl07XG4gICAgICAgICAgICByZWZlcmVuY2VJc09rID0gdHJ1ZTtcbiAgICAgICAgICAgIG9iaklkc1RvUmVmZXJlbmNlID0gW2lkXTtcbiAgICAgICAgICAgIGFsbFJlZmVyZW5jZXMucHVzaCgnIycgKyBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNYXRjaCBjbGFzcywgZXhhbXBsZTogXCIuY2xhc3NOYW1lLnN0YXJ0XCJcbiAgICAgICAgICAgIGNvbnN0IG0gPSBleHByLm1hdGNoKC9eXFxXKlxcLihbXi5dKykoLiopLyk7XG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IG1bMV07XG4gICAgICAgICAgICAgICAgcmVzdCA9IG1bMl07XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSXNPayA9IHRydWU7XG4gICAgICAgICAgICAgICAgb2JqSWRzVG9SZWZlcmVuY2UgPSByZXNvbHZlZFRpbWVsaW5lLmNsYXNzZXNbY2xhc3NOYW1lXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBhbGxSZWZlcmVuY2VzLnB1c2goJy4nICsgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1hdGNoIGxheWVyLCBleGFtcGxlOiBcIiRsYXllclwiXG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IGV4cHIubWF0Y2goL15cXFcqXFwkKFteLl0rKSguKikvKTtcbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXllciA9IG1bMV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3QgPSBtWzJdO1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VJc09rID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb2JqSWRzVG9SZWZlcmVuY2UgPSByZXNvbHZlZFRpbWVsaW5lLmxheWVyc1tsYXllcl0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGFsbFJlZmVyZW5jZXMucHVzaCgnJCcgKyBsYXllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqSWRzVG9SZWZlcmVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZk9iaklkID0gb2JqSWRzVG9SZWZlcmVuY2VbaV07XG4gICAgICAgICAgICBpZiAocmVmT2JqSWQgIT09IG9iai5pZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZk9iaiA9IHJlc29sdmVkVGltZWxpbmUub2JqZWN0c1tyZWZPYmpJZF07XG4gICAgICAgICAgICAgICAgaWYgKHJlZk9iaikge1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VkT2Jqcy5wdXNoKHJlZk9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTG9va3MgbGlrZSB0aGUgb2JqZWN0IGlzIHJlZmVyZW5jaW5nIGl0c2VsZiFcbiAgICAgICAgICAgICAgICBpZiAob2JqLnJlc29sdmVkLnJlc29sdmluZykge1xuICAgICAgICAgICAgICAgICAgICBvYmoucmVzb2x2ZWQuaXNTZWxmUmVmZXJlbmNpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlZmVyZW5jZUlzT2spIHtcbiAgICAgICAgICAgIHJldHVybiB7IGluc3RhbmNlczogbnVsbCwgYWxsUmVmZXJlbmNlczogW10gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnJlc29sdmVkLmlzU2VsZlJlZmVyZW5jaW5nKSB7XG4gICAgICAgICAgICAvLyBFeGNsdWRlIGFueSBzZWxmLXJlZmVyZW5jaW5nIG9iamVjdHM6XG4gICAgICAgICAgICByZWZlcmVuY2VkT2JqcyA9IF8uZmlsdGVyKHJlZmVyZW5jZWRPYmpzLCAocmVmT2JqKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFyZWZPYmoucmVzb2x2ZWQuaXNTZWxmUmVmZXJlbmNpbmc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmZXJlbmNlZE9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAocmVzdC5tYXRjaCgvc3RhcnQvKSlcbiAgICAgICAgICAgICAgICByZWYgPSAnc3RhcnQnO1xuICAgICAgICAgICAgaWYgKHJlc3QubWF0Y2goL2VuZC8pKVxuICAgICAgICAgICAgICAgIHJlZiA9ICdlbmQnO1xuICAgICAgICAgICAgaWYgKHJlc3QubWF0Y2goL2R1cmF0aW9uLykpXG4gICAgICAgICAgICAgICAgcmVmID0gJ2R1cmF0aW9uJztcbiAgICAgICAgICAgIGlmIChyZWYgPT09ICdkdXJhdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBEdXJhdGlvbiByZWZlcnMgdG8gdGhlIGZpcnN0IG9iamVjdCBvbiB0aGUgcmVzb2x2ZWQgdGltZWxpbmVcbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZUR1cmF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVmZXJlbmNlZE9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlZE9iaiA9IHJlZmVyZW5jZWRPYmpzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlVGltZWxpbmVPYmoocmVzb2x2ZWRUaW1lbGluZSwgcmVmZXJlbmNlZE9iaik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZlcmVuY2VkT2JqLnJlc29sdmVkLnJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLnJlc29sdmVkLmlzU2VsZlJlZmVyZW5jaW5nICYmIHJlZmVyZW5jZWRPYmoucmVzb2x2ZWQuaXNTZWxmUmVmZXJlbmNpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcXVlcnlpbmcgb2JqZWN0IGlzIHNlbGYtcmVmZXJlbmNpbmcsIGV4Y2x1ZGUgYW55IG90aGVyIHNlbGYtcmVmZXJlbmNpbmcgb2JqZWN0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RJbnN0YW5jZSA9IF8uZmlyc3QocmVmZXJlbmNlZE9iai5yZXNvbHZlZC5pbnN0YW5jZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gZmlyc3RJbnN0YW5jZS5lbmQgIT09IG51bGwgPyBmaXJzdEluc3RhbmNlLmVuZCAtIGZpcnN0SW5zdGFuY2Uuc3RhcnQgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlRHVyYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiAoMCwgbGliXzEuam9pblJlZmVyZW5jZXMpKHJlZmVyZW5jZWRPYmouaWQsIGZpcnN0SW5zdGFuY2UucmVmZXJlbmNlcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZmlyc3REdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0YW5jZUR1cmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkID0gaW5zdGFuY2VEdXJhdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdER1cmF0aW9uID09PSBudWxsIHx8IGQudmFsdWUgPCBmaXJzdER1cmF0aW9uLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3REdXJhdGlvbiA9IGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGluc3RhbmNlczogZmlyc3REdXJhdGlvbiwgYWxsUmVmZXJlbmNlczogYWxsUmVmZXJlbmNlcyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHJldHVybkluc3RhbmNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChyZWYgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWYgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmVydCA9ICFpbnZlcnQ7XG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZUZpcnN0SWZaZXJvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgVW5rbm93biByZWY6IFwiJHtyZWZ9XCJgKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZmVyZW5jZWRPYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZWRPYmogPSByZWZlcmVuY2VkT2Jqc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVRpbWVsaW5lT2JqKHJlc29sdmVkVGltZWxpbmUsIHJlZmVyZW5jZWRPYmopO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmZXJlbmNlZE9iai5yZXNvbHZlZC5yZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5yZXNvbHZlZC5pc1NlbGZSZWZlcmVuY2luZyAmJiByZWZlcmVuY2VkT2JqLnJlc29sdmVkLmlzU2VsZlJlZmVyZW5jaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHF1ZXJ5aW5nIG9iamVjdCBpcyBzZWxmLXJlZmVyZW5jaW5nLCBleGNsdWRlIGFueSBvdGhlciBzZWxmLXJlZmVyZW5jaW5nIG9iamVjdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkluc3RhbmNlcyA9IHJldHVybkluc3RhbmNlcy5jb25jYXQocmVmZXJlbmNlZE9iai5yZXNvbHZlZC5pbnN0YW5jZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5JbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnZlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkluc3RhbmNlcyA9ICgwLCBsaWJfMS5pbnZlcnRJbnN0YW5jZXMpKHJldHVybkluc3RhbmNlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5JbnN0YW5jZXMgPSAoMCwgbGliXzEuY2xlYW5JbnN0YW5jZXMpKHJldHVybkluc3RhbmNlcywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZUZpcnN0SWZaZXJvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IF8uZmlyc3QocmV0dXJuSW5zdGFuY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCAmJiBmaXJzdC5zdGFydCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkluc3RhbmNlcy5zcGxpY2UoMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaW5zdGFuY2VzOiByZXR1cm5JbnN0YW5jZXMsIGFsbFJlZmVyZW5jZXM6IGFsbFJlZmVyZW5jZXMgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGluc3RhbmNlczogW10sIGFsbFJlZmVyZW5jZXM6IGFsbFJlZmVyZW5jZXMgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBpbnN0YW5jZXM6IFtdLCBhbGxSZWZlcmVuY2VzOiBhbGxSZWZlcmVuY2VzIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChleHByKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gbG9va3VwRXhwcmVzc2lvbihyZXNvbHZlZFRpbWVsaW5lLCBvYmosIGV4cHIubCwgY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCByID0gbG9va3VwRXhwcmVzc2lvbihyZXNvbHZlZFRpbWVsaW5lLCBvYmosIGV4cHIuciwgY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBsb29rdXBFeHByID0ge1xuICAgICAgICAgICAgICAgIGw6IGwuaW5zdGFuY2VzLFxuICAgICAgICAgICAgICAgIG86IGV4cHIubyxcbiAgICAgICAgICAgICAgICByOiByLmluc3RhbmNlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBhbGxSZWZlcmVuY2VzID0gbC5hbGxSZWZlcmVuY2VzLmNvbmNhdChyLmFsbFJlZmVyZW5jZXMpO1xuICAgICAgICAgICAgaWYgKGxvb2t1cEV4cHIubyA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgLy8gRGlzY2FyZCBsLCBpbnZlcnQgYW5kIHJldHVybiByOlxuICAgICAgICAgICAgICAgIGlmIChsb29rdXBFeHByLnIgJiYgXy5pc0FycmF5KGxvb2t1cEV4cHIucikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlczogKDAsIGxpYl8xLmludmVydEluc3RhbmNlcykobG9va3VwRXhwci5yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbFJlZmVyZW5jZXM6IGFsbFJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCBpbnZlcnQgYSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VzOiBsb29rdXBFeHByLnIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxSZWZlcmVuY2VzOiBhbGxSZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChfLmlzTnVsbChsb29rdXBFeHByLmwpIHx8IF8uaXNOdWxsKGxvb2t1cEV4cHIucikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaW5zdGFuY2VzOiBudWxsLCBhbGxSZWZlcmVuY2VzOiBhbGxSZWZlcmVuY2VzIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsb29rdXBFeHByLm8gPT09ICcmJyB8fCBsb29rdXBFeHByLm8gPT09ICd8Jykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZEV2ZW50cyA9IChpbnN0YW5jZXMsIGxlZnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXJ0ICE9PSBpbnN0YW5jZS5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnQgZG9lc24ndCBhY3R1YWxseSBleGlzdC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogaW5zdGFuY2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5lbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IGluc3RhbmNlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkobG9va3VwRXhwci5sKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEV2ZW50cyhsb29rdXBFeHByLmwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXy5pc0FycmF5KGxvb2t1cEV4cHIucikpXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRFdmVudHMobG9va3VwRXhwci5yLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cyA9ICgwLCBsaWJfMS5zb3J0RXZlbnRzKShldmVudHMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxjUmVzdWx0ID0gbG9va3VwRXhwci5vID09PSAnJidcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKGxlZnQsIHJpZ2h0KSA9PiAhIShsZWZ0ICYmIHJpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBsb29rdXBFeHByLm8gPT09ICd8J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGxlZnQsIHJpZ2h0KSA9PiAhIShsZWZ0IHx8IHJpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxlZnRWYWx1ZSA9ICgwLCBsaWJfMS5pc1JlZmVyZW5jZSkobG9va3VwRXhwci5sKSA/ICEhbG9va3VwRXhwci5sLnZhbHVlIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCByaWdodFZhbHVlID0gKDAsIGxpYl8xLmlzUmVmZXJlbmNlKShsb29rdXBFeHByLnIpID8gISFsb29rdXBFeHByLnIudmFsdWUgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxlZnRJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCByaWdodEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdFZhbHVlID0gY2FsY1Jlc3VsdChsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlSW5zdGFuY2UgPSAodGltZSwgdmFsdWUsIHJlZmVyZW5jZXMsIGNhcHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICgwLCBsaWJfMS5nZXRJZCkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogcmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwczogY2FwcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBfLmxhc3QoaW5zdGFuY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0LmVuZCA9IHRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHVwZGF0ZSByZWZlcmVuY2Ugb24gZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVJbnN0YW5jZSgwLCByZXN1bHRWYWx1ZSwgKDAsIGxpYl8xLmpvaW5SZWZlcmVuY2VzKSgoMCwgbGliXzEuaXNSZWZlcmVuY2UpKGxvb2t1cEV4cHIubCkgPyBsb29rdXBFeHByLmwucmVmZXJlbmNlcyA6IFtdLCAoMCwgbGliXzEuaXNSZWZlcmVuY2UpKGxvb2t1cEV4cHIucikgPyBsb29rdXBFeHByLnIucmVmZXJlbmNlcyA6IFtdKSwgW10pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGV2ZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBldmVudHNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRWYWx1ZSA9IGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEluc3RhbmNlID0gZS5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0VmFsdWUgPSBlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0SW5zdGFuY2UgPSBlLmluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQudGltZSAhPT0gZS50aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UmVzdWx0VmFsdWUgPSBjYWxjUmVzdWx0KGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0Q2FwcyA9IChsZWZ0SW5zdGFuY2UgPyBsZWZ0SW5zdGFuY2UuY2FwcyB8fCBbXSA6IFtdKS5jb25jYXQocmlnaHRJbnN0YW5jZSA/IHJpZ2h0SW5zdGFuY2UuY2FwcyB8fCBbXSA6IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3UmVzdWx0VmFsdWUgIT09IHJlc3VsdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUluc3RhbmNlKGUudGltZSwgbmV3UmVzdWx0VmFsdWUsICgwLCBsaWJfMS5qb2luUmVmZXJlbmNlcykobGVmdEluc3RhbmNlID8gbGVmdEluc3RhbmNlLnJlZmVyZW5jZXMgOiBbXSwgcmlnaHRJbnN0YW5jZSA/IHJpZ2h0SW5zdGFuY2UucmVmZXJlbmNlcyA6IFtdKSwgcmVzdWx0Q2Fwcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlID0gbmV3UmVzdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGluc3RhbmNlczogaW5zdGFuY2VzLCBhbGxSZWZlcmVuY2VzOiBhbGxSZWZlcmVuY2VzIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcGVyYXRlSW5uZXIgPSBsb29rdXBFeHByLm8gPT09ICcrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhLnZhbHVlICsgYi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogKDAsIGxpYl8xLmpvaW5SZWZlcmVuY2VzKShhLnJlZmVyZW5jZXMsIGIucmVmZXJlbmNlcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogbG9va3VwRXhwci5vID09PSAnLSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYS52YWx1ZSAtIGIudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiAoMCwgbGliXzEuam9pblJlZmVyZW5jZXMpKGEucmVmZXJlbmNlcywgYi5yZWZlcmVuY2VzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBsb29rdXBFeHByLm8gPT09ICcqJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhLnZhbHVlICogYi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiAoMCwgbGliXzEuam9pblJlZmVyZW5jZXMpKGEucmVmZXJlbmNlcywgYi5yZWZlcmVuY2VzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBsb29rdXBFeHByLm8gPT09ICcvJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhLnZhbHVlIC8gYi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogKDAsIGxpYl8xLmpvaW5SZWZlcmVuY2VzKShhLnJlZmVyZW5jZXMsIGIucmVmZXJlbmNlcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbG9va3VwRXhwci5vID09PSAnJSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYS52YWx1ZSAlIGIudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiAoMCwgbGliXzEuam9pblJlZmVyZW5jZXMpKGEucmVmZXJlbmNlcywgYi5yZWZlcmVuY2VzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoKSA9PiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcGVyYXRlID0gKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0ZUlubmVyKGEsIGIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgbGliXzEub3BlcmF0ZU9uQXJyYXlzKShsb29rdXBFeHByLmwsIGxvb2t1cEV4cHIuciwgb3BlcmF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGluc3RhbmNlczogcmVzdWx0LCBhbGxSZWZlcmVuY2VzOiBhbGxSZWZlcmVuY2VzIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGluc3RhbmNlczogbnVsbCwgYWxsUmVmZXJlbmNlczogW10gfTtcbn1cbmV4cG9ydHMubG9va3VwRXhwcmVzc2lvbiA9IGxvb2t1cEV4cHJlc3Npb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXBwbHlLZXlmcmFtZUNvbnRlbnQgPSBleHBvcnRzLnJlc29sdmVTdGF0ZXMgPSBleHBvcnRzLmdldFN0YXRlID0gdm9pZCAwO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG5jb25zdCBlbnVtc18xID0gcmVxdWlyZShcIi4uL2FwaS9lbnVtc1wiKTtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4uL2xpYlwiKTtcbmZ1bmN0aW9uIGdldFN0YXRlKHJlc29sdmVkLCB0aW1lLCBldmVudExpbWl0ID0gMCkge1xuICAgIGNvbnN0IHJlc29sdmVkU3RhdGVzID0gaXNSZXNvbHZlZFN0YXRlcyhyZXNvbHZlZCkgPyByZXNvbHZlZCA6IHJlc29sdmVTdGF0ZXMocmVzb2x2ZWQpO1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICBsYXllcnM6IHt9LFxuICAgICAgICBuZXh0RXZlbnRzOiBfLmZpbHRlcihyZXNvbHZlZFN0YXRlcy5uZXh0RXZlbnRzLCAoZSkgPT4gZS50aW1lID4gdGltZSksXG4gICAgfTtcbiAgICBpZiAoZXZlbnRMaW1pdClcbiAgICAgICAgc3RhdGUubmV4dEV2ZW50cyA9IHN0YXRlLm5leHRFdmVudHMuc2xpY2UoMCwgZXZlbnRMaW1pdCk7XG4gICAgY29uc3QgbGF5ZXJLZXlzID0gT2JqZWN0LmtleXMocmVzb2x2ZWRTdGF0ZXMubGF5ZXJzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxheWVyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBsYXllciA9IGxheWVyS2V5c1tpXTtcbiAgICAgICAgY29uc3QgbyA9IGdldFN0YXRlQXRUaW1lKHJlc29sdmVkU3RhdGVzLnN0YXRlLCBsYXllciwgdGltZSk7XG4gICAgICAgIGlmIChvKVxuICAgICAgICAgICAgc3RhdGUubGF5ZXJzW2xheWVyXSA9IG87XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbn1cbmV4cG9ydHMuZ2V0U3RhdGUgPSBnZXRTdGF0ZTtcbmZ1bmN0aW9uIHJlc29sdmVTdGF0ZXMocmVzb2x2ZWQsIGNhY2hlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICBjb25zdCByZXNvbHZlZFN0YXRlcyA9IHtcbiAgICAgICAgb3B0aW9uczogcmVzb2x2ZWQub3B0aW9ucyxcbiAgICAgICAgc3RhdGlzdGljczogcmVzb2x2ZWQuc3RhdGlzdGljcyxcbiAgICAgICAgLy8gVGhlc2Ugd2lsbCBiZSByZS1jcmVhdGVkIGR1cmluZyB0aGUgc3RhdGUtcmVzb2x2aW5nOlxuICAgICAgICBvYmplY3RzOiB7fSxcbiAgICAgICAgY2xhc3Nlczoge30sXG4gICAgICAgIGxheWVyczoge30sXG4gICAgICAgIHN0YXRlOiB7fSxcbiAgICAgICAgbmV4dEV2ZW50czogW10sXG4gICAgfTtcbiAgICBpZiAoY2FjaGUgJiYgcmVzb2x2ZWQuc3RhdGlzdGljcy5yZXNvbHZpbmdDb3VudCA9PT0gMCAmJiBjYWNoZS5yZXNvbHZlZFN0YXRlcykge1xuICAgICAgICAvLyBOb3RoaW5nIGhhcyBjaGFuZ2VkIHNpbmNlIGxhc3QgdGltZSwganVzdCByZXR1cm4gdGhlIHN0YXRlcyByaWdodCBhd2F5OlxuICAgICAgICByZXR1cm4gY2FjaGUucmVzb2x2ZWRTdGF0ZXM7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkT2JqZWN0cyA9IF8udmFsdWVzKHJlc29sdmVkLm9iamVjdHMpO1xuICAgIC8vIFNvcnQgdG8gbWFrZSBzdXJlIHBhcmVudCBncm91cHMgYXJlIGV2YWx1YXRlZCBiZWZvcmUgdGhlaXIgY2hpbGRyZW46XG4gICAgcmVzb2x2ZWRPYmplY3RzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgaWYgKChhLnJlc29sdmVkLmxldmVsRGVlcCB8fCAwKSA+IChiLnJlc29sdmVkLmxldmVsRGVlcCB8fCAwKSlcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoKGEucmVzb2x2ZWQubGV2ZWxEZWVwIHx8IDApIDwgKGIucmVzb2x2ZWQubGV2ZWxEZWVwIHx8IDApKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYS5pZCA+IGIuaWQpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEuaWQgPCBiLmlkKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgICAvLyBTdGVwIDE6IENvbGxlY3QgYWxsIHBvaW50cy1vZi1pbnRlcmVzdCAod2hpY2ggcG9pbnRzIGluIHRpbWUgd2Ugd2FudCB0byBldmFsdWF0ZSlcbiAgICAvLyBhbmQgd2hpY2ggaW5zdGFuY2VzIHRoYXQgYXJlIGludGVyZXN0aW5nXG4gICAgY29uc3QgcG9pbnRzSW5UaW1lID0ge307XG4gICAgY29uc3QgYWRkUG9pbnRJblRpbWUgPSAodGltZSwgY2hlY2tJZCwgb3JkZXIsIG9iaiwgaW5zdGFuY2UpID0+IHtcbiAgICAgICAgLy8gTm90ZSBvbiBvcmRlcjogRW5kaW5nIGV2ZW50cyBjb21lIGJlZm9yZSBzdGFydGluZyBldmVudHNcbiAgICAgICAgaWYgKCFwb2ludHNJblRpbWVbdGltZSArICcnXSlcbiAgICAgICAgICAgIHBvaW50c0luVGltZVt0aW1lICsgJyddID0gW107XG4gICAgICAgIHBvaW50c0luVGltZVt0aW1lICsgJyddLnB1c2goeyBvYmosIGluc3RhbmNlLCBjaGVja0lkLCBvcmRlciB9KTtcbiAgICB9O1xuICAgIGZvciAoY29uc3Qgb2JqIG9mIHJlc29sdmVkT2JqZWN0cykge1xuICAgICAgICBpZiAoIW9iai5kaXNhYmxlZCAmJiBvYmoucmVzb2x2ZWQucmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGlmICghb2JqLnJlc29sdmVkLmlzS2V5ZnJhbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRUaW1lcyA9IGdldFRpbWVzRnJvbVBhcmVudHMocmVzb2x2ZWQsIG9iaik7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5sYXllcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBsYXllciBpcyBlbXB0eSwgZG9uJ3QgcHV0IGluIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2Ygb2JqLnJlc29sdmVkLmluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZUV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZUV2ZW50cy5wdXNoKHsgdGltZTogaW5zdGFuY2Uuc3RhcnQsIGVuYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5lbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZUV2ZW50cy5wdXNoKHsgdGltZTogaW5zdGFuY2UuZW5kLCBlbmFibGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxzbyBpbmNsdWRlIHRpbWVzIGZyb20gcGFyZW50cywgYXMgdGhleSBjb3VsZCBhZmZlY3QgdGhlIHN0YXRlIG9mIHRoaXMgaW5zdGFuY2U6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudFRpbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50VGltZSA9IHBhcmVudFRpbWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUaW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFRpbWUudGltZSA+IChpbnN0YW5jZS5zdGFydCB8fCAwKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUaW1lLnRpbWUgPCAoKF9hID0gaW5zdGFuY2UuZW5kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBJbmZpbml0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZUV2ZW50cy5wdXNoKHBhcmVudFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgYSByZWZlcmVuY2UgdG8gdGhpcyBpbnN0YW5jZSBvbiBhbGwgcG9pbnRzIGluIHRpbWUgdGhhdCBjb3VsZCBhZmZlY3QgaXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVFdmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lRXZlbnQgPSB0aW1lRXZlbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lRXZlbnQuZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBvaW50SW5UaW1lKHRpbWVFdmVudC50aW1lLCAnc3RhcnQnLCAxLCBvYmosIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBvaW50SW5UaW1lKHRpbWVFdmVudC50aW1lLCAnZW5kJywgMCwgb2JqLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob2JqLnJlc29sdmVkLmlzS2V5ZnJhbWUgJiYgb2JqLnJlc29sdmVkLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ZnJhbWUgPSBvYmo7XG4gICAgICAgICAgICAgICAgLy8gQWxzbyBhZGQga2V5ZnJhbWVzIHRvIHBvaW50c0luVGltZTpcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGtleWZyYW1lLnJlc29sdmVkLmluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBLZXlmcmFtZSBzdGFydCB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGFkZFBvaW50SW5UaW1lKGluc3RhbmNlLnN0YXJ0LCAnc3RhcnQnLCAxLCBrZXlmcmFtZSwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBLZXlmcmFtZSBlbmQgdGltZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuZW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRQb2ludEluVGltZShpbnN0YW5jZS5lbmQsICdlbmQnLCAwLCBrZXlmcmFtZSwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFN0ZXAgMjogUmVzb2x2ZSB0aGUgc3RhdGUgZm9yIHRoZSBwb2ludHMtb2YtaW50ZXJlc3RcbiAgICAvLyBUaGlzIGlzIGRvbmUgYnkgc3dlZXBpbmcgdGhlIHBvaW50cy1vZi1pbnRlcmVzdCBjaHJvbm9sb2dpY2FsbHksXG4gICAgLy8gZGV0ZXJtaW5pbmcgdGhlIHN0YXRlIGZvciBldmVyeSBwb2ludCBpbiB0aW1lIGJ5IGFkZGluZyAmIHJlbW92aW5nIG9iamVjdHMgZnJvbSBhc3BpcmluZ0luc3RhbmNlc1xuICAgIC8vIFRoZW4gc29ydGluZyBpdCB0byBkZXRlcm1pbmUgd2hvIHRha2VzIHByZWNlZGVuY2VcbiAgICBjb25zdCBldmVudE9iamVjdFRpbWVzID0ge307XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0ge307XG4gICAgY29uc3QgYWN0aXZlT2JqSWRzID0ge307XG4gICAgY29uc3QgYWN0aXZlS2V5ZnJhbWVzID0ge307XG4gICAgY29uc3QgYWN0aXZlS2V5ZnJhbWVzQ2hlY2tlZCA9IHt9O1xuICAgIC8qKiBUaGUgb2JqZWN0cyBpbiBhc3BpcmluZ0luc3RhbmNlcyAgKi9cbiAgICBjb25zdCBhc3BpcmluZ0luc3RhbmNlcyA9IHt9O1xuICAgIGNvbnN0IGtleWZyYW1lRXZlbnRzID0gW107XG4gICAgY29uc3QgdGltZXMgPSBPYmplY3Qua2V5cyhwb2ludHNJblRpbWUpXG4gICAgICAgIC5tYXAoKHRpbWUpID0+IHBhcnNlRmxvYXQodGltZSkpXG4gICAgICAgIC8vIFNvcnQgY2hyb25vbG9naWNhbGx5OlxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgcG9pbnRzLW9mLWludGVyZXN0IHRpbWVzOlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdGltZSA9IHRpbWVzW2ldO1xuICAgICAgICBjb25zdCBpbnN0YW5jZXNUb0NoZWNrID0gcG9pbnRzSW5UaW1lW3RpbWVdO1xuICAgICAgICBjb25zdCBjaGVja2VkT2JqZWN0c1RoaXNUaW1lID0ge307XG4gICAgICAgIGluc3RhbmNlc1RvQ2hlY2suc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKGEub2JqLnJlc29sdmVkICYmIGIub2JqLnJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gS2V5ZnJhbWVzIGNvbWVzIGZpcnN0OlxuICAgICAgICAgICAgICAgIGlmIChhLm9iai5yZXNvbHZlZC5pc0tleWZyYW1lICYmICFiLm9iai5yZXNvbHZlZC5pc0tleWZyYW1lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgaWYgKCFhLm9iai5yZXNvbHZlZC5pc0tleWZyYW1lICYmIGIub2JqLnJlc29sdmVkLmlzS2V5ZnJhbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIGlmIChhLm9yZGVyID4gYi5vcmRlcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgaWYgKGEub3JkZXIgPCBiLm9yZGVyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgLy8gRGVlcGVyIG9iamVjdHMgKGNoaWxkcmVuIGluIGdyb3VwcykgY29tZXMgbGF0ZXIsIHdlIHdhbnQgdG8gY2hlY2sgdGhlIHBhcmVudCBncm91cHMgZmlyc3Q6XG4gICAgICAgICAgICAgICAgaWYgKChhLm9iai5yZXNvbHZlZC5sZXZlbERlZXAgfHwgMCkgPiAoYi5vYmoucmVzb2x2ZWQubGV2ZWxEZWVwIHx8IDApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICBpZiAoKGEub2JqLnJlc29sdmVkLmxldmVsRGVlcCB8fCAwKSA8IChiLm9iai5yZXNvbHZlZC5sZXZlbERlZXAgfHwgMCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbnN0YW5jZXNUb0NoZWNrLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBvID0gaW5zdGFuY2VzVG9DaGVja1tqXTtcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IG8ub2JqO1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBvLmluc3RhbmNlO1xuICAgICAgICAgICAgbGV0IHRvQmVFbmFibGVkID0gKGluc3RhbmNlLnN0YXJ0IHx8IDApIDw9IHRpbWUgJiYgKChfYiA9IGluc3RhbmNlLmVuZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogSW5maW5pdHkpID4gdGltZTtcbiAgICAgICAgICAgIGNvbnN0IGxheWVyID0gb2JqLmxheWVyICsgJyc7XG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gb2JqLmlkICsgJ18nICsgaW5zdGFuY2UuaWQgKyAnXycgKyBvLmNoZWNrSWQ7XG4gICAgICAgICAgICBpZiAoIWNoZWNrZWRPYmplY3RzVGhpc1RpbWVbaWRlbnRpZmllcl0pIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGNoZWNrIGVhY2ggb2JqZWN0IGFuZCBldmVudC10eXBlIG9uY2UgZm9yIGV2ZXJ5IHBvaW50IGluIHRpbWVcbiAgICAgICAgICAgICAgICBjaGVja2VkT2JqZWN0c1RoaXNUaW1lW2lkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIW9iai5yZXNvbHZlZC5pc0tleWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG9iamVjdCBoYXMgYSBwYXJlbnQsIG9ubHkgc2V0IGlmIHBhcmVudCBpcyBvbiBhIGxheWVyIChpZiBsYXllciBpcyBzZXQgZm9yIHBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvQmVFbmFibGVkICYmIG9iai5yZXNvbHZlZC5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50T2JqID0gb2JqLnJlc29sdmVkLnBhcmVudElkID8gcmVzb2x2ZWQub2JqZWN0c1tvYmoucmVzb2x2ZWQucGFyZW50SWRdIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQmVFbmFibGVkID0gISEocGFyZW50T2JqICYmICghcGFyZW50T2JqLmxheWVyIHx8IGFjdGl2ZU9iaklkc1twYXJlbnRPYmouaWRdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhc3BpcmluZ0luc3RhbmNlc1tvYmoubGF5ZXJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNwaXJpbmdJbnN0YW5jZXNbb2JqLmxheWVyXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9CZUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBpbnN0YW5jZSB3YW50cyB0byBiZSBlbmFibGVkIChpcyBzdGFydGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byBhc3BpcmluZ0luc3RhbmNlczpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzcGlyaW5nSW5zdGFuY2VzW29iai5sYXllcl0ucHVzaCh7IG9iaiwgaW5zdGFuY2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgaW5zdGFuY2UgZG9lc24ndCB3YW50IHRvIGJlIGVuYWJsZWQgKGlzIGVuZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGFzcGlyaW5nSW5zdGFuY2VzOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXNwaXJpbmdJbnN0YW5jZXNbbGF5ZXJdID0gXy5yZWplY3QoYXNwaXJpbmdJbnN0YW5jZXNbbGF5ZXJdIHx8IFtdLCAobykgPT4gby5vYmouaWQgPT09IG9iai5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRXZhbHVhdGUgdGhlIGxheWVyIHRvIGRldGVybWluZSB3aG8gaGFzIHRoZSB0aHJvbmU6XG4gICAgICAgICAgICAgICAgICAgIGFzcGlyaW5nSW5zdGFuY2VzW2xheWVyXS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hvIHRha2VzIHByZWNlZGVuY2U6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCwgc29ydCB1c2luZyBwcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChhLm9iai5wcmlvcml0eSB8fCAwKSA8IChiLm9iai5wcmlvcml0eSB8fCAwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYS5vYmoucHJpb3JpdHkgfHwgMCkgPiAoYi5vYmoucHJpb3JpdHkgfHwgMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiwgc29ydCB1c2luZyB0aGUgc3RhcnQgdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChhLmluc3RhbmNlLnN0YXJ0IHx8IDApIDwgKGIuaW5zdGFuY2Uuc3RhcnQgfHwgMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGEuaW5zdGFuY2Uuc3RhcnQgfHwgMCkgPiAoYi5pbnN0YW5jZS5zdGFydCB8fCAwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMYXN0IHJlc29ydDogc29ydCB1c2luZyBpZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhLm9iai5pZCA+IGIub2JqLmlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEub2JqLmlkIDwgYi5vYmouaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3csIHRoZSBvbmUgb24gdG9wIGhhcyB0aGUgdGhyb25lXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjdXJyZW50IHN0YXRlOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50T25Ub3BPZkxheWVyID0gYXNwaXJpbmdJbnN0YW5jZXNbbGF5ZXJdWzBdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2T2JqID0gY3VycmVudFN0YXRlW2xheWVyXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZU9sZE9iaiA9IGN1cnJlbnRPblRvcE9mTGF5ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghcHJldk9iaiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZPYmouaWQgIT09IGN1cnJlbnRPblRvcE9mTGF5ZXIub2JqLmlkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldk9iai5pbnN0YW5jZS5pZCAhPT0gY3VycmVudE9uVG9wT2ZMYXllci5pbnN0YW5jZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZU9sZE9iaiA9ICFjdXJyZW50T25Ub3BPZkxheWVyICYmIHByZXZPYmo7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlT2xkT2JqIHx8IHJlbW92ZU9sZE9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYXAgdGhlIG9sZCBpbnN0YW5jZSwgc28gaXQnbGwgZW5kIGF0IHRoaXMgcG9pbnQgaW4gdGltZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgbGliXzEuc2V0SW5zdGFuY2VFbmRUaW1lKShwcmV2T2JqLmluc3RhbmNlLCB0aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYWN0aXZlT2JqSWRzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhY3RpdmVPYmpJZHNbcHJldk9iai5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIG5leHRFdmVudHM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRTdGF0ZXMubmV4dEV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZW51bXNfMS5FdmVudFR5cGUuRU5ELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpJZDogcHJldk9iai5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudE9iamVjdFRpbWVzW2luc3RhbmNlLmVuZCArICcnXSA9IGVudW1zXzEuRXZlbnRUeXBlLkVORDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwbGFjZU9sZE9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBuZXcgb2JqZWN0IHRvIFN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgYSBuZXcgb2JqZWN0IGNsb25lOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld09iajtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFN0YXRlcy5vYmplY3RzW2N1cnJlbnRPblRvcE9mTGF5ZXIub2JqLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgYWxyZWFkeSBleGlzdGluZyBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdPYmogPSByZXNvbHZlZFN0YXRlcy5vYmplY3RzW2N1cnJlbnRPblRvcE9mTGF5ZXIub2JqLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld09iaiA9IF8uY2xvbmUoY3VycmVudE9uVG9wT2ZMYXllci5vYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld09iai5jb250ZW50ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShuZXdPYmouY29udGVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld09iai5yZXNvbHZlZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKG5ld09iai5yZXNvbHZlZCB8fCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgY29tbW9uXzEuYWRkT2JqZWN0VG9SZXNvbHZlZFRpbWVsaW5lKShyZXNvbHZlZFN0YXRlcywgbmV3T2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0luc3RhbmNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN1cnJlbnRPblRvcE9mTGF5ZXIuaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgc2V0dGluZyBuZXcgc3RhcnQgJiBlbmQgdGltZXMgc28gdGhleSBtYXRjaCB1cCB3aXRoIHRoZSBzdGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogdGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUluc3RhbmNlSWQ6IGN1cnJlbnRPblRvcE9mTGF5ZXIuaW5zdGFuY2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbmQ6IGN1cnJlbnRPblRvcE9mTGF5ZXIuaW5zdGFuY2Uub3JpZ2luYWxFbmQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnRPblRvcE9mTGF5ZXIuaW5zdGFuY2Uub3JpZ2luYWxFbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50T25Ub3BPZkxheWVyLmluc3RhbmNlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0OiBjdXJyZW50T25Ub3BPZkxheWVyLmluc3RhbmNlLm9yaWdpbmFsU3RhcnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnRPblRvcE9mTGF5ZXIuaW5zdGFuY2Uub3JpZ2luYWxTdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGN1cnJlbnRPblRvcE9mTGF5ZXIuaW5zdGFuY2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgaW5zdGFuY2UgaWQgdW5pcXVlOlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdPYmoucmVzb2x2ZWQuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld09iai5yZXNvbHZlZC5pbnN0YW5jZXNbaV0uaWQgPT09IG5ld0luc3RhbmNlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luc3RhbmNlLmlkID0gbmV3SW5zdGFuY2UuaWQgKyAnXyQnICsgbmV3T2JqLnJlc29sdmVkLmluc3RhbmNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3T2JqLnJlc29sdmVkLmluc3RhbmNlcy5wdXNoKG5ld0luc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld09iakluc3RhbmNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm5ld09iaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogbmV3SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSB0byBjdXJyZW50IHN0YXRlOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlW2xheWVyXSA9IG5ld09iakluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGFjdGl2ZU9iaklkczpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZU9iaklkc1tuZXdPYmpJbnN0YW5jZS5pZF0gPSBuZXdPYmpJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byBuZXh0RXZlbnRzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRTdGF0ZXMubmV4dEV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBlbnVtc18xLkV2ZW50VHlwZS5TVEFSVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBuZXdJbnN0YW5jZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpJZDogb2JqLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudE9iamVjdFRpbWVzW25ld0luc3RhbmNlLnN0YXJ0ICsgJyddID0gZW51bXNfMS5FdmVudFR5cGUuU1RBUlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZW1vdmVPbGRPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGN1cnJlbnQgc3RhdGU6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY3VycmVudFN0YXRlW2xheWVyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHNvIG1ha2Ugc3VyZSBhbnkgY2hpbGRyZW4gYXJlIHVwZGF0ZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHbyB0aHJvdWdoIHRoZSBvYmplY3Qgb24gaGFuZCwgYnV0IGFsc28gdGhlIG9uZSBpbiB0aGUgY3VycmVudFN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRzVG9DaGVjayA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5pc0dyb3VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHNUb0NoZWNrLnB1c2gob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2MgPSBjdXJyZW50U3RhdGVbbGF5ZXJdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaXNHcm91cClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzVG9DaGVjay5wdXNoKGN1cnJlbnRTdGF0ZVtsYXllcl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXJlbnQgb2YgcGFyZW50c1RvQ2hlY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9kID0gcGFyZW50LmNoaWxkcmVuKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQwIG9mIHBhcmVudC5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSByZXNvbHZlZC5vYmplY3RzW2NoaWxkMC5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGNoaWxkLnJlc29sdmVkLmluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGFydCA8PSB0aW1lICYmICgoX2UgPSBpbnN0YW5jZS5lbmQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IEluZmluaXR5KSA+IHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjaGlsZCBpbnN0YW5jZSwgYmVjYXVzZSB0aGF0IG1pZ2h0IGJlIGFmZmVjdGVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRQb2ludEluVGltZSh0aW1lLCAnY2hpbGQnLCA5OSwgY2hpbGQsIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElzIGEga2V5ZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ZnJhbWUgPSBvYmo7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBrZXlmcmFtZSB0byByZXNvbHZlZFN0YXRlcy5vYmplY3RzOlxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFN0YXRlcy5vYmplY3RzW2tleWZyYW1lLmlkXSA9IGtleWZyYW1lO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b0JlRW5hYmxlZCA9IChpbnN0YW5jZS5zdGFydCB8fCAwKSA8PSB0aW1lICYmICgoX2YgPSBpbnN0YW5jZS5lbmQpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IEluZmluaXR5KSA+IHRpbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b0JlRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3T2JqSW5zdGFuY2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ua2V5ZnJhbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUtleWZyYW1lc1trZXlmcmFtZS5pZF0gPSBuZXdPYmpJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhY3RpdmVLZXlmcmFtZXNba2V5ZnJhbWUuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFjdGl2ZUtleWZyYW1lc0NoZWNrZWRba2V5ZnJhbWUuaWRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEdvIHRocm91Z2gga2V5ZnJhbWVzOlxuICAgICAgICBjb25zdCBhY3RpdmVLZXlmcmFtZXNPYmpJZHMgPSBPYmplY3Qua2V5cyhhY3RpdmVLZXlmcmFtZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGl2ZUtleWZyYW1lc09iaklkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgb2JqSWQgPSBhY3RpdmVLZXlmcmFtZXNPYmpJZHNbaV07XG4gICAgICAgICAgICBjb25zdCBvYmpJbnN0YW5jZSA9IGFjdGl2ZUtleWZyYW1lc1tvYmpJZF07XG4gICAgICAgICAgICBjb25zdCBrZXlmcmFtZSA9IG9iakluc3RhbmNlO1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBvYmpJbnN0YW5jZS5pbnN0YW5jZTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBrZXlmcmFtZSdzIHBhcmVudCBpcyBjdXJyZW50bHkgYWN0aXZlP1xuICAgICAgICAgICAgaWYgKGtleWZyYW1lLnJlc29sdmVkLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50T2JqID0gYWN0aXZlT2JqSWRzW2tleWZyYW1lLnJlc29sdmVkLnBhcmVudElkXTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50T2JqICYmIHBhcmVudE9iai5sYXllcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBrZXlmcmFtZSBpcyBvbiBhbiBhY3RpdmUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE9iakluc3RhbmNlID0gY3VycmVudFN0YXRlW3BhcmVudE9iai5sYXllcl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRPYmpJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhY3RpdmVLZXlmcmFtZXNDaGVja2VkW29iaklkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhc24ndCBzdGFydGVkIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUtleWZyYW1lc0NoZWNrZWRbb2JqSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBUaGUga2V5ZnJhbWVzIGFyZSBhIGxpdHRsZSBiaXQgc3BlY2lhbCwgc2luY2UgdGhlaXIgY29udGVudHMgYXJlIGFwcGxpZWQgdG8gdGhlaXIgcGFyZW50cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGF0IGFwcGxpY2F0aW9uIGlzIGRvbmUgaW4gdGhlIGdldFN0YXRlQXRUaW1lIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBrZXlmcmFtZSB0byBuZXh0RXZlbnRzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleWZyYW1lRXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBlbnVtc18xLkV2ZW50VHlwZS5LRVlGUkFNRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogaW5zdGFuY2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaklkOiBrZXlmcmFtZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYXAgZW5kIHdpdGhpbiBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2VFbmQgPSBNYXRoLm1pbigoX2cgPSBpbnN0YW5jZS5lbmQpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IEluZmluaXR5LCAoX2ggPSBwYXJlbnRPYmpJbnN0YW5jZS5pbnN0YW5jZS5lbmQpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IEluZmluaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2VFbmQgPT09IEluZmluaXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUVuZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlRW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleWZyYW1lRXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZW51bXNfMS5FdmVudFR5cGUuS0VZRlJBTUUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBpbnN0YW5jZUVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaklkOiBrZXlmcmFtZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlOiB0aGUga2V5ZnJhbWU6cyBwYXJlbnQgaXNuJ3QgYWN0aXZlLCByZW1vdmUvc3RvcCB0aGUga2V5ZnJhbWUgdGhlbjpcbiAgICAgICAgICAgIGRlbGV0ZSBhY3RpdmVLZXlmcmFtZXNDaGVja2VkW29iaklkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgaW5zdGFuY2VzIG9mIGFsbCBvYmplY3RzIChleGNsdWRpbmcga2V5ZnJhbWVzKSBhcmUgcHJvcGVybHkgY2FsY3VsYXRlZCxcbiAgICAvLyB0YWtpbmcgaW50byBhY2NvdW50IHByaW9yaXRpZXMsIGNsYXNoZXMgZXRjLlxuICAgIC8vIENhcCBjaGlsZHJlbiBpbnNpZGUgdGhlaXIgcGFyZW50czpcbiAgICB7XG4gICAgICAgIGNvbnN0IGFsbENoaWxkcmVuID0gT2JqZWN0LnZhbHVlcyhyZXNvbHZlZFN0YXRlcy5vYmplY3RzKVxuICAgICAgICAgICAgLmZpbHRlcigob2JqKSA9PiAhIW9iai5yZXNvbHZlZC5wYXJlbnRJZClcbiAgICAgICAgICAgIC8vIFNvcnQsIHNvIHRoYXQgdGhlIG91dGVybW9zdCBhcmUgaGFuZGxlZCBmaXJzdDpcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuICgoX2EgPSBhLnJlc29sdmVkLmxldmVsRGVlcCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgLSAoKF9iID0gYi5yZXNvbHZlZC5sZXZlbERlZXApICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBvYmogb2YgYWxsQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChvYmoucmVzb2x2ZWQucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSByZXNvbHZlZFN0YXRlcy5vYmplY3RzW29iai5yZXNvbHZlZC5wYXJlbnRJZF07XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBvYmoucmVzb2x2ZWQuaW5zdGFuY2VzID0gKDAsIGxpYl8xLmNsZWFuSW5zdGFuY2VzKSgoMCwgbGliXzEuY2FwSW5zdGFuY2VzKShvYmoucmVzb2x2ZWQuaW5zdGFuY2VzLCBwYXJlbnQucmVzb2x2ZWQuaW5zdGFuY2VzKSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXQgdGhpcyBwb2ludCwgYWxsIGluc3RhbmNlcyBvZiB0aGUgb2JqZWN0cyBzaG91bGQgYmUgcHJvcGVybHkgY2FsY3VsYXRlZC5cbiAgICAvLyBHbyB0aHJvdWdoIGFsbCBpbnN0YW5jZXMgb2YgYWxsIG9iamVjdHMgdG8gY3JlYXRlIHRlbXBvcmFyeSBzdGF0ZXMgb2YgYWxsIGxheWVycyBhbmQgdGltZXM6XG4gICAge1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBPYmplY3Qua2V5cyhyZXNvbHZlZFN0YXRlcy5vYmplY3RzKSkge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0gcmVzb2x2ZWRTdGF0ZXMub2JqZWN0c1tpZF07XG4gICAgICAgICAgICBjb25zdCBsYXllciA9IGAke29iai5sYXllcn1gO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZXNbbGF5ZXJdKVxuICAgICAgICAgICAgICAgIHN0YXRlc1tsYXllcl0gPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlTGF5ZXIgPSBzdGF0ZXNbbGF5ZXJdO1xuICAgICAgICAgICAgaWYgKCFvYmoucmVzb2x2ZWQuaXNLZXlmcmFtZSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2Ygb2JqLnJlc29sdmVkLmluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBpbnN0YW5jZS5zdGFydCArICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlTGF5ZXJbc3RhcnRUaW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVMYXllcltzdGFydFRpbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q291bnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ291bnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0SW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld09iakluc3RhbmNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ub2JqLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZUxheWVyW3N0YXJ0VGltZV0uc3RhcnRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZUxheWVyW3N0YXJ0VGltZV0ub2JqZWN0SW5zdGFuY2UgPSBuZXdPYmpJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmVuZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kVGltZSA9IGluc3RhbmNlLmVuZCArICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZUxheWVyW2VuZFRpbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVMYXllcltlbmRUaW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDb3VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ291bnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdEluc3RhbmNlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUxheWVyW2VuZFRpbWVdLmVuZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gR28gdGhyb3VnaCB0aGUgdGVtcG9yYXJ5IHN0YXRlcyBhbmQgYXBwbHkgdGhlIGNoYW5nZXMgdG8gdGhlIHJlc29sdmVkU3RhdGVzLnN0YXRlOlxuICAgICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIE9iamVjdC5rZXlzKHN0YXRlcykpIHtcbiAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgY29uc3QgdGltZXMgPSBPYmplY3Qua2V5cyhzdGF0ZXNbbGF5ZXJdKVxuICAgICAgICAgICAgICAgIC5tYXAoKHRpbWUpID0+IHBhcnNlRmxvYXQodGltZSkpXG4gICAgICAgICAgICAgICAgLy8gU29ydCBjaHJvbm9sb2dpY2FsbHk6XG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lID0gdGltZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IHN0YXRlc1tsYXllcl1bYCR7dGltZX1gXTtcbiAgICAgICAgICAgICAgICBzdW0gKz0gcy5zdGFydENvdW50O1xuICAgICAgICAgICAgICAgIHN1bSAtPSBzLmVuZENvdW50O1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBmYXRhbCBidWdzOlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzdW0gaXMgbGFyZ2VyIHRoYW4gb25lLCBtb3JlIHRoYW4gb25lIHN0YXJ0IHdhcyBmb3VuZCBhdCB0aGUgc2FtZSB0aW1lLCB3aGljaCBzaG91bGQgbm90IGJlIHBvc3NpYmxlLlxuICAgICAgICAgICAgICAgIGlmIChzdW0gPiAxKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvbyBtYW55IHN0YXJ0IGV2ZW50cyBhdCAke2xheWVyfSAke3RpbWV9OiAke3N1bX1gKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc3VtIGlzIGxlc3MgdGhhbiB6ZXJvLCB0aGVyZSBoYXZlIGJlZW4gbW9yZSBlbmRzIHRoYW4gc3RhcnRzLCB3aGljaCBzaG91bGQgbm90IGJlIHBvc3NpYmxlLlxuICAgICAgICAgICAgICAgIGlmIChzdW0gPCAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvbyBtYW55IGVuZCBldmVudHMgYXQgJHtsYXllcn0gJHt0aW1lfTogJHtzdW19YCk7XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgdGhlIHN0YXRlOlxuICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZWRTdGF0ZXMuc3RhdGVbbGF5ZXJdKVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFN0YXRlcy5zdGF0ZVtsYXllcl0gPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoc3VtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgb2JqZWN0IGhhcyBzdGFydGVkXG4gICAgICAgICAgICAgICAgICAgIGlmICghcy5vYmplY3RJbnN0YW5jZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb2JqZWN0SW5zdGFuY2Ugbm90IHNldCwgZXZlbnQgdGhvdWdoIHN1bT0ke3N1bX0gYXQgJHtsYXllcn0gJHt0aW1lfWApO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFN0YXRlcy5zdGF0ZVtsYXllcl1bdGltZV0gPSBbcy5vYmplY3RJbnN0YW5jZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgdGhlIG9iamVjdCBoYXMgZW5kZWRcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRTdGF0ZXMuc3RhdGVbbGF5ZXJdW3RpbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FwIGtleWZyYW1lcyBpbnNpZGUgdGhlaXIgcGFyZW50czpcbiAgICBmb3IgKGNvbnN0IGlkIG9mIE9iamVjdC5rZXlzKHJlc29sdmVkU3RhdGVzLm9iamVjdHMpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGtleWZyYW1lID0gcmVzb2x2ZWRTdGF0ZXMub2JqZWN0c1tpZF07XG4gICAgICAgICAgICBpZiAoa2V5ZnJhbWUucmVzb2x2ZWQuaXNLZXlmcmFtZSAmJiBrZXlmcmFtZS5yZXNvbHZlZC5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHJlc29sdmVkU3RhdGVzLm9iamVjdHNba2V5ZnJhbWUucmVzb2x2ZWQucGFyZW50SWRdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FwIHRoZSBrZXlmcmFtZSBpbnN0YW5jZXMgd2l0aGluIGl0cyBwYXJlbnRzIGluc3RhbmNlczpcbiAgICAgICAgICAgICAgICAgICAga2V5ZnJhbWUucmVzb2x2ZWQuaW5zdGFuY2VzID0gKDAsIGxpYl8xLmNhcEluc3RhbmNlcykoa2V5ZnJhbWUucmVzb2x2ZWQuaW5zdGFuY2VzLCBwYXJlbnQucmVzb2x2ZWQuaW5zdGFuY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHN1cmUgdGhlIGluc3RhbmNlcyBhcmUgaW4gdGhlIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5ZnJhbWUucmVzb2x2ZWQuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGtleWZyYW1lLnJlc29sdmVkLmluc3RhbmNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleWZyYW1lSW5zdGFuY2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ua2V5ZnJhbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzS2V5ZnJhbWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ZnJhbWVFbmRUaW1lOiBpbnN0YW5jZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGtleWZyYW1lIHRvIHRoZSB0cmFja2luZyBzdGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEtleWZyYW1lQXRUaW1lKHJlc29sdmVkU3RhdGVzLnN0YXRlLCBwYXJlbnQubGF5ZXIgKyAnJywgaW5zdGFuY2Uuc3RhcnQsIGtleWZyYW1lSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZpeCAobWVyZ2UpIGluc3RhbmNlcyBvZiBzZWFtbGVzcyBvYmplY3RzOlxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvYmogPSByZXNvbHZlZFN0YXRlcy5vYmplY3RzW2lkXTtcbiAgICAgICAgICAgIGlmIChvYmouc2VhbWxlc3MgJiYgb2JqLnJlc29sdmVkLmluc3RhbmNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgb2JqLnJlc29sdmVkLmluc3RhbmNlcyA9ICgwLCBsaWJfMS5jbGVhbkluc3RhbmNlcykob2JqLnJlc29sdmVkLmluc3RhbmNlcywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIEFMTCBpbnN0YW5jZXMgYXJlIHByb3Blcmx5IGNhbGN1bGF0ZWQuXG4gICAgLy8gR28gdGhyb3VnaCB0aGUga2V5ZnJhbWUgZXZlbnRzIGFuZCBhZGQgdGhlbSB0byBuZXh0RXZlbnRzOlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5ZnJhbWVFdmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ZnJhbWVFdmVudCA9IGtleWZyYW1lRXZlbnRzW2ldO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgaWYgKGV2ZW50T2JqZWN0VGltZXNba2V5ZnJhbWVFdmVudC50aW1lICsgJyddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gcHV0IGEga2V5ZnJhbWUgZXZlbnQgaWYgdGhlcmUncyBhbHJlYWR5IGFub3RoZXIgZXZlbnQgdGhlcmVcbiAgICAgICAgICAgIHJlc29sdmVkU3RhdGVzLm5leHRFdmVudHMucHVzaChrZXlmcmFtZUV2ZW50KTtcbiAgICAgICAgICAgIGV2ZW50T2JqZWN0VGltZXNba2V5ZnJhbWVFdmVudC50aW1lICsgJyddID0gZW51bXNfMS5FdmVudFR5cGUuS0VZRlJBTUU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzb2x2ZWRTdGF0ZXMubmV4dEV2ZW50cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGlmIChhLnRpbWUgPiBiLnRpbWUpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEudGltZSA8IGIudGltZSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEudHlwZSA+IGIudHlwZSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEudHlwZSA8IGIudHlwZSlcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoYS5vYmpJZCA8IGIub2JqSWQpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhLm9iaklkID4gYi5vYmpJZClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgY2FjaGUucmVzb2x2ZWRTdGF0ZXMgPSByZXNvbHZlZFN0YXRlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmVkU3RhdGVzO1xufVxuZXhwb3J0cy5yZXNvbHZlU3RhdGVzID0gcmVzb2x2ZVN0YXRlcztcbmZ1bmN0aW9uIGFwcGx5S2V5ZnJhbWVDb250ZW50KHBhcmVudENvbnRlbnQsIGtleWZyYW1lQ29udGVudCkge1xuICAgIGZvciAoY29uc3QgW2F0dHIsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhrZXlmcmFtZUNvbnRlbnQpKSB7XG4gICAgICAgIGlmIChfLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIV8uaXNBcnJheShwYXJlbnRDb250ZW50W2F0dHJdKSlcbiAgICAgICAgICAgICAgICBwYXJlbnRDb250ZW50W2F0dHJdID0gW107XG4gICAgICAgICAgICBhcHBseUtleWZyYW1lQ29udGVudChwYXJlbnRDb250ZW50W2F0dHJdLCB2YWx1ZSk7XG4gICAgICAgICAgICBwYXJlbnRDb250ZW50W2F0dHJdLnNwbGljZSh2YWx1ZS5sZW5ndGgsIDk5OTk5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCFfLmlzT2JqZWN0KHBhcmVudENvbnRlbnRbYXR0cl0pIHx8IF8uaXNBcnJheShwYXJlbnRDb250ZW50W2F0dHJdKSlcbiAgICAgICAgICAgICAgICBwYXJlbnRDb250ZW50W2F0dHJdID0ge307XG4gICAgICAgICAgICBhcHBseUtleWZyYW1lQ29udGVudChwYXJlbnRDb250ZW50W2F0dHJdLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnRDb250ZW50W2F0dHJdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmFwcGx5S2V5ZnJhbWVDb250ZW50ID0gYXBwbHlLZXlmcmFtZUNvbnRlbnQ7XG5mdW5jdGlvbiBnZXRUaW1lc0Zyb21QYXJlbnRzKHJlc29sdmVkLCBvYmopIHtcbiAgICBsZXQgdGltZXMgPSBbXTtcbiAgICBjb25zdCBwYXJlbnRPYmogPSBvYmoucmVzb2x2ZWQucGFyZW50SWQgPyByZXNvbHZlZC5vYmplY3RzW29iai5yZXNvbHZlZC5wYXJlbnRJZF0gOiBudWxsO1xuICAgIGlmIChwYXJlbnRPYmogJiYgcGFyZW50T2JqLnJlc29sdmVkLnJlc29sdmVkKSB7XG4gICAgICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgcGFyZW50T2JqLnJlc29sdmVkLmluc3RhbmNlcykge1xuICAgICAgICAgICAgdGltZXMucHVzaCh7IHRpbWU6IGluc3RhbmNlLnN0YXJ0LCBlbmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuZW5kKVxuICAgICAgICAgICAgICAgIHRpbWVzLnB1c2goeyB0aW1lOiBpbnN0YW5jZS5lbmQsIGVuYWJsZTogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGltZXMgPSB0aW1lcy5jb25jYXQoZ2V0VGltZXNGcm9tUGFyZW50cyhyZXNvbHZlZCwgcGFyZW50T2JqKSk7XG4gICAgfVxuICAgIHJldHVybiB0aW1lcztcbn1cbmZ1bmN0aW9uIGFkZEtleWZyYW1lQXRUaW1lKHN0YXRlcywgbGF5ZXIsIHRpbWUsIG9iakluc3RhbmNlS2YpIHtcbiAgICBpZiAoIXN0YXRlc1tsYXllcl0pXG4gICAgICAgIHN0YXRlc1tsYXllcl0gPSB7fTtcbiAgICBjb25zdCBpbm5lciA9IHN0YXRlc1tsYXllcl1bdGltZSArICcnXTtcbiAgICBpZiAoIWlubmVyKSB7XG4gICAgICAgIHN0YXRlc1tsYXllcl1bdGltZSArICcnXSA9IFtvYmpJbnN0YW5jZUtmXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlubmVyLnB1c2gob2JqSW5zdGFuY2VLZik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U3RhdGVBdFRpbWUoc3RhdGVzLCBsYXllciwgcmVxdWVzdFRpbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbGF5ZXJTdGF0ZXMgPSBzdGF0ZXNbbGF5ZXJdIHx8IHt9O1xuICAgIGNvbnN0IHRpbWVzID0gT2JqZWN0LmtleXMobGF5ZXJTdGF0ZXMpXG4gICAgICAgIC5tYXAoKHRpbWUpID0+IHBhcnNlRmxvYXQodGltZSkpXG4gICAgICAgIC8vIFNvcnQgY2hyb25vbG9naWNhbGx5OlxuICAgICAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgfSk7XG4gICAgbGV0IHN0YXRlID0gbnVsbDtcbiAgICBsZXQgaXNDbG9uZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSB0aW1lc1tpXTtcbiAgICAgICAgaWYgKHRpbWUgPD0gcmVxdWVzdFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZUluc3RhbmNlcyA9IGxheWVyU3RhdGVzW3RpbWUgKyAnJ107XG4gICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlSW5zdGFuY2VzICYmIGN1cnJlbnRTdGF0ZUluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlmcmFtZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRTdGF0ZUluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBjdXJyZW50U3RhdGVJbnN0YW5jZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgJiYgY3VycmVudFN0YXRlLmlzS2V5ZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleWZyYW1lcy5wdXNoKGN1cnJlbnRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IGN1cnJlbnRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2xvbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ZnJhbWUgPSBrZXlmcmFtZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZSAmJiBrZXlmcmFtZS5yZXNvbHZlZC5wYXJlbnRJZCA9PT0gc3RhdGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKF9hID0ga2V5ZnJhbWUua2V5ZnJhbWVFbmRUaW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBJbmZpbml0eSkgPiByZXF1ZXN0VGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNDbG9uZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDbG9uZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzdGF0ZS5jb250ZW50KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBrZXlmcmFtZSBvbiB0aGUgc3RhdGU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlLZXlmcmFtZUNvbnRlbnQoc3RhdGUuY29udGVudCwga2V5ZnJhbWUuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaXNDbG9uZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIGlzUmVzb2x2ZWRTdGF0ZXMocmVzb2x2ZWQpIHtcbiAgICByZXR1cm4gISEocmVzb2x2ZWQgJiYgdHlwZW9mIHJlc29sdmVkID09PSAnb2JqZWN0JyAmJiByZXNvbHZlZC5vYmplY3RzICYmIHJlc29sdmVkLnN0YXRlICYmIHJlc29sdmVkLm5leHRFdmVudHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlS2V5ZnJhbWUgPSBleHBvcnRzLnZhbGlkYXRlT2JqZWN0ID0gZXhwb3J0cy52YWxpZGF0ZVRpbWVsaW5lID0gdm9pZCAwO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuZnVuY3Rpb24gdmFsaWRhdGVPYmplY3QwKG9iaiwgc3RyaWN0LCB1bmlxdWVJZHMpIHtcbiAgICBpZiAoIXVuaXF1ZUlkcylcbiAgICAgICAgdW5pcXVlSWRzID0ge307XG4gICAgaWYgKCFvYmopXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IGlzIHVuZGVmaW5lZGApO1xuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgaXMgbm90IGFuIG9iamVjdGApO1xuICAgIGlmICghb2JqLmlkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBtaXNzaW5nIFwiaWRcIiBhdHRyaWJ1dGVgKTtcbiAgICBpZiAodHlwZW9mIG9iai5pZCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IFwiaWRcIiBhdHRyaWJ1dGUgaXMgbm90IGEgc3RyaW5nOiBcIiR7b2JqLmlkfVwiYCk7XG4gICAgaWYgKHVuaXF1ZUlkc1tvYmouaWRdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBpZCBcIiR7b2JqLmlkfVwiIGlzIG5vdCB1bmlxdWVgKTtcbiAgICB1bmlxdWVJZHNbb2JqLmlkXSA9IHRydWU7XG4gICAgaWYgKG9iai5sYXllciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBcIiR7b2JqLmlkfVwiOiBcImxheWVyXCIgYXR0cmlidXRlIGlzIHVuZGVmaW5lZGApO1xuICAgIGlmICghb2JqLmNvbnRlbnQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IFwiJHtvYmouaWR9XCI6IFwiY29udGVudFwiIGF0dHJpYnV0ZSBtdXN0IGJlIHNldGApO1xuICAgIGlmICghb2JqLmVuYWJsZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgXCIke29iai5pZH1cIjogXCJlbmFibGVcIiBhdHRyaWJ1dGUgbXVzdCBiZSBzZXRgKTtcbiAgICBjb25zdCBlbmFibGVzID0gXy5pc0FycmF5KG9iai5lbmFibGUpID8gb2JqLmVuYWJsZSA6IFtvYmouZW5hYmxlXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZW5hYmxlID0gZW5hYmxlc1tpXTtcbiAgICAgICAgaWYgKGVuYWJsZS5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGVuYWJsZS53aGlsZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IFwiJHtvYmouaWR9XCI6IFwiZW5hYmxlLnN0YXJ0XCIgYW5kIFwiZW5hYmxlLndoaWxlXCIgY2Fubm90IGJlIGNvbWJpbmVkYCk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGVuYWJsZS5lbmQgIT09IHVuZGVmaW5lZCAmJiBlbmFibGUuZHVyYXRpb24gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBcIiR7b2JqLmlkfVwiOiBcImVuYWJsZS5lbmRcIiBhbmQgXCJlbmFibGUuZHVyYXRpb25cIiBjYW5ub3QgYmUgY29tYmluZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbmFibGUud2hpbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBlbmFibGUuZW5kICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgXCIke29iai5pZH1cIjogXCJlbmFibGUud2hpbGVcIiBhbmQgXCJlbmFibGUuZW5kXCIgY2Fubm90IGJlIGNvbWJpbmVkYCk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGVuYWJsZS5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IFwiJHtvYmouaWR9XCI6IFwiZW5hYmxlLndoaWxlXCIgYW5kIFwiZW5hYmxlLmR1cmF0aW9uXCIgY2Fubm90IGJlIGNvbWJpbmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgXCIke29iai5pZH1cIjogXCJlbmFibGUuc3RhcnRcIiBvciBcImVuYWJsZS53aGlsZVwiIG11c3QgYmUgc2V0YCk7XG4gICAgfVxuICAgIGlmIChvYmoua2V5ZnJhbWVzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ZnJhbWUgPSBvYmoua2V5ZnJhbWVzW2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUtleWZyYW1lMChrZXlmcmFtZSwgc3RyaWN0LCB1bmlxdWVJZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBcIiR7b2JqLmlkfVwiIGtleWZyYW1lWyR7aX1dOiAke2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iai5jbGFzc2VzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IG9iai5jbGFzc2VzW2ldO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSAmJiB0eXBlb2YgY2xhc3NOYW1lICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBcIiR7b2JqLmlkfVwiOiBcImNsYXNzZXNbJHtpfV1cIiBpcyBub3QgYSBzdHJpbmdgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2JqLmNoaWxkcmVuICYmICFvYmouaXNHcm91cClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgXCIke29iai5pZH1cIjogYXR0cmlidXRlIFwiY2hpbGRyZW5cIiBpcyBzZXQgYnV0IFwiaXNHcm91cFwiIGlzIG5vdGApO1xuICAgIGlmIChvYmouaXNHcm91cCAmJiAhb2JqLmNoaWxkcmVuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBcIiR7b2JqLmlkfVwiOiBhdHRyaWJ1dGUgXCJpc0dyb3VwXCIgaXMgc2V0IGJ1dCBcImNoaWxkcmVuXCIgbWlzc2luZ2ApO1xuICAgIGlmIChvYmouY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmouY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gb2JqLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZU9iamVjdDAoY2hpbGQsIHN0cmljdCwgdW5pcXVlSWRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgXCIke29iai5pZH1cIiBjaGlsZFske2l9XTogJHtlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvYmoucHJpb3JpdHkgIT09IHVuZGVmaW5lZCAmJiAhXy5pc051bWJlcihvYmoucHJpb3JpdHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBcIiR7b2JqLmlkfVwiOiBhdHRyaWJ1dGUgXCJwcmlvcml0eVwiIGlzIG5vdCBhIG51bWJlcmApO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVLZXlmcmFtZTAoa2V5ZnJhbWUsIHN0cmljdCwgdW5pcXVlSWRzKSB7XG4gICAgaWYgKCF1bmlxdWVJZHMpXG4gICAgICAgIHVuaXF1ZUlkcyA9IHt9O1xuICAgIGlmICgha2V5ZnJhbWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ZnJhbWUgaXMgdW5kZWZpbmVkYCk7XG4gICAgaWYgKHR5cGVvZiBrZXlmcmFtZSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ZnJhbWUgaXMgbm90IGFuIG9iamVjdGApO1xuICAgIGlmICgha2V5ZnJhbWUuaWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ZnJhbWUgbWlzc2luZyBpZCBhdHRyaWJ1dGVgKTtcbiAgICBpZiAodHlwZW9mIGtleWZyYW1lLmlkICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXlmcmFtZSBpZCBhdHRyaWJ1dGUgaXMgbm90IGEgc3RyaW5nOiBcIiR7a2V5ZnJhbWUuaWR9XCJgKTtcbiAgICBpZiAodW5pcXVlSWRzW2tleWZyYW1lLmlkXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXlmcmFtZSBpZCBcIiR7a2V5ZnJhbWUuaWR9XCIgaXMgbm90IHVuaXF1ZWApO1xuICAgIHVuaXF1ZUlkc1trZXlmcmFtZS5pZF0gPSB0cnVlO1xuICAgIGlmICgha2V5ZnJhbWUuY29udGVudClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXlmcmFtZSBcIiR7a2V5ZnJhbWUuaWR9XCI6IFwiY29udGVudFwiIGF0dHJpYnV0ZSBtdXN0IGJlIHNldGApO1xuICAgIGlmICgha2V5ZnJhbWUuZW5hYmxlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleWZyYW1lIFwiJHtrZXlmcmFtZS5pZH1cIjogXCJlbmFibGVcIiBhdHRyaWJ1dGUgbXVzdCBiZSBzZXRgKTtcbiAgICBjb25zdCBlbmFibGVzID0gXy5pc0FycmF5KGtleWZyYW1lLmVuYWJsZSkgPyBrZXlmcmFtZS5lbmFibGUgOiBba2V5ZnJhbWUuZW5hYmxlXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZW5hYmxlID0gZW5hYmxlc1tpXTtcbiAgICAgICAgaWYgKGVuYWJsZS5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGVuYWJsZS53aGlsZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ZnJhbWUgXCIke2tleWZyYW1lLmlkfVwiOiBcImVuYWJsZS5zdGFydFwiIGFuZCBcImVuYWJsZS53aGlsZVwiIGNhbm5vdCBiZSBjb21iaW5lZGApO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBlbmFibGUuZW5kICE9PSB1bmRlZmluZWQgJiYgZW5hYmxlLmR1cmF0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXlmcmFtZSBcIiR7a2V5ZnJhbWUuaWR9XCI6IFwiZW5hYmxlLmVuZFwiIGFuZCBcImVuYWJsZS5kdXJhdGlvblwiIGNhbm5vdCBiZSBjb21iaW5lZGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVuYWJsZS53aGlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGVuYWJsZS5lbmQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleWZyYW1lIFwiJHtrZXlmcmFtZS5pZH1cIjogXCJlbmFibGUud2hpbGVcIiBhbmQgXCJlbmFibGUuZW5kXCIgY2Fubm90IGJlIGNvbWJpbmVkYCk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGVuYWJsZS5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ZnJhbWUgXCIke2tleWZyYW1lLmlkfVwiOiBcImVuYWJsZS53aGlsZVwiIGFuZCBcImVuYWJsZS5kdXJhdGlvblwiIGNhbm5vdCBiZSBjb21iaW5lZGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ZnJhbWUgXCIke2tleWZyYW1lLmlkfVwiOiBcImVuYWJsZS5zdGFydFwiIG9yIFwiZW5hYmxlLndoaWxlXCIgbXVzdCBiZSBzZXRgKTtcbiAgICB9XG4gICAgaWYgKGtleWZyYW1lLmNsYXNzZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlmcmFtZS5jbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBrZXlmcmFtZS5jbGFzc2VzW2ldO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSAmJiAhXy5pc1N0cmluZyhjbGFzc05hbWUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ZnJhbWUgXCIke2tleWZyYW1lLmlkfVwiOiBcImNsYXNzZXNbJHtpfV1cIiBpcyBub3QgYSBzdHJpbmdgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIGFsbCBvYmplY3RzIGluIHRoZSB0aW1lbGluZS4gVGhyb3dzIGFuIGVycm9yIGlmIHNvbWV0aGluZydzIHdyb25nXG4gKiBAcGFyYW0gdGltZWxpbmUgVGhlIHRpbWVsaW5lIHRvIHZhbGlkYXRlXG4gKiBAcGFyYW0gc3RyaWN0IFNldCB0byB0cnVlIHRvIGVuYWJsZSBzb21lIHN0cmljdCBydWxlcyAocnVsZXMgdGhhdCBjYW4gcG9zc2libHkgYmUgaWdub3JlZClcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVUaW1lbGluZSh0aW1lbGluZSwgc3RyaWN0KSB7XG4gICAgY29uc3QgdW5pcXVlSWRzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvYmogPSB0aW1lbGluZVtpXTtcbiAgICAgICAgdmFsaWRhdGVPYmplY3QwKG9iaiwgc3RyaWN0LCB1bmlxdWVJZHMpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUaW1lbGluZSA9IHZhbGlkYXRlVGltZWxpbmU7XG4vKipcbiAqIFZhbGlkYXRlcyBhIFRpbWVsaW5lLW9iamVjdC4gVGhyb3dzIGFuIGVycm9yIGlmIHNvbWV0aGluZydzIHdyb25nXG4gKiBAcGFyYW0gdGltZWxpbmUgVGhlIHRpbWVsaW5lIHRvIHZhbGlkYXRlXG4gKiBAcGFyYW0gc3RyaWN0IFNldCB0byB0cnVlIHRvIGVuYWJsZSBzb21lIHN0cmljdCBydWxlcyAocnVsZXMgdGhhdCBjYW4gcG9zc2libHkgYmUgaWdub3JlZClcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqLCBzdHJpY3QpIHtcbiAgICB2YWxpZGF0ZU9iamVjdDAob2JqLCBzdHJpY3QpO1xufVxuZXhwb3J0cy52YWxpZGF0ZU9iamVjdCA9IHZhbGlkYXRlT2JqZWN0O1xuLyoqXG4gKiBWYWxpZGF0ZXMgYSBUaW1lbGluZS1rZXlmcmFtZS4gVGhyb3dzIGFuIGVycm9yIGlmIHNvbWV0aGluZydzIHdyb25nXG4gKiBAcGFyYW0gdGltZWxpbmUgVGhlIHRpbWVsaW5lIHRvIHZhbGlkYXRlXG4gKiBAcGFyYW0gc3RyaWN0IFNldCB0byB0cnVlIHRvIGVuYWJsZSBzb21lIHN0cmljdCBydWxlcyAocnVsZXMgdGhhdCBjYW4gcG9zc2libHkgYmUgaWdub3JlZClcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVLZXlmcmFtZShrZXlmcmFtZSwgc3RyaWN0KSB7XG4gICAgdmFsaWRhdGVLZXlmcmFtZTAoa2V5ZnJhbWUsIHN0cmljdCk7XG59XG5leHBvcnRzLnZhbGlkYXRlS2V5ZnJhbWUgPSB2YWxpZGF0ZUtleWZyYW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGUuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBnbG9iYWwsIGRlZmluZSwgU3lzdGVtLCBSZWZsZWN0LCBQcm9taXNlICovXHJcbnZhciBfX2V4dGVuZHM7XHJcbnZhciBfX2Fzc2lnbjtcclxudmFyIF9fcmVzdDtcclxudmFyIF9fZGVjb3JhdGU7XHJcbnZhciBfX3BhcmFtO1xyXG52YXIgX19tZXRhZGF0YTtcclxudmFyIF9fYXdhaXRlcjtcclxudmFyIF9fZ2VuZXJhdG9yO1xyXG52YXIgX19leHBvcnRTdGFyO1xyXG52YXIgX192YWx1ZXM7XHJcbnZhciBfX3JlYWQ7XHJcbnZhciBfX3NwcmVhZDtcclxudmFyIF9fc3ByZWFkQXJyYXlzO1xyXG52YXIgX19zcHJlYWRBcnJheTtcclxudmFyIF9fYXdhaXQ7XHJcbnZhciBfX2FzeW5jR2VuZXJhdG9yO1xyXG52YXIgX19hc3luY0RlbGVnYXRvcjtcclxudmFyIF9fYXN5bmNWYWx1ZXM7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdDtcclxudmFyIF9faW1wb3J0U3RhcjtcclxudmFyIF9faW1wb3J0RGVmYXVsdDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQ7XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEluO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nO1xyXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHR5cGVvZiB0aGlzID09PSBcIm9iamVjdFwiID8gdGhpcyA6IHt9O1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFwidHNsaWJcIiwgW1wiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKGV4cG9ydHMpIHsgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihleHBvcnRzKSkpOyB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihtb2R1bGUuZXhwb3J0cykpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cywgcHJldmlvdXMpIHtcclxuICAgICAgICBpZiAoZXhwb3J0cyAhPT0gcm9vdCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGlkLCB2KSB7IHJldHVybiBleHBvcnRzW2lkXSA9IHByZXZpb3VzID8gcHJldmlvdXMoaWQsIHYpIDogdjsgfTtcclxuICAgIH1cclxufSlcclxuKGZ1bmN0aW9uIChleHBvcnRlcikge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3Jlc3QgPSBmdW5jdGlvbiAocywgZSkge1xyXG4gICAgICAgIHZhciB0ID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZGVjb3JhdGUgPSBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgICAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3BhcmFtID0gZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdGVyID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZ2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgICAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgX19leHBvcnRTdGFyID0gZnVuY3Rpb24obSwgbykge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxuICAgIH07XHJcblxyXG4gICAgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xyXG4gICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgICAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbiAgICB9KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICAgICAgb1trMl0gPSBtW2tdO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX192YWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICAgICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICAgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVhZCA9IGZ1bmN0aW9uIChvLCBuKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICAgICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIEBkZXByZWNhdGVkICovXHJcbiAgICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIEBkZXByZWNhdGVkICovXHJcbiAgICBfX3NwcmVhZEFycmF5cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fc3ByZWFkQXJyYXkgPSBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcclxuICAgICAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2F3YWl0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNEZWxlZ2F0b3IgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBpLCBwO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jVmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgICAgICByZXR1cm4gY29va2VkO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG4gICAgfSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2ltcG9ydFN0YXIgPSBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgX19pbXBvcnREZWZhdWx0ID0gZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgICAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgICAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICAgICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRJbiA9IGZ1bmN0aW9uIChzdGF0ZSwgcmVjZWl2ZXIpIHtcclxuICAgICAgICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgKHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlICdpbicgb3BlcmF0b3Igb24gbm9uLW9iamVjdFwiKTtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRlcihcIl9fZXh0ZW5kc1wiLCBfX2V4dGVuZHMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2Fzc2lnblwiLCBfX2Fzc2lnbik7XHJcbiAgICBleHBvcnRlcihcIl9fcmVzdFwiLCBfX3Jlc3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2RlY29yYXRlXCIsIF9fZGVjb3JhdGUpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3BhcmFtXCIsIF9fcGFyYW0pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX21ldGFkYXRhXCIsIF9fbWV0YWRhdGEpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2F3YWl0ZXJcIiwgX19hd2FpdGVyKTtcclxuICAgIGV4cG9ydGVyKFwiX19nZW5lcmF0b3JcIiwgX19nZW5lcmF0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2V4cG9ydFN0YXJcIiwgX19leHBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX19jcmVhdGVCaW5kaW5nXCIsIF9fY3JlYXRlQmluZGluZyk7XHJcbiAgICBleHBvcnRlcihcIl9fdmFsdWVzXCIsIF9fdmFsdWVzKTtcclxuICAgIGV4cG9ydGVyKFwiX19yZWFkXCIsIF9fcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkXCIsIF9fc3ByZWFkKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheXNcIiwgX19zcHJlYWRBcnJheXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZEFycmF5XCIsIF9fc3ByZWFkQXJyYXkpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2F3YWl0XCIsIF9fYXdhaXQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jR2VuZXJhdG9yXCIsIF9fYXN5bmNHZW5lcmF0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jRGVsZWdhdG9yXCIsIF9fYXN5bmNEZWxlZ2F0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jVmFsdWVzXCIsIF9fYXN5bmNWYWx1ZXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX21ha2VUZW1wbGF0ZU9iamVjdFwiLCBfX21ha2VUZW1wbGF0ZU9iamVjdCk7XHJcbiAgICBleHBvcnRlcihcIl9faW1wb3J0U3RhclwiLCBfX2ltcG9ydFN0YXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2ltcG9ydERlZmF1bHRcIiwgX19pbXBvcnREZWZhdWx0KTtcclxuICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZEdldFwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KTtcclxuICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZFNldFwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KTtcclxuICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZEluXCIsIF9fY2xhc3NQcml2YXRlRmllbGRJbik7XHJcbn0pO1xyXG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuLyogZ2xvYmFsIGdsb2JhbCwgZGVmaW5lLCBTeXN0ZW0sIFJlZmxlY3QsIFByb21pc2UgKi9cclxudmFyIF9fZXh0ZW5kcztcclxudmFyIF9fYXNzaWduO1xyXG52YXIgX19yZXN0O1xyXG52YXIgX19kZWNvcmF0ZTtcclxudmFyIF9fcGFyYW07XHJcbnZhciBfX21ldGFkYXRhO1xyXG52YXIgX19hd2FpdGVyO1xyXG52YXIgX19nZW5lcmF0b3I7XHJcbnZhciBfX2V4cG9ydFN0YXI7XHJcbnZhciBfX3ZhbHVlcztcclxudmFyIF9fcmVhZDtcclxudmFyIF9fc3ByZWFkO1xyXG52YXIgX19zcHJlYWRBcnJheXM7XHJcbnZhciBfX2F3YWl0O1xyXG52YXIgX19hc3luY0dlbmVyYXRvcjtcclxudmFyIF9fYXN5bmNEZWxlZ2F0b3I7XHJcbnZhciBfX2FzeW5jVmFsdWVzO1xyXG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3Q7XHJcbnZhciBfX2ltcG9ydFN0YXI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQ7XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldDtcclxudmFyIF9fY3JlYXRlQmluZGluZztcclxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICB2YXIgcm9vdCA9IHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiA/IHRoaXMgOiB7fTtcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShcInRzbGliXCIsIFtcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChleHBvcnRzKSB7IGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cykpKTsgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIobW9kdWxlLmV4cG9ydHMpKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMsIHByZXZpb3VzKSB7XHJcbiAgICAgICAgaWYgKGV4cG9ydHMgIT09IHJvb3QpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgdikgeyByZXR1cm4gZXhwb3J0c1tpZF0gPSBwcmV2aW91cyA/IHByZXZpb3VzKGlkLCB2KSA6IHY7IH07XHJcbiAgICB9XHJcbn0pXHJcbihmdW5jdGlvbiAoZXhwb3J0ZXIpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19yZXN0ID0gZnVuY3Rpb24gKHMsIGUpIHtcclxuICAgICAgICB2YXIgdCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgICAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2RlY29yYXRlID0gZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxuICAgIH07XHJcblxyXG4gICAgX19wYXJhbSA9IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19tZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXRlciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgICAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY3JlYXRlQmluZGluZyA9IGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgICAgICBvW2syXSA9IG1ba107XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZXhwb3J0U3RhciA9IGZ1bmN0aW9uIChtLCBleHBvcnRzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgICAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgICAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIH07XHJcblxyXG4gICAgX19yZWFkID0gZnVuY3Rpb24gKG8sIG4pIHtcclxuICAgICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICAgICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgICAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgX19zcHJlYWRBcnJheXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2F3YWl0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNEZWxlZ2F0b3IgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBpLCBwO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jVmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgICAgICByZXR1cm4gY29va2VkO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2ltcG9ydFN0YXIgPSBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgICAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9faW1wb3J0RGVmYXVsdCA9IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgICAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xyXG4gICAgICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gZnVuY3Rpb24gKHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcml2YXRlTWFwLnNldChyZWNlaXZlciwgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0ZXIoXCJfX2V4dGVuZHNcIiwgX19leHRlbmRzKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3NpZ25cIiwgX19hc3NpZ24pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3Jlc3RcIiwgX19yZXN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19kZWNvcmF0ZVwiLCBfX2RlY29yYXRlKTtcclxuICAgIGV4cG9ydGVyKFwiX19wYXJhbVwiLCBfX3BhcmFtKTtcclxuICAgIGV4cG9ydGVyKFwiX19tZXRhZGF0YVwiLCBfX21ldGFkYXRhKTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdGVyXCIsIF9fYXdhaXRlcik7XHJcbiAgICBleHBvcnRlcihcIl9fZ2VuZXJhdG9yXCIsIF9fZ2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19leHBvcnRTdGFyXCIsIF9fZXhwb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9fY3JlYXRlQmluZGluZ1wiLCBfX2NyZWF0ZUJpbmRpbmcpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3ZhbHVlc1wiLCBfX3ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlzXCIsIF9fc3ByZWFkQXJyYXlzKTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdFwiLCBfX2F3YWl0KTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0dlbmVyYXRvclwiLCBfX2FzeW5jR2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0RlbGVnYXRvclwiLCBfX2FzeW5jRGVsZWdhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY1ZhbHVlc1wiLCBfX2FzeW5jVmFsdWVzKTtcclxuICAgIGV4cG9ydGVyKFwiX19tYWtlVGVtcGxhdGVPYmplY3RcIiwgX19tYWtlVGVtcGxhdGVPYmplY3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2ltcG9ydFN0YXJcIiwgX19pbXBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX19pbXBvcnREZWZhdWx0XCIsIF9faW1wb3J0RGVmYXVsdCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRHZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRTZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZFNldCk7XHJcbn0pO1xyXG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgndW5kZXJzY29yZScsIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudCA9IGdsb2JhbC5fO1xuICAgIHZhciBleHBvcnRzID0gZ2xvYmFsLl8gPSBmYWN0b3J5KCk7XG4gICAgZXhwb3J0cy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkgeyBnbG9iYWwuXyA9IGN1cnJlbnQ7IHJldHVybiBleHBvcnRzOyB9O1xuICB9KCkpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHtcbiAgLy8gICAgIFVuZGVyc2NvcmUuanMgMS4xMy40XG4gIC8vICAgICBodHRwczovL3VuZGVyc2NvcmVqcy5vcmdcbiAgLy8gICAgIChjKSAyMDA5LTIwMjIgSmVyZW15IEFzaGtlbmFzLCBKdWxpYW4gR29uZ2dyaWpwLCBhbmQgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gIC8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbi5cbiAgdmFyIFZFUlNJT04gPSAnMS4xMy40JztcblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCAoYHNlbGZgKSBpbiB0aGUgYnJvd3NlciwgYGdsb2JhbGBcbiAgLy8gb24gdGhlIHNlcnZlciwgb3IgYHRoaXNgIGluIHNvbWUgdmlydHVhbCBtYWNoaW5lcy4gV2UgdXNlIGBzZWxmYFxuICAvLyBpbnN0ZWFkIG9mIGB3aW5kb3dgIGZvciBgV2ViV29ya2VyYCBzdXBwb3J0LlxuICB2YXIgcm9vdCA9ICh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGYgJiYgc2VsZikgfHxcbiAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbC5nbG9iYWwgPT09IGdsb2JhbCAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpIHx8XG4gICAgICAgICAgICB7fTtcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgU3ltYm9sUHJvdG8gPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbC5wcm90b3R5cGUgOiBudWxsO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXIgcHVzaCA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICAgIHNsaWNlID0gQXJyYXlQcm90by5zbGljZSxcbiAgICAgIHRvU3RyaW5nID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIE1vZGVybiBmZWF0dXJlIGRldGVjdGlvbi5cbiAgdmFyIHN1cHBvcnRzQXJyYXlCdWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnLFxuICAgICAgc3VwcG9ydHNEYXRhVmlldyA9IHR5cGVvZiBEYXRhVmlldyAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KyoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyIG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5LFxuICAgICAgbmF0aXZlS2V5cyA9IE9iamVjdC5rZXlzLFxuICAgICAgbmF0aXZlQ3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgICAgIG5hdGl2ZUlzVmlldyA9IHN1cHBvcnRzQXJyYXlCdWZmZXIgJiYgQXJyYXlCdWZmZXIuaXNWaWV3O1xuXG4gIC8vIENyZWF0ZSByZWZlcmVuY2VzIHRvIHRoZXNlIGJ1aWx0aW4gZnVuY3Rpb25zIGJlY2F1c2Ugd2Ugb3ZlcnJpZGUgdGhlbS5cbiAgdmFyIF9pc05hTiA9IGlzTmFOLFxuICAgICAgX2lzRmluaXRlID0gaXNGaW5pdGU7XG5cbiAgLy8gS2V5cyBpbiBJRSA8IDkgdGhhdCB3b24ndCBiZSBpdGVyYXRlZCBieSBgZm9yIGtleSBpbiAuLi5gIGFuZCB0aHVzIG1pc3NlZC5cbiAgdmFyIGhhc0VudW1CdWcgPSAhe3RvU3RyaW5nOiBudWxsfS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKTtcbiAgdmFyIG5vbkVudW1lcmFibGVQcm9wcyA9IFsndmFsdWVPZicsICdpc1Byb3RvdHlwZU9mJywgJ3RvU3RyaW5nJyxcbiAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLCAnaGFzT3duUHJvcGVydHknLCAndG9Mb2NhbGVTdHJpbmcnXTtcblxuICAvLyBUaGUgbGFyZ2VzdCBpbnRlZ2VyIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGV4YWN0bHkuXG4gIHZhciBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG4gIC8vIFNvbWUgZnVuY3Rpb25zIHRha2UgYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzLCBvciBhIGZldyBleHBlY3RlZFxuICAvLyBhcmd1bWVudHMgYXQgdGhlIGJlZ2lubmluZyBhbmQgdGhlbiBhIHZhcmlhYmxlIG51bWJlciBvZiB2YWx1ZXMgdG8gb3BlcmF0ZVxuICAvLyBvbi4gVGhpcyBoZWxwZXIgYWNjdW11bGF0ZXMgYWxsIHJlbWFpbmluZyBhcmd1bWVudHMgcGFzdCB0aGUgZnVuY3Rpb27igJlzXG4gIC8vIGFyZ3VtZW50IGxlbmd0aCAob3IgYW4gZXhwbGljaXQgYHN0YXJ0SW5kZXhgKSwgaW50byBhbiBhcnJheSB0aGF0IGJlY29tZXNcbiAgLy8gdGhlIGxhc3QgYXJndW1lbnQuIFNpbWlsYXIgdG8gRVM24oCZcyBcInJlc3QgcGFyYW1ldGVyXCIuXG4gIGZ1bmN0aW9uIHJlc3RBcmd1bWVudHMoZnVuYywgc3RhcnRJbmRleCkge1xuICAgIHN0YXJ0SW5kZXggPSBzdGFydEluZGV4ID09IG51bGwgPyBmdW5jLmxlbmd0aCAtIDEgOiArc3RhcnRJbmRleDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoYXJndW1lbnRzLmxlbmd0aCAtIHN0YXJ0SW5kZXgsIDApLFxuICAgICAgICAgIHJlc3QgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICByZXN0W2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCArIHN0YXJ0SW5kZXhdO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChzdGFydEluZGV4KSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCByZXN0KTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3VtZW50c1swXSwgcmVzdCk7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgcmVzdCk7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IEFycmF5KHN0YXJ0SW5kZXggKyAxKTtcbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHN0YXJ0SW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgfVxuICAgICAgYXJnc1tzdGFydEluZGV4XSA9IHJlc3Q7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmopO1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBmdW5jdGlvbiBpc051bGwob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkP1xuICBmdW5jdGlvbiBpc1VuZGVmaW5lZChvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgZnVuY3Rpb24gaXNCb29sZWFuKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgZnVuY3Rpb24gaXNFbGVtZW50KG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbiAgfVxuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIGB0b1N0cmluZ2AtYmFzZWQgdHlwZSB0ZXN0ZXIuXG4gIGZ1bmN0aW9uIHRhZ1Rlc3RlcihuYW1lKSB7XG4gICAgdmFyIHRhZyA9ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IHRhZztcbiAgICB9O1xuICB9XG5cbiAgdmFyIGlzU3RyaW5nID0gdGFnVGVzdGVyKCdTdHJpbmcnKTtcblxuICB2YXIgaXNOdW1iZXIgPSB0YWdUZXN0ZXIoJ051bWJlcicpO1xuXG4gIHZhciBpc0RhdGUgPSB0YWdUZXN0ZXIoJ0RhdGUnKTtcblxuICB2YXIgaXNSZWdFeHAgPSB0YWdUZXN0ZXIoJ1JlZ0V4cCcpO1xuXG4gIHZhciBpc0Vycm9yID0gdGFnVGVzdGVyKCdFcnJvcicpO1xuXG4gIHZhciBpc1N5bWJvbCA9IHRhZ1Rlc3RlcignU3ltYm9sJyk7XG5cbiAgdmFyIGlzQXJyYXlCdWZmZXIgPSB0YWdUZXN0ZXIoJ0FycmF5QnVmZmVyJyk7XG5cbiAgdmFyIGlzRnVuY3Rpb24gPSB0YWdUZXN0ZXIoJ0Z1bmN0aW9uJyk7XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLiBXb3JrIGFyb3VuZCBzb21lIGB0eXBlb2ZgIGJ1Z3MgaW4gb2xkXG4gIC8vIHY4LCBJRSAxMSAoIzE2MjEpLCBTYWZhcmkgOCAoIzE5MjkpLCBhbmQgUGhhbnRvbUpTICgjMjIzNikuXG4gIHZhciBub2RlbGlzdCA9IHJvb3QuZG9jdW1lbnQgJiYgcm9vdC5kb2N1bWVudC5jaGlsZE5vZGVzO1xuICBpZiAodHlwZW9mIC8uLyAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiBJbnQ4QXJyYXkgIT0gJ29iamVjdCcgJiYgdHlwZW9mIG5vZGVsaXN0ICE9ICdmdW5jdGlvbicpIHtcbiAgICBpc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICB2YXIgaXNGdW5jdGlvbiQxID0gaXNGdW5jdGlvbjtcblxuICB2YXIgaGFzT2JqZWN0VGFnID0gdGFnVGVzdGVyKCdPYmplY3QnKTtcblxuICAvLyBJbiBJRSAxMCAtIEVkZ2UgMTMsIGBEYXRhVmlld2AgaGFzIHN0cmluZyB0YWcgYCdbb2JqZWN0IE9iamVjdF0nYC5cbiAgLy8gSW4gSUUgMTEsIHRoZSBtb3N0IGNvbW1vbiBhbW9uZyB0aGVtLCB0aGlzIHByb2JsZW0gYWxzbyBhcHBsaWVzIHRvXG4gIC8vIGBNYXBgLCBgV2Vha01hcGAgYW5kIGBTZXRgLlxuICB2YXIgaGFzU3RyaW5nVGFnQnVnID0gKFxuICAgICAgICBzdXBwb3J0c0RhdGFWaWV3ICYmIGhhc09iamVjdFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDgpKSlcbiAgICAgICksXG4gICAgICBpc0lFMTEgPSAodHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaGFzT2JqZWN0VGFnKG5ldyBNYXApKTtcblxuICB2YXIgaXNEYXRhVmlldyA9IHRhZ1Rlc3RlcignRGF0YVZpZXcnKTtcblxuICAvLyBJbiBJRSAxMCAtIEVkZ2UgMTMsIHdlIG5lZWQgYSBkaWZmZXJlbnQgaGV1cmlzdGljXG4gIC8vIHRvIGRldGVybWluZSB3aGV0aGVyIGFuIG9iamVjdCBpcyBhIGBEYXRhVmlld2AuXG4gIGZ1bmN0aW9uIGllMTBJc0RhdGFWaWV3KG9iaikge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBpc0Z1bmN0aW9uJDEob2JqLmdldEludDgpICYmIGlzQXJyYXlCdWZmZXIob2JqLmJ1ZmZlcik7XG4gIH1cblxuICB2YXIgaXNEYXRhVmlldyQxID0gKGhhc1N0cmluZ1RhZ0J1ZyA/IGllMTBJc0RhdGFWaWV3IDogaXNEYXRhVmlldyk7XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIGBBcnJheS5pc0FycmF5YC5cbiAgdmFyIGlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IHRhZ1Rlc3RlcignQXJyYXknKTtcblxuICAvLyBJbnRlcm5hbCBmdW5jdGlvbiB0byBjaGVjayB3aGV0aGVyIGBrZXlgIGlzIGFuIG93biBwcm9wZXJ0eSBuYW1lIG9mIGBvYmpgLlxuICBmdW5jdGlvbiBoYXMkMShvYmosIGtleSkge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgfVxuXG4gIHZhciBpc0FyZ3VtZW50cyA9IHRhZ1Rlc3RlcignQXJndW1lbnRzJyk7XG5cbiAgLy8gRGVmaW5lIGEgZmFsbGJhY2sgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGluIGJyb3dzZXJzIChhaGVtLCBJRSA8IDkpLCB3aGVyZVxuICAvLyB0aGVyZSBpc24ndCBhbnkgaW5zcGVjdGFibGUgXCJBcmd1bWVudHNcIiB0eXBlLlxuICAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgICBpc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gaGFzJDEob2JqLCAnY2FsbGVlJyk7XG4gICAgICB9O1xuICAgIH1cbiAgfSgpKTtcblxuICB2YXIgaXNBcmd1bWVudHMkMSA9IGlzQXJndW1lbnRzO1xuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgZnVuY3Rpb24gaXNGaW5pdGUkMShvYmopIHtcbiAgICByZXR1cm4gIWlzU3ltYm9sKG9iaikgJiYgX2lzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH1cblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/XG4gIGZ1bmN0aW9uIGlzTmFOJDEob2JqKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKG9iaikgJiYgX2lzTmFOKG9iaik7XG4gIH1cblxuICAvLyBQcmVkaWNhdGUtZ2VuZXJhdGluZyBmdW5jdGlvbi4gT2Z0ZW4gdXNlZnVsIG91dHNpZGUgb2YgVW5kZXJzY29yZS5cbiAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIC8vIENvbW1vbiBpbnRlcm5hbCBsb2dpYyBmb3IgYGlzQXJyYXlMaWtlYCBhbmQgYGlzQnVmZmVyTGlrZWAuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNpemVQcm9wZXJ0eUNoZWNrKGdldFNpemVQcm9wZXJ0eSkge1xuICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgc2l6ZVByb3BlcnR5ID0gZ2V0U2l6ZVByb3BlcnR5KGNvbGxlY3Rpb24pO1xuICAgICAgcmV0dXJuIHR5cGVvZiBzaXplUHJvcGVydHkgPT0gJ251bWJlcicgJiYgc2l6ZVByb3BlcnR5ID49IDAgJiYgc2l6ZVByb3BlcnR5IDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgICB9XG4gIH1cblxuICAvLyBJbnRlcm5hbCBoZWxwZXIgdG8gZ2VuZXJhdGUgYSBmdW5jdGlvbiB0byBvYnRhaW4gcHJvcGVydHkgYGtleWAgZnJvbSBgb2JqYC5cbiAgZnVuY3Rpb24gc2hhbGxvd1Byb3BlcnR5KGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9ialtrZXldO1xuICAgIH07XG4gIH1cblxuICAvLyBJbnRlcm5hbCBoZWxwZXIgdG8gb2J0YWluIHRoZSBgYnl0ZUxlbmd0aGAgcHJvcGVydHkgb2YgYW4gb2JqZWN0LlxuICB2YXIgZ2V0Qnl0ZUxlbmd0aCA9IHNoYWxsb3dQcm9wZXJ0eSgnYnl0ZUxlbmd0aCcpO1xuXG4gIC8vIEludGVybmFsIGhlbHBlciB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSBzaG91bGQgc3BlbmQgZXh0ZW5zaXZlIGNoZWNrcyBhZ2FpbnN0XG4gIC8vIGBBcnJheUJ1ZmZlcmAgZXQgYWwuXG4gIHZhciBpc0J1ZmZlckxpa2UgPSBjcmVhdGVTaXplUHJvcGVydHlDaGVjayhnZXRCeXRlTGVuZ3RoKTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgdHlwZWQgYXJyYXk/XG4gIHZhciB0eXBlZEFycmF5UGF0dGVybiA9IC9cXFtvYmplY3QgKChJfFVpKW50KDh8MTZ8MzIpfEZsb2F0KDMyfDY0KXxVaW50OENsYW1wZWR8QmlnKEl8VWkpbnQ2NClBcnJheVxcXS87XG4gIGZ1bmN0aW9uIGlzVHlwZWRBcnJheShvYmopIHtcbiAgICAvLyBgQXJyYXlCdWZmZXIuaXNWaWV3YCBpcyB0aGUgbW9zdCBmdXR1cmUtcHJvb2YsIHNvIHVzZSBpdCB3aGVuIGF2YWlsYWJsZS5cbiAgICAvLyBPdGhlcndpc2UsIGZhbGwgYmFjayBvbiB0aGUgYWJvdmUgcmVndWxhciBleHByZXNzaW9uLlxuICAgIHJldHVybiBuYXRpdmVJc1ZpZXcgPyAobmF0aXZlSXNWaWV3KG9iaikgJiYgIWlzRGF0YVZpZXckMShvYmopKSA6XG4gICAgICAgICAgICAgICAgICBpc0J1ZmZlckxpa2Uob2JqKSAmJiB0eXBlZEFycmF5UGF0dGVybi50ZXN0KHRvU3RyaW5nLmNhbGwob2JqKSk7XG4gIH1cblxuICB2YXIgaXNUeXBlZEFycmF5JDEgPSBzdXBwb3J0c0FycmF5QnVmZmVyID8gaXNUeXBlZEFycmF5IDogY29uc3RhbnQoZmFsc2UpO1xuXG4gIC8vIEludGVybmFsIGhlbHBlciB0byBvYnRhaW4gdGhlIGBsZW5ndGhgIHByb3BlcnR5IG9mIGFuIG9iamVjdC5cbiAgdmFyIGdldExlbmd0aCA9IHNoYWxsb3dQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbiAgLy8gSW50ZXJuYWwgaGVscGVyIHRvIGNyZWF0ZSBhIHNpbXBsZSBsb29rdXAgc3RydWN0dXJlLlxuICAvLyBgY29sbGVjdE5vbkVudW1Qcm9wc2AgdXNlZCB0byBkZXBlbmQgb24gYF8uY29udGFpbnNgLCBidXQgdGhpcyBsZWQgdG9cbiAgLy8gY2lyY3VsYXIgaW1wb3J0cy4gYGVtdWxhdGVkU2V0YCBpcyBhIG9uZS1vZmYgc29sdXRpb24gdGhhdCBvbmx5IHdvcmtzIGZvclxuICAvLyBhcnJheXMgb2Ygc3RyaW5ncy5cbiAgZnVuY3Rpb24gZW11bGF0ZWRTZXQoa2V5cykge1xuICAgIHZhciBoYXNoID0ge307XG4gICAgZm9yICh2YXIgbCA9IGtleXMubGVuZ3RoLCBpID0gMDsgaSA8IGw7ICsraSkgaGFzaFtrZXlzW2ldXSA9IHRydWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRhaW5zOiBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGhhc2hba2V5XSA9PT0gdHJ1ZTsgfSxcbiAgICAgIHB1c2g6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBoYXNoW2tleV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4ga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIEludGVybmFsIGhlbHBlci4gQ2hlY2tzIGBrZXlzYCBmb3IgdGhlIHByZXNlbmNlIG9mIGtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3RcbiAgLy8gYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuIEV4dGVuZHMgYGtleXNgIGluIHBsYWNlIGlmXG4gIC8vIG5lZWRlZC5cbiAgZnVuY3Rpb24gY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpIHtcbiAgICBrZXlzID0gZW11bGF0ZWRTZXQoa2V5cyk7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAoaXNGdW5jdGlvbiQxKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChoYXMkMShvYmosIHByb3ApICYmICFrZXlzLmNvbnRhaW5zKHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIWtleXMuY29udGFpbnMocHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYC5cbiAgZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICBpZiAobmF0aXZlS2V5cykgcmV0dXJuIG5hdGl2ZUtleXMob2JqKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChoYXMkMShvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBTa2lwIHRoZSBtb3JlIGV4cGVuc2l2ZSBgdG9TdHJpbmdgLWJhc2VkIHR5cGUgY2hlY2tzIGlmIGBvYmpgIGhhcyBub1xuICAgIC8vIGAubGVuZ3RoYC5cbiAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKG9iaik7XG4gICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgKFxuICAgICAgaXNBcnJheShvYmopIHx8IGlzU3RyaW5nKG9iaikgfHwgaXNBcmd1bWVudHMkMShvYmopXG4gICAgKSkgcmV0dXJuIGxlbmd0aCA9PT0gMDtcbiAgICByZXR1cm4gZ2V0TGVuZ3RoKGtleXMob2JqKSkgPT09IDA7XG4gIH1cblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgZnVuY3Rpb24gaXNNYXRjaChvYmplY3QsIGF0dHJzKSB7XG4gICAgdmFyIF9rZXlzID0ga2V5cyhhdHRycyksIGxlbmd0aCA9IF9rZXlzLmxlbmd0aDtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xuICAgIHZhciBvYmogPSBPYmplY3Qob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gX2tleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0IGNhblxuICAvLyBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgZnVuY3Rpb25zIGFkZGVkXG4gIC8vIHRocm91Z2ggYF8ubWl4aW5gLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG4gIGZ1bmN0aW9uIF8kMShvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXyQxKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfJDEpKSByZXR1cm4gbmV3IF8kMShvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH1cblxuICBfJDEuVkVSU0lPTiA9IFZFUlNJT047XG5cbiAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXG4gIF8kMS5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveGllcyBmb3Igc29tZSBtZXRob2RzIHVzZWQgaW4gZW5naW5lIG9wZXJhdGlvbnNcbiAgLy8gc3VjaCBhcyBhcml0aG1ldGljIGFuZCBKU09OIHN0cmluZ2lmaWNhdGlvbi5cbiAgXyQxLnByb3RvdHlwZS52YWx1ZU9mID0gXyQxLnByb3RvdHlwZS50b0pTT04gPSBfJDEucHJvdG90eXBlLnZhbHVlO1xuXG4gIF8kMS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gU3RyaW5nKHRoaXMuX3dyYXBwZWQpO1xuICB9O1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRvIHdyYXAgb3Igc2hhbGxvdy1jb3B5IGFuIEFycmF5QnVmZmVyLFxuICAvLyB0eXBlZCBhcnJheSBvciBEYXRhVmlldyB0byBhIG5ldyB2aWV3LCByZXVzaW5nIHRoZSBidWZmZXIuXG4gIGZ1bmN0aW9uIHRvQnVmZmVyVmlldyhidWZmZXJTb3VyY2UpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICBidWZmZXJTb3VyY2UuYnVmZmVyIHx8IGJ1ZmZlclNvdXJjZSxcbiAgICAgIGJ1ZmZlclNvdXJjZS5ieXRlT2Zmc2V0IHx8IDAsXG4gICAgICBnZXRCeXRlTGVuZ3RoKGJ1ZmZlclNvdXJjZSlcbiAgICApO1xuICB9XG5cbiAgLy8gV2UgdXNlIHRoaXMgc3RyaW5nIHR3aWNlLCBzbyBnaXZlIGl0IGEgbmFtZSBmb3IgbWluaWZpY2F0aW9uLlxuICB2YXIgdGFnRGF0YVZpZXcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgXy5pc0VxdWFsYC5cbiAgZnVuY3Rpb24gZXEoYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHBzOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gYG51bGxgIG9yIGB1bmRlZmluZWRgIG9ubHkgZXF1YWwgdG8gaXRzZWxmIChzdHJpY3QgY29tcGFyaXNvbikuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgIGlmIChhICE9PSBhKSByZXR1cm4gYiAhPT0gYjtcbiAgICAvLyBFeGhhdXN0IHByaW1pdGl2ZSBjaGVja3NcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBhO1xuICAgIGlmICh0eXBlICE9PSAnZnVuY3Rpb24nICYmIHR5cGUgIT09ICdvYmplY3QnICYmIHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGRlZXBFcShhLCBiLCBhU3RhY2ssIGJTdGFjayk7XG4gIH1cblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYF8uaXNFcXVhbGAuXG4gIGZ1bmN0aW9uIGRlZXBFcShhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXyQxKSBhID0gYS5fd3JhcHBlZDtcbiAgICBpZiAoYiBpbnN0YW5jZW9mIF8kMSkgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gV29yayBhcm91bmQgYSBidWcgaW4gSUUgMTAgLSBFZGdlIDEzLlxuICAgIGlmIChoYXNTdHJpbmdUYWdCdWcgJiYgY2xhc3NOYW1lID09ICdbb2JqZWN0IE9iamVjdF0nICYmIGlzRGF0YVZpZXckMShhKSkge1xuICAgICAgaWYgKCFpc0RhdGFWaWV3JDEoYikpIHJldHVybiBmYWxzZTtcbiAgICAgIGNsYXNzTmFtZSA9IHRhZ0RhdGFWaWV3O1xuICAgIH1cbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gVGhlc2UgdHlwZXMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU4uXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgICAgY2FzZSAnW29iamVjdCBTeW1ib2xdJzpcbiAgICAgICAgcmV0dXJuIFN5bWJvbFByb3RvLnZhbHVlT2YuY2FsbChhKSA9PT0gU3ltYm9sUHJvdG8udmFsdWVPZi5jYWxsKGIpO1xuICAgICAgY2FzZSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nOlxuICAgICAgY2FzZSB0YWdEYXRhVmlldzpcbiAgICAgICAgLy8gQ29lcmNlIHRvIHR5cGVkIGFycmF5IHNvIHdlIGNhbiBmYWxsIHRocm91Z2guXG4gICAgICAgIHJldHVybiBkZWVwRXEodG9CdWZmZXJWaWV3KGEpLCB0b0J1ZmZlclZpZXcoYiksIGFTdGFjaywgYlN0YWNrKTtcbiAgICB9XG5cbiAgICB2YXIgYXJlQXJyYXlzID0gY2xhc3NOYW1lID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIGlmICghYXJlQXJyYXlzICYmIGlzVHlwZWRBcnJheSQxKGEpKSB7XG4gICAgICAgIHZhciBieXRlTGVuZ3RoID0gZ2V0Qnl0ZUxlbmd0aChhKTtcbiAgICAgICAgaWYgKGJ5dGVMZW5ndGggIT09IGdldEJ5dGVMZW5ndGgoYikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGEuYnVmZmVyID09PSBiLmJ1ZmZlciAmJiBhLmJ5dGVPZmZzZXQgPT09IGIuYnl0ZU9mZnNldCkgcmV0dXJuIHRydWU7XG4gICAgICAgIGFyZUFycmF5cyA9IHRydWU7XG4gICAgfVxuICAgIGlmICghYXJlQXJyYXlzKSB7XG4gICAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzIG9yIGBBcnJheWBzXG4gICAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvciwgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKGlzRnVuY3Rpb24kMShhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24kMShiQ3RvcikgJiYgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuXG4gICAgLy8gSW5pdGlhbGl6aW5nIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIC8vIEl0J3MgZG9uZSBoZXJlIHNpbmNlIHdlIG9ubHkgbmVlZCB0aGVtIGZvciBvYmplY3RzIGFuZCBhcnJheXMgY29tcGFyaXNvbi5cbiAgICBhU3RhY2sgPSBhU3RhY2sgfHwgW107XG4gICAgYlN0YWNrID0gYlN0YWNrIHx8IFtdO1xuICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG5cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICBpZiAoYXJlQXJyYXlzKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKCFlcShhW2xlbmd0aF0sIGJbbGVuZ3RoXSwgYVN0YWNrLCBiU3RhY2spKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgICAgdmFyIF9rZXlzID0ga2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0gX2tleXMubGVuZ3RoO1xuICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxuICAgICAgaWYgKGtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgICAga2V5ID0gX2tleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoaGFzJDEoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG4gIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiKTtcbiAgfVxuXG4gIC8vIFJldHJpZXZlIGFsbCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIGZ1bmN0aW9uIGFsbEtleXMob2JqKSB7XG4gICAgaWYgKCFpc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfVxuXG4gIC8vIFNpbmNlIHRoZSByZWd1bGFyIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCB0eXBlIHRlc3RzIGRvbid0IHdvcmsgZm9yXG4gIC8vIHNvbWUgdHlwZXMgaW4gSUUgMTEsIHdlIHVzZSBhIGZpbmdlcnByaW50aW5nIGhldXJpc3RpYyBpbnN0ZWFkLCBiYXNlZFxuICAvLyBvbiB0aGUgbWV0aG9kcy4gSXQncyBub3QgZ3JlYXQsIGJ1dCBpdCdzIHRoZSBiZXN0IHdlIGdvdC5cbiAgLy8gVGhlIGZpbmdlcnByaW50IG1ldGhvZCBsaXN0cyBhcmUgZGVmaW5lZCBiZWxvdy5cbiAgZnVuY3Rpb24gaWUxMWZpbmdlcnByaW50KG1ldGhvZHMpIHtcbiAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKG1ldGhvZHMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gYE1hcGAsIGBXZWFrTWFwYCBhbmQgYFNldGAgaGF2ZSBubyBlbnVtZXJhYmxlIGtleXMuXG4gICAgICB2YXIga2V5cyA9IGFsbEtleXMob2JqKTtcbiAgICAgIGlmIChnZXRMZW5ndGgoa2V5cykpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uJDEob2JqW21ldGhvZHNbaV1dKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UgYXJlIHRlc3RpbmcgYWdhaW5zdCBgV2Vha01hcGAsIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXRcbiAgICAgIC8vIGBvYmpgIGRvZXNuJ3QgaGF2ZSBhIGBmb3JFYWNoYCBtZXRob2QgaW4gb3JkZXIgdG8gZGlzdGluZ3Vpc2hcbiAgICAgIC8vIGl0IGZyb20gYSByZWd1bGFyIGBNYXBgLlxuICAgICAgcmV0dXJuIG1ldGhvZHMgIT09IHdlYWtNYXBNZXRob2RzIHx8ICFpc0Z1bmN0aW9uJDEob2JqW2ZvckVhY2hOYW1lXSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEluIHRoZSBpbnRlcmVzdCBvZiBjb21wYWN0IG1pbmlmaWNhdGlvbiwgd2Ugd3JpdGVcbiAgLy8gZWFjaCBzdHJpbmcgaW4gdGhlIGZpbmdlcnByaW50cyBvbmx5IG9uY2UuXG4gIHZhciBmb3JFYWNoTmFtZSA9ICdmb3JFYWNoJyxcbiAgICAgIGhhc05hbWUgPSAnaGFzJyxcbiAgICAgIGNvbW1vbkluaXQgPSBbJ2NsZWFyJywgJ2RlbGV0ZSddLFxuICAgICAgbWFwVGFpbCA9IFsnZ2V0JywgaGFzTmFtZSwgJ3NldCddO1xuXG4gIC8vIGBNYXBgLCBgV2Vha01hcGAgYW5kIGBTZXRgIGVhY2ggaGF2ZSBzbGlnaHRseSBkaWZmZXJlbnRcbiAgLy8gY29tYmluYXRpb25zIG9mIHRoZSBhYm92ZSBzdWJsaXN0cy5cbiAgdmFyIG1hcE1ldGhvZHMgPSBjb21tb25Jbml0LmNvbmNhdChmb3JFYWNoTmFtZSwgbWFwVGFpbCksXG4gICAgICB3ZWFrTWFwTWV0aG9kcyA9IGNvbW1vbkluaXQuY29uY2F0KG1hcFRhaWwpLFxuICAgICAgc2V0TWV0aG9kcyA9IFsnYWRkJ10uY29uY2F0KGNvbW1vbkluaXQsIGZvckVhY2hOYW1lLCBoYXNOYW1lKTtcblxuICB2YXIgaXNNYXAgPSBpc0lFMTEgPyBpZTExZmluZ2VycHJpbnQobWFwTWV0aG9kcykgOiB0YWdUZXN0ZXIoJ01hcCcpO1xuXG4gIHZhciBpc1dlYWtNYXAgPSBpc0lFMTEgPyBpZTExZmluZ2VycHJpbnQod2Vha01hcE1ldGhvZHMpIDogdGFnVGVzdGVyKCdXZWFrTWFwJyk7XG5cbiAgdmFyIGlzU2V0ID0gaXNJRTExID8gaWUxMWZpbmdlcnByaW50KHNldE1ldGhvZHMpIDogdGFnVGVzdGVyKCdTZXQnKTtcblxuICB2YXIgaXNXZWFrU2V0ID0gdGFnVGVzdGVyKCdXZWFrU2V0Jyk7XG5cbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICBmdW5jdGlvbiB2YWx1ZXMob2JqKSB7XG4gICAgdmFyIF9rZXlzID0ga2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBfa2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW19rZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICAvLyBUaGUgb3Bwb3NpdGUgb2YgYF8ub2JqZWN0YCB3aXRoIG9uZSBhcmd1bWVudC5cbiAgZnVuY3Rpb24gcGFpcnMob2JqKSB7XG4gICAgdmFyIF9rZXlzID0ga2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBfa2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtfa2V5c1tpXSwgb2JqW19rZXlzW2ldXV07XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbiAgfVxuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgZnVuY3Rpb24gaW52ZXJ0KG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgX2tleXMgPSBrZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IF9rZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW19rZXlzW2ldXV0gPSBfa2V5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uJDEob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH1cblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYXNzaWduZXIgZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihrZXlzRnVuYywgZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChkZWZhdWx0cykgb2JqID0gT2JqZWN0KG9iaik7XG4gICAgICBpZiAobGVuZ3RoIDwgMiB8fCBvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF0sXG4gICAgICAgICAgICBrZXlzID0ga2V5c0Z1bmMoc291cmNlKSxcbiAgICAgICAgICAgIGwgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoIWRlZmF1bHRzIHx8IG9ialtrZXldID09PSB2b2lkIDApIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICB2YXIgZXh0ZW5kID0gY3JlYXRlQXNzaWduZXIoYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pblxuICAvLyBvYmplY3QocykuXG4gIC8vIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduKVxuICB2YXIgZXh0ZW5kT3duID0gY3JlYXRlQXNzaWduZXIoa2V5cyk7XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgdmFyIGRlZmF1bHRzID0gY3JlYXRlQXNzaWduZXIoYWxsS2V5cywgdHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlIGEgbmFrZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGZvciBzdXJyb2dhdGUtcHJvdG90eXBlLXN3YXBwaW5nLlxuICBmdW5jdGlvbiBjdG9yKCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpe307XG4gIH1cblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBhbm90aGVyLlxuICBmdW5jdGlvbiBiYXNlQ3JlYXRlKHByb3RvdHlwZSkge1xuICAgIGlmICghaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICB2YXIgQ3RvciA9IGN0b3IoKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGdpdmVuIHByb3RvdHlwZSBvYmplY3QuXG4gIC8vIElmIGFkZGl0aW9uYWwgcHJvcGVydGllcyBhcmUgcHJvdmlkZWQgdGhlbiB0aGV5IHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4gIC8vIGNyZWF0ZWQgb2JqZWN0LlxuICBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBleHRlbmRPd24ocmVzdWx0LCBwcm9wcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICAgaWYgKCFpc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBpc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IGV4dGVuZCh7fSwgb2JqKTtcbiAgfVxuXG4gIC8vIEludm9rZXMgYGludGVyY2VwdG9yYCB3aXRoIHRoZSBgb2JqYCBhbmQgdGhlbiByZXR1cm5zIGBvYmpgLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIGZ1bmN0aW9uIHRhcChvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgLy8gTm9ybWFsaXplIGEgKGRlZXApIHByb3BlcnR5IGBwYXRoYCB0byBhcnJheS5cbiAgLy8gTGlrZSBgXy5pdGVyYXRlZWAsIHRoaXMgZnVuY3Rpb24gY2FuIGJlIGN1c3RvbWl6ZWQuXG4gIGZ1bmN0aW9uIHRvUGF0aCQxKHBhdGgpIHtcbiAgICByZXR1cm4gaXNBcnJheShwYXRoKSA/IHBhdGggOiBbcGF0aF07XG4gIH1cbiAgXyQxLnRvUGF0aCA9IHRvUGF0aCQxO1xuXG4gIC8vIEludGVybmFsIHdyYXBwZXIgZm9yIGBfLnRvUGF0aGAgdG8gZW5hYmxlIG1pbmlmaWNhdGlvbi5cbiAgLy8gU2ltaWxhciB0byBgY2JgIGZvciBgXy5pdGVyYXRlZWAuXG4gIGZ1bmN0aW9uIHRvUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIF8kMS50b1BhdGgocGF0aCk7XG4gIH1cblxuICAvLyBJbnRlcm5hbCBmdW5jdGlvbiB0byBvYnRhaW4gYSBuZXN0ZWQgcHJvcGVydHkgaW4gYG9iamAgYWxvbmcgYHBhdGhgLlxuICBmdW5jdGlvbiBkZWVwR2V0KG9iaiwgcGF0aCkge1xuICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgICBvYmogPSBvYmpbcGF0aFtpXV07XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGggPyBvYmogOiB2b2lkIDA7XG4gIH1cblxuICAvLyBHZXQgdGhlIHZhbHVlIG9mIHRoZSAoZGVlcCkgcHJvcGVydHkgb24gYHBhdGhgIGZyb20gYG9iamVjdGAuXG4gIC8vIElmIGFueSBwcm9wZXJ0eSBpbiBgcGF0aGAgZG9lcyBub3QgZXhpc3Qgb3IgaWYgdGhlIHZhbHVlIGlzXG4gIC8vIGB1bmRlZmluZWRgLCByZXR1cm4gYGRlZmF1bHRWYWx1ZWAgaW5zdGVhZC5cbiAgLy8gVGhlIGBwYXRoYCBpcyBub3JtYWxpemVkIHRocm91Z2ggYF8udG9QYXRoYC5cbiAgZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIHZhbHVlID0gZGVlcEdldChvYmplY3QsIHRvUGF0aChwYXRoKSk7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKHZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xuICB9XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseSBvblxuICAvLyBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLiBVbmxpa2UgdGhlIGludGVybmFsIGBoYXNgXG4gIC8vIGZ1bmN0aW9uLCB0aGlzIHB1YmxpYyB2ZXJzaW9uIGNhbiBhbHNvIHRyYXZlcnNlIG5lc3RlZCBwcm9wZXJ0aWVzLlxuICBmdW5jdGlvbiBoYXMob2JqLCBwYXRoKSB7XG4gICAgcGF0aCA9IHRvUGF0aChwYXRoKTtcbiAgICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHBhdGhbaV07XG4gICAgICBpZiAoIWhhcyQxKG9iaiwga2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgfVxuICAgIHJldHVybiAhIWxlbmd0aDtcbiAgfVxuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRlZXMuXG4gIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHByZWRpY2F0ZSBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mXG4gIC8vIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBmdW5jdGlvbiBtYXRjaGVyKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBleHRlbmRPd24oe30sIGF0dHJzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gaXNNYXRjaChvYmosIGF0dHJzKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gcGFzc2VkIGFuIG9iamVjdCwgd2lsbCB0cmF2ZXJzZSB0aGF0IG9iamVjdOKAmXNcbiAgLy8gcHJvcGVydGllcyBkb3duIHRoZSBnaXZlbiBgcGF0aGAsIHNwZWNpZmllZCBhcyBhbiBhcnJheSBvZiBrZXlzIG9yIGluZGljZXMuXG4gIGZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBkZWVwR2V0KG9iaiwgcGF0aCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBvcHRpbWl6ZUNiKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICAvLyBUaGUgMi1hcmd1bWVudCBjYXNlIGlzIG9taXR0ZWQgYmVjYXVzZSB3ZeKAmXJlIG5vdCB1c2luZyBpdC5cbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgY2FsbGJhY2tzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gZWFjaFxuICAvLyBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIHJlc3VsdCDigJQgZWl0aGVyIGBfLmlkZW50aXR5YCxcbiAgLy8gYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIGZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICAgIGlmIChpc0Z1bmN0aW9uJDEodmFsdWUpKSByZXR1cm4gb3B0aW1pemVDYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICAgIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpKSByZXR1cm4gbWF0Y2hlcih2YWx1ZSk7XG4gICAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbiAgfVxuXG4gIC8vIEV4dGVybmFsIHdyYXBwZXIgZm9yIG91ciBjYWxsYmFjayBnZW5lcmF0b3IuIFVzZXJzIG1heSBjdXN0b21pemVcbiAgLy8gYF8uaXRlcmF0ZWVgIGlmIHRoZXkgd2FudCBhZGRpdGlvbmFsIHByZWRpY2F0ZS9pdGVyYXRlZSBzaG9ydGhhbmQgc3R5bGVzLlxuICAvLyBUaGlzIGFic3RyYWN0aW9uIGhpZGVzIHRoZSBpbnRlcm5hbC1vbmx5IGBhcmdDb3VudGAgYXJndW1lbnQuXG4gIGZ1bmN0aW9uIGl0ZXJhdGVlKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGJhc2VJdGVyYXRlZSh2YWx1ZSwgY29udGV4dCwgSW5maW5pdHkpO1xuICB9XG4gIF8kMS5pdGVyYXRlZSA9IGl0ZXJhdGVlO1xuXG4gIC8vIFRoZSBmdW5jdGlvbiB3ZSBjYWxsIGludGVybmFsbHkgdG8gZ2VuZXJhdGUgYSBjYWxsYmFjay4gSXQgaW52b2tlc1xuICAvLyBgXy5pdGVyYXRlZWAgaWYgb3ZlcnJpZGRlbiwgb3RoZXJ3aXNlIGBiYXNlSXRlcmF0ZWVgLlxuICBmdW5jdGlvbiBjYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoXyQxLml0ZXJhdGVlICE9PSBpdGVyYXRlZSkgcmV0dXJuIF8kMS5pdGVyYXRlZSh2YWx1ZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIGJhc2VJdGVyYXRlZSh2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgYGl0ZXJhdGVlYCB0byBlYWNoIGVsZW1lbnQgb2YgYG9iamAuXG4gIC8vIEluIGNvbnRyYXN0IHRvIGBfLm1hcGAgaXQgcmV0dXJucyBhbiBvYmplY3QuXG4gIGZ1bmN0aW9uIG1hcE9iamVjdChvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIF9rZXlzID0ga2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSBfa2V5cy5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IF9rZXlzW2luZGV4XTtcbiAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb24uIE9mdGVuIHVzZWZ1bCBvdXRzaWRlIG9mIFVuZGVyc2NvcmUuXG4gIGZ1bmN0aW9uIG5vb3AoKXt9XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgcmV0dXJucyBhIGdpdmVuIHByb3BlcnR5LlxuICBmdW5jdGlvbiBwcm9wZXJ0eU9mKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIG5vb3A7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiBnZXQob2JqLCBwYXRoKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIGZ1bmN0aW9uIHRpbWVzKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9XG5cbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAgKGluY2x1c2l2ZSkuXG4gIGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCkge1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gIH1cblxuICAvLyBBIChwb3NzaWJseSBmYXN0ZXIpIHdheSB0byBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGFzIGFuIGludGVnZXIuXG4gIHZhciBub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaGVscGVyIHRvIGdlbmVyYXRlIGZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5nc1xuICAvLyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgZnVuY3Rpb24gY3JlYXRlRXNjYXBlcihtYXApIHtcbiAgICB2YXIgZXNjYXBlciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWFwW21hdGNoXTtcbiAgICB9O1xuICAgIC8vIFJlZ2V4ZXMgZm9yIGlkZW50aWZ5aW5nIGEga2V5IHRoYXQgbmVlZHMgdG8gYmUgZXNjYXBlZC5cbiAgICB2YXIgc291cmNlID0gJyg/OicgKyBrZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH1cblxuICAvLyBJbnRlcm5hbCBsaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICB2YXIgZXNjYXBlTWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjeDI3OycsXG4gICAgJ2AnOiAnJiN4NjA7J1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIGZvciBlc2NhcGluZyBzdHJpbmdzIHRvIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgdmFyIF9lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XG5cbiAgLy8gSW50ZXJuYWwgbGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciB1bmVzY2FwaW5nLlxuICB2YXIgdW5lc2NhcGVNYXAgPSBpbnZlcnQoZXNjYXBlTWFwKTtcblxuICAvLyBGdW5jdGlvbiBmb3IgdW5lc2NhcGluZyBzdHJpbmdzIGZyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgX3VuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiBDaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgdmFyIHRlbXBsYXRlU2V0dGluZ3MgPSBfJDEudGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZTogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZTogLzwlPShbXFxzXFxTXSs/KSU+L2csXG4gICAgZXNjYXBlOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xuICB9O1xuXG4gIC8vIFdoZW4gY3VzdG9taXppbmcgYF8udGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgdmFyIGVzY2FwZVJlZ0V4cCA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICBmdW5jdGlvbiBlc2NhcGVDaGFyKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9XG5cbiAgLy8gSW4gb3JkZXIgdG8gcHJldmVudCB0aGlyZC1wYXJ0eSBjb2RlIGluamVjdGlvbiB0aHJvdWdoXG4gIC8vIGBfLnRlbXBsYXRlU2V0dGluZ3MudmFyaWFibGVgLCB3ZSB0ZXN0IGl0IGFnYWluc3QgdGhlIGZvbGxvd2luZyByZWd1bGFyXG4gIC8vIGV4cHJlc3Npb24uIEl0IGlzIGludGVudGlvbmFsbHkgYSBiaXQgbW9yZSBsaWJlcmFsIHRoYW4ganVzdCBtYXRjaGluZyB2YWxpZFxuICAvLyBpZGVudGlmaWVycywgYnV0IHN0aWxsIHByZXZlbnRzIHBvc3NpYmxlIGxvb3Bob2xlcyB0aHJvdWdoIGRlZmF1bHRzIG9yXG4gIC8vIGRlc3RydWN0dXJpbmcgYXNzaWdubWVudC5cbiAgdmFyIGJhcmVJZGVudGlmaWVyID0gL15cXHMqKFxcd3xcXCQpK1xccyokLztcblxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICAvLyBOQjogYG9sZFNldHRpbmdzYCBvbmx5IGV4aXN0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIGZ1bmN0aW9uIHRlbXBsYXRlKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBkZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8kMS50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZVJlZ0V4cCwgZXNjYXBlQ2hhcik7XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2Zmc2V0LlxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZTtcbiAgICBpZiAoYXJndW1lbnQpIHtcbiAgICAgIC8vIEluc3VyZSBhZ2FpbnN0IHRoaXJkLXBhcnR5IGNvZGUgaW5qZWN0aW9uLiAoQ1ZFLTIwMjEtMjMzNTgpXG4gICAgICBpZiAoIWJhcmVJZGVudGlmaWVyLnRlc3QoYXJndW1lbnQpKSB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICd2YXJpYWJsZSBpcyBub3QgYSBiYXJlIGlkZW50aWZpZXI6ICcgKyBhcmd1bWVudFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICAgIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG4gICAgICBhcmd1bWVudCA9ICdvYmonO1xuICAgIH1cblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyAncmV0dXJuIF9fcDtcXG4nO1xuXG4gICAgdmFyIHJlbmRlcjtcbiAgICB0cnkge1xuICAgICAgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKGFyZ3VtZW50LCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfJDEpO1xuICAgIH07XG5cbiAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXG4gICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyBhcmd1bWVudCArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cblxuICAvLyBUcmF2ZXJzZXMgdGhlIGNoaWxkcmVuIG9mIGBvYmpgIGFsb25nIGBwYXRoYC4gSWYgYSBjaGlsZCBpcyBhIGZ1bmN0aW9uLCBpdFxuICAvLyBpcyBpbnZva2VkIHdpdGggaXRzIHBhcmVudCBhcyBjb250ZXh0LiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmluYWxcbiAgLy8gY2hpbGQsIG9yIGBmYWxsYmFja2AgaWYgYW55IGNoaWxkIGlzIHVuZGVmaW5lZC5cbiAgZnVuY3Rpb24gcmVzdWx0KG9iaiwgcGF0aCwgZmFsbGJhY2spIHtcbiAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24kMShmYWxsYmFjaykgPyBmYWxsYmFjay5jYWxsKG9iaikgOiBmYWxsYmFjaztcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9ialtwYXRoW2ldXTtcbiAgICAgIGlmIChwcm9wID09PSB2b2lkIDApIHtcbiAgICAgICAgcHJvcCA9IGZhbGxiYWNrO1xuICAgICAgICBpID0gbGVuZ3RoOyAvLyBFbnN1cmUgd2UgZG9uJ3QgY29udGludWUgaXRlcmF0aW5nLlxuICAgICAgfVxuICAgICAgb2JqID0gaXNGdW5jdGlvbiQxKHByb3ApID8gcHJvcC5jYWxsKG9iaikgOiBwcm9wO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH1cblxuICAvLyBTdGFydCBjaGFpbmluZyBhIHdyYXBwZWQgVW5kZXJzY29yZSBvYmplY3QuXG4gIGZ1bmN0aW9uIGNoYWluKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8kMShvYmopO1xuICAgIGluc3RhbmNlLl9jaGFpbiA9IHRydWU7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdG8gZXhlY3V0ZSBgc291cmNlRnVuY2AgYm91bmQgdG8gYGNvbnRleHRgIHdpdGggb3B0aW9uYWxcbiAgLy8gYGFyZ3NgLiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3Igb3IgYXMgYVxuICAvLyBub3JtYWwgZnVuY3Rpb24uXG4gIGZ1bmN0aW9uIGV4ZWN1dGVCb3VuZChzb3VyY2VGdW5jLCBib3VuZEZ1bmMsIGNvbnRleHQsIGNhbGxpbmdDb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB2YXIgc2VsZiA9IGJhc2VDcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmIChpc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLy8gUGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb24gYnkgY3JlYXRpbmcgYSB2ZXJzaW9uIHRoYXQgaGFzIGhhZCBzb21lIG9mIGl0c1xuICAvLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC4gYF9gIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciBieSBkZWZhdWx0LCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlXG4gIC8vIHByZS1maWxsZWQuIFNldCBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCBmb3IgYSBjdXN0b20gcGxhY2Vob2xkZXIgYXJndW1lbnQuXG4gIHZhciBwYXJ0aWFsID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihmdW5jLCBib3VuZEFyZ3MpIHtcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSBwYXJ0aWFsLnBsYWNlaG9sZGVyO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gYm91bmRBcmdzLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXSA9PT0gcGxhY2Vob2xkZXIgPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9KTtcblxuICBwYXJ0aWFsLnBsYWNlaG9sZGVyID0gXyQxO1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS5cbiAgdmFyIGJpbmQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ3MpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24kMShmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGJvdW5kID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihjYWxsQXJncykge1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgY29udGV4dCwgdGhpcywgYXJncy5jb25jYXQoY2FsbEFyZ3MpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH0pO1xuXG4gIC8vIEludGVybmFsIGhlbHBlciBmb3IgY29sbGVjdGlvbiBtZXRob2RzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgY29sbGVjdGlvblxuICAvLyBzaG91bGQgYmUgaXRlcmF0ZWQgYXMgYW4gYXJyYXkgb3IgYXMgYW4gb2JqZWN0LlxuICAvLyBSZWxhdGVkOiBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGhcbiAgLy8gQXZvaWRzIGEgdmVyeSBuYXN0eSBpT1MgOCBKSVQgYnVnIG9uIEFSTS02NC4gIzIwOTRcbiAgdmFyIGlzQXJyYXlMaWtlID0gY3JlYXRlU2l6ZVByb3BlcnR5Q2hlY2soZ2V0TGVuZ3RoKTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIGZ1bmN0aW9uIGZsYXR0ZW4kMShpbnB1dCwgZGVwdGgsIHN0cmljdCwgb3V0cHV0KSB7XG4gICAgb3V0cHV0ID0gb3V0cHV0IHx8IFtdO1xuICAgIGlmICghZGVwdGggJiYgZGVwdGggIT09IDApIHtcbiAgICAgIGRlcHRoID0gSW5maW5pdHk7XG4gICAgfSBlbHNlIGlmIChkZXB0aCA8PSAwKSB7XG4gICAgICByZXR1cm4gb3V0cHV0LmNvbmNhdChpbnB1dCk7XG4gICAgfVxuICAgIHZhciBpZHggPSBvdXRwdXQubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoaW5wdXQpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHMkMSh2YWx1ZSkpKSB7XG4gICAgICAgIC8vIEZsYXR0ZW4gY3VycmVudCBsZXZlbCBvZiBhcnJheSBvciBhcmd1bWVudHMgb2JqZWN0LlxuICAgICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgICAgZmxhdHRlbiQxKHZhbHVlLCBkZXB0aCAtIDEsIHN0cmljdCwgb3V0cHV0KTtcbiAgICAgICAgICBpZHggPSBvdXRwdXQubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChqIDwgbGVuKSBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICB2YXIgYmluZEFsbCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gICAga2V5cyA9IGZsYXR0ZW4kMShrZXlzLCBmYWxzZSwgZmFsc2UpO1xuICAgIHZhciBpbmRleCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChpbmRleCA8IDEpIHRocm93IG5ldyBFcnJvcignYmluZEFsbCBtdXN0IGJlIHBhc3NlZCBmdW5jdGlvbiBuYW1lcycpO1xuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICBvYmpba2V5XSA9IGJpbmQob2JqW2tleV0sIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH0pO1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW9pemUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBjYWNoZSA9IG1lbW9pemUuY2FjaGU7XG4gICAgICB2YXIgYWRkcmVzcyA9ICcnICsgKGhhc2hlciA/IGhhc2hlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5KTtcbiAgICAgIGlmICghaGFzJDEoY2FjaGUsIGFkZHJlc3MpKSBjYWNoZVthZGRyZXNzXSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBjYWNoZVthZGRyZXNzXTtcbiAgICB9O1xuICAgIG1lbW9pemUuY2FjaGUgPSB7fTtcbiAgICByZXR1cm4gbWVtb2l6ZTtcbiAgfVxuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICB2YXIgZGVsYXkgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0sIHdhaXQpO1xuICB9KTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgdmFyIGRlZmVyID0gcGFydGlhbChkZWxheSwgXyQxLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGltZW91dCwgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBub3coKTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgdGhyb3R0bGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX25vdyA9IG5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IF9ub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChfbm93IC0gcHJldmlvdXMpO1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBfbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB0aHJvdHRsZWQuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICBwcmV2aW91cyA9IDA7XG4gICAgICB0aW1lb3V0ID0gY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhyb3R0bGVkO1xuICB9XG5cbiAgLy8gV2hlbiBhIHNlcXVlbmNlIG9mIGNhbGxzIG9mIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBlbmRzLCB0aGUgYXJndW1lbnRcbiAgLy8gZnVuY3Rpb24gaXMgdHJpZ2dlcmVkLiBUaGUgZW5kIG9mIGEgc2VxdWVuY2UgaXMgZGVmaW5lZCBieSB0aGUgYHdhaXRgXG4gIC8vIHBhcmFtZXRlci4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0aGUgYXJndW1lbnQgZnVuY3Rpb24gd2lsbCBiZVxuICAvLyB0cmlnZ2VyZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2VxdWVuY2UgaW5zdGVhZCBvZiBhdCB0aGUgZW5kLlxuICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dCwgcHJldmlvdXMsIGFyZ3MsIHJlc3VsdCwgY29udGV4dDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhc3NlZCA9IG5vdygpIC0gcHJldmlvdXM7XG4gICAgICBpZiAod2FpdCA+IHBhc3NlZCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIHBhc3NlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIGJlY2F1c2UgYGZ1bmNgIGNhbiByZWN1cnNpdmVseSBpbnZva2UgYGRlYm91bmNlZGAuXG4gICAgICAgIGlmICghdGltZW91dCkgYXJncyA9IGNvbnRleHQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZGVib3VuY2VkID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihfYXJncykge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gX2FyZ3M7XG4gICAgICBwcmV2aW91cyA9IG5vdygpO1xuICAgICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgICAgaWYgKGltbWVkaWF0ZSkgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICBkZWJvdW5jZWQuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gYXJncyA9IGNvbnRleHQgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVib3VuY2VkO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgZnVuY3Rpb24gd3JhcChmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIHBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQtaW4gcHJlZGljYXRlLlxuICBmdW5jdGlvbiBuZWdhdGUocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgc3RhcnQgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSBzdGFydDtcbiAgICAgIHZhciByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgb24gYW5kIGFmdGVyIHRoZSBOdGggY2FsbC5cbiAgZnVuY3Rpb24gYWZ0ZXIodGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHVwIHRvIChidXQgbm90IGluY2x1ZGluZykgdGhlXG4gIC8vIE50aCBjYWxsLlxuICBmdW5jdGlvbiBiZWZvcmUodGltZXMsIGZ1bmMpIHtcbiAgICB2YXIgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA+IDApIHtcbiAgICAgICAgbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lcyA8PSAxKSBmdW5jID0gbnVsbDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgdmFyIG9uY2UgPSBwYXJ0aWFsKGJlZm9yZSwgMik7XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3Qga2V5IG9uIGFuIG9iamVjdCB0aGF0IHBhc3NlcyBhIHRydXRoIHRlc3QuXG4gIGZ1bmN0aW9uIGZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBfa2V5cyA9IGtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBfa2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gX2tleXNbaV07XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtrZXldLCBrZXksIG9iaikpIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKGRpcikge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICB2YXIgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSB0cnV0aCB0ZXN0LlxuICB2YXIgZmluZEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoMSk7XG5cbiAgLy8gUmV0dXJucyB0aGUgbGFzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgdHJ1dGggdGVzdC5cbiAgdmFyIGZpbmRMYXN0SW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigtMSk7XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCBvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgdmFyIHZhbHVlID0gaXRlcmF0ZWUob2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W21pZF0pIDwgdmFsdWUpIGxvdyA9IG1pZCArIDE7IGVsc2UgaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfVxuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHRoZSBgXy5pbmRleE9mYCBhbmQgYF8ubGFzdEluZGV4T2ZgIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gY3JlYXRlSW5kZXhGaW5kZXIoZGlyLCBwcmVkaWNhdGVGaW5kLCBzb3J0ZWRJbmRleCkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgaXRlbSwgaWR4KSB7XG4gICAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICBpZiAodHlwZW9mIGlkeCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgIGkgPSBpZHggPj0gMCA/IGlkeCA6IE1hdGgubWF4KGlkeCArIGxlbmd0aCwgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgaXNOYU4kMSk7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIHZhciBpbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoMSwgZmluZEluZGV4LCBzb3J0ZWRJbmRleCk7XG5cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksXG4gIC8vIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIHZhciBsYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBmaW5kTGFzdEluZGV4KTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuXG4gIGZ1bmN0aW9uIGZpbmQob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIga2V5RmluZGVyID0gaXNBcnJheUxpa2Uob2JqKSA/IGZpbmRJbmRleCA6IGZpbmRLZXk7XG4gICAgdmFyIGtleSA9IGtleUZpbmRlcihvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgaWYgKGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gLTEpIHJldHVybiBvYmpba2V5XTtcbiAgfVxuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYF8uZmluZGA6IGdldHRpbmcgdGhlIGZpcnN0XG4gIC8vIG9iamVjdCBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBmdW5jdGlvbiBmaW5kV2hlcmUob2JqLCBhdHRycykge1xuICAgIHJldHVybiBmaW5kKG9iaiwgbWF0Y2hlcihhdHRycykpO1xuICB9XG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lIGZvciBjb2xsZWN0aW9uIGZ1bmN0aW9ucywgYW4gYGVhY2hgXG4gIC8vIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIGZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGksIGxlbmd0aDtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9rZXlzID0ga2V5cyhvYmopO1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gX2tleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW19rZXlzW2ldXSwgX2tleXNbaV0sIG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgZnVuY3Rpb24gbWFwKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgX2tleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBrZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChfa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBfa2V5cyA/IF9rZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgcmVzdWx0c1tpbmRleF0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgaGVscGVyIHRvIGNyZWF0ZSBhIHJlZHVjaW5nIGZ1bmN0aW9uLCBpdGVyYXRpbmcgbGVmdCBvciByaWdodC5cbiAgZnVuY3Rpb24gY3JlYXRlUmVkdWNlKGRpcikge1xuICAgIC8vIFdyYXAgY29kZSB0aGF0IHJlYXNzaWducyBhcmd1bWVudCB2YXJpYWJsZXMgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbiB0aGFuXG4gICAgLy8gdGhlIG9uZSB0aGF0IGFjY2Vzc2VzIGBhcmd1bWVudHMubGVuZ3RoYCB0byBhdm9pZCBhIHBlcmYgaGl0LiAoIzE5OTEpXG4gICAgdmFyIHJlZHVjZXIgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBpbml0aWFsKSB7XG4gICAgICB2YXIgX2tleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBrZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKF9rZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgIG1lbW8gPSBvYmpbX2tleXMgPyBfa2V5c1tpbmRleF0gOiBpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGRpcjtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBfa2V5cyA/IF9rZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgICBtZW1vID0gaXRlcmF0ZWUobWVtbywgb2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMztcbiAgICAgIHJldHVybiByZWR1Y2VyKG9iaiwgb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgNCksIG1lbW8sIGluaXRpYWwpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIHZhciByZWR1Y2UgPSBjcmVhdGVSZWR1Y2UoMSk7XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIHZhciByZWR1Y2VSaWdodCA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgZnVuY3Rpb24gZmlsdGVyKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIGZ1bmN0aW9uIHJlamVjdChvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBmaWx0ZXIob2JqLCBuZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgZnVuY3Rpb24gZXZlcnkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBfa2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIGtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKF9rZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0gX2tleXMgPyBfa2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IHBhc3NlcyBhIHRydXRoIHRlc3QuXG4gIGZ1bmN0aW9uIHNvbWUob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBfa2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIGtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKF9rZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0gX2tleXMgPyBfa2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiBpdGVtICh1c2luZyBgPT09YCkuXG4gIGZ1bmN0aW9uIGNvbnRhaW5zKG9iaiwgaXRlbSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gdmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIGluZGV4T2Yob2JqLCBpdGVtLCBmcm9tSW5kZXgpID49IDA7XG4gIH1cblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgdmFyIGludm9rZSA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24ob2JqLCBwYXRoLCBhcmdzKSB7XG4gICAgdmFyIGNvbnRleHRQYXRoLCBmdW5jO1xuICAgIGlmIChpc0Z1bmN0aW9uJDEocGF0aCkpIHtcbiAgICAgIGZ1bmMgPSBwYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgICAgY29udGV4dFBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICAgIHBhdGggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBtYXAob2JqLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgbWV0aG9kID0gZnVuYztcbiAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgIGlmIChjb250ZXh0UGF0aCAmJiBjb250ZXh0UGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICBjb250ZXh0ID0gZGVlcEdldChjb250ZXh0LCBjb250ZXh0UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgbWV0aG9kID0gY29udGV4dFtwYXRoXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXRob2QgPT0gbnVsbCA/IG1ldGhvZCA6IG1ldGhvZC5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgXy5tYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBmdW5jdGlvbiBwbHVjayhvYmosIGtleSkge1xuICAgIHJldHVybiBtYXAob2JqLCBwcm9wZXJ0eShrZXkpKTtcbiAgfVxuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYF8uZmlsdGVyYDogc2VsZWN0aW5nIG9ubHlcbiAgLy8gb2JqZWN0cyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBmdW5jdGlvbiB3aGVyZShvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIGZpbHRlcihvYmosIG1hdGNoZXIoYXR0cnMpKTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgZnVuY3Rpb24gbWF4KG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gLUluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCB8fCAodHlwZW9mIGl0ZXJhdGVlID09ICdudW1iZXInICYmIHR5cGVvZiBvYmpbMF0gIT0gJ29iamVjdCcgJiYgb2JqICE9IG51bGwpKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogdmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgZWFjaChvYmosIGZ1bmN0aW9uKHYsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodiwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPiBsYXN0Q29tcHV0ZWQgfHwgKGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdjtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIGZ1bmN0aW9uIG1pbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IEluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSBJbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsIHx8ICh0eXBlb2YgaXRlcmF0ZWUgPT0gJ251bWJlcicgJiYgdHlwZW9mIG9ialswXSAhPSAnb2JqZWN0JyAmJiBvYmogIT0gbnVsbCkpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiB2YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBlYWNoKG9iaiwgZnVuY3Rpb24odiwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2LCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCAoY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdjtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICB2YXIgcmVTdHJTeW1ib2wgPSAvW15cXHVkODAwLVxcdWRmZmZdfFtcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl18W1xcdWQ4MDAtXFx1ZGZmZl0vZztcbiAgZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChpc0FycmF5KG9iaikpIHJldHVybiBzbGljZS5jYWxsKG9iaik7XG4gICAgaWYgKGlzU3RyaW5nKG9iaikpIHtcbiAgICAgIC8vIEtlZXAgc3Vycm9nYXRlIHBhaXIgY2hhcmFjdGVycyB0b2dldGhlci5cbiAgICAgIHJldHVybiBvYmoubWF0Y2gocmVTdHJTeW1ib2wpO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIG1hcChvYmosIGlkZW50aXR5KTtcbiAgICByZXR1cm4gdmFsdWVzKG9iaik7XG4gIH1cblxuICAvLyBTYW1wbGUgKipuKiogcmFuZG9tIHZhbHVlcyBmcm9tIGEgY29sbGVjdGlvbiB1c2luZyB0aGUgbW9kZXJuIHZlcnNpb24gb2YgdGhlXG4gIC8vIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQuXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgZnVuY3Rpb24gc2FtcGxlKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IHZhbHVlcyhvYmopO1xuICAgICAgcmV0dXJuIG9ialtyYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgdmFyIHNhbXBsZSA9IHRvQXJyYXkob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKHNhbXBsZSk7XG4gICAgbiA9IE1hdGgubWF4KE1hdGgubWluKG4sIGxlbmd0aCksIDApO1xuICAgIHZhciBsYXN0ID0gbGVuZ3RoIC0gMTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbjsgaW5kZXgrKykge1xuICAgICAgdmFyIHJhbmQgPSByYW5kb20oaW5kZXgsIGxhc3QpO1xuICAgICAgdmFyIHRlbXAgPSBzYW1wbGVbaW5kZXhdO1xuICAgICAgc2FtcGxlW2luZGV4XSA9IHNhbXBsZVtyYW5kXTtcbiAgICAgIHNhbXBsZVtyYW5kXSA9IHRlbXA7XG4gICAgfVxuICAgIHJldHVybiBzYW1wbGUuc2xpY2UoMCwgbik7XG4gIH1cblxuICAvLyBTaHVmZmxlIGEgY29sbGVjdGlvbi5cbiAgZnVuY3Rpb24gc2h1ZmZsZShvYmopIHtcbiAgICByZXR1cm4gc2FtcGxlKG9iaiwgSW5maW5pdHkpO1xuICB9XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBmdW5jdGlvbiBzb3J0Qnkob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIHBsdWNrKG1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGxpc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgaW5kZXg6IGluZGV4KyssXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwga2V5LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gICAgfSksICd2YWx1ZScpO1xuICB9XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICBmdW5jdGlvbiBncm91cChiZWhhdmlvciwgcGFydGl0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBwYXJ0aXRpb24gPyBbW10sIFtdXSA6IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcbiAgLy8gdG8gZ3JvdXAgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjcml0ZXJpb24uXG4gIHZhciBncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKGhhcyQxKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYF8uZ3JvdXBCeWAsIGJ1dCBmb3JcbiAgLy8gd2hlbiB5b3Uga25vdyB0aGF0IHlvdXIgaW5kZXggdmFsdWVzIHdpbGwgYmUgdW5pcXVlLlxuICB2YXIgaW5kZXhCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH0pO1xuXG4gIC8vIENvdW50cyBpbnN0YW5jZXMgb2YgYW4gb2JqZWN0IHRoYXQgZ3JvdXAgYnkgYSBjZXJ0YWluIGNyaXRlcmlvbi4gUGFzc1xuICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgLy8gY3JpdGVyaW9uLlxuICB2YXIgY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChoYXMkMShyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHBhc3MgdGhlIGdpdmVuXG4gIC8vIHRydXRoIHRlc3QsIGFuZCBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIGRvIG5vdCBwYXNzIHRoZSB0cnV0aCB0ZXN0LlxuICB2YXIgcGFydGl0aW9uID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwgcGFzcykge1xuICAgIHJlc3VsdFtwYXNzID8gMCA6IDFdLnB1c2godmFsdWUpO1xuICB9LCB0cnVlKTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhIGNvbGxlY3Rpb24uXG4gIGZ1bmN0aW9uIHNpemUob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gMDtcbiAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqKSA/IG9iai5sZW5ndGggOiBrZXlzKG9iaikubGVuZ3RoO1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgYF8ucGlja2AgaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGV0aGVyIGBrZXlgIGlzIGFuIGVudW1lcmFibGVcbiAgLy8gcHJvcGVydHkgbmFtZSBvZiBgb2JqYC5cbiAgZnVuY3Rpb24ga2V5SW5PYmoodmFsdWUsIGtleSwgb2JqKSB7XG4gICAgcmV0dXJuIGtleSBpbiBvYmo7XG4gIH1cblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSBhbGxvd2VkIHByb3BlcnRpZXMuXG4gIHZhciBwaWNrID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihvYmosIGtleXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sIGl0ZXJhdGVlID0ga2V5c1swXTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGlzRnVuY3Rpb24kMShpdGVyYXRlZSkpIHtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDEpIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwga2V5c1sxXSk7XG4gICAgICBrZXlzID0gYWxsS2V5cyhvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGtleUluT2JqO1xuICAgICAga2V5cyA9IGZsYXR0ZW4kMShrZXlzLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgb2JqID0gT2JqZWN0KG9iaik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgaWYgKGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iaikpIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCB3aXRob3V0IHRoZSBkaXNhbGxvd2VkIHByb3BlcnRpZXMuXG4gIHZhciBvbWl0ID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihvYmosIGtleXMpIHtcbiAgICB2YXIgaXRlcmF0ZWUgPSBrZXlzWzBdLCBjb250ZXh0O1xuICAgIGlmIChpc0Z1bmN0aW9uJDEoaXRlcmF0ZWUpKSB7XG4gICAgICBpdGVyYXRlZSA9IG5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPiAxKSBjb250ZXh0ID0ga2V5c1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IG1hcChmbGF0dGVuJDEoa2V5cywgZmFsc2UsIGZhbHNlKSwgU3RyaW5nKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gIWNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGljayhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgfSk7XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjaWFsbHkgdXNlZnVsIG9uXG4gIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uXG4gIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgZnVuY3Rpb24gZmlyc3QoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwgfHwgYXJyYXkubGVuZ3RoIDwgMSkgcmV0dXJuIG4gPT0gbnVsbCB8fCBndWFyZCA/IHZvaWQgMCA6IFtdO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gaW5pdGlhbChhcnJheSwgYXJyYXkubGVuZ3RoIC0gbik7XG4gIH1cblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYGFycmF5YC4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGBhcmd1bWVudHNgIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVybiB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGVcbiAgLy8gYGFycmF5YC5cbiAgZnVuY3Rpb24gcmVzdChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgbiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pO1xuICB9XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBmdW5jdGlvbiBsYXN0KGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsIHx8IGFycmF5Lmxlbmd0aCA8IDEpIHJldHVybiBuID09IG51bGwgfHwgZ3VhcmQgPyB2b2lkIDAgOiBbXTtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHJlc3QoYXJyYXksIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIG4pKTtcbiAgfVxuXG4gIC8vIFRyaW0gb3V0IGFsbCBmYWxzeSB2YWx1ZXMgZnJvbSBhbiBhcnJheS5cbiAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgIHJldHVybiBmaWx0ZXIoYXJyYXksIEJvb2xlYW4pO1xuICB9XG5cbiAgLy8gRmxhdHRlbiBvdXQgYW4gYXJyYXksIGVpdGhlciByZWN1cnNpdmVseSAoYnkgZGVmYXVsdCksIG9yIHVwIHRvIGBkZXB0aGAuXG4gIC8vIFBhc3NpbmcgYHRydWVgIG9yIGBmYWxzZWAgYXMgYGRlcHRoYCBtZWFucyBgMWAgb3IgYEluZmluaXR5YCwgcmVzcGVjdGl2ZWx5LlxuICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5LCBkZXB0aCkge1xuICAgIHJldHVybiBmbGF0dGVuJDEoYXJyYXksIGRlcHRoLCBmYWxzZSk7XG4gIH1cblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIHZhciBkaWZmZXJlbmNlID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihhcnJheSwgcmVzdCkge1xuICAgIHJlc3QgPSBmbGF0dGVuJDEocmVzdCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIGZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpe1xuICAgICAgcmV0dXJuICFjb250YWlucyhyZXN0LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICB2YXIgd2l0aG91dCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oYXJyYXksIG90aGVyQXJyYXlzKSB7XG4gICAgcmV0dXJuIGRpZmZlcmVuY2UoYXJyYXksIG90aGVyQXJyYXlzKTtcbiAgfSk7XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBUaGUgZmFzdGVyIGFsZ29yaXRobSB3aWxsIG5vdCB3b3JrIHdpdGggYW4gaXRlcmF0ZWUgaWYgdGhlIGl0ZXJhdGVlXG4gIC8vIGlzIG5vdCBhIG9uZS10by1vbmUgZnVuY3Rpb24sIHNvIHByb3ZpZGluZyBhbiBpdGVyYXRlZSB3aWxsIGRpc2FibGVcbiAgLy8gdGhlIGZhc3RlciBhbGdvcml0aG0uXG4gIGZ1bmN0aW9uIHVuaXEoYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmICghaXNCb29sZWFuKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xuICAgICAgaXRlcmF0ZWUgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpdGVyYXRlZSAhPSBudWxsKSBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGksIGFycmF5KSA6IHZhbHVlO1xuICAgICAgaWYgKGlzU29ydGVkICYmICFpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIWNvbnRhaW5zKHNlZW4sIGNvbXB1dGVkKSkge1xuICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFjb250YWlucyhyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHVuaW9uOiBlYWNoIGRpc3RpbmN0IGVsZW1lbnQgZnJvbSBhbGwgb2ZcbiAgLy8gdGhlIHBhc3NlZC1pbiBhcnJheXMuXG4gIHZhciB1bmlvbiA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgcmV0dXJuIHVuaXEoZmxhdHRlbiQxKGFycmF5cywgdHJ1ZSwgdHJ1ZSkpO1xuICB9KTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIGZ1bmN0aW9uIGludGVyc2VjdGlvbihhcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgIGlmIChjb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIHZhciBqO1xuICAgICAgZm9yIChqID0gMTsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIWNvbnRhaW5zKGFyZ3VtZW50c1tqXSwgaXRlbSkpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGogPT09IGFyZ3NMZW5ndGgpIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gQ29tcGxlbWVudCBvZiB6aXAuIFVuemlwIGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIGFuZCBncm91cHNcbiAgLy8gZWFjaCBhcnJheSdzIGVsZW1lbnRzIG9uIHNoYXJlZCBpbmRpY2VzLlxuICBmdW5jdGlvbiB1bnppcChhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSAoYXJyYXkgJiYgbWF4KGFycmF5LCBnZXRMZW5ndGgpLmxlbmd0aCkgfHwgMDtcbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBwbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgdmFyIHppcCA9IHJlc3RBcmd1bWVudHModW56aXApO1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy4gUGFzc2luZyBieSBwYWlycyBpcyB0aGUgcmV2ZXJzZSBvZiBgXy5wYWlyc2AuXG4gIGZ1bmN0aW9uIG9iamVjdChsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBmdW5jdGlvbiByYW5nZShzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChzdG9wID09IG51bGwpIHtcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBpZiAoIXN0ZXApIHtcbiAgICAgIHN0ZXAgPSBzdG9wIDwgc3RhcnQgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKywgc3RhcnQgKz0gc3RlcCkge1xuICAgICAgcmFuZ2VbaWR4XSA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfVxuXG4gIC8vIENodW5rIGEgc2luZ2xlIGFycmF5IGludG8gbXVsdGlwbGUgYXJyYXlzLCBlYWNoIGNvbnRhaW5pbmcgYGNvdW50YCBvciBmZXdlclxuICAvLyBpdGVtcy5cbiAgZnVuY3Rpb24gY2h1bmsoYXJyYXksIGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IG51bGwgfHwgY291bnQgPCAxKSByZXR1cm4gW107XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChzbGljZS5jYWxsKGFycmF5LCBpLCBpICs9IGNvdW50KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIGZ1bmN0aW9uIGNoYWluUmVzdWx0KGluc3RhbmNlLCBvYmopIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX2NoYWluID8gXyQxKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfVxuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gICAgZWFjaChmdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfJDFbbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICBfJDEucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW3RoaXMuX3dyYXBwZWRdO1xuICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBjaGFpblJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8kMSwgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gXyQxO1xuICB9XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIGBBcnJheWAgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBlYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfJDEucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIGlmIChvYmogIT0gbnVsbCkge1xuICAgICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoKG5hbWUgPT09ICdzaGlmdCcgfHwgbmFtZSA9PT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgb2JqWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hhaW5SZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIGBBcnJheWAgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBlYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8kMS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgaWYgKG9iaiAhPSBudWxsKSBvYmogPSBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNoYWluUmVzdWx0KHRoaXMsIG9iaik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gTmFtZWQgRXhwb3J0c1xuXG4gIHZhciBhbGxFeHBvcnRzID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBWRVJTSU9OOiBWRVJTSU9OLFxuICAgIHJlc3RBcmd1bWVudHM6IHJlc3RBcmd1bWVudHMsXG4gICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgIGlzTnVsbDogaXNOdWxsLFxuICAgIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgICBpc0Jvb2xlYW46IGlzQm9vbGVhbixcbiAgICBpc0VsZW1lbnQ6IGlzRWxlbWVudCxcbiAgICBpc1N0cmluZzogaXNTdHJpbmcsXG4gICAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICAgIGlzRGF0ZTogaXNEYXRlLFxuICAgIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgICBpc0Vycm9yOiBpc0Vycm9yLFxuICAgIGlzU3ltYm9sOiBpc1N5bWJvbCxcbiAgICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICAgIGlzRGF0YVZpZXc6IGlzRGF0YVZpZXckMSxcbiAgICBpc0FycmF5OiBpc0FycmF5LFxuICAgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24kMSxcbiAgICBpc0FyZ3VtZW50czogaXNBcmd1bWVudHMkMSxcbiAgICBpc0Zpbml0ZTogaXNGaW5pdGUkMSxcbiAgICBpc05hTjogaXNOYU4kMSxcbiAgICBpc1R5cGVkQXJyYXk6IGlzVHlwZWRBcnJheSQxLFxuICAgIGlzRW1wdHk6IGlzRW1wdHksXG4gICAgaXNNYXRjaDogaXNNYXRjaCxcbiAgICBpc0VxdWFsOiBpc0VxdWFsLFxuICAgIGlzTWFwOiBpc01hcCxcbiAgICBpc1dlYWtNYXA6IGlzV2Vha01hcCxcbiAgICBpc1NldDogaXNTZXQsXG4gICAgaXNXZWFrU2V0OiBpc1dlYWtTZXQsXG4gICAga2V5czoga2V5cyxcbiAgICBhbGxLZXlzOiBhbGxLZXlzLFxuICAgIHZhbHVlczogdmFsdWVzLFxuICAgIHBhaXJzOiBwYWlycyxcbiAgICBpbnZlcnQ6IGludmVydCxcbiAgICBmdW5jdGlvbnM6IGZ1bmN0aW9ucyxcbiAgICBtZXRob2RzOiBmdW5jdGlvbnMsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgZXh0ZW5kT3duOiBleHRlbmRPd24sXG4gICAgYXNzaWduOiBleHRlbmRPd24sXG4gICAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgIGNsb25lOiBjbG9uZSxcbiAgICB0YXA6IHRhcCxcbiAgICBnZXQ6IGdldCxcbiAgICBoYXM6IGhhcyxcbiAgICBtYXBPYmplY3Q6IG1hcE9iamVjdCxcbiAgICBpZGVudGl0eTogaWRlbnRpdHksXG4gICAgY29uc3RhbnQ6IGNvbnN0YW50LFxuICAgIG5vb3A6IG5vb3AsXG4gICAgdG9QYXRoOiB0b1BhdGgkMSxcbiAgICBwcm9wZXJ0eTogcHJvcGVydHksXG4gICAgcHJvcGVydHlPZjogcHJvcGVydHlPZixcbiAgICBtYXRjaGVyOiBtYXRjaGVyLFxuICAgIG1hdGNoZXM6IG1hdGNoZXIsXG4gICAgdGltZXM6IHRpbWVzLFxuICAgIHJhbmRvbTogcmFuZG9tLFxuICAgIG5vdzogbm93LFxuICAgIGVzY2FwZTogX2VzY2FwZSxcbiAgICB1bmVzY2FwZTogX3VuZXNjYXBlLFxuICAgIHRlbXBsYXRlU2V0dGluZ3M6IHRlbXBsYXRlU2V0dGluZ3MsXG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgIHJlc3VsdDogcmVzdWx0LFxuICAgIHVuaXF1ZUlkOiB1bmlxdWVJZCxcbiAgICBjaGFpbjogY2hhaW4sXG4gICAgaXRlcmF0ZWU6IGl0ZXJhdGVlLFxuICAgIHBhcnRpYWw6IHBhcnRpYWwsXG4gICAgYmluZDogYmluZCxcbiAgICBiaW5kQWxsOiBiaW5kQWxsLFxuICAgIG1lbW9pemU6IG1lbW9pemUsXG4gICAgZGVsYXk6IGRlbGF5LFxuICAgIGRlZmVyOiBkZWZlcixcbiAgICB0aHJvdHRsZTogdGhyb3R0bGUsXG4gICAgZGVib3VuY2U6IGRlYm91bmNlLFxuICAgIHdyYXA6IHdyYXAsXG4gICAgbmVnYXRlOiBuZWdhdGUsXG4gICAgY29tcG9zZTogY29tcG9zZSxcbiAgICBhZnRlcjogYWZ0ZXIsXG4gICAgYmVmb3JlOiBiZWZvcmUsXG4gICAgb25jZTogb25jZSxcbiAgICBmaW5kS2V5OiBmaW5kS2V5LFxuICAgIGZpbmRJbmRleDogZmluZEluZGV4LFxuICAgIGZpbmRMYXN0SW5kZXg6IGZpbmRMYXN0SW5kZXgsXG4gICAgc29ydGVkSW5kZXg6IHNvcnRlZEluZGV4LFxuICAgIGluZGV4T2Y6IGluZGV4T2YsXG4gICAgbGFzdEluZGV4T2Y6IGxhc3RJbmRleE9mLFxuICAgIGZpbmQ6IGZpbmQsXG4gICAgZGV0ZWN0OiBmaW5kLFxuICAgIGZpbmRXaGVyZTogZmluZFdoZXJlLFxuICAgIGVhY2g6IGVhY2gsXG4gICAgZm9yRWFjaDogZWFjaCxcbiAgICBtYXA6IG1hcCxcbiAgICBjb2xsZWN0OiBtYXAsXG4gICAgcmVkdWNlOiByZWR1Y2UsXG4gICAgZm9sZGw6IHJlZHVjZSxcbiAgICBpbmplY3Q6IHJlZHVjZSxcbiAgICByZWR1Y2VSaWdodDogcmVkdWNlUmlnaHQsXG4gICAgZm9sZHI6IHJlZHVjZVJpZ2h0LFxuICAgIGZpbHRlcjogZmlsdGVyLFxuICAgIHNlbGVjdDogZmlsdGVyLFxuICAgIHJlamVjdDogcmVqZWN0LFxuICAgIGV2ZXJ5OiBldmVyeSxcbiAgICBhbGw6IGV2ZXJ5LFxuICAgIHNvbWU6IHNvbWUsXG4gICAgYW55OiBzb21lLFxuICAgIGNvbnRhaW5zOiBjb250YWlucyxcbiAgICBpbmNsdWRlczogY29udGFpbnMsXG4gICAgaW5jbHVkZTogY29udGFpbnMsXG4gICAgaW52b2tlOiBpbnZva2UsXG4gICAgcGx1Y2s6IHBsdWNrLFxuICAgIHdoZXJlOiB3aGVyZSxcbiAgICBtYXg6IG1heCxcbiAgICBtaW46IG1pbixcbiAgICBzaHVmZmxlOiBzaHVmZmxlLFxuICAgIHNhbXBsZTogc2FtcGxlLFxuICAgIHNvcnRCeTogc29ydEJ5LFxuICAgIGdyb3VwQnk6IGdyb3VwQnksXG4gICAgaW5kZXhCeTogaW5kZXhCeSxcbiAgICBjb3VudEJ5OiBjb3VudEJ5LFxuICAgIHBhcnRpdGlvbjogcGFydGl0aW9uLFxuICAgIHRvQXJyYXk6IHRvQXJyYXksXG4gICAgc2l6ZTogc2l6ZSxcbiAgICBwaWNrOiBwaWNrLFxuICAgIG9taXQ6IG9taXQsXG4gICAgZmlyc3Q6IGZpcnN0LFxuICAgIGhlYWQ6IGZpcnN0LFxuICAgIHRha2U6IGZpcnN0LFxuICAgIGluaXRpYWw6IGluaXRpYWwsXG4gICAgbGFzdDogbGFzdCxcbiAgICByZXN0OiByZXN0LFxuICAgIHRhaWw6IHJlc3QsXG4gICAgZHJvcDogcmVzdCxcbiAgICBjb21wYWN0OiBjb21wYWN0LFxuICAgIGZsYXR0ZW46IGZsYXR0ZW4sXG4gICAgd2l0aG91dDogd2l0aG91dCxcbiAgICB1bmlxOiB1bmlxLFxuICAgIHVuaXF1ZTogdW5pcSxcbiAgICB1bmlvbjogdW5pb24sXG4gICAgaW50ZXJzZWN0aW9uOiBpbnRlcnNlY3Rpb24sXG4gICAgZGlmZmVyZW5jZTogZGlmZmVyZW5jZSxcbiAgICB1bnppcDogdW56aXAsXG4gICAgdHJhbnNwb3NlOiB1bnppcCxcbiAgICB6aXA6IHppcCxcbiAgICBvYmplY3Q6IG9iamVjdCxcbiAgICByYW5nZTogcmFuZ2UsXG4gICAgY2h1bms6IGNodW5rLFxuICAgIG1peGluOiBtaXhpbixcbiAgICAnZGVmYXVsdCc6IF8kMVxuICB9O1xuXG4gIC8vIERlZmF1bHQgRXhwb3J0XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICB2YXIgXyA9IG1peGluKGFsbEV4cG9ydHMpO1xuICAvLyBMZWdhY3kgTm9kZS5qcyBBUEkuXG4gIF8uXyA9IF87XG5cbiAgcmV0dXJuIF87XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmRlcnNjb3JlLXVtZC5qcy5tYXBcbiJdfQ=="}